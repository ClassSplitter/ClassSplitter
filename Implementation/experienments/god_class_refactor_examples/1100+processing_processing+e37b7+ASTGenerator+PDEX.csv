index,name,document,type,inner invocations,external invocations,calls,visits,length,lines,modifier,commit,full text,moved,removed,gpt text,code summary
1,SHOW_DEBUG_TREE,show debug tree ,Field,,,,,52,1,25,,public static final boolean SHOW_DEBUG_TREE = false;,False,False,,
2,ecs,ecs ,Field,"ASTGenerator(JavaEditor,ErrorCheckerService)",,,,40,1,20,,protected final ErrorCheckerService ecs;,True,True,,
3,editor,editor ,Field,"ASTGenerator(JavaEditor,ErrorCheckerService)",,,,34,1,20,,protected final JavaEditor editor;,True,True,,
4,gui,gui ,Field,,,,,24,1,20,,protected final GUI gui;,False,False,,
5,"ASTGenerator(JavaEditor,ErrorCheckerService)",ast generator editor ecs ,Method,,,"processing.mode.java.pdex.ASTGenerator.GUI+GUI(JavaEditor,ASTGenerator)",processing.mode.java.pdex.ASTGenerator+editor processing.mode.java.pdex.ASTGenerator+editor processing.mode.java.pdex.ASTGenerator+ecs processing.mode.java.pdex.ASTGenerator+ecs processing.mode.java.pdex.ASTGenerator+gui,204,7,1,,"public ASTGenerator(JavaEditor editor, ErrorCheckerService ecs) {
    this.editor = editor;
    this.ecs = ecs;
    gui = new GUI(editor, this);
    //addCompletionPopupListner();
    //loadJavaDoc();
  }",False,False,"The function of the method is to initialize an ASTGenerator object by assigning values to its instance variables editor, ecs, and gui.","The code snippet shows a constructor for the ASTGenerator class that takes a JavaEditor object and an ErrorCheckerService object as parameters. It initializes the editor and ecs variables, and creates a new GUI object with the editor and the current instance of ASTGenerator. The commented out lines suggest that there might be additional functionality related to completion popup listeners and loading JavaDoc."
6,checkForTypes(ASTNode),check for types node ,Method,"preparePredictions(PreprocessedSketch,String,int) preparePredictions(PreprocessedSketch,String,int)",,org.eclipse.jdt.core.dom.ASTNode+getNodeType() org.eclipse.jdt.core.dom.ASTNode+getNodeType() processing.mode.java.pdex.CompletionCandidate+CompletionCandidate(TypeDeclaration) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) java.util.List+size() java.util.List+size() processing.mode.java.pdex.CompletionCandidate+CompletionCandidate(MethodDeclaration) java.util.List+size() java.util.List+size() processing.mode.java.pdex.CompletionCandidate+CompletionCandidate(SingleVariableDeclaration) java.util.List+get(int) java.util.List+get(int) processing.mode.java.pdex.CompletionCandidate+CompletionCandidate(SingleVariableDeclaration) org.eclipse.jdt.core.dom.FieldDeclaration+fragments() org.eclipse.jdt.core.dom.FieldDeclaration+fragments() org.eclipse.jdt.core.dom.VariableDeclarationStatement+fragments() org.eclipse.jdt.core.dom.VariableDeclarationStatement+fragments() org.eclipse.jdt.core.dom.VariableDeclarationExpression+fragments() org.eclipse.jdt.core.dom.VariableDeclarationExpression+fragments() java.util.List+size() java.util.List+size() processing.mode.java.pdex.CompletionCandidate+CompletionCandidate(VariableDeclarationFragment),org.eclipse.jdt.core.dom.ASTNode+TYPE_DECLARATION org.eclipse.jdt.core.dom.ASTNode+METHOD_DECLARATION org.eclipse.jdt.core.dom.MethodDeclaration+PARAMETERS_PROPERTY org.eclipse.jdt.core.dom.ASTNode+SINGLE_VARIABLE_DECLARATION org.eclipse.jdt.core.dom.ASTNode+FIELD_DECLARATION org.eclipse.jdt.core.dom.ASTNode+VARIABLE_DECLARATION_STATEMENT org.eclipse.jdt.core.dom.ASTNode+VARIABLE_DECLARATION_EXPRESSION,1929,50,9,,"public static CompletionCandidate[] checkForTypes(ASTNode node) {

    List<VariableDeclarationFragment> vdfs = null;
    switch (node.getNodeType()) {
    case ASTNode.TYPE_DECLARATION:
      return new CompletionCandidate[]{new CompletionCandidate((TypeDeclaration) node)};

    case ASTNode.METHOD_DECLARATION:
      MethodDeclaration md = (MethodDeclaration) node;
      log(getNodeAsString(md));
      List<ASTNode> params = (List<ASTNode>) md
          .getStructuralProperty(MethodDeclaration.PARAMETERS_PROPERTY);
      CompletionCandidate[] cand = new CompletionCandidate[params.size() + 1];
      cand[0] = new CompletionCandidate(md);
      for (int i = 0; i < params.size(); i++) {
//        cand[i + 1] = new CompletionCandidate(params.get(i).toString(), """", """",
//                                              CompletionCandidate.LOCAL_VAR);
        cand[i + 1] = new CompletionCandidate((SingleVariableDeclaration) params.get(i));
      }
      return cand;

    case ASTNode.SINGLE_VARIABLE_DECLARATION:
      return new CompletionCandidate[]{new CompletionCandidate((SingleVariableDeclaration) node)};

    case ASTNode.FIELD_DECLARATION:
      vdfs = ((FieldDeclaration) node).fragments();
      break;
    case ASTNode.VARIABLE_DECLARATION_STATEMENT:
      vdfs = ((VariableDeclarationStatement) node).fragments();
      break;
    case ASTNode.VARIABLE_DECLARATION_EXPRESSION:
      vdfs = ((VariableDeclarationExpression) node).fragments();
      break;
    default:
      break;
    }

    if (vdfs != null) {
      CompletionCandidate ret[] = new CompletionCandidate[vdfs.size()];
      int i = 0;
      for (VariableDeclarationFragment vdf : vdfs) {
//        ret[i++] = new CompletionCandidate(getNodeAsString2(vdf), """", """",
//                                           CompletionCandidate.LOCAL_VAR);
        ret[i++] = new CompletionCandidate(vdf);
      }
      return ret;
    }

    return null;
  }",False,False,"The function of this method is to check the type of an ASTNode and return an array of CompletionCandidate objects based on the type of the node. The method handles different types of nodes such as type declaration, method declaration, single variable declaration, field declaration, variable declaration statement, and variable declaration expression. It creates and returns an array of CompletionCandidate objects based on the type of the node.","The code defines a method called ""checkForTypes"" that takes an ASTNode as input. It checks the type of the node and returns an array of CompletionCandidate objects based on the type of the node. The method handles different types of nodes such as type declaration, method declaration, single variable declaration, field declaration, and variable declaration statement."
7,"resolveExpression(ASTNode,ASTNode,boolean)",resolve expression nearest node expression no compare find the parent of the expression in a b this would give me the return type of a so that we can find all children of a begininng with b param nearest node param expression return ,Method,"resolveExpression(ASTNode,ASTNode,boolean)",,"processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) org.eclipse.jdt.core.dom.MethodInvocation+getName() org.eclipse.jdt.core.dom.MethodInvocation+getName() processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) org.eclipse.jdt.core.dom.MethodInvocation+getName() org.eclipse.jdt.core.dom.MethodInvocation+getName() processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) org.eclipse.jdt.core.dom.FieldAccess+getExpression() org.eclipse.jdt.core.dom.FieldAccess+getExpression() processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) org.eclipse.jdt.core.dom.FieldAccess+getName() org.eclipse.jdt.core.dom.FieldAccess+getName() processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) org.eclipse.jdt.core.dom.FieldAccess+getName() org.eclipse.jdt.core.dom.FieldAccess+getName() processing.mode.java.pdex.ASTGenerator+resolveExpression(ASTNode,ASTNode,boolean) processing.mode.java.pdex.ASTGenerator+resolveExpression(ASTNode,ASTNode,boolean) org.eclipse.jdt.core.dom.FieldAccess+getExpression() org.eclipse.jdt.core.dom.FieldAccess+getExpression() processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) org.eclipse.jdt.core.dom.QualifiedName+getQualifier() org.eclipse.jdt.core.dom.QualifiedName+getQualifier() org.eclipse.jdt.core.dom.QualifiedName+getName() org.eclipse.jdt.core.dom.QualifiedName+getName() processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) org.eclipse.jdt.core.dom.QualifiedName+getName() org.eclipse.jdt.core.dom.QualifiedName+getName() processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) org.eclipse.jdt.core.dom.QualifiedName+getQualifier() org.eclipse.jdt.core.dom.QualifiedName+getQualifier()",,2723,61,9,"/** 
 * Find the parent of the expression in a().b, this would give me the return type of a(), so that we can find all children of a() begininng with b
 * @param nearestNode
 * @param expression
 * @return
 */
","/**
   * Find the parent of the expression in a().b, this would give me the return
   * type of a(), so that we can find all children of a() begininng with b
   *
   * @param nearestNode
   * @param expression
   * @return
   */
  public static ASTNode resolveExpression(ASTNode nearestNode,
                                          ASTNode expression, boolean noCompare) {
    log(""Resolving "" + getNodeAsString(expression) + "" noComp ""
        + noCompare);
    if (expression instanceof SimpleName) {
      return findDeclaration2(((SimpleName) expression), nearestNode);
    } else if (expression instanceof MethodInvocation) {
      log(""3. Method Invo ""
          + ((MethodInvocation) expression).getName());
      return findDeclaration2(((MethodInvocation) expression).getName(),
                              nearestNode);
    } else if (expression instanceof FieldAccess) {
      log(""2. Field access ""
          + getNodeAsString(((FieldAccess) expression).getExpression()) + ""|||""
          + getNodeAsString(((FieldAccess) expression).getName()));
      if (noCompare) {
        /*
         * ASTNode ret = findDeclaration2(((FieldAccess) expression).getName(),
         * nearestNode); log(""Found as ->""+getNodeAsString(ret));
         * return ret;
         */
        return findDeclaration2(((FieldAccess) expression).getName(),
                                nearestNode);
      } else {

        /*
         * Note how for the next recursion, noCompare is reversed. Let's say
         * I've typed getABC().quark.nin where nin is incomplete(ninja being the
         * field), when execution first enters here, it calls resolveExpr again
         * for ""getABC().quark"" where we know that quark field must be complete,
         * so we toggle noCompare. And kaboom.
         */
        return resolveExpression(nearestNode,
                                 ((FieldAccess) expression).getExpression(),
                                 true);
      }
      //return findDeclaration2(((FieldAccess) expression).getExpression(), nearestNode);
    } else if (expression instanceof QualifiedName) {
      log(""1. Resolving ""
          + ((QualifiedName) expression).getQualifier() + "" ||| ""
          + ((QualifiedName) expression).getName());
      if (noCompare) { // no compare, as in ""abc.hello."" need to resolve hello here
        return findDeclaration2(((QualifiedName) expression).getName(),
                                nearestNode);
      } else {
        //User typed ""abc.hello.by"" (bye being complete), so need to resolve ""abc.hello."" only
        return findDeclaration2(((QualifiedName) expression).getQualifier(),
                          nearestNode);
      }
    }

    return null;
  }",False,False,"The function of this method is to resolve the parent of an expression in the form of a().b. It returns the return type of a(), allowing for the finding of all children of a() starting with b.","The `resolveExpression` method takes in an ASTNode and determines the parent expression in a given expression. It handles different types of expressions such as SimpleName, MethodInvocation, FieldAccess, and QualifiedName, and returns the corresponding declaration. The method also includes logging statements for debugging purposes."
8,"resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean)",resolve expression3rd party ps nearest node ast node no compare finds the type of the expression in foo bar a b this would give me the type of b if it exists in return type of a if no compare is true it ll return type of a param nearest node param ast node return ,Method,"resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) preparePredictions(PreprocessedSketch,String,int)",,"processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) org.eclipse.jdt.core.dom.ASTNode+getNodeType() org.eclipse.jdt.core.dom.ASTNode+getNodeType() processing.mode.java.pdex.ASTGenerator.ClassMember+ClassMember(PreprocessedSketch,ASTNode) processing.mode.java.pdex.ASTGenerator+extracTypeInfo2(ASTNode) processing.mode.java.pdex.ASTGenerator+extracTypeInfo2(ASTNode) org.eclipse.jdt.core.dom.Type+isArrayType() org.eclipse.jdt.core.dom.Type+isArrayType() org.eclipse.jdt.core.dom.ASTNode+getNodeType() org.eclipse.jdt.core.dom.ASTNode+getParent() org.eclipse.jdt.core.dom.ASTNode+getParent() org.eclipse.jdt.core.dom.ASTNode+getNodeType() org.eclipse.jdt.core.dom.ArrayType+getElementType() org.eclipse.jdt.core.dom.ArrayType+getElementType() org.eclipse.jdt.core.dom.Type+isSimpleType() org.eclipse.jdt.core.dom.Type+isSimpleType() processing.mode.java.pdex.ASTGenerator+findClassIfExists(PreprocessedSketch,String) processing.mode.java.pdex.ASTGenerator+findClassIfExists(PreprocessedSketch,String) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.ASTNode+toString() java.lang.Class+getName() java.lang.Class+getName() org.eclipse.jdt.core.dom.Type+isPrimitiveType() org.eclipse.jdt.core.dom.Type+isPrimitiveType() org.eclipse.jdt.core.dom.PrimitiveType.Code+toString() org.eclipse.jdt.core.dom.PrimitiveType+getPrimitiveTypeCode() org.eclipse.jdt.core.dom.PrimitiveType+getPrimitiveTypeCode() org.eclipse.jdt.core.dom.PrimitiveType.Code+toString() processing.mode.java.pdex.ASTGenerator+getArrayClass(String,ClassLoader) processing.mode.java.pdex.ASTGenerator+getArrayClass(String,ClassLoader) processing.mode.java.pdex.ASTGenerator.ClassMember+ClassMember(Class<?>) processing.mode.java.pdex.ASTGenerator.ClassMember+ClassMember(PreprocessedSketch,ASTNode) processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+findClassIfExists(PreprocessedSketch,String) processing.mode.java.pdex.ASTGenerator+findClassIfExists(PreprocessedSketch,String) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.ASTNode+toString() processing.mode.java.pdex.ASTGenerator.ClassMember+ClassMember(Class<?>) org.eclipse.jdt.core.dom.ASTNode+getParent() org.eclipse.jdt.core.dom.ASTNode+getParent() org.eclipse.jdt.core.dom.ASTNode+getNodeType() org.eclipse.jdt.core.dom.ASTNode+getNodeType() org.eclipse.jdt.core.dom.FieldAccess+getExpression() org.eclipse.jdt.core.dom.FieldAccess+getExpression() processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) org.eclipse.jdt.core.dom.FieldAccess+getExpression() org.eclipse.jdt.core.dom.FieldAccess+getExpression() processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) org.eclipse.jdt.core.dom.FieldAccess+getExpression() org.eclipse.jdt.core.dom.FieldAccess+getExpression() processing.mode.java.pdex.ASTGenerator+findClassIfExists(PreprocessedSketch,String) processing.mode.java.pdex.ASTGenerator+findClassIfExists(PreprocessedSketch,String) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.FieldAccess+getExpression() org.eclipse.jdt.core.dom.FieldAccess+getExpression() org.eclipse.jdt.core.dom.ASTNode+toString() processing.mode.java.pdex.ASTGenerator+definedIn3rdPartyClass(PreprocessedSketch,ClassMember,String) processing.mode.java.pdex.ASTGenerator+definedIn3rdPartyClass(PreprocessedSketch,ClassMember,String) processing.mode.java.pdex.ASTGenerator.ClassMember+ClassMember(Class<?>) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.FieldAccess+getName() org.eclipse.jdt.core.dom.FieldAccess+getName() org.eclipse.jdt.core.dom.ASTNode+toString() processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) org.eclipse.jdt.core.dom.FieldAccess+getExpression() org.eclipse.jdt.core.dom.FieldAccess+getExpression() processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.mode.java.pdex.ASTGenerator+definedIn3rdPartyClass(PreprocessedSketch,String,String) processing.mode.java.pdex.ASTGenerator+definedIn3rdPartyClass(PreprocessedSketch,String,String) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.SimpleType+getName() org.eclipse.jdt.core.dom.SimpleType+getName() org.eclipse.jdt.core.dom.ASTNode+toString() processing.mode.java.pdex.ASTGenerator+resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) processing.mode.java.pdex.ASTGenerator+resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) org.eclipse.jdt.core.dom.FieldAccess+getExpression() org.eclipse.jdt.core.dom.FieldAccess+getExpression() processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+definedIn3rdPartyClass(PreprocessedSketch,ClassMember,String) processing.mode.java.pdex.ASTGenerator+definedIn3rdPartyClass(PreprocessedSketch,ClassMember,String) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.FieldAccess+getName() org.eclipse.jdt.core.dom.FieldAccess+getName() org.eclipse.jdt.core.dom.ASTNode+toString() processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) org.eclipse.jdt.core.dom.MethodInvocation+getName() org.eclipse.jdt.core.dom.MethodInvocation+getName() processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) org.eclipse.jdt.core.dom.MethodInvocation+getName() org.eclipse.jdt.core.dom.MethodInvocation+getName() processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+extracTypeInfo2(ASTNode) processing.mode.java.pdex.ASTGenerator+extracTypeInfo2(ASTNode) org.eclipse.jdt.core.dom.Type+isArrayType() org.eclipse.jdt.core.dom.Type+isArrayType() org.eclipse.jdt.core.dom.ASTNode+getNodeType() org.eclipse.jdt.core.dom.ASTNode+getParent() org.eclipse.jdt.core.dom.ASTNode+getParent() org.eclipse.jdt.core.dom.ASTNode+getNodeType() org.eclipse.jdt.core.dom.ArrayType+getElementType() org.eclipse.jdt.core.dom.ArrayType+getElementType() org.eclipse.jdt.core.dom.Type+isSimpleType() org.eclipse.jdt.core.dom.Type+isSimpleType() processing.mode.java.pdex.ASTGenerator+findClassIfExists(PreprocessedSketch,String) processing.mode.java.pdex.ASTGenerator+findClassIfExists(PreprocessedSketch,String) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.ASTNode+toString() java.lang.Class+getName() java.lang.Class+getName() org.eclipse.jdt.core.dom.Type+isPrimitiveType() org.eclipse.jdt.core.dom.Type+isPrimitiveType() org.eclipse.jdt.core.dom.PrimitiveType.Code+toString() org.eclipse.jdt.core.dom.PrimitiveType+getPrimitiveTypeCode() org.eclipse.jdt.core.dom.PrimitiveType+getPrimitiveTypeCode() org.eclipse.jdt.core.dom.PrimitiveType.Code+toString() processing.mode.java.pdex.ASTGenerator+getArrayClass(String,ClassLoader) processing.mode.java.pdex.ASTGenerator+getArrayClass(String,ClassLoader) processing.mode.java.pdex.ASTGenerator.ClassMember+ClassMember(Class<?>) processing.mode.java.pdex.ASTGenerator.ClassMember+ClassMember(PreprocessedSketch,ASTNode) processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) org.eclipse.jdt.core.dom.MethodInvocation+getExpression() org.eclipse.jdt.core.dom.MethodInvocation+getExpression() processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) org.eclipse.jdt.core.dom.MethodInvocation+getExpression() org.eclipse.jdt.core.dom.MethodInvocation+getExpression() processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) org.eclipse.jdt.core.dom.MethodInvocation+getExpression() org.eclipse.jdt.core.dom.MethodInvocation+getExpression() org.eclipse.jdt.core.dom.ASTNode+getNodeType() org.eclipse.jdt.core.dom.ASTNode+getNodeType() processing.mode.java.pdex.ASTGenerator.ClassMember+ClassMember(PreprocessedSketch,ASTNode) processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+findClassIfExists(PreprocessedSketch,String) processing.mode.java.pdex.ASTGenerator+findClassIfExists(PreprocessedSketch,String) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.MethodInvocation+getExpression() org.eclipse.jdt.core.dom.MethodInvocation+getExpression() org.eclipse.jdt.core.dom.ASTNode+toString() processing.mode.java.pdex.ASTGenerator+definedIn3rdPartyClass(PreprocessedSketch,ClassMember,String) processing.mode.java.pdex.ASTGenerator+definedIn3rdPartyClass(PreprocessedSketch,ClassMember,String) processing.mode.java.pdex.ASTGenerator.ClassMember+ClassMember(Class<?>) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.MethodInvocation+getName() org.eclipse.jdt.core.dom.MethodInvocation+getName() org.eclipse.jdt.core.dom.ASTNode+toString() processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) org.eclipse.jdt.core.dom.MethodInvocation+getExpression() org.eclipse.jdt.core.dom.MethodInvocation+getExpression() processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) org.eclipse.jdt.core.dom.SimpleType+getName() org.eclipse.jdt.core.dom.SimpleType+getName() processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) org.eclipse.jdt.core.dom.SimpleType+getName() org.eclipse.jdt.core.dom.SimpleType+getName() processing.mode.java.pdex.ASTGenerator+findClassIfExists(PreprocessedSketch,String) processing.mode.java.pdex.ASTGenerator+findClassIfExists(PreprocessedSketch,String) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.SimpleType+getName() org.eclipse.jdt.core.dom.SimpleType+getName() org.eclipse.jdt.core.dom.ASTNode+toString() processing.mode.java.pdex.ASTGenerator+definedIn3rdPartyClass(PreprocessedSketch,ClassMember,String) processing.mode.java.pdex.ASTGenerator+definedIn3rdPartyClass(PreprocessedSketch,ClassMember,String) processing.mode.java.pdex.ASTGenerator.ClassMember+ClassMember(Class<?>) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.MethodInvocation+getName() org.eclipse.jdt.core.dom.MethodInvocation+getName() org.eclipse.jdt.core.dom.ASTNode+toString() processing.mode.java.pdex.ASTGenerator+definedIn3rdPartyClass(PreprocessedSketch,ClassMember,String) processing.mode.java.pdex.ASTGenerator+definedIn3rdPartyClass(PreprocessedSketch,ClassMember,String) processing.mode.java.pdex.ASTGenerator.ClassMember+ClassMember(PreprocessedSketch,ASTNode) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.MethodInvocation+getName() org.eclipse.jdt.core.dom.MethodInvocation+getName() org.eclipse.jdt.core.dom.ASTNode+toString() processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) org.eclipse.jdt.core.dom.MethodInvocation+getExpression() org.eclipse.jdt.core.dom.MethodInvocation+getExpression() processing.mode.java.pdex.ASTGenerator+resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) processing.mode.java.pdex.ASTGenerator+resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) org.eclipse.jdt.core.dom.MethodInvocation+getExpression() org.eclipse.jdt.core.dom.MethodInvocation+getExpression() processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+definedIn3rdPartyClass(PreprocessedSketch,ClassMember,String) processing.mode.java.pdex.ASTGenerator+definedIn3rdPartyClass(PreprocessedSketch,ClassMember,String) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.MethodInvocation+getName() org.eclipse.jdt.core.dom.MethodInvocation+getName() org.eclipse.jdt.core.dom.ASTNode+toString() processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) org.eclipse.jdt.core.dom.QualifiedName+getName() org.eclipse.jdt.core.dom.QualifiedName+getName() processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) org.eclipse.jdt.core.dom.QualifiedName+getName() org.eclipse.jdt.core.dom.QualifiedName+getName() processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator.ClassMember+ClassMember(PreprocessedSketch,ASTNode) processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) org.eclipse.jdt.core.dom.QualifiedName+getQualifier() org.eclipse.jdt.core.dom.QualifiedName+getQualifier() processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) org.eclipse.jdt.core.dom.QualifiedName+getQualifier() org.eclipse.jdt.core.dom.QualifiedName+getQualifier() processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) org.eclipse.jdt.core.dom.QualifiedName+getQualifier() org.eclipse.jdt.core.dom.QualifiedName+getQualifier() processing.mode.java.pdex.ASTGenerator+findClassIfExists(PreprocessedSketch,String) processing.mode.java.pdex.ASTGenerator+findClassIfExists(PreprocessedSketch,String) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.QualifiedName+getQualifier() org.eclipse.jdt.core.dom.QualifiedName+getQualifier() org.eclipse.jdt.core.dom.ASTNode+toString() processing.mode.java.pdex.ASTGenerator+definedIn3rdPartyClass(PreprocessedSketch,ClassMember,String) processing.mode.java.pdex.ASTGenerator+definedIn3rdPartyClass(PreprocessedSketch,ClassMember,String) processing.mode.java.pdex.ASTGenerator.ClassMember+ClassMember(Class<?>) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.QualifiedName+getName() org.eclipse.jdt.core.dom.QualifiedName+getName() org.eclipse.jdt.core.dom.ASTNode+toString() processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) org.eclipse.jdt.core.dom.QualifiedName+getQualifier() org.eclipse.jdt.core.dom.QualifiedName+getQualifier() processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) org.eclipse.jdt.core.dom.SimpleType+getName() org.eclipse.jdt.core.dom.SimpleType+getName() processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) org.eclipse.jdt.core.dom.SimpleType+getName() org.eclipse.jdt.core.dom.SimpleType+getName() processing.mode.java.pdex.ASTGenerator+findClassIfExists(PreprocessedSketch,String) processing.mode.java.pdex.ASTGenerator+findClassIfExists(PreprocessedSketch,String) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.SimpleType+getName() org.eclipse.jdt.core.dom.SimpleType+getName() org.eclipse.jdt.core.dom.ASTNode+toString() processing.mode.java.pdex.ASTGenerator+definedIn3rdPartyClass(PreprocessedSketch,ClassMember,String) processing.mode.java.pdex.ASTGenerator+definedIn3rdPartyClass(PreprocessedSketch,ClassMember,String) processing.mode.java.pdex.ASTGenerator.ClassMember+ClassMember(Class<?>) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.QualifiedName+getName() org.eclipse.jdt.core.dom.QualifiedName+getName() org.eclipse.jdt.core.dom.ASTNode+toString() processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) org.eclipse.jdt.core.dom.QualifiedName+getQualifier() org.eclipse.jdt.core.dom.QualifiedName+getQualifier() processing.mode.java.pdex.ASTGenerator+definedIn3rdPartyClass(PreprocessedSketch,ClassMember,String) processing.mode.java.pdex.ASTGenerator+definedIn3rdPartyClass(PreprocessedSketch,ClassMember,String) processing.mode.java.pdex.ASTGenerator.ClassMember+ClassMember(PreprocessedSketch,ASTNode) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.QualifiedName+getName() org.eclipse.jdt.core.dom.QualifiedName+getName() org.eclipse.jdt.core.dom.ASTNode+toString() processing.mode.java.pdex.ASTGenerator+resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) processing.mode.java.pdex.ASTGenerator+resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) org.eclipse.jdt.core.dom.QualifiedName+getQualifier() org.eclipse.jdt.core.dom.QualifiedName+getQualifier() processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+definedIn3rdPartyClass(PreprocessedSketch,ClassMember,String) processing.mode.java.pdex.ASTGenerator+definedIn3rdPartyClass(PreprocessedSketch,ClassMember,String) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.QualifiedName+getName() org.eclipse.jdt.core.dom.QualifiedName+getName() org.eclipse.jdt.core.dom.ASTNode+toString() processing.mode.java.pdex.ASTGenerator+resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) processing.mode.java.pdex.ASTGenerator+resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) org.eclipse.jdt.core.dom.ArrayAccess+getArray() org.eclipse.jdt.core.dom.ArrayAccess+getArray() processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode)",org.eclipse.jdt.core.dom.ASTNode+TYPE_DECLARATION org.eclipse.jdt.core.dom.ASTNode+ARRAY_ACCESS processing.mode.java.pdex.PreprocessedSketch+classLoader org.eclipse.jdt.core.dom.ASTNode+FIELD_ACCESS org.eclipse.jdt.core.dom.ASTNode+METHOD_INVOCATION org.eclipse.jdt.core.dom.ASTNode+ARRAY_ACCESS processing.mode.java.pdex.PreprocessedSketch+classLoader org.eclipse.jdt.core.dom.ASTNode+TYPE_DECLARATION org.eclipse.jdt.core.dom.ASTNode+QUALIFIED_NAME org.eclipse.jdt.core.dom.ASTNode+ARRAY_ACCESS,11078,255,9,"/** 
 * Finds the type of the expression in foo.bar().a().b, this would give me the type of b if it exists in return type of a(). If noCompare is true, it'll return type of a()
 * @param nearestNode
 * @param astNode
 * @return
 */
","/**
   * Finds the type of the expression in foo.bar().a().b, this would give me the
   * type of b if it exists in return type of a(). If noCompare is true,
   * it'll return type of a()
   * @param nearestNode
   * @param astNode
   * @return
   */
  public static ClassMember resolveExpression3rdParty(PreprocessedSketch ps, ASTNode nearestNode,
                                                      ASTNode astNode, boolean noCompare) {
    log(""Resolve 3rdParty expr-- "" + getNodeAsString(astNode)
        + "" nearest node "" + getNodeAsString(nearestNode));
    if(astNode == null) return null;
    ClassMember scopeParent;
    SimpleType stp;
    if(astNode instanceof SimpleName){
      ASTNode decl = findDeclaration2(((SimpleName)astNode),nearestNode);
      if(decl != null){
        // see if locally defined
        log(getNodeAsString(astNode)+"" found decl -> "" + getNodeAsString(decl));

        {
          if (decl.getNodeType() == ASTNode.TYPE_DECLARATION) {
            TypeDeclaration td = (TypeDeclaration) decl;
            return new ClassMember(ps, td);
          }
        }

        { // Handle ""array."" x ""array[1].""
          Type type = extracTypeInfo2(decl);
          if (type != null && type.isArrayType() &&
              astNode.getParent().getNodeType() != ASTNode.ARRAY_ACCESS) {
            // No array access, we want members of the array itself
            Type elementType = ((ArrayType) type).getElementType();

            // Get name of the element class
            String name = """";
            if (elementType.isSimpleType()) {
              Class<?> c = findClassIfExists(ps, elementType.toString());
              if (c != null) name = c.getName();
            } else if (elementType.isPrimitiveType()) {
              name = ((PrimitiveType) elementType).getPrimitiveTypeCode().toString();
            }

            // Convert element class to array class
            Class<?> arrayClass = getArrayClass(name, ps.classLoader);

            return arrayClass == null ? null : new ClassMember(arrayClass);
          }
        }

        return new ClassMember(ps, extracTypeInfo(decl));
      }
      else {
        // or in a predefined class?
        Class<?> tehClass = findClassIfExists(ps, astNode.toString());
        if (tehClass != null) {
          return new ClassMember(tehClass);
        }
      }
      astNode = astNode.getParent();
    }
    switch (astNode.getNodeType()) {
    //TODO: Notice the redundancy in the 3 cases, you can simplify things even more.
    case ASTNode.FIELD_ACCESS:
      FieldAccess fa = (FieldAccess) astNode;
      if (fa.getExpression() == null) {

        // TODO: Check for existence of 'new' keyword. Could be a ClassInstanceCreation

        // Local code or belongs to super class
        log(""FA,Not implemented."");
        return null;
      } else {
        if (fa.getExpression() instanceof SimpleName) {
          stp = extracTypeInfo(findDeclaration2((SimpleName) fa.getExpression(),
                                                nearestNode));
          if(stp == null){
            /*The type wasn't found in local code, so it might be something like
             * log(), or maybe belonging to super class, etc.
             */
            Class<?> tehClass = findClassIfExists(ps, fa.getExpression().toString());
            if (tehClass != null) {
              // Method Expression is a simple name and wasn't located locally, but found in a class
              // so look for method in this class.
              return definedIn3rdPartyClass(ps, new ClassMember(tehClass), fa
                  .getName().toString());
            }
            log(""FA resolve 3rd par, Can't resolve "" + fa.getExpression());

            return null;
          }
          log(""FA, SN Type "" + getNodeAsString(stp));
          scopeParent = definedIn3rdPartyClass(ps, stp.getName().toString(), ""THIS"");

        } else {
          scopeParent = resolveExpression3rdParty(ps, nearestNode,
                                                  fa.getExpression(), noCompare);
        }
        log(""FA, ScopeParent "" + scopeParent);
        return definedIn3rdPartyClass(ps, scopeParent, fa.getName().toString());
      }
    case ASTNode.METHOD_INVOCATION:
      MethodInvocation mi = (MethodInvocation) astNode;
      ASTNode temp = findDeclaration2(mi.getName(), nearestNode);
      if(temp instanceof MethodDeclaration){
        // method is locally defined
        log(mi.getName() + "" was found locally,"" + getNodeAsString(extracTypeInfo(temp)));

        { // Handle ""array."" x ""array[1].""
          Type type = extracTypeInfo2(temp);
          if (type != null && type.isArrayType() &&
              astNode.getParent().getNodeType() != ASTNode.ARRAY_ACCESS) {
            // No array access, we want members of the array itself
            Type elementType = ((ArrayType) type).getElementType();

            // Get name of the element class
            String name = """";
            if (elementType.isSimpleType()) {
              Class<?> c = findClassIfExists(ps, elementType.toString());
              if (c != null) name = c.getName();
            } else if (elementType.isPrimitiveType()) {
              name = ((PrimitiveType) elementType).getPrimitiveTypeCode().toString();
            }

            // Convert element class to array class
            Class<?> arrayClass = getArrayClass(name, ps.classLoader);

            return arrayClass == null ? null : new ClassMember(arrayClass);
          }
        }

        return new ClassMember(ps, extracTypeInfo(temp));
      }
      if (mi.getExpression() == null) {
//        if()
        //Local code or belongs to super class
        log(""MI,Not implemented."");
        return null;
      } else {
        if (mi.getExpression() instanceof SimpleName) {
          ASTNode decl = findDeclaration2((SimpleName) mi.getExpression(),
                                          nearestNode);
          if (decl != null) {
            if (decl.getNodeType() == ASTNode.TYPE_DECLARATION) {
              TypeDeclaration td = (TypeDeclaration) decl;
              return new ClassMember(ps, td);
            }

            stp = extracTypeInfo(decl);
            if(stp == null){
            /*The type wasn't found in local code, so it might be something like
             * System.console()., or maybe belonging to super class, etc.
             */
              Class<?> tehClass = findClassIfExists(ps, mi.getExpression().toString());
              if (tehClass != null) {
                // Method Expression is a simple name and wasn't located locally, but found in a class
                // so look for method in this class.
                return definedIn3rdPartyClass(ps, new ClassMember(tehClass), mi
                    .getName().toString());
              }
              log(""MI resolve 3rd par, Can't resolve "" + mi.getExpression());
              return null;
            }
            log(""MI, SN Type "" + getNodeAsString(stp));
            ASTNode typeDec = findDeclaration2(stp.getName(),nearestNode);
            if(typeDec == null){
              log(stp.getName() + "" couldn't be found locally.."");
              Class<?> tehClass = findClassIfExists(ps, stp.getName().toString());
              if (tehClass != null) {
                // Method Expression is a simple name and wasn't located locally, but found in a class
                // so look for method in this class.
                return definedIn3rdPartyClass(ps, new ClassMember(tehClass), mi
                    .getName().toString());
              }
              //return new ClassMember(findClassIfExists(stp.getName().toString()));
            }
            //scopeParent = definedIn3rdPartyClass(stp.getName().toString(), ""THIS"");
            return definedIn3rdPartyClass(ps, new ClassMember(ps, typeDec), mi
                .getName().toString());
          }
        } else {
          log(""MI EXP..""+getNodeAsString(mi.getExpression()));
//          return null;
          scopeParent = resolveExpression3rdParty(ps, nearestNode,
                                                  mi.getExpression(), noCompare);
          log(""MI, ScopeParent "" + scopeParent);
          return definedIn3rdPartyClass(ps, scopeParent, mi.getName().toString());
        }

      }
      break;
    case ASTNode.QUALIFIED_NAME:
      QualifiedName qn = (QualifiedName) astNode;
      ASTNode temp2 = findDeclaration2(qn.getName(), nearestNode);
      if(temp2 instanceof FieldDeclaration){
        // field is locally defined
        log(qn.getName() + "" was found locally,"" + getNodeAsString(extracTypeInfo(temp2)));
        return new ClassMember(ps, extracTypeInfo(temp2));
      }
      if (qn.getQualifier() == null) {
        log(""QN,Not implemented."");
        return null;
      } else  {

        if (qn.getQualifier() instanceof SimpleName) {
          stp = extracTypeInfo(findDeclaration2(qn.getQualifier(), nearestNode));
          if(stp == null){
            /*The type wasn't found in local code, so it might be something like
             * log(), or maybe belonging to super class, etc.
             */
            Class<?> tehClass = findClassIfExists(ps, qn.getQualifier().toString());
            if (tehClass != null) {
              // note how similar thing is called on line 690. Check check.
              return definedIn3rdPartyClass(ps, new ClassMember(tehClass), qn
                  .getName().toString());
            }
            log(""QN resolve 3rd par, Can't resolve "" + qn.getQualifier());
            return null;
          }
          log(""QN, SN Local Type "" + getNodeAsString(stp));
          //scopeParent = definedIn3rdPartyClass(stp.getName().toString(), ""THIS"");
          ASTNode typeDec = findDeclaration2(stp.getName(),nearestNode);
          if(typeDec == null){
            log(stp.getName() + "" couldn't be found locally.."");

            Class<?> tehClass = findClassIfExists(ps, stp.getName().toString());
            if (tehClass != null) {
              // note how similar thing is called on line 690. Check check.
              return definedIn3rdPartyClass(ps, new ClassMember(tehClass), qn
                  .getName().toString());
            }
            log(""QN resolve 3rd par, Can't resolve "" + qn.getQualifier());
            return null;
          }
          return definedIn3rdPartyClass(ps, new ClassMember(ps, typeDec), qn
                                        .getName().toString());
        } else {
          scopeParent = resolveExpression3rdParty(ps, nearestNode,
                                                  qn.getQualifier(), noCompare);
          log(""QN, ScopeParent "" + scopeParent);
          return definedIn3rdPartyClass(ps, scopeParent, qn.getName().toString());
        }

      }
    case ASTNode.ARRAY_ACCESS:
      ArrayAccess arac = (ArrayAccess)astNode;
      return resolveExpression3rdParty(ps, nearestNode, arac.getArray(), noCompare);
    default:
      log(""Unaccounted type "" + getNodeAsString(astNode));
      break;
    }

    return null;
  }",False,False,"The function resolves the type of an expression in a given code snippet. It takes in the nearest node, the AST node, and a boolean flag as parameters, and returns the resolved type of the expression.","The code defines a method called ""resolveExpression3rdParty"" that takes in several parameters and returns a ClassMember object. It is used to find the type of an expression in a given ASTNode, considering various scenarios such as field access, method invocation, qualified name, and array access. The method also handles cases where the type is not found locally and may belong to a predefined class."
9,"getArrayClass(String,ClassLoader)",get array class element class class loader ,Method,"resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean)",,"java.lang.String+startsWith(String) java.lang.String+startsWith(String) java.lang.String+equals(Object) java.lang.String+equals(Object) java.lang.String+equals(Object) java.lang.String+equals(Object) java.lang.String+equals(Object) java.lang.String+equals(Object) java.lang.String+equals(Object) java.lang.String+equals(Object) java.lang.String+equals(Object) java.lang.String+equals(Object) java.lang.String+equals(Object) java.lang.String+equals(Object) java.lang.String+equals(Object) java.lang.String+equals(Object) java.lang.String+equals(Object) java.lang.String+equals(Object) processing.mode.java.pdex.ASTGenerator+loadClass(String,ClassLoader) processing.mode.java.pdex.ASTGenerator+loadClass(String,ClassLoader)",,879,27,9,,"public static Class<?> getArrayClass(String elementClass, ClassLoader classLoader) {
    String name;
    if (elementClass.startsWith(""["")) {
      // just add a leading ""[""
      name = ""["" + elementClass;
    } else if (elementClass.equals(""boolean"")) {
      name = ""[Z"";
    } else if (elementClass.equals(""byte"")) {
      name = ""[B"";
    } else if (elementClass.equals(""char"")) {
      name = ""[C"";
    } else if (elementClass.equals(""double"")) {
      name = ""[D"";
    } else if (elementClass.equals(""float"")) {
      name = ""[F"";
    } else if (elementClass.equals(""int"")) {
      name = ""[I"";
    } else if (elementClass.equals(""long"")) {
      name = ""[J"";
    } else if (elementClass.equals(""short"")) {
      name = ""[S"";
    } else {
      // must be an object non-array class
      name = ""[L"" + elementClass + "";"";
    }
    return loadClass(name, classLoader);
  }",False,False,This method returns the Class object for an array class based on the given element class name and class loader. It handles primitive types and non-array object classes.,"The given code is a method named ""getArrayClass"" that takes in a string representing the element class and a class loader. It returns the class object for the corresponding array class based on the element class provided."
10,getChildExpression(ASTNode),get child expression expression for a abc a123 this would return a123 param expression return ,Method,"preparePredictions(PreprocessedSketch,String,int)",,org.eclipse.jdt.core.dom.FieldAccess+getName() org.eclipse.jdt.core.dom.FieldAccess+getName() org.eclipse.jdt.core.dom.QualifiedName+getName() org.eclipse.jdt.core.dom.QualifiedName+getName() org.eclipse.jdt.core.dom.MethodInvocation+getName() org.eclipse.jdt.core.dom.MethodInvocation+getName() org.eclipse.jdt.core.dom.ArrayAccess+getArray() org.eclipse.jdt.core.dom.ArrayAccess+getArray() processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode),,796,23,9,"/** 
 * For a().abc.a123 this would return a123
 * @param expression
 * @return
 */
","/**
   * For a().abc.a123 this would return a123
   *
   * @param expression
   * @return
   */
  public static ASTNode getChildExpression(ASTNode expression) {
//    ASTNode anode = null;
    if (expression instanceof SimpleName) {
      return expression;
    } else if (expression instanceof FieldAccess) {
      return ((FieldAccess) expression).getName();
    } else if (expression instanceof QualifiedName) {
      return ((QualifiedName) expression).getName();
    }else if (expression instanceof MethodInvocation) {
      return ((MethodInvocation) expression).getName();
    }else if(expression instanceof ArrayAccess){
      return ((ArrayAccess)expression).getArray();
    }
    log("" getChildExpression returning NULL for ""
        + getNodeAsString(expression));
    return null;
  }",False,False,"The function `getChildExpression` takes an `ASTNode` as input and returns a specific child expression based on the type of the input expression. It returns the name of the expression if it is a `SimpleName`, `FieldAccess`, `QualifiedName`, `MethodInvocation`, or `ArrayAccess`. Otherwise, it returns `null`.","The code defines a method named `getChildExpression` that takes an `ASTNode` as input and returns a specific child expression based on the type of the input expression. It handles different types of expressions such as `SimpleName`, `FieldAccess`, `QualifiedName`, `MethodInvocation`, and `ArrayAccess`, returning the appropriate child expression. If the input expression does not match any of these types, it logs an error message and returns null."
11,getParentExpression(ASTNode),get parent expression expression ,Method,"preparePredictions(PreprocessedSketch,String,int) preparePredictions(PreprocessedSketch,String,int)",,org.eclipse.jdt.core.dom.FieldAccess+getExpression() org.eclipse.jdt.core.dom.FieldAccess+getExpression() org.eclipse.jdt.core.dom.QualifiedName+getQualifier() org.eclipse.jdt.core.dom.QualifiedName+getQualifier() org.eclipse.jdt.core.dom.MethodInvocation+getExpression() org.eclipse.jdt.core.dom.MethodInvocation+getExpression() org.eclipse.jdt.core.dom.ArrayAccess+getArray() org.eclipse.jdt.core.dom.ArrayAccess+getArray() processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode),,719,17,9,,"public static ASTNode getParentExpression(ASTNode expression) {
//  ASTNode anode = null;
    if (expression instanceof SimpleName) {
      return expression;
    } else if (expression instanceof FieldAccess) {
      return ((FieldAccess) expression).getExpression();
    } else if (expression instanceof QualifiedName) {
      return ((QualifiedName) expression).getQualifier();
    } else if (expression instanceof MethodInvocation) {
      return ((MethodInvocation) expression).getExpression();
    } else if (expression instanceof ArrayAccess) {
      return ((ArrayAccess) expression).getArray();
    }
    log(""getParentExpression returning NULL for ""
        + getNodeAsString(expression));
    return null;
  }",False,False,"The function ""getParentExpression"" takes an ASTNode as input and returns the parent expression of that node. It checks the type of the input expression and returns the appropriate parent expression based on the type. If the type is not recognized, it logs an error message and returns null.","The code defines a method named ""getParentExpression"" that takes an ASTNode as input and returns the parent expression of that node. It checks the type of the input expression and returns the appropriate parent expression based on the type. If the type is not recognized, it logs an error message and returns null."
12,"getMembersForType(PreprocessedSketch,String,String,boolean,boolean)",get members for type ps type name child no compare static only loads classes from jar files in sketch classpath param type name param child param no compare return ,Method,"preparePredictions(PreprocessedSketch,String,int)",,"processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+findClassIfExists(PreprocessedSketch,String) processing.mode.java.pdex.ASTGenerator+findClassIfExists(PreprocessedSketch,String) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+getMembersForType(PreprocessedSketch,ClassMember,String,boolean,boolean) processing.mode.java.pdex.ASTGenerator+getMembersForType(PreprocessedSketch,ClassMember,String,boolean,boolean) processing.mode.java.pdex.ASTGenerator.ClassMember+ClassMember(Class<?>)",,1046,25,9,"/** 
 * Loads classes from .jar files in sketch classpath
 * @param typeName
 * @param child
 * @param noCompare
 * @return
 */
","/**
   * Loads classes from .jar files in sketch classpath
   *
   * @param typeName
   * @param child
   * @param noCompare
   * @return
   */
  public static ArrayList<CompletionCandidate> getMembersForType(PreprocessedSketch ps,
                                                                 String typeName,
                                                                 String child,
                                                                 boolean noCompare,
                                                                 boolean staticOnly) {
    ArrayList<CompletionCandidate> candidates = new ArrayList<>();
    log(""In GMFT(), Looking for match "" + child
        + "" in class "" + typeName + "" noCompare "" + noCompare + "" staticOnly ""
        + staticOnly);
    Class<?> probableClass = findClassIfExists(ps, typeName);
    if(probableClass == null){
      log(""In GMFT(), class not found."");
      return candidates;
    }
   return getMembersForType(ps, new ClassMember(probableClass), child, noCompare, staticOnly);

  }",False,False,"The function of this method is to retrieve a list of completion candidates (members) for a given type (class) from a preprocessed sketch. It takes in parameters such as the preprocessed sketch, the type name, a child name, a flag for comparison, and a flag for static members only. It returns an ArrayList of CompletionCandidate objects.","The given code is a method named ""getMembersForType"" that takes in several parameters including a PreprocessedSketch object, a typeName string, a child string, and boolean values. It returns an ArrayList of CompletionCandidate objects. The method searches for a match in the specified class and returns the members of that class based on the provided parameters."
13,"getMembersForType(PreprocessedSketch,ClassMember,String,boolean,boolean)",get members for type ps teh class child to look for no compare static only ,Method,"getMembersForType(PreprocessedSketch,String,String,boolean,boolean) getMembersForType(PreprocessedSketch,ClassMember,String,boolean,boolean) getMembersForType(PreprocessedSketch,ClassMember,String,boolean,boolean) preparePredictions(PreprocessedSketch,String,int)",,"java.lang.String+toLowerCase() java.lang.String+toLowerCase() processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator.ClassMember+getDeclaringNode() processing.mode.java.pdex.ASTGenerator.ClassMember+getDeclaringNode() processing.mode.java.pdex.ASTGenerator.ClassMember+getDeclaringNode() processing.mode.java.pdex.ASTGenerator.ClassMember+getDeclaringNode() org.eclipse.jdt.core.dom.TypeDeclaration+getFields() org.eclipse.jdt.core.dom.TypeDeclaration+getFields() processing.mode.java.pdex.ASTGenerator+isStatic(List<Modifier>) processing.mode.java.pdex.ASTGenerator+isStatic(List<Modifier>) org.eclipse.jdt.core.dom.BodyDeclaration+modifiers() org.eclipse.jdt.core.dom.BodyDeclaration+modifiers() org.eclipse.jdt.core.dom.FieldDeclaration+fragments() org.eclipse.jdt.core.dom.FieldDeclaration+fragments() java.util.ArrayList+add(E) java.util.ArrayList+add(E) processing.mode.java.pdex.CompletionCandidate+CompletionCandidate(VariableDeclarationFragment) java.lang.String+startsWith(String) java.lang.String+toLowerCase() org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.VariableDeclaration+getName() org.eclipse.jdt.core.dom.VariableDeclaration+getName() org.eclipse.jdt.core.dom.ASTNode+toString() java.lang.String+toLowerCase() java.lang.String+startsWith(String) java.util.ArrayList+add(E) java.util.ArrayList+add(E) processing.mode.java.pdex.CompletionCandidate+CompletionCandidate(VariableDeclarationFragment) org.eclipse.jdt.core.dom.TypeDeclaration+getMethods() org.eclipse.jdt.core.dom.TypeDeclaration+getMethods() processing.mode.java.pdex.ASTGenerator+isStatic(List<Modifier>) processing.mode.java.pdex.ASTGenerator+isStatic(List<Modifier>) org.eclipse.jdt.core.dom.BodyDeclaration+modifiers() org.eclipse.jdt.core.dom.BodyDeclaration+modifiers() java.util.ArrayList+add(E) java.util.ArrayList+add(E) processing.mode.java.pdex.CompletionCandidate+CompletionCandidate(MethodDeclaration) java.lang.String+startsWith(String) java.lang.String+toLowerCase() org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.MethodDeclaration+getName() org.eclipse.jdt.core.dom.MethodDeclaration+getName() org.eclipse.jdt.core.dom.ASTNode+toString() java.lang.String+toLowerCase() java.lang.String+startsWith(String) java.util.ArrayList+add(E) java.util.ArrayList+add(E) processing.mode.java.pdex.CompletionCandidate+CompletionCandidate(MethodDeclaration) org.eclipse.jdt.core.dom.TypeDeclaration+getSuperclassType() org.eclipse.jdt.core.dom.TypeDeclaration+getSuperclassType() processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) org.eclipse.jdt.core.dom.TypeDeclaration+getSuperclassType() org.eclipse.jdt.core.dom.TypeDeclaration+getSuperclassType() processing.mode.java.pdex.ASTGenerator+getMembersForType(PreprocessedSketch,ClassMember,String,boolean,boolean) processing.mode.java.pdex.ASTGenerator+getMembersForType(PreprocessedSketch,ClassMember,String,boolean,boolean) processing.mode.java.pdex.ASTGenerator.ClassMember+ClassMember(PreprocessedSketch,ASTNode) org.eclipse.jdt.core.dom.TypeDeclaration+getSuperclassType() org.eclipse.jdt.core.dom.TypeDeclaration+getSuperclassType() processing.mode.java.pdex.ASTGenerator+getMembersForType(PreprocessedSketch,ClassMember,String,boolean,boolean) processing.mode.java.pdex.ASTGenerator+getMembersForType(PreprocessedSketch,ClassMember,String,boolean,boolean) processing.mode.java.pdex.ASTGenerator.ClassMember+ClassMember(Class<?>) java.util.ArrayList+add(E) java.util.ArrayList+add(E) processing.mode.java.pdex.ASTGenerator.ClassMember+getClass_() processing.mode.java.pdex.ASTGenerator.ClassMember+getClass_() processing.mode.java.pdex.ASTGenerator.ClassMember+getClass_() processing.mode.java.pdex.ASTGenerator.ClassMember+getClass_() processing.mode.java.pdex.ASTGenerator+findClassIfExists(PreprocessedSketch,String) processing.mode.java.pdex.ASTGenerator+findClassIfExists(PreprocessedSketch,String) processing.mode.java.pdex.ASTGenerator.ClassMember+getTypeAsString() processing.mode.java.pdex.ASTGenerator.ClassMember+getTypeAsString() processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator.ClassMember+getTypeAsString() processing.mode.java.pdex.ASTGenerator.ClassMember+getTypeAsString() processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) java.lang.Class+toString() java.lang.Class+toString() java.lang.Class+getMethods() java.lang.Class+getMethods() java.lang.reflect.Modifier+isStatic(int) java.lang.reflect.Modifier+isStatic(int) java.lang.reflect.Method+getModifiers() java.lang.reflect.Method+getModifiers() java.lang.StringBuilder+StringBuilder(String) java.lang.reflect.Method+getName() java.lang.reflect.Method+getName() java.lang.reflect.Method+getParameterTypes() java.lang.reflect.Method+getParameterTypes() java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.Class+getSimpleName() java.lang.reflect.Method+getParameterTypes() java.lang.reflect.Method+getParameterTypes() java.lang.Class+getSimpleName() java.lang.reflect.Method+getParameterTypes() java.lang.reflect.Method+getParameterTypes() java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.util.ArrayList+add(E) java.util.ArrayList+add(E) processing.mode.java.pdex.CompletionCandidate+CompletionCandidate(Method) java.lang.String+startsWith(String) java.lang.String+toLowerCase() java.lang.StringBuilder+toString() java.lang.StringBuilder+toString() java.lang.String+toLowerCase() java.lang.String+startsWith(String) java.util.ArrayList+add(E) java.util.ArrayList+add(E) processing.mode.java.pdex.CompletionCandidate+CompletionCandidate(Method) java.lang.Class+getFields() java.lang.Class+getFields() java.lang.reflect.Modifier+isStatic(int) java.lang.reflect.Modifier+isStatic(int) java.lang.reflect.Field+getModifiers() java.lang.reflect.Field+getModifiers() java.util.ArrayList+add(E) java.util.ArrayList+add(E) processing.mode.java.pdex.CompletionCandidate+CompletionCandidate(Field) java.lang.String+startsWith(String) java.lang.String+toLowerCase() java.lang.reflect.Field+getName() java.lang.reflect.Field+getName() java.lang.String+toLowerCase() java.lang.String+startsWith(String) java.util.ArrayList+add(E) java.util.ArrayList+add(E) processing.mode.java.pdex.CompletionCandidate+CompletionCandidate(Field) java.lang.Class+isArray() java.lang.Class+isArray() java.lang.Class+getSimpleName() java.lang.Class+getSimpleName() java.lang.String+startsWith(String) java.lang.String+startsWith(String) java.util.ArrayList+add(E) java.util.ArrayList+add(E) processing.mode.java.pdex.CompletionCandidate+CompletionCandidate(String,String,String,int) java.lang.String+startsWith(String) java.lang.String+startsWith(String) java.util.ArrayList+add(E) java.util.ArrayList+add(E) processing.mode.java.pdex.CompletionCandidate+CompletionCandidate(String,String,String,int)",processing.mode.java.pdex.CompletionCandidate+PREDEF_METHOD processing.mode.java.pdex.CompletionCandidate+PREDEF_FIELD,5188,125,9,,"public static ArrayList<CompletionCandidate> getMembersForType(PreprocessedSketch ps,
                                                                 ClassMember tehClass,
                                                                 String childToLookFor,
                                                                 boolean noCompare,
                                                                 boolean staticOnly) {
    String child = childToLookFor.toLowerCase();
    ArrayList<CompletionCandidate> candidates = new ArrayList<>();
    log(""getMemFoType-> Looking for match "" + child
        + "" inside "" + tehClass + "" noCompare "" + noCompare + "" staticOnly ""
        + staticOnly);
    if(tehClass == null){
      return candidates;
    }
    // tehClass will either be a TypeDecl defined locally
    if(tehClass.getDeclaringNode() instanceof TypeDeclaration){
      TypeDeclaration td = (TypeDeclaration) tehClass.getDeclaringNode();
      {
        FieldDeclaration[] fields = td.getFields();
        for (FieldDeclaration field : fields) {
          if (staticOnly && !isStatic(field.modifiers())) {
            continue;
          }
          List<VariableDeclarationFragment> vdfs = field.fragments();
          for (VariableDeclarationFragment vdf : vdfs) {
            if (noCompare) {
              candidates.add(new CompletionCandidate(vdf));
            } else if (vdf.getName().toString().toLowerCase().startsWith(child))
              candidates.add(new CompletionCandidate(vdf));
          }
        }
      }
      {
        MethodDeclaration[] methods = td.getMethods();
        for (MethodDeclaration method : methods) {
          if (staticOnly && !isStatic(method.modifiers())) {
            continue;
          }
          if (noCompare) {
            candidates.add(new CompletionCandidate(method));
          } else if (method.getName().toString().toLowerCase()
              .startsWith(child))
            candidates.add(new CompletionCandidate(method));
        }
      }

      ArrayList<CompletionCandidate> superClassCandidates;
      if(td.getSuperclassType() != null){
        log(getNodeAsString(td.getSuperclassType()) + "" <-Looking into superclass of "" + tehClass);
        superClassCandidates = getMembersForType(ps, new ClassMember(ps, td
                                                     .getSuperclassType()),
                                                 childToLookFor, noCompare, staticOnly);
      }
      else
      {
        superClassCandidates = getMembersForType(ps, new ClassMember(Object.class),
                                                 childToLookFor, noCompare, staticOnly);
      }
      for (CompletionCandidate cc : superClassCandidates) {
        candidates.add(cc);
      }
      return candidates;
    }

    // Or tehClass will be a predefined class

    Class<?> probableClass;
    if (tehClass.getClass_() != null) {
      probableClass = tehClass.getClass_();
    } else {
      probableClass = findClassIfExists(ps, tehClass.getTypeAsString());
      if (probableClass == null) {
        log(""Couldn't find class "" + tehClass.getTypeAsString());
        return candidates;
      }
      log(""Loaded "" + probableClass.toString());
    }
    for (Method method : probableClass.getMethods()) {
      if (!Modifier.isStatic(method.getModifiers()) && staticOnly) {
        continue;
      }

      StringBuilder label = new StringBuilder(method.getName() + ""("");
      for (int i = 0; i < method.getParameterTypes().length; i++) {
        label.append(method.getParameterTypes()[i].getSimpleName());
        if (i < method.getParameterTypes().length - 1)
          label.append("","");
      }
      label.append("")"");
      if (noCompare) {
        candidates.add(new CompletionCandidate(method));
      } else if (label.toString().toLowerCase().startsWith(child)) {
        candidates.add(new CompletionCandidate(method));
      }
    }
    for (Field field : probableClass.getFields()) {
      if (!Modifier.isStatic(field.getModifiers()) && staticOnly) {
        continue;
      }
      if (noCompare) {
        candidates.add(new CompletionCandidate(field));
      } else if (field.getName().toLowerCase().startsWith(child)) {
        candidates.add(new CompletionCandidate(field));
      }
    }
    if (probableClass.isArray() && !staticOnly) {
      // add array members manually, they can't be fetched through code

      String className = probableClass.getSimpleName();

      if (noCompare || ""clone()"".startsWith(child)) {
        String methodLabel = ""<html>clone() : "" + className +
            "" - <font color=#777777>"" + className + ""</font></html>"";
        candidates.add(new CompletionCandidate(""clone()"", methodLabel, ""clone()"",
                                               CompletionCandidate.PREDEF_METHOD));
      }

      if (""length"".startsWith(child)) {
        String fieldLabel = ""<html>length : int - <font color=#777777>"" +
            className + ""</font></html>"";
        candidates.add(new CompletionCandidate(""length"", fieldLabel, ""length"",
                                               CompletionCandidate.PREDEF_FIELD));
      }
    }
    return candidates;
  }",False,False,"The function of this method is to retrieve a list of completion candidates (methods and fields) for a given type. It searches for matches within the type's fields and methods, as well as in its superclass and predefined class. The method takes into account various parameters such as whether to compare case-insensitively, whether to include only static members, and the specific child to look for.","The code defines a method called `getMembersForType` that takes in a preprocessed sketch, a class member, a string to search for, and boolean flags. It searches for matching fields and methods within the given class and its superclass, or within a predefined class, and returns a list of completion candidates."
14,isStatic(List<org.eclipse.jdt.core.dom.Modifier>),is static modifiers ,Method,,,org.eclipse.jdt.core.dom.Modifier+isStatic() org.eclipse.jdt.core.dom.Modifier+isStatic(),,209,6,10,,"private static boolean isStatic(List<org.eclipse.jdt.core.dom.Modifier> modifiers) {
    for (org.eclipse.jdt.core.dom.Modifier m : modifiers) {
      if (m.isStatic()) return true;
    }
    return false;
  }",False,False,"The function checks if any of the modifiers in the given list is static. It returns true if at least one modifier is static, otherwise it returns false.","The given code is a method named ""isStatic"" that takes a list of modifiers as input. It iterates through the list and checks if any of the modifiers are static. If it finds a static modifier, it returns true; otherwise, it returns false."
15,"findClassIfExists(PreprocessedSketch,String)",find class if exists ps class name searches for the particular class in the default list of imports as well as the sketch classpath param class name return ,Method,"resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) getMembersForType(PreprocessedSketch,String,String,boolean,boolean) getMembersForType(PreprocessedSketch,ClassMember,String,boolean,boolean) definedIn3rdPartyClass(PreprocessedSketch,String,String) definedIn3rdPartyClass(PreprocessedSketch,ClassMember,String) ClassMember.ClassMember(PreprocessedSketch,ASTNode)",,"java.lang.String+indexOf(int) java.lang.String+indexOf(int) java.lang.String+split(String) java.lang.String+split(String) com.google.classpath.ClassPath+isPackage(String) com.google.classpath.ClassPath+isPackage(String) java.lang.String+replace(char,char) java.lang.String+replace(char,char) processing.mode.java.pdex.ASTGenerator+loadClass(String,ClassLoader) processing.mode.java.pdex.ASTGenerator+loadClass(String,ClassLoader) java.lang.String+indexOf(int) java.lang.String+indexOf(int) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ImportStatement+wholePackage(String) processing.mode.java.pdex.ImportStatement+wholePackage(String) java.util.stream.Stream+of(T) java.util.stream.Stream+of(T) java.util.Collections+singletonList(T) java.util.Collections+singletonList(T) java.util.stream.Stream+filter(Predicate) java.util.stream.Stream+map(Function) java.util.stream.Stream+map(Function) java.util.stream.Stream+filter(Predicate)",processing.mode.java.pdex.PreprocessedSketch+classPath processing.mode.java.pdex.PreprocessedSketch+classLoader processing.mode.java.pdex.PreprocessedSketch+programImports processing.mode.java.pdex.PreprocessedSketch+codeFolderImports processing.mode.java.pdex.PreprocessedSketch+coreAndDefaultImports,2777,79,12,"/** 
 * Searches for the particular class in the default list of imports as well as the Sketch classpath
 * @param className
 * @return
 */
","/**
   * Searches for the particular class in the default list of imports as well as
   * the Sketch classpath
   * @param className
   * @return
   */
  protected static Class<?> findClassIfExists(PreprocessedSketch ps, String className){
    if (className == null){
      return null;
    }

    //PreprocessedSketch ps = ecs.requestResult();

    if (className.indexOf('.') >= 0) {
      // Figure out what is package and what is class
      String[] parts = className.split(""\\."");
      String newClassName = parts[0];
      int i = 1;
      while (i < parts.length &&
          ps.classPath.isPackage(newClassName)) {
        newClassName = newClassName + ""/"" + parts[i++];
      }
      while (i < parts.length) {
        newClassName = newClassName + ""$"" + parts[i++];
      }
      className = newClassName.replace('/', '.');
    }

    // First, see if the classname is a fully qualified name and loads straightaway
    Class<?> tehClass = loadClass(className, ps.classLoader);

    if (tehClass != null) {
      //log(tehClass.getName() + "" located straightaway"");
      return tehClass;
    }

    // This name is qualified and it already had its chance
    if (className.indexOf('.') >= 0) {
      return null;
    }

    log(""Looking in the classloader for "" + className);
    // Using ClassPath and RegExResourceFilter to find a matching class
    // and then loading the thing might be simpler and faster

    // These can be preprocessed during error check for performance
    // (collect, split into starred and not starred)
    List<ImportStatement> programImports = ps.programImports;
    List<ImportStatement> codeFolderImports = ps.codeFolderImports;
    List<ImportStatement> coreAndDefaultImports = ps.coreAndDefaultImports;

    ImportStatement javaLang = ImportStatement.wholePackage(""java.lang"");

    Stream<List<ImportStatement>> importListStream =
        Stream.of(Collections.singletonList(javaLang), coreAndDefaultImports,
                  programImports, codeFolderImports);

    final String finalClassName = className;

    // These streams can be made unordered parallel if it helps performance
    return importListStream
        .map(list -> list.stream()
            .map(is -> {
              if (is.getClassName().equals(finalClassName)) {
                return is.getFullClassName();
              } else if (is.isStarredImport()) {
                return is.getPackageName() + ""."" + finalClassName;
              }
              return null;
            })
            .filter(name -> name != null)
            .map(name -> loadClass(name, ps.classLoader))
            .filter(cls -> cls != null)
            .findAny())
        .filter(Optional::isPresent)
        .map(Optional::get)
        .findAny()
        .orElse(null);
  }",False,False,"The function of the given method is to search for a particular class in the default list of imports as well as the Sketch classpath. It takes a class name as input and returns the corresponding Class object if found, or null if not found.","The `findClassIfExists` method searches for a specified class in the default list of imports and the Sketch classpath. It first checks if the class can be loaded directly, and if not, it iterates through the import statements to find a matching class and loads it using the classloader."
16,"loadClass(String,ClassLoader)",load class class name class loader ,Method,"getArrayClass(String,ClassLoader) findClassIfExists(PreprocessedSketch,String)",,"java.lang.Class+forName(String,boolean,ClassLoader) java.lang.Class+forName(String,boolean,ClassLoader)",,342,11,12,,"protected static Class<?> loadClass(String className, ClassLoader classLoader){
    Class<?> tehClass = null;
    if (className != null) {
      try {
        tehClass = Class.forName(className, false, classLoader);
      } catch (ClassNotFoundException e) {
        //log(""Doesn't exist in package: "");
      }
    }
    return tehClass;
  }",False,False,This method loads a class using the provided class name and class loader. It returns the loaded class or null if the class does not exist.,"The given code is a method named ""loadClass"" that takes a class name and a class loader as parameters. It attempts to load the specified class using the provided class loader and returns the loaded class if successful, otherwise it returns null."
17,"definedIn3rdPartyClass(PreprocessedSketch,String,String)",defined in3rd party class ps class name member name ,Method,"resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean)",,"processing.mode.java.pdex.ASTGenerator+findClassIfExists(PreprocessedSketch,String) processing.mode.java.pdex.ASTGenerator+findClassIfExists(PreprocessedSketch,String) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) java.lang.String+equals(Object) java.lang.String+equals(Object) processing.mode.java.pdex.ASTGenerator.ClassMember+ClassMember(Class<?>) processing.mode.java.pdex.ASTGenerator+definedIn3rdPartyClass(PreprocessedSketch,ClassMember,String) processing.mode.java.pdex.ASTGenerator+definedIn3rdPartyClass(PreprocessedSketch,ClassMember,String) processing.mode.java.pdex.ASTGenerator.ClassMember+ClassMember(Class<?>)",,460,12,9,,"public static ClassMember definedIn3rdPartyClass(PreprocessedSketch ps, String className,String memberName){
    Class<?> probableClass = findClassIfExists(ps, className);
    if (probableClass == null) {
      log(""Couldn't load "" + className);
      return null;
    }
    if (memberName.equals(""THIS"")) {
      return new ClassMember(probableClass);
    } else {
      return definedIn3rdPartyClass(ps, new ClassMember(probableClass), memberName);
    }
  }",False,False,"This method returns a ClassMember object that represents a member (field or method) defined in a third-party class. It takes a preprocessed sketch, a class name, and a member name as input parameters.","This code defines a method called ""definedIn3rdPartyClass"" that takes in a preprocessed sketch, a class name, and a member name as parameters. It attempts to find the specified class, and if successful, it returns a new ClassMember object representing either the class itself or the specified member within the class."
18,"definedIn3rdPartyClass(PreprocessedSketch,ClassMember,String)",defined in3rd party class ps teh class member name ,Method,"resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) definedIn3rdPartyClass(PreprocessedSketch,String,String) definedIn3rdPartyClass(PreprocessedSketch,ClassMember,String) definedIn3rdPartyClass(PreprocessedSketch,ClassMember,String)",,"processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) java.lang.String+toLowerCase() java.lang.String+toLowerCase() processing.mode.java.pdex.ASTGenerator.ClassMember+getDeclaringNode() processing.mode.java.pdex.ASTGenerator.ClassMember+getDeclaringNode() processing.mode.java.pdex.ASTGenerator.ClassMember+getDeclaringNode() processing.mode.java.pdex.ASTGenerator.ClassMember+getDeclaringNode() org.eclipse.jdt.core.dom.TypeDeclaration+getFields() org.eclipse.jdt.core.dom.TypeDeclaration+getFields() org.eclipse.jdt.core.dom.FieldDeclaration+fragments() org.eclipse.jdt.core.dom.TypeDeclaration+getFields() org.eclipse.jdt.core.dom.TypeDeclaration+getFields() org.eclipse.jdt.core.dom.FieldDeclaration+fragments() java.lang.String+startsWith(String) java.lang.String+toLowerCase() org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.VariableDeclaration+getName() org.eclipse.jdt.core.dom.VariableDeclaration+getName() org.eclipse.jdt.core.dom.ASTNode+toString() java.lang.String+toLowerCase() java.lang.String+startsWith(String) processing.mode.java.pdex.ASTGenerator.ClassMember+ClassMember(PreprocessedSketch,ASTNode) org.eclipse.jdt.core.dom.TypeDeclaration+getMethods() org.eclipse.jdt.core.dom.TypeDeclaration+getMethods() java.lang.String+startsWith(String) java.lang.String+toLowerCase() org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.MethodDeclaration+getName() org.eclipse.jdt.core.dom.TypeDeclaration+getMethods() org.eclipse.jdt.core.dom.TypeDeclaration+getMethods() org.eclipse.jdt.core.dom.MethodDeclaration+getName() org.eclipse.jdt.core.dom.ASTNode+toString() java.lang.String+toLowerCase() java.lang.String+startsWith(String) processing.mode.java.pdex.ASTGenerator.ClassMember+ClassMember(PreprocessedSketch,ASTNode) org.eclipse.jdt.core.dom.TypeDeclaration+getMethods() org.eclipse.jdt.core.dom.TypeDeclaration+getMethods() org.eclipse.jdt.core.dom.TypeDeclaration+getSuperclassType() org.eclipse.jdt.core.dom.TypeDeclaration+getSuperclassType() processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) org.eclipse.jdt.core.dom.TypeDeclaration+getSuperclassType() org.eclipse.jdt.core.dom.TypeDeclaration+getSuperclassType() processing.mode.java.pdex.ASTGenerator+definedIn3rdPartyClass(PreprocessedSketch,ClassMember,String) processing.mode.java.pdex.ASTGenerator+definedIn3rdPartyClass(PreprocessedSketch,ClassMember,String) processing.mode.java.pdex.ASTGenerator.ClassMember+ClassMember(PreprocessedSketch,ASTNode) org.eclipse.jdt.core.dom.TypeDeclaration+getSuperclassType() org.eclipse.jdt.core.dom.TypeDeclaration+getSuperclassType() processing.mode.java.pdex.ASTGenerator+definedIn3rdPartyClass(PreprocessedSketch,ClassMember,String) processing.mode.java.pdex.ASTGenerator+definedIn3rdPartyClass(PreprocessedSketch,ClassMember,String) processing.mode.java.pdex.ASTGenerator.ClassMember+ClassMember(Class<?>) processing.mode.java.pdex.ASTGenerator.ClassMember+getClass_() processing.mode.java.pdex.ASTGenerator.ClassMember+getClass_() processing.mode.java.pdex.ASTGenerator.ClassMember+getClass_() processing.mode.java.pdex.ASTGenerator.ClassMember+getClass_() processing.mode.java.pdex.ASTGenerator+findClassIfExists(PreprocessedSketch,String) processing.mode.java.pdex.ASTGenerator+findClassIfExists(PreprocessedSketch,String) processing.mode.java.pdex.ASTGenerator.ClassMember+getTypeAsString() processing.mode.java.pdex.ASTGenerator.ClassMember+getTypeAsString() processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) java.lang.Class+toString() java.lang.Class+toString() java.lang.Class+getMethods() java.lang.Class+getMethods() java.lang.String+equalsIgnoreCase(String) java.lang.reflect.Method+getName() java.lang.reflect.Method+getName() java.lang.String+equalsIgnoreCase(String) processing.mode.java.pdex.ASTGenerator.ClassMember+ClassMember(Method) java.lang.Class+getFields() java.lang.Class+getFields() java.lang.String+equalsIgnoreCase(String) java.lang.reflect.Field+getName() java.lang.reflect.Field+getName() java.lang.String+equalsIgnoreCase(String) processing.mode.java.pdex.ASTGenerator.ClassMember+ClassMember(Field)",,2039,52,9,,"public static ClassMember definedIn3rdPartyClass(PreprocessedSketch ps, ClassMember tehClass,String memberName){
    if(tehClass == null)
      return null;
    log(""definedIn3rdPartyClass-> Looking for "" + memberName
        + "" in "" + tehClass);
    String memberNameL = memberName.toLowerCase();
    if (tehClass.getDeclaringNode() instanceof TypeDeclaration) {

      TypeDeclaration td = (TypeDeclaration) tehClass.getDeclaringNode();
      for (int i = 0; i < td.getFields().length; i++) {
        List<VariableDeclarationFragment> vdfs =
          td.getFields()[i].fragments();
        for (VariableDeclarationFragment vdf : vdfs) {
          if (vdf.getName().toString().toLowerCase()
              .startsWith(memberNameL))
            return new ClassMember(ps, vdf);
        }

      }
      for (int i = 0; i < td.getMethods().length; i++) {
       if (td.getMethods()[i].getName().toString().toLowerCase()
            .startsWith(memberNameL))
         return new ClassMember(ps, td.getMethods()[i]);
      }
      if (td.getSuperclassType() != null) {
        log(getNodeAsString(td.getSuperclassType()) + "" <-Looking into superclass of "" + tehClass);
        return definedIn3rdPartyClass(ps, new ClassMember(ps, td
                                                     .getSuperclassType()),memberName);
      } else {
        return definedIn3rdPartyClass(ps, new ClassMember(Object.class),memberName);
      }
    }

    Class<?> probableClass;
    if (tehClass.getClass_() != null) {
      probableClass = tehClass.getClass_();
    } else {
      probableClass = findClassIfExists(ps, tehClass.getTypeAsString());
      log(""Loaded "" + probableClass.toString());
    }
    for (Method method : probableClass.getMethods()) {
      if (method.getName().equalsIgnoreCase(memberName)) {
        return new ClassMember(method);
      }
    }
    for (Field field : probableClass.getFields()) {
      if (field.getName().equalsIgnoreCase(memberName)) {
        return new ClassMember(field);
      }
    }
    return null;
  }",False,False,"This method searches for a member (field or method) with a given name in a class. It first checks if the class is defined in a third-party library, and if so, it searches for the member in the class and its superclass. If the class is not from a third-party library, it searches for the member in the class itself. If the member is found, it returns a ClassMember object representing the member. If the member is not found, it returns null.","This code defines a method called ""definedIn3rdPartyClass"" that takes in a preprocessed sketch, a class member, and a member name as parameters. It searches for the member name in the given class member and its superclass, if applicable, and returns a ClassMember object representing the found member or null if not found."
19,"findClosestParentNode(int,ASTNode)",find closest parent node line number node ,Method,"findClosestParentNode(int,ASTNode) findClosestParentNode(int,ASTNode) findClosestNode(int,ASTNode)",,"org.eclipse.jdt.core.dom.ASTNode+structuralPropertiesForType() org.eclipse.jdt.core.dom.ASTNode+structuralPropertiesForType() org.eclipse.jdt.core.dom.StructuralPropertyDescriptor+isChildProperty() org.eclipse.jdt.core.dom.StructuralPropertyDescriptor+isChildProperty() org.eclipse.jdt.core.dom.StructuralPropertyDescriptor+isSimpleProperty() org.eclipse.jdt.core.dom.StructuralPropertyDescriptor+isSimpleProperty() org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) org.eclipse.jdt.core.dom.CompilationUnit+getLineNumber(int) org.eclipse.jdt.core.dom.ASTNode+getRoot() org.eclipse.jdt.core.dom.ASTNode+getRoot() org.eclipse.jdt.core.dom.CompilationUnit+getLineNumber(int) org.eclipse.jdt.core.dom.ASTNode+getStartPosition() org.eclipse.jdt.core.dom.ASTNode+getStartPosition() org.eclipse.jdt.core.dom.ASTNode+getLength() org.eclipse.jdt.core.dom.ASTNode+getLength() processing.mode.java.pdex.ASTGenerator+getLineNumber(ASTNode) processing.mode.java.pdex.ASTGenerator+getLineNumber(ASTNode) processing.mode.java.pdex.ASTGenerator+findClosestParentNode(int,ASTNode) processing.mode.java.pdex.ASTGenerator+findClosestParentNode(int,ASTNode) org.eclipse.jdt.core.dom.StructuralPropertyDescriptor+isChildListProperty() org.eclipse.jdt.core.dom.StructuralPropertyDescriptor+isChildListProperty() org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) org.eclipse.jdt.core.dom.CompilationUnit+getLineNumber(int) org.eclipse.jdt.core.dom.ASTNode+getRoot() org.eclipse.jdt.core.dom.ASTNode+getRoot() org.eclipse.jdt.core.dom.CompilationUnit+getLineNumber(int) org.eclipse.jdt.core.dom.ASTNode+getStartPosition() org.eclipse.jdt.core.dom.ASTNode+getStartPosition() org.eclipse.jdt.core.dom.ASTNode+getLength() org.eclipse.jdt.core.dom.ASTNode+getLength() processing.mode.java.pdex.ASTGenerator+getLineNumber(ASTNode) processing.mode.java.pdex.ASTGenerator+getLineNumber(ASTNode) processing.mode.java.pdex.ASTGenerator+findClosestParentNode(int,ASTNode) processing.mode.java.pdex.ASTGenerator+findClosestParentNode(int,ASTNode)",,1646,33,12,,"protected static ASTNode findClosestParentNode(int lineNumber, ASTNode node) {
    // Base.loge(""Props of "" + node.getClass().getName());
    for (StructuralPropertyDescriptor prop : (Iterable<StructuralPropertyDescriptor>) node
        .structuralPropertiesForType()) {
      if (prop.isChildProperty() || prop.isSimpleProperty()) {
        if (node.getStructuralProperty(prop) != null) {
//          System.out
//              .println(node.getStructuralProperty(prop) + "" -> "" + (prop));
          if (node.getStructuralProperty(prop) instanceof ASTNode) {
            ASTNode cnode = (ASTNode) node.getStructuralProperty(prop);
//            log(""Looking at "" + getNodeAsString(cnode)+ "" for line num "" + lineNumber);
            int cLineNum = ((CompilationUnit) cnode.getRoot())
                .getLineNumber(cnode.getStartPosition() + cnode.getLength());
            if (getLineNumber(cnode) <= lineNumber && lineNumber <= cLineNum) {
              return findClosestParentNode(lineNumber, cnode);
            }
          }
        }
      } else if (prop.isChildListProperty()) {
        List<ASTNode> nodelist = (List<ASTNode>) node
            .getStructuralProperty(prop);
        for (ASTNode cnode : nodelist) {
          int cLineNum = ((CompilationUnit) cnode.getRoot())
              .getLineNumber(cnode.getStartPosition() + cnode.getLength());
//          log(""Looking at "" + getNodeAsString(cnode)+ "" for line num "" + lineNumber);
          if (getLineNumber(cnode) <= lineNumber && lineNumber <= cLineNum) {
            return findClosestParentNode(lineNumber, cnode);
          }
        }
      }
    }
    return node;
  }",False,False,The function finds the closest parent node in an Abstract Syntax Tree (AST) based on a given line number. It recursively searches through the AST nodes and returns the closest parent node that contains the specified line number.,"This code defines a method called ""findClosestParentNode"" that takes a line number and an ASTNode as input. It recursively searches for the closest parent node in the AST (Abstract Syntax Tree) that contains the given line number. The method iterates through the structural properties of the node and checks if the line number falls within the range of each child node or child list node."
20,"findClosestNode(int,ASTNode)",find closest node line number node ,Method,"preparePredictions(PreprocessedSketch,String,int)",,"processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+findClosestParentNode(int,ASTNode) processing.mode.java.pdex.ASTGenerator+findClosestParentNode(int,ASTNode) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.mode.java.pdex.ASTGenerator+getLineNumber(ASTNode) processing.mode.java.pdex.ASTGenerator+getLineNumber(ASTNode) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+getLineNumber(ASTNode) processing.mode.java.pdex.ASTGenerator+getLineNumber(ASTNode) org.eclipse.jdt.core.dom.AbstractTypeDeclaration+bodyDeclarations() org.eclipse.jdt.core.dom.AbstractTypeDeclaration+bodyDeclarations() org.eclipse.jdt.core.dom.Block+statements() org.eclipse.jdt.core.dom.Block+statements() processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) java.util.List+size() java.util.List+size() processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+getLineNumber(ASTNode) processing.mode.java.pdex.ASTGenerator+getLineNumber(ASTNode) processing.mode.java.pdex.ASTGenerator+getLineNumber(ASTNode) processing.mode.java.pdex.ASTGenerator+getLineNumber(ASTNode)",,1084,32,12,,"protected static ASTNode findClosestNode(int lineNumber, ASTNode node) {
    log(""findClosestNode to line "" + lineNumber);
    ASTNode parent = findClosestParentNode(lineNumber, node);
    log(""findClosestParentNode returned "" + getNodeAsString(parent));
    if (parent == null)
      return null;
    if (getLineNumber(parent) == lineNumber){
      log(parent + ""|PNode "" + getLineNumber(parent) + "", lfor "" + lineNumber );
      return parent;
    }
    List<ASTNode> nodes;
    if (parent instanceof TypeDeclaration) {
      nodes = ((TypeDeclaration) parent).bodyDeclarations();
    } else if (parent instanceof Block) {
      nodes = ((Block) parent).statements();
    } else {
      log(""findClosestNode() found "" + getNodeAsString(parent));
      return null;
    }

    if (nodes.size() > 0) {
      ASTNode retNode = parent;
      for (ASTNode cNode : nodes) {
        log(cNode + ""|cNode "" + getLineNumber(cNode) + "", lfor "" + lineNumber);
        if (getLineNumber(cNode) <= lineNumber)
          retNode = cNode;
      }

      return retNode;
    }
    return parent;
  }",False,False,"The function finds the closest ASTNode to a given line number within a given ASTNode. It first finds the closest parent node to the line number, then checks if the parent node itself matches the line number. If not, it checks the child nodes of the parent node and returns the closest one to the line number.","The code defines a method called ""findClosestNode"" that takes a line number and an ASTNode as input. It searches for the closest parent node to the given line number and returns it. If the parent node is found, it checks if the line number matches and returns the parent node. Otherwise, it searches for child nodes within the parent node and returns the closest child node with a line number less than or equal to the given line number."
21,"getSimpleNameAt(ASTNode,int,int)",get simple name at root start java offset stop java offset ,Method,"handleShowUsage(int,int,int) handleRename(int,int,int) handleCtrlClick(int,int)",,"processing.app.Messages+log(String) processing.app.Messages+log(String) processing.mode.java.pdex.ASTGenerator+getASTNodeAt(ASTNode,int,int) processing.mode.java.pdex.ASTGenerator+getASTNodeAt(ASTNode,int,int) org.eclipse.jdt.core.dom.ASTNode+getNodeType() org.eclipse.jdt.core.dom.ASTNode+getNodeType() processing.mode.java.pdex.ASTGenerator+getSimpleNameChildren(ASTNode) processing.mode.java.pdex.ASTGenerator+getSimpleNameChildren(ASTNode) java.util.List+isEmpty() java.util.List+isEmpty() java.util.stream.IntStream+toArray() java.util.stream.Stream+mapToInt(ToIntFunction) java.util.Collection+stream() java.util.Collection+stream() java.util.stream.Stream+mapToInt(ToIntFunction) java.lang.Math+min(int,int) java.lang.Math+min(int,int) java.lang.Math+max(int,int) java.lang.Math+max(int,int) java.util.stream.IntStream+toArray() java.util.stream.IntStream+range(int,int) java.util.stream.IntStream+range(int,int) java.util.List+size() java.util.List+size() java.util.List+get(int) java.util.List+get(int) processing.app.Messages+log(String) processing.app.Messages+log(String) processing.app.Messages+log(String) processing.app.Messages+log(String) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.ASTNode+toString()",org.eclipse.jdt.core.dom.ASTNode+SIMPLE_NAME,1445,42,9,,"public static SimpleName getSimpleNameAt(ASTNode root, int startJavaOffset, int stopJavaOffset) {
    Messages.log(""* getSimpleNameAt"");

    // Find node at offset
    ASTNode node = getASTNodeAt(root, startJavaOffset, stopJavaOffset);

    SimpleName result = null;

    if (node == null) {
      result = null;
    } else if (node.getNodeType() == ASTNode.SIMPLE_NAME) {
      result = (SimpleName) node;
    } else {
      // Return SimpleName with highest coverage
      List<SimpleName> simpleNames = getSimpleNameChildren(node);
      if (!simpleNames.isEmpty()) {
        // Compute coverage <selection x node>
        int[] coverages = simpleNames.stream()
            .mapToInt(name -> {
              int start = name.getStartPosition();
              int stop = start + name.getLength();
              return Math.min(stop, stopJavaOffset) -
                  Math.max(startJavaOffset, start);
            })
            .toArray();
        // Select node with highest coverage
        int maxIndex = IntStream.range(0, simpleNames.size())
            .filter(i -> coverages[i] >= 0)
            .reduce((i, j) -> coverages[i] > coverages[j] ? i : j)
            .orElse(-1);
        if (maxIndex == -1) return null;
        result = simpleNames.get(maxIndex);
      }
    }

    if (node == null) {
      Messages.log(""no simple name found"");
    } else {
      Messages.log(""found "" + node.toString());
    }
    return result;
  }",True,True,,"The `getSimpleNameAt` method takes an ASTNode, a start offset, and a stop offset as input and returns the SimpleName node with the highest coverage within the specified range. It computes the coverage of each SimpleName node within the range and selects the node with the highest coverage. If no SimpleName node is found, it returns null."
22,"getASTNodeAt(ASTNode,int,int)",get ast node at root start java offset stop java offset ,Method,"getSimpleNameAt(ASTNode,int,int)",,"processing.app.Messages+log(String) processing.app.Messages+log(String) org.eclipse.jdt.core.dom.NodeFinder+NodeFinder(ASTNode,int,int) org.eclipse.jdt.core.dom.NodeFinder+getCoveredNode() org.eclipse.jdt.core.dom.NodeFinder+getCoveredNode() org.eclipse.jdt.core.dom.NodeFinder+getCoveringNode() org.eclipse.jdt.core.dom.NodeFinder+getCoveringNode() processing.app.Messages+log(String) processing.app.Messages+log(String) processing.app.Messages+log(String) processing.app.Messages+log(String) java.lang.Class+getSimpleName() java.lang.Object+getClass() java.lang.Object+getClass() java.lang.Class+getSimpleName()",,514,17,9,,"public static ASTNode getASTNodeAt(ASTNode root, int startJavaOffset, int stopJavaOffset) {
    Messages.log(""* getASTNodeAt"");

    int length = stopJavaOffset - startJavaOffset;

    NodeFinder f = new NodeFinder(root, startJavaOffset, length);
    ASTNode node = f.getCoveredNode();
    if (node == null) {
      node = f.getCoveringNode();
    }
    if (node == null) {
      Messages.log(""no node found"");
    } else {
      Messages.log(""found "" + node.getClass().getSimpleName());
    }
    return node;
  }",True,True,This method returns the ASTNode (Abstract Syntax Tree Node) that covers or is covered by a given range of Java offsets in the AST tree. It logs messages about the node found or if no node is found.,"This code defines a method named ""getASTNodeAt"" that takes an ASTNode, a start offset, and a stop offset as parameters. It uses a NodeFinder to search for a node within the given range in the AST and returns the found node."
23,getSimpleNameChildren(ASTNode),get simple name children node ,Method,"getSimpleNameAt(ASTNode,int,int)",,org.eclipse.jdt.core.dom.ASTNode+accept(ASTVisitor) org.eclipse.jdt.core.dom.ASTNode+accept(ASTVisitor) +() +visit(SimpleName),,346,11,9,,"public static List<SimpleName> getSimpleNameChildren(ASTNode node) {
    List<SimpleName> simpleNames = new ArrayList<>();
    node.accept(new ASTVisitor() {
      @Override
      public boolean visit(SimpleName simpleName) {
        simpleNames.add(simpleName);
        return super.visit(simpleName);
      }
    });
    return simpleNames;
  }",True,True,This method returns a list of SimpleName objects that are children of the given ASTNode. It uses an ASTVisitor to traverse the AST and add any SimpleName nodes it encounters to the list.,"The given code defines a method named ""getSimpleNameChildren"" that takes an ASTNode as input and returns a list of SimpleName objects. It uses an ASTVisitor to traverse the ASTNode and add any SimpleName objects encountered to the list."
24,resolveBinding(SimpleName),resolve binding node ,Method,"handleShowUsage(int,int,int) handleRename(int,int,int) handleCtrlClick(int,int)",,org.eclipse.jdt.core.dom.Name+resolveBinding() org.eclipse.jdt.core.dom.Name+resolveBinding() org.eclipse.jdt.core.dom.IBinding+getKind() org.eclipse.jdt.core.dom.IBinding+getKind() processing.mode.java.pdex.ASTGenerator+isNameOrType(ASTNode) processing.mode.java.pdex.ASTGenerator+isNameOrType(ASTNode) java.lang.String+equals(Object) org.eclipse.jdt.core.dom.StructuralPropertyDescriptor+getId() org.eclipse.jdt.core.dom.ASTNode+getLocationInParent() org.eclipse.jdt.core.dom.ASTNode+getLocationInParent() org.eclipse.jdt.core.dom.StructuralPropertyDescriptor+getId() java.lang.String+equals(Object) org.eclipse.jdt.core.dom.ASTNode+getParent() org.eclipse.jdt.core.dom.ASTNode+getParent() org.eclipse.jdt.core.dom.ASTNode+getNodeType() org.eclipse.jdt.core.dom.ASTNode+getNodeType() org.eclipse.jdt.core.dom.MethodDeclaration+isConstructor() org.eclipse.jdt.core.dom.MethodDeclaration+isConstructor() org.eclipse.jdt.core.dom.MethodDeclaration+resolveBinding() org.eclipse.jdt.core.dom.MethodDeclaration+resolveBinding() org.eclipse.jdt.core.dom.ClassInstanceCreation+resolveConstructorBinding() org.eclipse.jdt.core.dom.ClassInstanceCreation+resolveConstructorBinding() org.eclipse.jdt.core.dom.IBinding+getKind() org.eclipse.jdt.core.dom.IBinding+getKind() org.eclipse.jdt.core.dom.ITypeBinding+isParameterizedType() org.eclipse.jdt.core.dom.ITypeBinding+isParameterizedType() org.eclipse.jdt.core.dom.ITypeBinding+isRawType() org.eclipse.jdt.core.dom.ITypeBinding+isRawType() org.eclipse.jdt.core.dom.ITypeBinding+getErasure() org.eclipse.jdt.core.dom.ITypeBinding+getErasure() org.eclipse.jdt.core.dom.IMethodBinding+getDeclaringClass() org.eclipse.jdt.core.dom.IMethodBinding+getDeclaringClass() org.eclipse.jdt.core.dom.ITypeBinding+isParameterizedType() org.eclipse.jdt.core.dom.ITypeBinding+isParameterizedType() org.eclipse.jdt.core.dom.ITypeBinding+isRawType() org.eclipse.jdt.core.dom.ITypeBinding+isRawType() org.eclipse.jdt.core.dom.ITypeBinding+getDeclaredMethods() org.eclipse.jdt.core.dom.ITypeBinding+getErasure() org.eclipse.jdt.core.dom.ITypeBinding+getErasure() org.eclipse.jdt.core.dom.ITypeBinding+getDeclaredMethods() java.util.stream.Stream+filter(Predicate) java.util.Arrays+stream(T[]) java.util.Arrays+stream(T[]) java.util.stream.Stream+filter(Predicate) org.eclipse.jdt.core.dom.IMethodBinding+isParameterizedMethod() org.eclipse.jdt.core.dom.IMethodBinding+isParameterizedMethod() org.eclipse.jdt.core.dom.IMethodBinding+isRawMethod() org.eclipse.jdt.core.dom.IMethodBinding+isRawMethod() org.eclipse.jdt.core.dom.IMethodBinding+getMethodDeclaration() org.eclipse.jdt.core.dom.IMethodBinding+getMethodDeclaration(),org.eclipse.jdt.core.dom.IBinding+TYPE org.eclipse.jdt.core.dom.ASTNode+METHOD_DECLARATION org.eclipse.jdt.core.dom.ASTNode+CLASS_INSTANCE_CREATION org.eclipse.jdt.core.dom.IBinding+TYPE org.eclipse.jdt.core.dom.IBinding+METHOD,1937,53,9,,"public static IBinding resolveBinding(SimpleName node) {
    IBinding binding = node.resolveBinding();
    if (binding == null) return null;

    // Fix constructor call/declaration being resolved as type
    if (binding.getKind() == IBinding.TYPE) {
      ASTNode context = node;
      while (isNameOrType(context) &&
          !context.getLocationInParent().getId().equals(""typeArguments"")) {
        context = context.getParent();
      }
      switch (context.getNodeType()) {
        case ASTNode.METHOD_DECLARATION:
          MethodDeclaration decl = (MethodDeclaration) context;
          if (decl.isConstructor()) {
            binding = decl.resolveBinding();
          }
          break;
        case ASTNode.CLASS_INSTANCE_CREATION:
          ClassInstanceCreation cic = (ClassInstanceCreation) context;
          binding = cic.resolveConstructorBinding();
          break;
      }
    }

    // Normalize parametrized and raw bindings into generic bindings
    switch (binding.getKind()) {
      case IBinding.TYPE:
        ITypeBinding type = (ITypeBinding) binding;
        if (type.isParameterizedType() || type.isRawType()) {
          binding = type.getErasure();
        }
        break;
      case IBinding.METHOD:
        IMethodBinding method = (IMethodBinding) binding;
        ITypeBinding declaringClass = method.getDeclaringClass();
        if (declaringClass.isParameterizedType() ||
            declaringClass.isRawType()) {
          IMethodBinding[] methods = declaringClass.getErasure().getDeclaredMethods();
          IMethodBinding generic = Arrays.stream(methods)
              .filter(method::overrides)
              .findAny().orElse(null);
          if (generic != null) method = generic;
        }
        if (method.isParameterizedMethod() || method.isRawMethod()) {
          method = method.getMethodDeclaration();
        }
        binding = method;
        break;
    }

    return binding;
  }",False,True,"This method resolves the binding of a given SimpleName node. It handles cases where the binding is resolved as a type instead of a constructor call or declaration, and normalizes parameterized and raw bindings into generic bindings. The resolved binding is then returned.","The `resolveBinding` method takes a `SimpleName` node as input and resolves its binding. It then performs some additional checks and modifications to handle cases where constructor calls or declarations are resolved as types, and normalizes parameterized and raw bindings into generic bindings. The method returns the resolved binding."
25,isNameOrType(ASTNode),is name or type node ,Method,resolveBinding(SimpleName),,,,111,3,9,,"public static boolean isNameOrType(ASTNode node) {
    return node instanceof Name || node instanceof Type;
  }",True,True,"The function of the given method is to determine whether the given ASTNode is an instance of either Name or Type, and return a boolean value accordingly.","The given code defines a method named ""isNameOrType"" that takes an ASTNode as input and returns a boolean value. It checks if the input node is an instance of either the Name or Type class and returns true if it is, otherwise false."
26,getLineNumber(ASTNode),get line number node fetches line number of the node in its compilation unit param node return ,Method,"findClosestParentNode(int,ASTNode) findClosestParentNode(int,ASTNode) findClosestNode(int,ASTNode) findClosestNode(int,ASTNode) findClosestNode(int,ASTNode) findClosestNode(int,ASTNode)",,org.eclipse.jdt.core.dom.CompilationUnit+getLineNumber(int) org.eclipse.jdt.core.dom.ASTNode+getRoot() org.eclipse.jdt.core.dom.ASTNode+getRoot() org.eclipse.jdt.core.dom.CompilationUnit+getLineNumber(int) org.eclipse.jdt.core.dom.ASTNode+getStartPosition() org.eclipse.jdt.core.dom.ASTNode+getStartPosition(),,249,9,9,"/** 
 * Fetches line number of the node in its CompilationUnit.
 * @param node
 * @return
 */
","/**
   * Fetches line number of the node in its CompilationUnit.
   * @param node
   * @return
   */
  public static int getLineNumber(ASTNode node) {
    return ((CompilationUnit) node.getRoot()).getLineNumber(node
        .getStartPosition());
  }",False,False,This method returns the line number of a given node in its CompilationUnit. It takes a node as input and returns an integer representing the line number.,"This code defines a method called ""getLineNumber"" that takes an ASTNode as input and returns the line number of that node in its CompilationUnit. It casts the node's root to a CompilationUnit and calls the ""getLineNumber"" method on it, passing in the node's start position."
27,"handleRename(PreprocessedSketch,IBinding,String)",handle rename ps binding new name ,Method,GUI.addListeners(),,"org.eclipse.jdt.core.dom.IBinding+getKind() org.eclipse.jdt.core.dom.IBinding+getKind() org.eclipse.jdt.core.dom.IMethodBinding+isConstructor() org.eclipse.jdt.core.dom.IMethodBinding+isConstructor() org.eclipse.jdt.core.dom.IMethodBinding+getDeclaringClass() org.eclipse.jdt.core.dom.IMethodBinding+getDeclaringClass() org.eclipse.jdt.core.dom.CompilationUnit+findDeclaringNode(String) org.eclipse.jdt.core.dom.CompilationUnit+findDeclaringNode(String) org.eclipse.jdt.core.dom.IBinding+getKey() org.eclipse.jdt.core.dom.IBinding+getKey() java.util.List+addAll(Collection) java.util.List+addAll(Collection) processing.mode.java.pdex.ASTGenerator+findAllOccurrences(ASTNode,String) processing.mode.java.pdex.ASTGenerator+findAllOccurrences(ASTNode,String) org.eclipse.jdt.core.dom.IBinding+getKey() org.eclipse.jdt.core.dom.IBinding+getKey() org.eclipse.jdt.core.dom.IBinding+getKind() org.eclipse.jdt.core.dom.IBinding+getKind() org.eclipse.jdt.core.dom.ITypeBinding+getDeclaredMethods() org.eclipse.jdt.core.dom.ITypeBinding+getDeclaredMethods() java.util.stream.Stream+filter(Predicate) java.util.Arrays+stream(T[]) java.util.Arrays+stream(T[]) java.util.stream.Stream+filter(Predicate) java.util.stream.Stream+map(Function) java.util.Collection+stream() java.util.Collection+stream() java.util.stream.Stream+map(Function) java.util.stream.Collectors+groupingBy(Function) java.util.stream.Collectors+groupingBy(Function) processing.app.ui.Editor+startCompoundEdit() processing.app.ui.Editor+startCompoundEdit() processing.app.Sketch+getCurrentCodeIndex() processing.app.Sketch+getCurrentCodeIndex() processing.app.ui.Editor+getCaretOffset() processing.app.ui.Editor+getCaretOffset() java.lang.Iterable+forEach(Consumer) java.util.Map+entrySet() java.util.Map+entrySet() java.lang.Iterable+forEach(Consumer) processing.app.Sketch+setCurrentCode(int) processing.app.Sketch+setCurrentCode(int) java.util.stream.Stream+sorted(Comparator) java.util.Collection+stream() java.util.Collection+stream() java.util.stream.Stream+sorted(Comparator) java.util.Comparator+comparing(Function) java.util.Comparator+comparing(Function) processing.app.Sketch+setModified(boolean) processing.app.Sketch+setModified(boolean) java.util.Map+getOrDefault(Object,V) java.util.Map+getOrDefault(Object,V) java.util.Collections+emptyList() java.util.Collections+emptyList() java.lang.String+length() java.lang.String+length() java.lang.String+length() org.eclipse.jdt.core.dom.IBinding+getName() org.eclipse.jdt.core.dom.IBinding+getName() java.lang.String+length() processing.app.Sketch+setCurrentCode(int) processing.app.Sketch+setCurrentCode(int) processing.app.syntax.JEditTextArea+setCaretPosition(int) processing.app.ui.Editor+getTextArea() processing.app.ui.Editor+getTextArea() processing.app.syntax.JEditTextArea+setCaretPosition(int) processing.app.ui.Editor+stopCompoundEdit() processing.app.ui.Editor+stopCompoundEdit() java.awt.Dialog+setVisible(boolean) java.awt.Dialog+setVisible(boolean)",processing.mode.java.pdex.PreprocessedSketch+compilationUnit org.eclipse.jdt.core.dom.IBinding+METHOD processing.mode.java.pdex.PreprocessedSketch+compilationUnit org.eclipse.jdt.core.dom.IBinding+TYPE processing.mode.java.pdex.PreprocessedSketch+sketch processing.mode.java.pdex.ASTGenerator+editor processing.mode.java.pdex.ASTGenerator+editor processing.mode.java.pdex.PreprocessedSketch.SketchInterval+startTabOffset processing.mode.java.pdex.ASTGenerator+editor processing.mode.java.pdex.ASTGenerator+editor processing.mode.java.pdex.ASTGenerator+gui processing.mode.java.pdex.ASTGenerator.GUI+showUsageBinding processing.mode.java.pdex.ASTGenerator+gui processing.mode.java.pdex.ASTGenerator.GUI+showUsageWindow,2904,77,4,,"protected void handleRename(PreprocessedSketch ps, IBinding binding, String newName) {
    CompilationUnit root = ps.compilationUnit;

    // Renaming constructor should rename class
    if (binding.getKind() == IBinding.METHOD) {
      IMethodBinding method = (IMethodBinding) binding;
      if (method.isConstructor()) {
        binding = method.getDeclaringClass();
      }
    }

    ASTNode decl = ps.compilationUnit.findDeclaringNode(binding.getKey());
    if (decl == null) return;

    List<SimpleName> occurrences = new ArrayList<>();
    occurrences.addAll(findAllOccurrences(root, binding.getKey()));

    // Renaming class should rename all constructors
    if (binding.getKind() == IBinding.TYPE) {
      ITypeBinding type = (ITypeBinding) binding;
      //type = type.getErasure();
      IMethodBinding[] methods = type.getDeclaredMethods();
      Arrays.stream(methods)
          .filter(IMethodBinding::isConstructor)
          .flatMap(c -> findAllOccurrences(root, c.getKey()).stream())
          .forEach(occurrences::add);
    }

    Map<Integer, List<SketchInterval>> mappedNodes = occurrences.stream()
        .map(ps::mapJavaToSketch)
        .collect(Collectors.groupingBy(interval -> interval.tabIndex));

    Sketch sketch = ps.sketch;

    editor.startCompoundEdit();

    int currentTabIndex = sketch.getCurrentCodeIndex();
    final int currentOffset = editor.getCaretOffset();
    mappedNodes.entrySet().forEach(entry -> {
      int tabIndex = entry.getKey();
      sketch.setCurrentCode(tabIndex);

      List<SketchInterval> nodes = entry.getValue();
      nodes.stream()
          // Replace from the end so all unprocess offsets stay valid
          .sorted(Comparator.comparing((SketchInterval si) -> si.startTabOffset).reversed())
          .forEach(si -> {
            // Make sure offsets are in bounds
            int length = editor.getTextArea().getDocumentLength();
            if (si.startTabOffset >= 0 && si.startTabOffset <= length &&
                si.stopTabOffset >= 0 && si.stopTabOffset <= length) {
              // Replace the code
              editor.getTextArea().select(si.startTabOffset, si.stopTabOffset);
              editor.getTextArea().setSelectedText(newName);
            }
          });

      sketch.setModified(true);
    });

    int precedingIntervals =
        (int) mappedNodes.getOrDefault(currentTabIndex, Collections.emptyList())
            .stream()
            .filter(interval -> interval.stopTabOffset < currentOffset)
            .count();
    int intervalLengthDiff = newName.length() - binding.getName().length();
    int offsetDiff = precedingIntervals * intervalLengthDiff;

    sketch.setCurrentCode(currentTabIndex);
    editor.getTextArea().setCaretPosition(currentOffset + offsetDiff);

    editor.stopCompoundEdit();

    if (gui.showUsageBinding != null) {
      gui.showUsageWindow.setVisible(false);
    }
  }",True,True,"The function of the given method is to handle the renaming of a class, constructor, or method in a Java program. It finds all occurrences of the specified binding (class, constructor, or method) in the program and replaces them with the new name. It also updates the caret position and handles compound edits.",The `handleRename` method is responsible for renaming a given binding (method or class) in a Java code compilation unit. It finds all occurrences of the binding in the code and replaces them with the new name. It also handles special cases such as renaming constructors and updating the caret position after the renaming.
28,"handleShowUsage(int,int,int)",handle show usage tab index start tab offset stop tab offset ,Method,,processing.mode.java.JavaEditor+handleShowUsage(),"processing.app.Messages+log(String) processing.app.Messages+log(String) processing.mode.java.JavaEditor+hasJavaTabs() processing.mode.java.JavaEditor+hasJavaTabs() processing.mode.java.pdex.ErrorCheckerService+acceptWhenDone(Consumer<PreprocessedSketch>) processing.mode.java.pdex.ErrorCheckerService+acceptWhenDone(Consumer<PreprocessedSketch>) processing.mode.java.pdex.PreprocessedSketch+tabOffsetToJavaOffset(int,int) processing.mode.java.pdex.PreprocessedSketch+tabOffsetToJavaOffset(int,int) processing.mode.java.pdex.PreprocessedSketch+tabOffsetToJavaOffset(int,int) processing.mode.java.pdex.PreprocessedSketch+tabOffsetToJavaOffset(int,int) processing.mode.java.pdex.ASTGenerator+getSimpleNameAt(ASTNode,int,int) processing.mode.java.pdex.ASTGenerator+getSimpleNameAt(ASTNode,int,int) processing.mode.java.pdex.ASTGenerator+resolveBinding(SimpleName) processing.mode.java.pdex.ASTGenerator+resolveBinding(SimpleName) processing.mode.java.pdex.ASTGenerator+handleShowUsage(PreprocessedSketch,IBinding) processing.mode.java.pdex.ASTGenerator+handleShowUsage(PreprocessedSketch,IBinding)",processing.mode.java.pdex.ASTGenerator+editor processing.mode.java.pdex.ASTGenerator+ecs processing.mode.java.pdex.PreprocessedSketch+compilationUnit,712,22,1,,"public void handleShowUsage(int tabIndex, int startTabOffset, int stopTabOffset) {
    Messages.log(""* handleShowUsage"");

    if (editor.hasJavaTabs()) return; // show usage disabled if java tabs

    ecs.acceptWhenDone(ps -> {

      // Map offsets
      int startJavaOffset = ps.tabOffsetToJavaOffset(tabIndex, startTabOffset);
      int stopJavaOffset = ps.tabOffsetToJavaOffset(tabIndex, stopTabOffset);

      // Find the node
      SimpleName name = getSimpleNameAt(ps.compilationUnit, startJavaOffset, stopJavaOffset);
      if (name == null) return;

      // Find binding
      IBinding binding = resolveBinding(name);
      if (binding == null) return;

      handleShowUsage(ps, binding);
    });
  }",True,True,"This method handles the functionality of showing the usage of a specific element in the code. It takes in the tab index and start/stop tab offsets, maps them to Java offsets, finds the corresponding node and binding, and then handles showing the usage of that element.","The `handleShowUsage` method takes in three parameters: `tabIndex`, `startTabOffset`, and `stopTabOffset`. It first checks if the editor has Java tabs, and if so, it returns. Otherwise, it maps the offsets, finds the node, resolves the binding, and then calls the `handleShowUsage` method with the resolved binding."
29,"handleShowUsage(PreprocessedSketch,IBinding)",handle show usage ps binding ,Method,"handleShowUsage(int,int,int) handleCtrlClick(int,int) handleCtrlClick(int,int) GUI.addListeners() GUI.reloadShowUsage(PreprocessedSketch)",,"org.eclipse.jdt.core.dom.IBinding+getKey() org.eclipse.jdt.core.dom.IBinding+getKey() processing.mode.java.pdex.ASTGenerator+findAllOccurrences(ASTNode,String) processing.mode.java.pdex.ASTGenerator+findAllOccurrences(ASTNode,String) java.util.stream.Stream+map(Function) java.util.Collection+stream() java.util.Collection+stream() java.util.stream.Stream+map(Function) java.util.stream.Collectors+toList() java.util.stream.Collectors+toList() java.awt.EventQueue+invokeLater(Runnable) java.awt.EventQueue+invokeLater(Runnable) processing.mode.java.pdex.ASTGenerator.GUI+handleShowUsage(PreprocessedSketch,IBinding,List<SketchInterval>) processing.mode.java.pdex.ASTGenerator.GUI+handleShowUsage(PreprocessedSketch,IBinding,List<SketchInterval>)",processing.mode.java.pdex.PreprocessedSketch+compilationUnit processing.mode.java.pdex.ASTGenerator+gui,528,14,1,,"public void handleShowUsage(PreprocessedSketch ps, IBinding binding) {
    String bindingKey = binding.getKey();

    // Find occurrences of the node
    List<SimpleName> occurrences = findAllOccurrences(ps.compilationUnit, bindingKey);
    if (occurrences == null) return;

    List<SketchInterval> occurrenceIntervals = occurrences.stream()
        .map(ps::mapJavaToSketch)
        .collect(Collectors.toList());

    // Send to gui
    EventQueue.invokeLater(() -> gui.handleShowUsage(ps, binding, occurrenceIntervals));
  }",False,True,"This method handles the event of showing the usage of a binding in a preprocessed sketch. It finds occurrences of the binding in the sketch, maps them to intervals, and sends them to the GUI for display.","This code defines a method called ""handleShowUsage"" that takes a PreprocessedSketch object and an IBinding object as parameters. It finds occurrences of a specific node in the compilation unit of the PreprocessedSketch object, maps them to SketchIntervals, and then sends them to the GUI using the handleShowUsage method of the gui object."
30,"findAllOccurrences(ASTNode,String)",find all occurrences root binding key ,Method,"handleRename(PreprocessedSketch,IBinding,String) handleShowUsage(PreprocessedSketch,IBinding)",,org.eclipse.jdt.core.dom.ASTNode+accept(ASTVisitor) org.eclipse.jdt.core.dom.ASTNode+getRoot() org.eclipse.jdt.core.dom.ASTNode+getRoot() org.eclipse.jdt.core.dom.ASTNode+accept(ASTVisitor) +() +visit(SimpleName),,486,15,12,,"protected static List<SimpleName> findAllOccurrences(ASTNode root, String bindingKey) {
    List<SimpleName> occurences = new ArrayList<>();
    root.getRoot().accept(new ASTVisitor() {
      @Override
      public boolean visit(SimpleName name) {
        IBinding binding = resolveBinding(name);
        if (binding != null && bindingKey.equals(binding.getKey())) {
          occurences.add(name);
        }
        return super.visit(name);
      }
    });

    return occurences;
  }",True,True,This method finds all occurrences of a specific binding key in an ASTNode and returns a list of SimpleName objects representing those occurrences.,This code defines a method called `findAllOccurrences` that takes an ASTNode and a binding key as input. It uses an ASTVisitor to traverse the AST and find all occurrences of SimpleName nodes whose resolved binding matches the given binding key. The method returns a list of all the found SimpleName nodes.
31,"handleRename(int,int,int)",handle rename tab index start tab offset stop tab offset ,Method,,processing.mode.java.JavaEditor+handleRefactor(),"processing.app.Messages+log(String) processing.app.Messages+log(String) processing.mode.java.JavaEditor+hasJavaTabs() processing.mode.java.JavaEditor+hasJavaTabs() processing.mode.java.pdex.ErrorCheckerService+acceptWhenDone(Consumer<PreprocessedSketch>) processing.mode.java.pdex.ErrorCheckerService+acceptWhenDone(Consumer<PreprocessedSketch>) processing.mode.java.JavaEditor+statusMessage(String,int) processing.mode.java.JavaEditor+statusMessage(String,int) processing.mode.java.pdex.PreprocessedSketch+tabOffsetToJavaOffset(int,int) processing.mode.java.pdex.PreprocessedSketch+tabOffsetToJavaOffset(int,int) processing.mode.java.pdex.PreprocessedSketch+tabOffsetToJavaOffset(int,int) processing.mode.java.pdex.PreprocessedSketch+tabOffsetToJavaOffset(int,int) processing.mode.java.pdex.ASTGenerator+getSimpleNameAt(ASTNode,int,int) processing.mode.java.pdex.ASTGenerator+getSimpleNameAt(ASTNode,int,int) processing.mode.java.JavaEditor+statusMessage(String,int) processing.mode.java.JavaEditor+statusMessage(String,int) processing.mode.java.pdex.ASTGenerator+resolveBinding(SimpleName) processing.mode.java.pdex.ASTGenerator+resolveBinding(SimpleName) processing.mode.java.JavaEditor+statusMessage(String,int) processing.mode.java.JavaEditor+statusMessage(String,int) org.eclipse.jdt.core.dom.SimpleName+getIdentifier() org.eclipse.jdt.core.dom.SimpleName+getIdentifier() org.eclipse.jdt.core.dom.CompilationUnit+findDeclaringNode(String) org.eclipse.jdt.core.dom.CompilationUnit+findDeclaringNode(String) org.eclipse.jdt.core.dom.IBinding+getKey() org.eclipse.jdt.core.dom.IBinding+getKey() processing.mode.java.JavaEditor+statusMessage(String,int) processing.mode.java.JavaEditor+statusMessage(String,int) org.eclipse.jdt.core.dom.SimpleName+getIdentifier() org.eclipse.jdt.core.dom.SimpleName+getIdentifier() java.awt.EventQueue+invokeLater(Runnable) java.awt.EventQueue+invokeLater(Runnable) processing.mode.java.pdex.ASTGenerator.GUI+handleRename(PreprocessedSketch,IBinding) processing.mode.java.pdex.ASTGenerator.GUI+handleRename(PreprocessedSketch,IBinding)",processing.mode.java.pdex.ASTGenerator+editor processing.mode.java.pdex.ASTGenerator+ecs processing.mode.java.pdex.PreprocessedSketch+hasSyntaxErrors processing.mode.java.pdex.ASTGenerator+editor processing.app.ui.EditorStatus+WARNING processing.mode.java.pdex.PreprocessedSketch+compilationUnit processing.mode.java.pdex.ASTGenerator+editor processing.app.ui.EditorStatus+NOTICE processing.mode.java.pdex.ASTGenerator+editor processing.app.ui.EditorStatus+ERROR processing.mode.java.pdex.PreprocessedSketch+compilationUnit processing.mode.java.pdex.ASTGenerator+editor processing.app.ui.EditorStatus+ERROR processing.mode.java.pdex.ASTGenerator+gui,1594,43,1,,"public void handleRename(int tabIndex, int startTabOffset, int stopTabOffset) {
    Messages.log(""* handleRename"");
    if (editor.hasJavaTabs()) return;  // refactoring disabled w/ java tabs

    ecs.acceptWhenDone(ps -> {
      if (ps.hasSyntaxErrors) {
        editor.statusMessage(""Can't perform action until syntax errors are fixed :("",
                             EditorStatus.WARNING);
        return;
      }

      ASTNode root = ps.compilationUnit;

      // Map offsets
      int startJavaOffset = ps.tabOffsetToJavaOffset(tabIndex, startTabOffset);
      int stopJavaOffset = ps.tabOffsetToJavaOffset(tabIndex, stopTabOffset);

      // Find the node
      SimpleName name = getSimpleNameAt(root, startJavaOffset, stopJavaOffset);
      if (name == null) {
        editor.statusMessage(""Highlight the class/function/variable name first"",
                             EditorStatus.NOTICE);
        return;
      }

      // Find binding
      IBinding binding = resolveBinding(name);
      if (binding == null) {
        editor.statusMessage(name.getIdentifier() + "" isn't defined in this sketch, "" +
                                 ""so it cannot be renamed"", EditorStatus.ERROR);
        return;
      }

      ASTNode decl = ps.compilationUnit.findDeclaringNode(binding.getKey());
      if (decl == null) {
        editor.statusMessage(name.getIdentifier() + "" isn't defined in this sketch, "" +
                                 ""so it cannot be renamed"", EditorStatus.ERROR);
        return;
      }

      EventQueue.invokeLater(() -> gui.handleRename(ps, binding));
    });
  }",True,True,"This method handles the renaming of a class, function, or variable in a code editor. It checks for syntax errors, maps offsets, finds the node to be renamed, resolves the binding, and invokes a GUI method to perform the renaming.","The `handleRename` method is responsible for handling the renaming of a class, function, or variable in a code editor. It checks for syntax errors, maps offsets, finds the node to be renamed, resolves its binding, and invokes a GUI method to perform the renaming action."
32,findDeclaration(Name),find declaration find me give this thing a link name instance a link simple name from the ast node for ex and it tries its level best to locate its declaration in the ast it really does param find me return ,Method,"findDeclaration(Name) findDeclaration(Name) findDeclaration(Name) findDeclaration(Name) findDeclaration(Name) findDeclaration(Name) findDeclaration(Name) findDeclaration(Name) findDeclaration(Name) findDeclaration(Name) findDeclaration(Name) findDeclaration(Name) findDeclaration(Name) findDeclaration(Name) findDeclaration(Name) findDeclaration(Name) ClassMember.ClassMember(PreprocessedSketch,ASTNode)",,"org.eclipse.jdt.core.dom.ASTNode+getParent() org.eclipse.jdt.core.dom.ASTNode+getParent() org.eclipse.jdt.core.dom.ASTNode+getNodeType() org.eclipse.jdt.core.dom.ASTNode+getNodeType() org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) java.lang.String+equals(Object) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.MethodInvocation+getName() org.eclipse.jdt.core.dom.MethodInvocation+getName() org.eclipse.jdt.core.dom.ASTNode+toString() java.lang.String+equals(Object) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.ASTNode+toString() java.util.ArrayList+add(int,E) java.util.ArrayList+add(int,E) java.util.ArrayList+add(int,E) java.util.ArrayList+add(int,E) processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration(Name) processing.mode.java.pdex.ASTGenerator+findDeclaration(Name) org.eclipse.jdt.core.dom.MethodInvocation+getName() org.eclipse.jdt.core.dom.MethodInvocation+getName() processing.mode.java.pdex.ASTGenerator+findDeclaration(Name) processing.mode.java.pdex.ASTGenerator+findDeclaration(Name) org.eclipse.jdt.core.dom.SimpleType+getName() org.eclipse.jdt.core.dom.SimpleType+getName() processing.mode.java.pdex.ASTGenerator+definedIn(ASTNode,String,ArrayList<Integer>) processing.mode.java.pdex.ASTGenerator+definedIn(ASTNode,String,ArrayList<Integer>) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.MethodInvocation+getName() org.eclipse.jdt.core.dom.MethodInvocation+getName() org.eclipse.jdt.core.dom.ASTNode+toString() processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration(Name) processing.mode.java.pdex.ASTGenerator+findDeclaration(Name) org.eclipse.jdt.core.dom.FieldAccess+getName() org.eclipse.jdt.core.dom.FieldAccess+getName() processing.mode.java.pdex.ASTGenerator+findDeclaration(Name) processing.mode.java.pdex.ASTGenerator+findDeclaration(Name) org.eclipse.jdt.core.dom.SimpleType+getName() org.eclipse.jdt.core.dom.SimpleType+getName() processing.mode.java.pdex.ASTGenerator+definedIn(ASTNode,String,ArrayList<Integer>) processing.mode.java.pdex.ASTGenerator+definedIn(ASTNode,String,ArrayList<Integer>) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.MethodInvocation+getName() org.eclipse.jdt.core.dom.MethodInvocation+getName() org.eclipse.jdt.core.dom.ASTNode+toString() processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration(Name) processing.mode.java.pdex.ASTGenerator+findDeclaration(Name) processing.mode.java.pdex.ASTGenerator+findDeclaration(Name) processing.mode.java.pdex.ASTGenerator+findDeclaration(Name) org.eclipse.jdt.core.dom.SimpleType+getName() org.eclipse.jdt.core.dom.SimpleType+getName() java.util.ArrayList+add(int,E) java.util.ArrayList+add(int,E) processing.mode.java.pdex.ASTGenerator+definedIn(ASTNode,String,ArrayList<Integer>) processing.mode.java.pdex.ASTGenerator+definedIn(ASTNode,String,ArrayList<Integer>) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.MethodInvocation+getName() org.eclipse.jdt.core.dom.MethodInvocation+getName() org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.ASTNode+getParent() org.eclipse.jdt.core.dom.ASTNode+getParent() org.eclipse.jdt.core.dom.ASTNode+getNodeType() org.eclipse.jdt.core.dom.ASTNode+getNodeType() org.eclipse.jdt.core.dom.FieldAccess+getExpression() org.eclipse.jdt.core.dom.FieldAccess+getExpression() java.lang.String+equals(Object) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.FieldAccess+getName() org.eclipse.jdt.core.dom.FieldAccess+getName() org.eclipse.jdt.core.dom.ASTNode+toString() java.lang.String+equals(Object) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.ASTNode+toString() java.util.ArrayList+add(int,E) java.util.ArrayList+add(int,E) java.util.ArrayList+add(int,E) java.util.ArrayList+add(int,E) processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration(Name) processing.mode.java.pdex.ASTGenerator+findDeclaration(Name) org.eclipse.jdt.core.dom.MethodInvocation+getName() org.eclipse.jdt.core.dom.MethodInvocation+getName() processing.mode.java.pdex.ASTGenerator+findDeclaration(Name) processing.mode.java.pdex.ASTGenerator+findDeclaration(Name) org.eclipse.jdt.core.dom.SimpleType+getName() org.eclipse.jdt.core.dom.SimpleType+getName() processing.mode.java.pdex.ASTGenerator+definedIn(ASTNode,String,ArrayList<Integer>) processing.mode.java.pdex.ASTGenerator+definedIn(ASTNode,String,ArrayList<Integer>) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.FieldAccess+getName() org.eclipse.jdt.core.dom.FieldAccess+getName() org.eclipse.jdt.core.dom.ASTNode+toString() processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration(Name) processing.mode.java.pdex.ASTGenerator+findDeclaration(Name) org.eclipse.jdt.core.dom.FieldAccess+getName() org.eclipse.jdt.core.dom.FieldAccess+getName() processing.mode.java.pdex.ASTGenerator+findDeclaration(Name) processing.mode.java.pdex.ASTGenerator+findDeclaration(Name) org.eclipse.jdt.core.dom.SimpleType+getName() org.eclipse.jdt.core.dom.SimpleType+getName() java.util.ArrayList+add(int,E) java.util.ArrayList+add(int,E) processing.mode.java.pdex.ASTGenerator+definedIn(ASTNode,String,ArrayList<Integer>) processing.mode.java.pdex.ASTGenerator+definedIn(ASTNode,String,ArrayList<Integer>) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.FieldAccess+getName() org.eclipse.jdt.core.dom.FieldAccess+getName() org.eclipse.jdt.core.dom.ASTNode+toString() processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration(Name) processing.mode.java.pdex.ASTGenerator+findDeclaration(Name) processing.mode.java.pdex.ASTGenerator+findDeclaration(Name) processing.mode.java.pdex.ASTGenerator+findDeclaration(Name) org.eclipse.jdt.core.dom.SimpleType+getName() org.eclipse.jdt.core.dom.SimpleType+getName() java.util.ArrayList+add(int,E) java.util.ArrayList+add(int,E) processing.mode.java.pdex.ASTGenerator+definedIn(ASTNode,String,ArrayList<Integer>) processing.mode.java.pdex.ASTGenerator+definedIn(ASTNode,String,ArrayList<Integer>) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.FieldAccess+getName() org.eclipse.jdt.core.dom.FieldAccess+getName() org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.ASTNode+getParent() org.eclipse.jdt.core.dom.ASTNode+getParent() org.eclipse.jdt.core.dom.ASTNode+getNodeType() org.eclipse.jdt.core.dom.ASTNode+getNodeType() java.lang.String+equals(Object) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.ASTNode+toString() java.lang.String+equals(Object) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.QualifiedName+getQualifier() org.eclipse.jdt.core.dom.QualifiedName+getQualifier() org.eclipse.jdt.core.dom.ASTNode+toString() processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration(Name) processing.mode.java.pdex.ASTGenerator+findDeclaration(Name) org.eclipse.jdt.core.dom.QualifiedName+getQualifier() org.eclipse.jdt.core.dom.QualifiedName+getQualifier() processing.mode.java.pdex.ASTGenerator+findDeclaration(Name) processing.mode.java.pdex.ASTGenerator+findDeclaration(Name) org.eclipse.jdt.core.dom.SimpleType+getName() org.eclipse.jdt.core.dom.SimpleType+getName() java.util.ArrayList+clear() java.util.ArrayList+clear() java.util.ArrayList+add(int,E) java.util.ArrayList+add(int,E) java.util.ArrayList+add(int,E) java.util.ArrayList+add(int,E) processing.mode.java.pdex.ASTGenerator+definedIn(ASTNode,String,ArrayList<Integer>) processing.mode.java.pdex.ASTGenerator+definedIn(ASTNode,String,ArrayList<Integer>) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.QualifiedName+getName() org.eclipse.jdt.core.dom.QualifiedName+getName() org.eclipse.jdt.core.dom.ASTNode+toString() processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration(Name) processing.mode.java.pdex.ASTGenerator+findDeclaration(Name) org.eclipse.jdt.core.dom.QualifiedName+getQualifier() org.eclipse.jdt.core.dom.QualifiedName+getQualifier() processing.mode.java.pdex.ASTGenerator+findDeclaration(Name) processing.mode.java.pdex.ASTGenerator+findDeclaration(Name) org.eclipse.jdt.core.dom.SimpleType+getName() org.eclipse.jdt.core.dom.SimpleType+getName() java.util.ArrayList+clear() java.util.ArrayList+clear() java.util.ArrayList+add(int,E) java.util.ArrayList+add(int,E) java.util.ArrayList+add(int,E) java.util.ArrayList+add(int,E) processing.mode.java.pdex.ASTGenerator+definedIn(ASTNode,String,ArrayList<Integer>) processing.mode.java.pdex.ASTGenerator+definedIn(ASTNode,String,ArrayList<Integer>) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.QualifiedName+getName() org.eclipse.jdt.core.dom.QualifiedName+getName() org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.ASTNode+getNodeType() org.eclipse.jdt.core.dom.ASTNode+getNodeType() java.util.ArrayList+add(int,E) java.util.ArrayList+add(int,E) org.eclipse.jdt.core.dom.ASTNode+getNodeType() org.eclipse.jdt.core.dom.ASTNode+getParent() org.eclipse.jdt.core.dom.ASTNode+getParent() org.eclipse.jdt.core.dom.ASTNode+getNodeType() java.util.ArrayList+add(int,E) java.util.ArrayList+add(int,E) org.eclipse.jdt.core.dom.ASTNode+getNodeType() org.eclipse.jdt.core.dom.ASTNode+getNodeType() org.eclipse.jdt.core.dom.ASTNode+equals(Object) org.eclipse.jdt.core.dom.ASTNode+equals(Object) org.eclipse.jdt.core.dom.AbstractTypeDeclaration+getName() org.eclipse.jdt.core.dom.AbstractTypeDeclaration+getName() org.eclipse.jdt.core.dom.ASTNode+structuralPropertiesForType() org.eclipse.jdt.core.dom.ASTNode+structuralPropertiesForType() org.eclipse.jdt.core.dom.StructuralPropertyDescriptor+isChildProperty() org.eclipse.jdt.core.dom.StructuralPropertyDescriptor+isChildProperty() org.eclipse.jdt.core.dom.StructuralPropertyDescriptor+isSimpleProperty() org.eclipse.jdt.core.dom.StructuralPropertyDescriptor+isSimpleProperty() org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) processing.mode.java.pdex.ASTGenerator+definedIn(ASTNode,String,ArrayList<Integer>) processing.mode.java.pdex.ASTGenerator+definedIn(ASTNode,String,ArrayList<Integer>) org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.StructuralPropertyDescriptor+isChildListProperty() org.eclipse.jdt.core.dom.StructuralPropertyDescriptor+isChildListProperty() org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) processing.mode.java.pdex.ASTGenerator+definedIn(ASTNode,String,ArrayList<Integer>) processing.mode.java.pdex.ASTGenerator+definedIn(ASTNode,String,ArrayList<Integer>) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.ASTNode+getParent() org.eclipse.jdt.core.dom.ASTNode+getParent()",org.eclipse.jdt.core.dom.ASTNode+METHOD_INVOCATION org.eclipse.jdt.core.dom.MethodInvocation+EXPRESSION_PROPERTY org.eclipse.jdt.core.dom.ASTNode+METHOD_DECLARATION org.eclipse.jdt.core.dom.ASTNode+TYPE_DECLARATION org.eclipse.jdt.core.dom.ASTNode+METHOD_DECLARATION org.eclipse.jdt.core.dom.ASTNode+FIELD_ACCESS org.eclipse.jdt.core.dom.ASTNode+FIELD_DECLARATION org.eclipse.jdt.core.dom.ASTNode+TYPE_DECLARATION org.eclipse.jdt.core.dom.ASTNode+TYPE_DECLARATION org.eclipse.jdt.core.dom.ASTNode+METHOD_DECLARATION org.eclipse.jdt.core.dom.ASTNode+QUALIFIED_NAME org.eclipse.jdt.core.dom.ASTNode+TYPE_DECLARATION org.eclipse.jdt.core.dom.ASTNode+FIELD_DECLARATION org.eclipse.jdt.core.dom.ASTNode+TYPE_DECLARATION org.eclipse.jdt.core.dom.ASTNode+FIELD_DECLARATION org.eclipse.jdt.core.dom.ASTNode+SIMPLE_TYPE org.eclipse.jdt.core.dom.ASTNode+TYPE_DECLARATION org.eclipse.jdt.core.dom.ASTNode+CLASS_INSTANCE_CREATION org.eclipse.jdt.core.dom.ASTNode+CLASS_INSTANCE_CREATION org.eclipse.jdt.core.dom.ASTNode+TYPE_DECLARATION,8277,196,12,"/** 
 * Give this thing a  {@link Name} instance - a {@link SimpleName} from theASTNode for ex, and it tries its level best to locate its declaration in the AST. It really does.
 * @param findMe
 * @return
 */
","/**
   * Give this thing a {@link Name} instance - a {@link SimpleName} from the
   * ASTNode for ex, and it tries its level best to locate its declaration in
   * the AST. It really does.
   *
   * @param findMe
   * @return
   */
  protected static ASTNode findDeclaration(Name findMe) {

    // WARNING: You're entering the Rube Goldberg territory of Experimental Mode.
    // To debug this code, thou must take the Recursive Leap of Faith.

    // log(""entering --findDeclaration1 -- "" + findMe.toString());
    ASTNode declaringClass;
    ASTNode parent = findMe.getParent();
    ASTNode ret;
    ArrayList<Integer> constrains = new ArrayList<>();
    if (parent.getNodeType() == ASTNode.METHOD_INVOCATION) {
      Expression exp = (Expression) parent.getStructuralProperty(MethodInvocation.EXPRESSION_PROPERTY);
      //TODO: Note the imbalance of constrains.add(ASTNode.METHOD_DECLARATION);
      // Possibly a bug here. Investigate later.
      if (((MethodInvocation) parent).getName().toString()
          .equals(findMe.toString())) {
        constrains.add(ASTNode.METHOD_DECLARATION);

        if (exp != null) {
          constrains.add(ASTNode.TYPE_DECLARATION);
//          log(""MI EXP: "" + exp.toString() + "" of type ""
//              + exp.getClass().getName() + "" parent: "" + exp.getParent());
          if (exp instanceof MethodInvocation) {
            SimpleType stp = extracTypeInfo(findDeclaration(((MethodInvocation) exp)
                .getName()));
            if (stp == null)
              return null;
            declaringClass = findDeclaration(stp.getName());
            return definedIn(declaringClass, ((MethodInvocation) parent)
                .getName().toString(), constrains);
          } else if (exp instanceof FieldAccess) {
            SimpleType stp = extracTypeInfo(findDeclaration(((FieldAccess) exp)
                .getName()));
            if (stp == null)
              return null;
            declaringClass = findDeclaration((stp.getName()));
            return definedIn(declaringClass, ((MethodInvocation) parent)
                .getName().toString(), constrains);
          }
          if (exp instanceof SimpleName) {
            SimpleType stp = extracTypeInfo(findDeclaration(((SimpleName) exp)));
            if (stp == null)
              return null;
            declaringClass = findDeclaration(stp.getName());
//            log(""MI.SN "" + getNodeAsString(declaringClass));
            constrains.add(ASTNode.METHOD_DECLARATION);
            return definedIn(declaringClass, ((MethodInvocation) parent)
                .getName().toString(), constrains);
          }

        }
      } else {
        parent = parent.getParent(); // Move one up the ast. V V IMP!!
      }
    } else if (parent.getNodeType() == ASTNode.FIELD_ACCESS) {
      FieldAccess fa = (FieldAccess) parent;
      Expression exp = fa.getExpression();
      if (fa.getName().toString().equals(findMe.toString())) {
        constrains.add(ASTNode.FIELD_DECLARATION);

        if (exp != null) {
          constrains.add(ASTNode.TYPE_DECLARATION);
//          log(""FA EXP: "" + exp.toString() + "" of type ""
//              + exp.getClass().getName() + "" parent: "" + exp.getParent());
          if (exp instanceof MethodInvocation) {
            SimpleType stp = extracTypeInfo(findDeclaration(((MethodInvocation) exp)
                .getName()));
            if (stp == null)
              return null;
            declaringClass = findDeclaration(stp.getName());
            return definedIn(declaringClass, fa.getName().toString(),
                             constrains);
          } else if (exp instanceof FieldAccess) {
            SimpleType stp = extracTypeInfo(findDeclaration(((FieldAccess) exp)
                .getName()));
            if (stp == null)
              return null;
            declaringClass = findDeclaration((stp.getName()));
            constrains.add(ASTNode.TYPE_DECLARATION);
            return definedIn(declaringClass, fa.getName().toString(),
                             constrains);
          }
          if (exp instanceof SimpleName) {
            SimpleType stp = extracTypeInfo(findDeclaration(((SimpleName) exp)));
            if (stp == null)
              return null;
            declaringClass = findDeclaration(stp.getName());
//            log(""FA.SN "" + getNodeAsString(declaringClass));
            constrains.add(ASTNode.METHOD_DECLARATION);
            return definedIn(declaringClass, fa.getName().toString(),
                             constrains);
          }
        }

      } else {
        parent = parent.getParent(); // Move one up the ast. V V IMP!!
      }
    } else if (parent.getNodeType() == ASTNode.QUALIFIED_NAME) {

      QualifiedName qn = (QualifiedName) parent;
      if (!findMe.toString().equals(qn.getQualifier().toString())) {

        SimpleType stp = extracTypeInfo(findDeclaration((qn.getQualifier())));
//        log(qn.getQualifier() + ""->"" + qn.getName());
        if (stp == null) {
          return null;
        }

        declaringClass = findDeclaration(stp.getName());

//        log(""QN decl class: "" + getNodeAsString(declaringClass));
        constrains.clear();
        constrains.add(ASTNode.TYPE_DECLARATION);
        constrains.add(ASTNode.FIELD_DECLARATION);
        return definedIn(declaringClass, qn.getName().toString(), constrains);
      }
      else{
        if(findMe instanceof QualifiedName){
          QualifiedName qnn = (QualifiedName) findMe;
//          log(""findMe is a QN, ""
//              + (qnn.getQualifier().toString() + "" other "" + qnn.getName()
//                  .toString()));

          SimpleType stp = extracTypeInfo(findDeclaration((qnn.getQualifier())));
          if (stp == null) {
            return null;
          }
          declaringClass = findDeclaration(stp.getName());
          constrains.clear();
          constrains.add(ASTNode.TYPE_DECLARATION);
          constrains.add(ASTNode.FIELD_DECLARATION);
          return definedIn(declaringClass, qnn.getName().toString(),
                           constrains);
        }
      }
    } else if (parent.getNodeType() == ASTNode.SIMPLE_TYPE) {
      constrains.add(ASTNode.TYPE_DECLARATION);
      if (parent.getParent().getNodeType() == ASTNode.CLASS_INSTANCE_CREATION) {
        constrains.add(ASTNode.CLASS_INSTANCE_CREATION);
      }
    } else if (parent.getNodeType() == ASTNode.TYPE_DECLARATION) {
      // The condition where we look up the name of a class decl
      TypeDeclaration td = (TypeDeclaration) parent;
      if (findMe.equals(td.getName())) {
        return parent;
      }

    } else if (parent instanceof Expression) {
//      constrains.add(ASTNode.TYPE_DECLARATION);
//      constrains.add(ASTNode.METHOD_DECLARATION);
//      constrains.add(ASTNode.FIELD_DECLARATION);
    }
//    else if(findMe instanceof QualifiedName){
//      QualifiedName qn = (QualifiedName) findMe;
//      System.out
//          .println(""findMe is a QN, ""
//              + (qn.getQualifier().toString() + "" other "" + qn.getName()
//                  .toString()));
//    }
    while (parent != null) {
//      log(""findDeclaration1 -> "" + getNodeAsString(parent));
      for (Object oprop : parent.structuralPropertiesForType()) {
        StructuralPropertyDescriptor prop = (StructuralPropertyDescriptor) oprop;
        if (prop.isChildProperty() || prop.isSimpleProperty()) {
          if (parent.getStructuralProperty(prop) instanceof ASTNode) {
//            log(prop + "" C/S Prop of -> ""
//                + getNodeAsString(parent));
            ret = definedIn((ASTNode) parent.getStructuralProperty(prop),
                            findMe.toString(), constrains);
            if (ret != null)
              return ret;
          }
        } else if (prop.isChildListProperty()) {
//          log((prop) + "" ChildList props of ""
//              + getNodeAsString(parent));
          List<ASTNode> nodelist = (List<ASTNode>) parent
              .getStructuralProperty(prop);
          for (ASTNode retNode : nodelist) {
            ret = definedIn(retNode, findMe.toString(), constrains);
            if (ret != null)
              return ret;
          }
        }
      }
      parent = parent.getParent();
    }
    return null;
  }",False,False,The function of this method is to find the declaration of a given Name instance in an Abstract Syntax Tree (AST). It traverses the AST and checks various conditions to locate the declaration.,"The code defines a method called ""findDeclaration"" that takes a Name instance as input and attempts to locate its declaration in the Abstract Syntax Tree (AST). It handles different cases such as method invocations, field accesses, qualified names, and type declarations to find the corresponding declaration node in the AST."
33,"findDeclaration2(Name,ASTNode)",find declaration2 find me alternate parent a variation of find declaration but accepts an alternate parent ast node param find me param alternate parent return ,Method,"resolveExpression(ASTNode,ASTNode,boolean) resolveExpression(ASTNode,ASTNode,boolean) resolveExpression(ASTNode,ASTNode,boolean) resolveExpression(ASTNode,ASTNode,boolean) resolveExpression(ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) findDeclaration2(Name,ASTNode) findDeclaration2(Name,ASTNode) findDeclaration2(Name,ASTNode) findDeclaration2(Name,ASTNode) findDeclaration2(Name,ASTNode) findDeclaration2(Name,ASTNode) findDeclaration2(Name,ASTNode) findDeclaration2(Name,ASTNode) findDeclaration2(Name,ASTNode) findDeclaration2(Name,ASTNode) findDeclaration2(Name,ASTNode) findDeclaration2(Name,ASTNode) findDeclaration2(Name,ASTNode) findDeclaration2(Name,ASTNode) findDeclaration2(Name,ASTNode) findDeclaration2(Name,ASTNode)",,"org.eclipse.jdt.core.dom.ASTNode+getParent() org.eclipse.jdt.core.dom.ASTNode+getParent() org.eclipse.jdt.core.dom.ASTNode+getNodeType() org.eclipse.jdt.core.dom.ASTNode+getNodeType() org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) java.lang.String+equals(Object) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.MethodInvocation+getName() org.eclipse.jdt.core.dom.MethodInvocation+getName() org.eclipse.jdt.core.dom.ASTNode+toString() java.lang.String+equals(Object) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.ASTNode+toString() java.util.ArrayList+add(int,E) java.util.ArrayList+add(int,E) java.util.ArrayList+add(int,E) java.util.ArrayList+add(int,E) processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) org.eclipse.jdt.core.dom.MethodInvocation+getName() org.eclipse.jdt.core.dom.MethodInvocation+getName() processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) org.eclipse.jdt.core.dom.SimpleType+getName() org.eclipse.jdt.core.dom.SimpleType+getName() processing.mode.java.pdex.ASTGenerator+definedIn(ASTNode,String,ArrayList<Integer>) processing.mode.java.pdex.ASTGenerator+definedIn(ASTNode,String,ArrayList<Integer>) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.MethodInvocation+getName() org.eclipse.jdt.core.dom.MethodInvocation+getName() org.eclipse.jdt.core.dom.ASTNode+toString() processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) org.eclipse.jdt.core.dom.FieldAccess+getName() org.eclipse.jdt.core.dom.FieldAccess+getName() processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) org.eclipse.jdt.core.dom.SimpleType+getName() org.eclipse.jdt.core.dom.SimpleType+getName() processing.mode.java.pdex.ASTGenerator+definedIn(ASTNode,String,ArrayList<Integer>) processing.mode.java.pdex.ASTGenerator+definedIn(ASTNode,String,ArrayList<Integer>) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.MethodInvocation+getName() org.eclipse.jdt.core.dom.MethodInvocation+getName() org.eclipse.jdt.core.dom.ASTNode+toString() processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) org.eclipse.jdt.core.dom.SimpleType+getName() org.eclipse.jdt.core.dom.SimpleType+getName() java.util.ArrayList+add(int,E) java.util.ArrayList+add(int,E) processing.mode.java.pdex.ASTGenerator+definedIn(ASTNode,String,ArrayList<Integer>) processing.mode.java.pdex.ASTGenerator+definedIn(ASTNode,String,ArrayList<Integer>) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.MethodInvocation+getName() org.eclipse.jdt.core.dom.MethodInvocation+getName() org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.ASTNode+getParent() org.eclipse.jdt.core.dom.ASTNode+getParent() org.eclipse.jdt.core.dom.ASTNode+getParent() org.eclipse.jdt.core.dom.ASTNode+getParent() org.eclipse.jdt.core.dom.ASTNode+getNodeType() org.eclipse.jdt.core.dom.ASTNode+getNodeType() org.eclipse.jdt.core.dom.FieldAccess+getExpression() org.eclipse.jdt.core.dom.FieldAccess+getExpression() java.lang.String+equals(Object) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.FieldAccess+getName() org.eclipse.jdt.core.dom.FieldAccess+getName() org.eclipse.jdt.core.dom.ASTNode+toString() java.lang.String+equals(Object) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.ASTNode+toString() java.util.ArrayList+add(int,E) java.util.ArrayList+add(int,E) java.util.ArrayList+add(int,E) java.util.ArrayList+add(int,E) processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) org.eclipse.jdt.core.dom.MethodInvocation+getName() org.eclipse.jdt.core.dom.MethodInvocation+getName() processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) org.eclipse.jdt.core.dom.SimpleType+getName() org.eclipse.jdt.core.dom.SimpleType+getName() processing.mode.java.pdex.ASTGenerator+definedIn(ASTNode,String,ArrayList<Integer>) processing.mode.java.pdex.ASTGenerator+definedIn(ASTNode,String,ArrayList<Integer>) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.FieldAccess+getName() org.eclipse.jdt.core.dom.FieldAccess+getName() org.eclipse.jdt.core.dom.ASTNode+toString() processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) org.eclipse.jdt.core.dom.FieldAccess+getName() org.eclipse.jdt.core.dom.FieldAccess+getName() processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) org.eclipse.jdt.core.dom.SimpleType+getName() org.eclipse.jdt.core.dom.SimpleType+getName() java.util.ArrayList+add(int,E) java.util.ArrayList+add(int,E) processing.mode.java.pdex.ASTGenerator+definedIn(ASTNode,String,ArrayList<Integer>) processing.mode.java.pdex.ASTGenerator+definedIn(ASTNode,String,ArrayList<Integer>) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.FieldAccess+getName() org.eclipse.jdt.core.dom.FieldAccess+getName() org.eclipse.jdt.core.dom.ASTNode+toString() processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) org.eclipse.jdt.core.dom.SimpleType+getName() org.eclipse.jdt.core.dom.SimpleType+getName() java.util.ArrayList+add(int,E) java.util.ArrayList+add(int,E) processing.mode.java.pdex.ASTGenerator+definedIn(ASTNode,String,ArrayList<Integer>) processing.mode.java.pdex.ASTGenerator+definedIn(ASTNode,String,ArrayList<Integer>) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.FieldAccess+getName() org.eclipse.jdt.core.dom.FieldAccess+getName() org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.ASTNode+getParent() org.eclipse.jdt.core.dom.ASTNode+getParent() org.eclipse.jdt.core.dom.ASTNode+getParent() org.eclipse.jdt.core.dom.ASTNode+getParent() org.eclipse.jdt.core.dom.ASTNode+getNodeType() org.eclipse.jdt.core.dom.ASTNode+getNodeType() java.lang.String+equals(Object) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.ASTNode+toString() java.lang.String+equals(Object) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.QualifiedName+getQualifier() org.eclipse.jdt.core.dom.QualifiedName+getQualifier() org.eclipse.jdt.core.dom.ASTNode+toString() processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) org.eclipse.jdt.core.dom.QualifiedName+getQualifier() org.eclipse.jdt.core.dom.QualifiedName+getQualifier() processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) org.eclipse.jdt.core.dom.SimpleType+getName() org.eclipse.jdt.core.dom.SimpleType+getName() java.util.ArrayList+clear() java.util.ArrayList+clear() java.util.ArrayList+add(int,E) java.util.ArrayList+add(int,E) java.util.ArrayList+add(int,E) java.util.ArrayList+add(int,E) processing.mode.java.pdex.ASTGenerator+definedIn(ASTNode,String,ArrayList<Integer>) processing.mode.java.pdex.ASTGenerator+definedIn(ASTNode,String,ArrayList<Integer>) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.QualifiedName+getName() org.eclipse.jdt.core.dom.QualifiedName+getName() org.eclipse.jdt.core.dom.ASTNode+toString() processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) org.eclipse.jdt.core.dom.QualifiedName+getQualifier() org.eclipse.jdt.core.dom.QualifiedName+getQualifier() processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration2(Name,ASTNode) org.eclipse.jdt.core.dom.SimpleType+getName() org.eclipse.jdt.core.dom.SimpleType+getName() java.util.ArrayList+clear() java.util.ArrayList+clear() java.util.ArrayList+add(int,E) java.util.ArrayList+add(int,E) java.util.ArrayList+add(int,E) java.util.ArrayList+add(int,E) processing.mode.java.pdex.ASTGenerator+definedIn(ASTNode,String,ArrayList<Integer>) processing.mode.java.pdex.ASTGenerator+definedIn(ASTNode,String,ArrayList<Integer>) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.QualifiedName+getName() org.eclipse.jdt.core.dom.QualifiedName+getName() org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.ASTNode+getNodeType() org.eclipse.jdt.core.dom.ASTNode+getNodeType() java.util.ArrayList+add(int,E) java.util.ArrayList+add(int,E) org.eclipse.jdt.core.dom.ASTNode+getNodeType() org.eclipse.jdt.core.dom.ASTNode+getParent() org.eclipse.jdt.core.dom.ASTNode+getParent() org.eclipse.jdt.core.dom.ASTNode+getNodeType() java.util.ArrayList+add(int,E) java.util.ArrayList+add(int,E) org.eclipse.jdt.core.dom.ASTNode+structuralPropertiesForType() org.eclipse.jdt.core.dom.ASTNode+structuralPropertiesForType() org.eclipse.jdt.core.dom.StructuralPropertyDescriptor+isChildProperty() org.eclipse.jdt.core.dom.StructuralPropertyDescriptor+isChildProperty() org.eclipse.jdt.core.dom.StructuralPropertyDescriptor+isSimpleProperty() org.eclipse.jdt.core.dom.StructuralPropertyDescriptor+isSimpleProperty() org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) processing.mode.java.pdex.ASTGenerator+definedIn(ASTNode,String,ArrayList<Integer>) processing.mode.java.pdex.ASTGenerator+definedIn(ASTNode,String,ArrayList<Integer>) org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.StructuralPropertyDescriptor+isChildListProperty() org.eclipse.jdt.core.dom.StructuralPropertyDescriptor+isChildListProperty() org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) processing.mode.java.pdex.ASTGenerator+definedIn(ASTNode,String,ArrayList<Integer>) processing.mode.java.pdex.ASTGenerator+definedIn(ASTNode,String,ArrayList<Integer>) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.ASTNode+getParent() org.eclipse.jdt.core.dom.ASTNode+getParent()",org.eclipse.jdt.core.dom.ASTNode+METHOD_INVOCATION org.eclipse.jdt.core.dom.MethodInvocation+EXPRESSION_PROPERTY org.eclipse.jdt.core.dom.ASTNode+METHOD_DECLARATION org.eclipse.jdt.core.dom.ASTNode+TYPE_DECLARATION org.eclipse.jdt.core.dom.ASTNode+METHOD_DECLARATION org.eclipse.jdt.core.dom.ASTNode+FIELD_ACCESS org.eclipse.jdt.core.dom.ASTNode+FIELD_DECLARATION org.eclipse.jdt.core.dom.ASTNode+TYPE_DECLARATION org.eclipse.jdt.core.dom.ASTNode+TYPE_DECLARATION org.eclipse.jdt.core.dom.ASTNode+METHOD_DECLARATION org.eclipse.jdt.core.dom.ASTNode+QUALIFIED_NAME org.eclipse.jdt.core.dom.ASTNode+TYPE_DECLARATION org.eclipse.jdt.core.dom.ASTNode+FIELD_DECLARATION org.eclipse.jdt.core.dom.ASTNode+TYPE_DECLARATION org.eclipse.jdt.core.dom.ASTNode+FIELD_DECLARATION org.eclipse.jdt.core.dom.ASTNode+SIMPLE_TYPE org.eclipse.jdt.core.dom.ASTNode+TYPE_DECLARATION org.eclipse.jdt.core.dom.ASTNode+CLASS_INSTANCE_CREATION org.eclipse.jdt.core.dom.ASTNode+CLASS_INSTANCE_CREATION,8901,189,12,"/** 
 * A variation of findDeclaration() but accepts an alternate parent ASTNode
 * @param findMe
 * @param alternateParent
 * @return
 */
","/**
   * A variation of findDeclaration() but accepts an alternate parent ASTNode
   * @param findMe
   * @param alternateParent
   * @return
   */
  protected static ASTNode findDeclaration2(Name findMe, ASTNode alternateParent) {
    ASTNode declaringClass;
    ASTNode parent = findMe.getParent();
    ASTNode ret;
    ArrayList<Integer> constrains = new ArrayList<>();
    if (parent.getNodeType() == ASTNode.METHOD_INVOCATION) {
      Expression exp = (Expression) parent.getStructuralProperty(MethodInvocation.EXPRESSION_PROPERTY);
      //TODO: Note the imbalance of constrains.add(ASTNode.METHOD_DECLARATION);
      // Possibly a bug here. Investigate later.
      if (((MethodInvocation) parent).getName().toString()
          .equals(findMe.toString())) {
        constrains.add(ASTNode.METHOD_DECLARATION);

        if (exp != null) {
          constrains.add(ASTNode.TYPE_DECLARATION);
//          log(""MI EXP: "" + exp.toString() + "" of type ""
//              + exp.getClass().getName() + "" parent: "" + exp.getParent());
          if (exp instanceof MethodInvocation) {
            SimpleType stp = extracTypeInfo(findDeclaration2(((MethodInvocation) exp)
                                                                 .getName(),
                                                             alternateParent));
            if (stp == null)
              return null;
            declaringClass = findDeclaration2(stp.getName(), alternateParent);
            return definedIn(declaringClass, ((MethodInvocation) parent)
                .getName().toString(), constrains);
          } else if (exp instanceof FieldAccess) {
            SimpleType stp = extracTypeInfo(findDeclaration2(((FieldAccess) exp)
                                                                 .getName(),
                                                             alternateParent));
            if (stp == null)
              return null;
            declaringClass = findDeclaration2((stp.getName()), alternateParent);
            return definedIn(declaringClass, ((MethodInvocation) parent)
                .getName().toString(), constrains);
          }
          if (exp instanceof SimpleName) {
            SimpleType stp = extracTypeInfo(findDeclaration2(((SimpleName) exp),
                                                             alternateParent));
            if (stp == null)
              return null;
            declaringClass = findDeclaration2(stp.getName(), alternateParent);
//            log(""MI.SN "" + getNodeAsString(declaringClass));
            constrains.add(ASTNode.METHOD_DECLARATION);
            return definedIn(declaringClass, ((MethodInvocation) parent)
                .getName().toString(), constrains);
          }

        }
      } else {
        parent = parent.getParent(); // Move one up the ast. V V IMP!!
        alternateParent = alternateParent.getParent();
      }
    } else if (parent.getNodeType() == ASTNode.FIELD_ACCESS) {
      FieldAccess fa = (FieldAccess) parent;
      Expression exp = fa.getExpression();
      if (fa.getName().toString().equals(findMe.toString())) {
        constrains.add(ASTNode.FIELD_DECLARATION);

        if (exp != null) {
          constrains.add(ASTNode.TYPE_DECLARATION);
//          log(""FA EXP: "" + exp.toString() + "" of type ""
//              + exp.getClass().getName() + "" parent: "" + exp.getParent());
          if (exp instanceof MethodInvocation) {
            SimpleType stp = extracTypeInfo(findDeclaration2(((MethodInvocation) exp)
                                                                 .getName(),
                                                             alternateParent));
            if (stp == null)
              return null;
            declaringClass = findDeclaration2(stp.getName(), alternateParent);
            return definedIn(declaringClass, fa.getName().toString(),
                             constrains);
          } else if (exp instanceof FieldAccess) {
            SimpleType stp = extracTypeInfo(findDeclaration2(((FieldAccess) exp)
                                                                 .getName(),
                                                             alternateParent));
            if (stp == null)
              return null;
            declaringClass = findDeclaration2((stp.getName()), alternateParent);
            constrains.add(ASTNode.TYPE_DECLARATION);
            return definedIn(declaringClass, fa.getName().toString(),
                             constrains);
          }
          if (exp instanceof SimpleName) {
            SimpleType stp = extracTypeInfo(findDeclaration2(((SimpleName) exp),
                                                             alternateParent));
            if (stp == null)
              return null;
            declaringClass = findDeclaration2(stp.getName(), alternateParent);
//            log(""FA.SN "" + getNodeAsString(declaringClass));
            constrains.add(ASTNode.METHOD_DECLARATION);
            return definedIn(declaringClass, fa.getName().toString(),
                             constrains);
          }
        }

      } else {
        parent = parent.getParent(); // Move one up the ast. V V IMP!!
        alternateParent = alternateParent.getParent();
      }
    } else if (parent.getNodeType() == ASTNode.QUALIFIED_NAME) {

      QualifiedName qn = (QualifiedName) parent;
      if (!findMe.toString().equals(qn.getQualifier().toString())) {

        SimpleType stp = extracTypeInfo(findDeclaration2((qn.getQualifier()),
                                                         alternateParent));
        if(stp == null)
          return null;
        declaringClass = findDeclaration2(stp.getName(), alternateParent);
//        log(qn.getQualifier() + ""->"" + qn.getName());
//        log(""QN decl class: "" + getNodeAsString(declaringClass));
        constrains.clear();
        constrains.add(ASTNode.TYPE_DECLARATION);
        constrains.add(ASTNode.FIELD_DECLARATION);
        return definedIn(declaringClass, qn.getName().toString(), constrains);
      }
      else{
        if(findMe instanceof QualifiedName){
          QualifiedName qnn = (QualifiedName) findMe;
//          log(""findMe is a QN, ""
//              + (qnn.getQualifier().toString() + "" other "" + qnn.getName()
//                  .toString()));

          SimpleType stp = extracTypeInfo(findDeclaration2((qnn.getQualifier()), alternateParent));

          if (stp == null) {
            return null;
          }

//          log(qnn.getQualifier() + ""->"" + qnn.getName());
          declaringClass = findDeclaration2(stp.getName(), alternateParent);

//          log(""QN decl class: ""
//              + getNodeAsString(declaringClass));
          constrains.clear();
          constrains.add(ASTNode.TYPE_DECLARATION);
          constrains.add(ASTNode.FIELD_DECLARATION);
          return definedIn(declaringClass, qnn.getName().toString(), constrains);
        }
      }
    } else if (parent.getNodeType() == ASTNode.SIMPLE_TYPE) {
      constrains.add(ASTNode.TYPE_DECLARATION);
      if (parent.getParent().getNodeType() == ASTNode.CLASS_INSTANCE_CREATION)
        constrains.add(ASTNode.CLASS_INSTANCE_CREATION);
    } else if (parent instanceof Expression) {
//      constrains.add(ASTNode.TYPE_DECLARATION);
//      constrains.add(ASTNode.METHOD_DECLARATION);
//      constrains.add(ASTNode.FIELD_DECLARATION);
    } // TODO: in findDec, we also have a case where parent of type TD is handled.
      // Figure out if needed here as well.
//    log(""Alternate parent: "" + getNodeAsString(alternateParent));
    while (alternateParent != null) {
//      log(""findDeclaration2 -> ""
//          + getNodeAsString(alternateParent));
      for (Object oprop : alternateParent.structuralPropertiesForType()) {
        StructuralPropertyDescriptor prop = (StructuralPropertyDescriptor) oprop;
        if (prop.isChildProperty() || prop.isSimpleProperty()) {
          if (alternateParent.getStructuralProperty(prop) instanceof ASTNode) {
//            log(prop + "" C/S Prop of -> ""
//                + getNodeAsString(alternateParent));
            ret = definedIn((ASTNode) alternateParent
                                .getStructuralProperty(prop),
                            findMe.toString(), constrains);
            if (ret != null)
              return ret;
          }
        } else if (prop.isChildListProperty()) {
//          log((prop) + "" ChildList props of ""
//              + getNodeAsString(alternateParent));
          List<ASTNode> nodelist = (List<ASTNode>) alternateParent
              .getStructuralProperty(prop);
          for (ASTNode retNode : nodelist) {
            ret = definedIn(retNode, findMe.toString(), constrains);
            if (ret != null)
              return ret;
          }
        }
      }
      alternateParent = alternateParent.getParent();
    }
    return null;
  }",False,False,"The function of this method is to find the declaration of a given name in an Abstract Syntax Tree (AST), using an alternate parent ASTNode as a starting point. It returns the ASTNode that represents the declaration.","The code defines a method called `findDeclaration2` that searches for a declaration of a given name within an abstract syntax tree (AST). It handles different types of parent nodes and constraints, and recursively searches for the declaration within the AST. The method returns the AST node representing the declaration if found, or null otherwise."
34,getGui(),get gui ,Method,,processing.mode.java.pdex.ErrorCheckerService+mainLoop() processing.mode.java.pdex.ErrorCheckerService+handleHasJavaTabsChange(boolean) processing.mode.java.pdex.ErrorCheckerService+handleHasJavaTabsChange(boolean),,processing.mode.java.pdex.ASTGenerator+gui,41,3,1,,"public GUI getGui() {
    return gui;
  }",False,False,This method returns the GUI object.,"The code defines a method named ""getGui"" that returns an object of type ""GUI"". This method is used to retrieve the GUI object associated with the current instance of the class."
35,ClassMember,class member a wrapper for java lang reflect types will have to see if the usage turns out to be internal only here or not and then accordingly decide where to place this class author quarkninja ,MemberClass,,,"processing.mode.java.pdex.ASTGenerator.ClassMember+ClassMember(Class<?>) java.lang.Class+getName() java.lang.Class+getName() java.lang.Class+getName() java.lang.Class+getName() processing.mode.java.pdex.ASTGenerator.ClassMember+ClassMember(Method) java.lang.Class+getName() java.lang.reflect.Method+getReturnType() java.lang.reflect.Method+getReturnType() java.lang.Class+getName() java.lang.reflect.Method+getName() java.lang.reflect.Method+getName() java.lang.Class+getName() java.lang.reflect.Method+getDeclaringClass() java.lang.reflect.Method+getDeclaringClass() java.lang.Class+getName() java.lang.Class+getName() java.lang.reflect.Method+getReturnType() java.lang.reflect.Method+getReturnType() java.lang.Class+getName() processing.mode.java.pdex.ASTGenerator.ClassMember+ClassMember(Field) java.lang.Class+getName() java.lang.reflect.Field+getType() java.lang.reflect.Field+getType() java.lang.Class+getName() java.lang.reflect.Field+getName() java.lang.reflect.Field+getName() java.lang.Class+getName() java.lang.reflect.Field+getDeclaringClass() java.lang.reflect.Field+getDeclaringClass() java.lang.Class+getName() java.lang.Class+getName() java.lang.reflect.Field+getType() java.lang.reflect.Field+getType() java.lang.Class+getName() processing.mode.java.pdex.ASTGenerator.ClassMember+ClassMember(Constructor<?>) java.lang.reflect.Constructor+getName() java.lang.reflect.Constructor+getName() java.lang.Class+getName() java.lang.reflect.Constructor+getDeclaringClass() java.lang.reflect.Constructor+getDeclaringClass() java.lang.Class+getName() processing.mode.java.pdex.ASTGenerator.ClassMember+ClassMember(PreprocessedSketch,ASTNode) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.SimpleType+getName() org.eclipse.jdt.core.dom.SimpleType+getName() org.eclipse.jdt.core.dom.ASTNode+toString() processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+extracTypeInfo(ASTNode) processing.mode.java.pdex.ASTGenerator+findDeclaration(Name) processing.mode.java.pdex.ASTGenerator+findDeclaration(Name) org.eclipse.jdt.core.dom.SimpleType+getName() org.eclipse.jdt.core.dom.SimpleType+getName() org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.SimpleType+getName() org.eclipse.jdt.core.dom.SimpleType+getName() org.eclipse.jdt.core.dom.ASTNode+toString() processing.mode.java.pdex.ASTGenerator+findClassIfExists(PreprocessedSketch,String) processing.mode.java.pdex.ASTGenerator+findClassIfExists(PreprocessedSketch,String) processing.mode.java.pdex.ASTGenerator.ClassMember+getClass_() processing.mode.java.pdex.ASTGenerator.ClassMember+getDeclaringNode() processing.mode.java.pdex.ASTGenerator.ClassMember+getField() processing.mode.java.pdex.ASTGenerator.ClassMember+getMethod() processing.mode.java.pdex.ASTGenerator.ClassMember+getCons() processing.mode.java.pdex.ASTGenerator.ClassMember+getASTNode() processing.mode.java.pdex.ASTGenerator.ClassMember+toString() processing.mode.java.pdex.ASTGenerator.ClassMember+getTypeAsString()",processing.mode.java.pdex.ASTGenerator.ClassMember+field processing.mode.java.pdex.ASTGenerator.ClassMember+method processing.mode.java.pdex.ASTGenerator.ClassMember+cons processing.mode.java.pdex.ASTGenerator.ClassMember+thisclass processing.mode.java.pdex.ASTGenerator.ClassMember+stringVal processing.mode.java.pdex.ASTGenerator.ClassMember+classType processing.mode.java.pdex.ASTGenerator.ClassMember+astNode processing.mode.java.pdex.ASTGenerator.ClassMember+declaringNode processing.mode.java.pdex.ASTGenerator.ClassMember+thisclass processing.mode.java.pdex.ASTGenerator.ClassMember+stringVal processing.mode.java.pdex.ASTGenerator.ClassMember+classType processing.mode.java.pdex.ASTGenerator.ClassMember+method processing.mode.java.pdex.ASTGenerator.ClassMember+stringVal processing.mode.java.pdex.ASTGenerator.ClassMember+classType processing.mode.java.pdex.ASTGenerator.ClassMember+field processing.mode.java.pdex.ASTGenerator.ClassMember+stringVal processing.mode.java.pdex.ASTGenerator.ClassMember+classType processing.mode.java.pdex.ASTGenerator.ClassMember+cons processing.mode.java.pdex.ASTGenerator.ClassMember+stringVal processing.mode.java.pdex.ASTGenerator.ClassMember+astNode processing.mode.java.pdex.ASTGenerator.ClassMember+stringVal processing.mode.java.pdex.ASTGenerator.ClassMember+declaringNode processing.mode.java.pdex.ASTGenerator.ClassMember+classType processing.mode.java.pdex.ASTGenerator.ClassMember+classType processing.mode.java.pdex.ASTGenerator.ClassMember+thisclass processing.mode.java.pdex.ASTGenerator.ClassMember+classType processing.mode.java.pdex.ASTGenerator.ClassMember+declaringNode processing.mode.java.pdex.ASTGenerator.ClassMember+thisclass processing.mode.java.pdex.ASTGenerator.ClassMember+declaringNode processing.mode.java.pdex.ASTGenerator.ClassMember+field processing.mode.java.pdex.ASTGenerator.ClassMember+method processing.mode.java.pdex.ASTGenerator.ClassMember+cons processing.mode.java.pdex.ASTGenerator.ClassMember+astNode processing.mode.java.pdex.ASTGenerator.ClassMember+stringVal processing.mode.java.pdex.ASTGenerator.ClassMember+classType,2622,108,9,"/** 
 * A wrapper for java.lang.reflect types. Will have to see if the usage turns out to be internal only here or not and then accordingly decide where to place this class.
 * @author quarkninja
 */
","/**
   * A wrapper for java.lang.reflect types.
   * Will have to see if the usage turns out to be internal only here or not
   * and then accordingly decide where to place this class.
   * @author quarkninja
   *
   */
  public static class ClassMember {
    private Field field;

    private Method method;

    private Constructor<?> cons;

    private Class<?> thisclass;

    private String stringVal;

    private String classType;

    private ASTNode astNode;

    private ASTNode declaringNode;

    public ClassMember(Class<?> m) {
      thisclass = m;
      stringVal = ""Predefined Class "" + m.getName();
      classType = m.getName();
    }

    public ClassMember(Method m) {
      method = m;
      stringVal = ""Method "" + m.getReturnType().getName() + "" | "" + m.getName()
          + "" defined in "" + m.getDeclaringClass().getName();
      classType = m.getReturnType().getName();
    }

    public ClassMember(Field m) {
      field = m;
      stringVal = ""Field "" + m.getType().getName() + "" | "" + m.getName()
          + "" defined in "" + m.getDeclaringClass().getName();
      classType = m.getType().getName();
    }

    public ClassMember(Constructor<?> m) {
      cons = m;
      stringVal = ""Cons "" + "" "" + m.getName() + "" defined in ""
          + m.getDeclaringClass().getName();
    }

    public ClassMember(PreprocessedSketch ps, ASTNode node){
      astNode = node;
      stringVal = getNodeAsString(node);
      if(node instanceof TypeDeclaration){
        declaringNode = node;
      }
      if(node instanceof SimpleType){
        classType = ((SimpleType)node).getName().toString();
      }
      SimpleType stp = (node instanceof SimpleType) ? (SimpleType) node
          : extracTypeInfo(node);
      if(stp != null){
        ASTNode decl =findDeclaration(stp.getName());
        // Czech out teh mutation
        if(decl == null){
          // a predefined type
          classType = stp.getName().toString();
          thisclass = findClassIfExists(ps, classType);
        }
        else{
          // a local type
          declaringNode = decl;
        }
      }
    }

    public Class<?> getClass_() {
      return thisclass;
    }

    public ASTNode getDeclaringNode(){
      return declaringNode;
    }

    public Field getField() {
      return field;
    }

    public Method getMethod() {
      return method;
    }

    public Constructor<?> getCons() {
      return cons;
    }

    public ASTNode getASTNode(){
      return astNode;
    }

    public String toString() {
      return stringVal;
    }

    public String getTypeAsString(){
      return classType;
    }
  }",False,False,"/** 
 * A wrapper for java.lang.reflect types. Will have to see if the usage turns out to be internal only here or not and then accordingly decide where to place this class.
 * @author quarkninja
 */
","/** 
 * A wrapper for java.lang.reflect types. Will have to see if the usage turns out to be internal only here or not and then accordingly decide where to place this class.
 * @author quarkninja
 */
"
36,extracTypeInfo(ASTNode),extrac type info node find the simple type from fd svd vds etc param node return ,Method,"resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) findDeclaration(Name) findDeclaration(Name) findDeclaration(Name) findDeclaration(Name) findDeclaration(Name) findDeclaration(Name) findDeclaration(Name) findDeclaration(Name) findDeclaration2(Name,ASTNode) findDeclaration2(Name,ASTNode) findDeclaration2(Name,ASTNode) findDeclaration2(Name,ASTNode) findDeclaration2(Name,ASTNode) findDeclaration2(Name,ASTNode) findDeclaration2(Name,ASTNode) findDeclaration2(Name,ASTNode) ClassMember.ClassMember(PreprocessedSketch,ASTNode)",,processing.mode.java.pdex.ASTGenerator+extracTypeInfo2(ASTNode) processing.mode.java.pdex.ASTGenerator+extracTypeInfo2(ASTNode) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) org.eclipse.jdt.core.dom.ArrayType+getElementType() org.eclipse.jdt.core.dom.ArrayType+getElementType() java.lang.Class+getName() java.lang.Object+getClass() org.eclipse.jdt.core.dom.ArrayType+getElementType() org.eclipse.jdt.core.dom.ArrayType+getElementType() java.lang.Object+getClass() java.lang.Class+getName() org.eclipse.jdt.core.dom.ArrayType+getElementType() org.eclipse.jdt.core.dom.ArrayType+getElementType() org.eclipse.jdt.core.dom.ArrayType+getElementType() org.eclipse.jdt.core.dom.ArrayType+getElementType() org.eclipse.jdt.core.dom.ArrayType+getElementType() org.eclipse.jdt.core.dom.ArrayType+getElementType() processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) org.eclipse.jdt.core.dom.ParameterizedType+getType() org.eclipse.jdt.core.dom.ParameterizedType+getType() java.lang.Object+getClass() org.eclipse.jdt.core.dom.ParameterizedType+getType() org.eclipse.jdt.core.dom.ParameterizedType+getType() java.lang.Object+getClass() org.eclipse.jdt.core.dom.ParameterizedType+getType() org.eclipse.jdt.core.dom.ParameterizedType+getType() org.eclipse.jdt.core.dom.ParameterizedType+getType() org.eclipse.jdt.core.dom.ParameterizedType+getType(),,1042,34,9,"/** 
 * Find the SimpleType from FD, SVD, VDS, etc
 * @param node
 * @return
 */
","/**
   * Find the SimpleType from FD, SVD, VDS, etc
   *
   * @param node
   * @return
   */
  public static SimpleType extracTypeInfo(ASTNode node) {
    if (node == null) {
      return null;
    }
    Type t = extracTypeInfo2(node);
    if (t instanceof PrimitiveType) {
      return null;
    } else if (t instanceof ArrayType) {
      ArrayType at = (ArrayType) t;
      log(""ele type ""
              + at.getElementType() + "", ""
              + at.getElementType().getClass().getName());
      if (at.getElementType() instanceof PrimitiveType) {
        return null;
      } else if (at.getElementType() instanceof SimpleType) {
        return (SimpleType) at.getElementType();
      } else
        return null;
    } else if (t instanceof ParameterizedType) {
      ParameterizedType pmt = (ParameterizedType) t;
      log(pmt.getType() + "", "" + pmt.getType().getClass());
      if (pmt.getType() instanceof SimpleType) {
        return (SimpleType) pmt.getType();
      } else
        return null;
    }
    return (SimpleType) t;
  }",False,False,"The function of this method is to extract the SimpleType from a given ASTNode. It checks the type of the node and returns the corresponding SimpleType if it exists, otherwise it returns null.","This code defines a method named `extracTypeInfo` that takes an `ASTNode` as input and returns a `SimpleType`. It checks the type of the input node and returns null if it is a primitive type or an array type with a primitive element type. Otherwise, it returns the simple type of the input node."
37,extracTypeInfo2(ASTNode),extrac type info2 node ,Method,"resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) extracTypeInfo(ASTNode) extracTypeInfo2(ASTNode)",processing.mode.java.pdex.CompletionCandidate+CompletionCandidate(VariableDeclarationFragment),processing.app.Messages+log(String) processing.app.Messages+log(String) org.eclipse.jdt.core.dom.ASTNode+getNodeType() org.eclipse.jdt.core.dom.ASTNode+getNodeType() org.eclipse.jdt.core.dom.MethodDeclaration+getReturnType2() org.eclipse.jdt.core.dom.MethodDeclaration+getReturnType2() org.eclipse.jdt.core.dom.FieldDeclaration+getType() org.eclipse.jdt.core.dom.FieldDeclaration+getType() org.eclipse.jdt.core.dom.VariableDeclarationExpression+getType() org.eclipse.jdt.core.dom.VariableDeclarationExpression+getType() org.eclipse.jdt.core.dom.VariableDeclarationStatement+getType() org.eclipse.jdt.core.dom.VariableDeclarationStatement+getType() org.eclipse.jdt.core.dom.SingleVariableDeclaration+getType() org.eclipse.jdt.core.dom.SingleVariableDeclaration+getType() processing.mode.java.pdex.ASTGenerator+extracTypeInfo2(ASTNode) processing.mode.java.pdex.ASTGenerator+extracTypeInfo2(ASTNode) org.eclipse.jdt.core.dom.ASTNode+getParent() org.eclipse.jdt.core.dom.ASTNode+getParent() processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode),org.eclipse.jdt.core.dom.ASTNode+METHOD_DECLARATION org.eclipse.jdt.core.dom.ASTNode+FIELD_DECLARATION org.eclipse.jdt.core.dom.ASTNode+VARIABLE_DECLARATION_EXPRESSION org.eclipse.jdt.core.dom.ASTNode+VARIABLE_DECLARATION_STATEMENT org.eclipse.jdt.core.dom.ASTNode+SINGLE_VARIABLE_DECLARATION org.eclipse.jdt.core.dom.ASTNode+VARIABLE_DECLARATION_FRAGMENT,863,21,9,,"static public Type extracTypeInfo2(ASTNode node) {
    Messages.log(""* extracTypeInfo2"");
    if (node == null)
      return null;
    switch (node.getNodeType()) {
    case ASTNode.METHOD_DECLARATION:
      return ((MethodDeclaration) node).getReturnType2();
    case ASTNode.FIELD_DECLARATION:
      return ((FieldDeclaration) node).getType();
    case ASTNode.VARIABLE_DECLARATION_EXPRESSION:
      return  ((VariableDeclarationExpression) node).getType();
    case ASTNode.VARIABLE_DECLARATION_STATEMENT:
      return  ((VariableDeclarationStatement) node).getType();
    case ASTNode.SINGLE_VARIABLE_DECLARATION:
      return  ((SingleVariableDeclaration) node).getType();
    case ASTNode.VARIABLE_DECLARATION_FRAGMENT:
      return extracTypeInfo2(node.getParent());
    }
    log(""Unknown type info request "" + getNodeAsString(node));
    return null;
  }",False,False,The function extracTypeInfo2 takes an ASTNode as input and returns the type information associated with that node. It logs an error message if the node type is unknown.,"The code defines a static method named `extracTypeInfo2` that takes an `ASTNode` object as input and returns the type information associated with that node. The method uses a switch statement to handle different types of nodes and retrieve the corresponding type information. If the node type is unknown, an error message is logged and null is returned."
38,"definedIn(ASTNode,String,ArrayList<Integer>)",defined in node name constrains ,Method,"findDeclaration(Name) findDeclaration(Name) findDeclaration(Name) findDeclaration(Name) findDeclaration(Name) findDeclaration(Name) findDeclaration(Name) findDeclaration(Name) findDeclaration(Name) findDeclaration(Name) findDeclaration2(Name,ASTNode) findDeclaration2(Name,ASTNode) findDeclaration2(Name,ASTNode) findDeclaration2(Name,ASTNode) findDeclaration2(Name,ASTNode) findDeclaration2(Name,ASTNode) findDeclaration2(Name,ASTNode) findDeclaration2(Name,ASTNode) findDeclaration2(Name,ASTNode) findDeclaration2(Name,ASTNode)",,java.util.ArrayList+contains(Object) java.util.ArrayList+contains(Object) org.eclipse.jdt.core.dom.ASTNode+getNodeType() org.eclipse.jdt.core.dom.ASTNode+getNodeType() java.util.ArrayList+size() java.util.ArrayList+size() org.eclipse.jdt.core.dom.ASTNode+getNodeType() org.eclipse.jdt.core.dom.ASTNode+getNodeType() java.lang.String+equals(Object) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.AbstractTypeDeclaration+getName() org.eclipse.jdt.core.dom.AbstractTypeDeclaration+getName() org.eclipse.jdt.core.dom.ASTNode+toString() java.lang.String+equals(Object) java.util.ArrayList+contains(Object) java.util.ArrayList+contains(Object) org.eclipse.jdt.core.dom.TypeDeclaration+getMethods() org.eclipse.jdt.core.dom.TypeDeclaration+getMethods() java.lang.String+equalsIgnoreCase(String) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.MethodDeclaration+getName() org.eclipse.jdt.core.dom.MethodDeclaration+getName() org.eclipse.jdt.core.dom.ASTNode+toString() java.lang.String+equalsIgnoreCase(String) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) java.util.ArrayList+contains(Object) java.util.ArrayList+contains(Object) org.eclipse.jdt.core.dom.TypeDeclaration+getFields() org.eclipse.jdt.core.dom.TypeDeclaration+getFields() org.eclipse.jdt.core.dom.FieldDeclaration+fragments() org.eclipse.jdt.core.dom.FieldDeclaration+fragments() java.lang.String+equalsIgnoreCase(String) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.VariableDeclaration+getName() org.eclipse.jdt.core.dom.VariableDeclaration+getName() org.eclipse.jdt.core.dom.ASTNode+toString() java.lang.String+equalsIgnoreCase(String) java.util.ArrayList+contains(Object) java.util.ArrayList+contains(Object) org.eclipse.jdt.core.dom.TypeDeclaration+getMethods() org.eclipse.jdt.core.dom.TypeDeclaration+getMethods() java.lang.String+equalsIgnoreCase(String) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.MethodDeclaration+getName() org.eclipse.jdt.core.dom.MethodDeclaration+getName() org.eclipse.jdt.core.dom.ASTNode+toString() java.lang.String+equalsIgnoreCase(String) java.lang.String+equalsIgnoreCase(String) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.MethodDeclaration+getName() org.eclipse.jdt.core.dom.MethodDeclaration+getName() org.eclipse.jdt.core.dom.ASTNode+toString() java.lang.String+equalsIgnoreCase(String) java.lang.String+equalsIgnoreCase(String) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.VariableDeclaration+getName() org.eclipse.jdt.core.dom.VariableDeclaration+getName() org.eclipse.jdt.core.dom.ASTNode+toString() java.lang.String+equalsIgnoreCase(String) org.eclipse.jdt.core.dom.FieldDeclaration+fragments() org.eclipse.jdt.core.dom.FieldDeclaration+fragments() org.eclipse.jdt.core.dom.VariableDeclarationExpression+fragments() org.eclipse.jdt.core.dom.VariableDeclarationExpression+fragments() org.eclipse.jdt.core.dom.VariableDeclarationStatement+fragments() org.eclipse.jdt.core.dom.VariableDeclarationStatement+fragments() java.lang.String+equalsIgnoreCase(String) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.VariableDeclaration+getName() org.eclipse.jdt.core.dom.VariableDeclaration+getName() org.eclipse.jdt.core.dom.ASTNode+toString() java.lang.String+equalsIgnoreCase(String),org.eclipse.jdt.core.dom.ASTNode+TYPE_DECLARATION org.eclipse.jdt.core.dom.ASTNode+CLASS_INSTANCE_CREATION org.eclipse.jdt.core.dom.ASTNode+FIELD_DECLARATION org.eclipse.jdt.core.dom.ASTNode+METHOD_DECLARATION org.eclipse.jdt.core.dom.ASTNode+METHOD_DECLARATION org.eclipse.jdt.core.dom.ASTNode+SINGLE_VARIABLE_DECLARATION org.eclipse.jdt.core.dom.ASTNode+FIELD_DECLARATION org.eclipse.jdt.core.dom.ASTNode+VARIABLE_DECLARATION_EXPRESSION org.eclipse.jdt.core.dom.ASTNode+VARIABLE_DECLARATION_STATEMENT,3274,93,12,,"static protected ASTNode definedIn(ASTNode node, String name,
                                   ArrayList<Integer> constrains) {
    if (node == null)
      return null;
    if (constrains != null) {
//      log(""Looking at "" + getNodeAsString(node) + "" for "" + name
//          + "" in definedIn"");
      if (!constrains.contains(node.getNodeType()) && constrains.size() > 0) {
//        System.err.print(""definedIn -1 "" + "" But constrain was "");
//        for (Integer integer : constrains) {
//          System.out.print(ASTNode.nodeClassForType(integer) + "","");
//        }
//        log();
        return null;
      }
    }

    List<VariableDeclarationFragment> vdfList = null;
    switch (node.getNodeType()) {

    case ASTNode.TYPE_DECLARATION:
      //Base.loge(getNodeAsString(node));
      TypeDeclaration td = (TypeDeclaration) node;
      if (td.getName().toString().equals(name)) {
        if (constrains.contains(ASTNode.CLASS_INSTANCE_CREATION)) {
          // look for constructor;
          MethodDeclaration[] methods = td.getMethods();
          for (MethodDeclaration md : methods) {
            if (md.getName().toString().equalsIgnoreCase(name)) {
              log(""Found a constructor."");
              return md;
            }
          }
        } else {
          // it's just the TD we're lookin for
          return node;
        }
      } else {
        if (constrains.contains(ASTNode.FIELD_DECLARATION)) {
          // look for fields
          FieldDeclaration[] fields = td.getFields();
          for (FieldDeclaration fd : fields) {
            List<VariableDeclarationFragment> fragments = fd.fragments();
            for (VariableDeclarationFragment vdf : fragments) {
              if (vdf.getName().toString().equalsIgnoreCase(name))
                return fd;
            }
          }
        } else if (constrains.contains(ASTNode.METHOD_DECLARATION)) {
          // look for methods
          MethodDeclaration[] methods = td.getMethods();
          for (MethodDeclaration md : methods) {
            if (md.getName().toString().equalsIgnoreCase(name)) {
              return md;
            }
          }
        }
      }
      break;
    case ASTNode.METHOD_DECLARATION:
      //Base.loge(getNodeAsString(node));
      if (((MethodDeclaration) node).getName().toString().equalsIgnoreCase(name))
        return node;
      break;
    case ASTNode.SINGLE_VARIABLE_DECLARATION:
      //Base.loge(getNodeAsString(node));
      if (((SingleVariableDeclaration) node).getName().toString().equalsIgnoreCase(name))
        return node;
      break;
    case ASTNode.FIELD_DECLARATION:
      //Base.loge(""FD"" + node);
      vdfList = ((FieldDeclaration) node).fragments();
      break;
    case ASTNode.VARIABLE_DECLARATION_EXPRESSION:
      //Base.loge(""VDE"" + node);
      vdfList = ((VariableDeclarationExpression) node).fragments();
      break;
    case ASTNode.VARIABLE_DECLARATION_STATEMENT:
      //Base.loge(""VDS"" + node);
      vdfList = ((VariableDeclarationStatement) node).fragments();
      break;

    default:

    }
    if (vdfList != null) {
      for (VariableDeclarationFragment vdf : vdfList) {
        if (vdf.getName().toString().equalsIgnoreCase(name))
          return node;
      }
    }
    return null;
  }",False,False,"The function of this method is to find and return an ASTNode (Abstract Syntax Tree Node) that matches the given name and constraints. It searches through the ASTNode hierarchy and checks for matches based on the node type and name. If a match is found, the corresponding ASTNode is returned. If no match is found, null is returned.","The code defines a method called ""definedIn"" that takes an ASTNode, a name, and a list of constraints as input. It searches for a specific node or declaration within the given ASTNode based on the provided name and constraints, and returns the found node or declaration."
39,getNodeAsString(ASTNode),get node as string node ,Method,"checkForTypes(ASTNode) resolveExpression(ASTNode,ASTNode,boolean) resolveExpression(ASTNode,ASTNode,boolean) resolveExpression(ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) getChildExpression(ASTNode) getParentExpression(ASTNode) getMembersForType(PreprocessedSketch,ClassMember,String,boolean,boolean) definedIn3rdPartyClass(PreprocessedSketch,ClassMember,String) findClosestNode(int,ASTNode) findClosestNode(int,ASTNode) ClassMember.ClassMember(PreprocessedSketch,ASTNode) extracTypeInfo2(ASTNode) preparePredictions(PreprocessedSketch,String,int) preparePredictions(PreprocessedSketch,String,int) preparePredictions(PreprocessedSketch,String,int) preparePredictions(PreprocessedSketch,String,int) preparePredictions(PreprocessedSketch,String,int)",,java.lang.Class+getName() java.lang.Object+getClass() java.lang.Object+getClass() java.lang.Class+getName() java.lang.String+lastIndexOf(String) java.lang.String+lastIndexOf(String) java.lang.String+substring(int) java.lang.String+substring(int) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.AbstractTypeDeclaration+getName() org.eclipse.jdt.core.dom.AbstractTypeDeclaration+getName() org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.MethodDeclaration+getName() org.eclipse.jdt.core.dom.MethodDeclaration+getName() org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.MethodInvocation+getName() org.eclipse.jdt.core.dom.MethodInvocation+getName() org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.VariableDeclaration+getName() org.eclipse.jdt.core.dom.VariableDeclaration+getName() org.eclipse.jdt.core.dom.SingleVariableDeclaration+getType() org.eclipse.jdt.core.dom.SingleVariableDeclaration+getType() org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.Name+getFullyQualifiedName() org.eclipse.jdt.core.dom.Name+getFullyQualifiedName() org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.ASTNode+toString() java.lang.String+startsWith(String) java.lang.String+startsWith(String) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.ASTNode+toString() java.lang.String+endsWith(String) java.lang.String+endsWith(String) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.ASTNode+getStartPosition() org.eclipse.jdt.core.dom.ASTNode+getStartPosition() org.eclipse.jdt.core.dom.ASTNode+getStartPosition() org.eclipse.jdt.core.dom.ASTNode+getStartPosition() org.eclipse.jdt.core.dom.ASTNode+getLength() org.eclipse.jdt.core.dom.ASTNode+getLength() org.eclipse.jdt.core.dom.CompilationUnit+getLineNumber(int) org.eclipse.jdt.core.dom.ASTNode+getRoot() org.eclipse.jdt.core.dom.ASTNode+getRoot() org.eclipse.jdt.core.dom.CompilationUnit+getLineNumber(int) org.eclipse.jdt.core.dom.ASTNode+getStartPosition() org.eclipse.jdt.core.dom.ASTNode+getStartPosition(),,1884,45,12,,"static protected String getNodeAsString(ASTNode node) {
    if (node == null)
      return ""NULL"";
    String className = node.getClass().getName();
    int index = className.lastIndexOf(""."");
    if (index > 0)
      className = className.substring(index + 1);

    // if(node instanceof BodyDeclaration)
    // return className;

    String value = className;

    if (node instanceof TypeDeclaration)
      value = ((TypeDeclaration) node).getName().toString() + "" | "" + className;
    else if (node instanceof MethodDeclaration)
      value = ((MethodDeclaration) node).getName().toString() + "" | ""
          + className;
    else if (node instanceof MethodInvocation)
      value = ((MethodInvocation) node).getName().toString() + "" | ""
          + className;
    else if (node instanceof FieldDeclaration)
      value = node.toString() + "" FldDecl | "";
    else if (node instanceof SingleVariableDeclaration)
      value = ((SingleVariableDeclaration) node).getName() + "" - ""
          + ((SingleVariableDeclaration) node).getType() + "" | SVD "";
    else if (node instanceof ExpressionStatement)
      value = node.toString() + className;
    else if (node instanceof SimpleName)
      value = ((SimpleName) node).getFullyQualifiedName() + "" | "" + className;
    else if (node instanceof QualifiedName)
      value = node.toString() + "" | "" + className;
    else if(node instanceof FieldAccess)
      value = node.toString() + "" | "";
    else if (className.startsWith(""Variable""))
      value = node.toString() + "" | "" + className;
    else if (className.endsWith(""Type""))
      value = node.toString() + "" | "" + className;
    value += "" ["" + node.getStartPosition() + "",""
        + (node.getStartPosition() + node.getLength()) + ""]"";
    value += "" Line: ""
        + ((CompilationUnit) node.getRoot()).getLineNumber(node
            .getStartPosition());
    return value;
  }",False,False,"The function of the given method is to convert an ASTNode object into a string representation. It checks the type of the node and appends relevant information to the string, including the class name, name of the node (if applicable), and the start position and line number of the node.","The `getNodeAsString` method takes an `ASTNode` as input and returns a string representation of the node. It checks the type of the node and appends additional information based on the node's type, such as the name of a method or variable, and its position in the code."
40,log(Object),log object ,Method,"checkForTypes(ASTNode) resolveExpression(ASTNode,ASTNode,boolean) resolveExpression(ASTNode,ASTNode,boolean) resolveExpression(ASTNode,ASTNode,boolean) resolveExpression(ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) getChildExpression(ASTNode) getParentExpression(ASTNode) getMembersForType(PreprocessedSketch,String,String,boolean,boolean) getMembersForType(PreprocessedSketch,String,String,boolean,boolean) getMembersForType(PreprocessedSketch,ClassMember,String,boolean,boolean) getMembersForType(PreprocessedSketch,ClassMember,String,boolean,boolean) getMembersForType(PreprocessedSketch,ClassMember,String,boolean,boolean) getMembersForType(PreprocessedSketch,ClassMember,String,boolean,boolean) findClassIfExists(PreprocessedSketch,String) definedIn3rdPartyClass(PreprocessedSketch,String,String) definedIn3rdPartyClass(PreprocessedSketch,ClassMember,String) definedIn3rdPartyClass(PreprocessedSketch,ClassMember,String) definedIn3rdPartyClass(PreprocessedSketch,ClassMember,String) findClosestNode(int,ASTNode) findClosestNode(int,ASTNode) findClosestNode(int,ASTNode) findClosestNode(int,ASTNode) findClosestNode(int,ASTNode) extracTypeInfo(ASTNode) extracTypeInfo(ASTNode) extracTypeInfo2(ASTNode) definedIn(ASTNode,String,ArrayList<Integer>) preparePredictions(PreprocessedSketch,String,int) preparePredictions(PreprocessedSketch,String,int) preparePredictions(PreprocessedSketch,String,int) preparePredictions(PreprocessedSketch,String,int) preparePredictions(PreprocessedSketch,String,int) preparePredictions(PreprocessedSketch,String,int) preparePredictions(PreprocessedSketch,String,int) preparePredictions(PreprocessedSketch,String,int) preparePredictions(PreprocessedSketch,String,int) preparePredictions(PreprocessedSketch,String,int) preparePredictions(PreprocessedSketch,String,int) preparePredictions(PreprocessedSketch,String,int) filterPredictions(List<CompletionCandidate>) filterPredictions(List<CompletionCandidate>)",,processing.app.Messages+log(String) processing.app.Messages+log(String) java.lang.Object+toString() java.lang.Object+toString(),,107,3,10,,"static private void log(Object object) {
    Messages.log(object == null ? ""null"" : object.toString());
  }",False,False,"This method logs the given object by converting it to a string and passing it to the log method in the Messages class. If the object is null, it logs the string ""null"".","The code defines a static method called ""log"" that takes an object as a parameter. It checks if the object is null and logs ""null"" if it is, otherwise it logs the object's string representation using the Messages.log() method."
41,"trimCandidates(String,List<CompletionCandidate>)",trim candidates new word candidates ,Method,"preparePredictions(PreprocessedSketch,String,int) preparePredictions(PreprocessedSketch,String,int)",,java.lang.String+toLowerCase() java.lang.String+toLowerCase() java.lang.String+startsWith(String) java.lang.String+toLowerCase() processing.mode.java.pdex.CompletionCandidate+getNoHtmlLabel() processing.mode.java.pdex.CompletionCandidate+getNoHtmlLabel() java.lang.String+toLowerCase() java.lang.String+startsWith(String) java.util.ArrayList+add(E) java.util.ArrayList+add(E),,411,10,12,,"protected static List<CompletionCandidate> trimCandidates(String newWord, List<CompletionCandidate> candidates) {
    ArrayList<CompletionCandidate> newCandidate = new ArrayList<>();
    newWord = newWord.toLowerCase();
    for (CompletionCandidate comp : candidates) {
      if(comp.getNoHtmlLabel().toLowerCase().startsWith(newWord)){
        newCandidate.add(comp);
      }
    }
    return newCandidate;
  }",False,False,This method takes a new word and a list of completion candidates as input. It creates a new list of completion candidates and adds only those candidates whose label (with HTML removed) starts with the new word (case-insensitive). The method then returns the new list of candidates.,"This code defines a method called ""trimCandidates"" that takes a string and a list of completion candidates as input. It creates a new list and populates it with candidates whose labels, after removing HTML tags and converting to lowercase, start with the given string. The method then returns the new list of filtered candidates."
42,candidates,candidates ,Field,,,,,47,1,4,,protected List<CompletionCandidate> candidates;,False,False,,
43,lastPredictedPhrase,last predicted phrase ,Field,,,,,43,1,4,,"protected String lastPredictedPhrase = "" "";",False,False,,
44,"preparePredictions(PreprocessedSketch,String,int)",prepare predictions ps pde phrase line number the main function that calculates possible code completion candidates param pde phrase param line param line start non ws offset ,Method,,processing.mode.java.pdex.JavaTextArea+fetchPhrase(),"processing.app.Messages+log(String) processing.app.Messages+log(String) java.util.List+get(int) org.eclipse.jdt.core.dom.CompilationUnit+types() org.eclipse.jdt.core.dom.CompilationUnit+types() java.util.List+get(int) processing.mode.java.pdex.TextTransform+TextTransform(CharSequence) processing.mode.java.pdex.TextTransform+addAll(Collection<Edit>) processing.mode.java.pdex.TextTransform+addAll(Collection<Edit>) processing.mode.java.pdex.SourceUtils+replaceTypeConstructors(CharSequence) processing.mode.java.pdex.SourceUtils+replaceTypeConstructors(CharSequence) processing.mode.java.pdex.TextTransform+addAll(Collection<Edit>) processing.mode.java.pdex.TextTransform+addAll(Collection<Edit>) processing.mode.java.pdex.SourceUtils+replaceHexLiterals(CharSequence) processing.mode.java.pdex.SourceUtils+replaceHexLiterals(CharSequence) processing.mode.java.pdex.TextTransform+addAll(Collection<Edit>) processing.mode.java.pdex.TextTransform+addAll(Collection<Edit>) processing.mode.java.pdex.SourceUtils+replaceColorRegex(CharSequence) processing.mode.java.pdex.SourceUtils+replaceColorRegex(CharSequence) processing.mode.java.pdex.TextTransform+addAll(Collection<Edit>) processing.mode.java.pdex.TextTransform+addAll(Collection<Edit>) processing.mode.java.pdex.SourceUtils+fixFloatsRegex(CharSequence) processing.mode.java.pdex.SourceUtils+fixFloatsRegex(CharSequence) processing.mode.java.pdex.TextTransform+apply() processing.mode.java.pdex.TextTransform+apply() java.lang.String+endsWith(String) java.lang.String+endsWith(String) java.lang.String+substring(int,int) java.lang.String+substring(int,int) java.lang.String+length() java.lang.String+length() java.lang.String+length() java.lang.String+length() java.lang.String+length() java.lang.String+length() java.lang.String+startsWith(String) java.lang.String+startsWith(String) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) java.lang.String+contains(CharSequence) java.lang.String+contains(CharSequence) java.lang.String+lastIndexOf(int) java.lang.String+lastIndexOf(int) processing.mode.java.pdex.ASTGenerator+trimCandidates(String,List<CompletionCandidate>) processing.mode.java.pdex.ASTGenerator+trimCandidates(String,List<CompletionCandidate>) java.lang.String+substring(int) java.lang.String+substring(int) processing.mode.java.pdex.ASTGenerator+trimCandidates(String,List<CompletionCandidate>) processing.mode.java.pdex.ASTGenerator+trimCandidates(String,List<CompletionCandidate>) org.eclipse.jdt.core.dom.ASTParser+newParser(int) org.eclipse.jdt.core.dom.ASTParser+newParser(int) org.eclipse.jdt.core.dom.ASTParser+setKind(int) org.eclipse.jdt.core.dom.ASTParser+setKind(int) org.eclipse.jdt.core.dom.ASTParser+setSource(char[]) org.eclipse.jdt.core.dom.ASTParser+setSource(char[]) java.lang.String+toCharArray() java.lang.String+toCharArray() org.eclipse.jdt.core.dom.ASTParser+createAST(IProgressMonitor) org.eclipse.jdt.core.dom.ASTParser+createAST(IProgressMonitor) processing.app.Messages+loge(String) processing.app.Messages+loge(String) java.lang.Class+getSimpleName() java.lang.Object+getClass() java.lang.Object+getClass() java.lang.Class+getSimpleName() processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) org.eclipse.jdt.core.dom.MethodInvocation+getName() org.eclipse.jdt.core.dom.MethodInvocation+getName() org.eclipse.jdt.core.dom.MethodInvocation+getExpression() org.eclipse.jdt.core.dom.MethodInvocation+getExpression() java.util.List+size() org.eclipse.jdt.core.dom.MethodInvocation+typeArguments() org.eclipse.jdt.core.dom.MethodInvocation+typeArguments() java.util.List+size() processing.mode.java.pdex.ASTGenerator+findClosestNode(int,ASTNode) processing.mode.java.pdex.ASTGenerator+findClosestNode(int,ASTNode) processing.app.Messages+loge(String) processing.app.Messages+loge(String) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.app.Messages+loge(String) processing.app.Messages+loge(String) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) org.eclipse.jdt.core.dom.SimpleType+getName() org.eclipse.jdt.core.dom.SimpleType+getName() processing.mode.java.pdex.ASTGenerator+getMembersForType(PreprocessedSketch,String,String,boolean,boolean) processing.mode.java.pdex.ASTGenerator+getMembersForType(PreprocessedSketch,String,String,boolean,boolean) org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.SimpleType+getName() org.eclipse.jdt.core.dom.SimpleType+getName() org.eclipse.jdt.core.dom.ASTNode+toString() java.util.List+add(E) java.util.List+add(E) org.eclipse.jdt.core.dom.ASTNode+structuralPropertiesForType() org.eclipse.jdt.core.dom.ASTNode+structuralPropertiesForType() org.eclipse.jdt.core.dom.StructuralPropertyDescriptor+isChildListProperty() org.eclipse.jdt.core.dom.StructuralPropertyDescriptor+isChildListProperty() org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) processing.mode.java.pdex.ASTGenerator+checkForTypes(ASTNode) processing.mode.java.pdex.ASTGenerator+checkForTypes(ASTNode) java.lang.String+startsWith(String) java.lang.String+toLowerCase() processing.mode.java.pdex.CompletionCandidate+getElementName() processing.mode.java.pdex.CompletionCandidate+getElementName() java.lang.String+toLowerCase() java.lang.String+startsWith(String) java.lang.String+toLowerCase() java.lang.String+toLowerCase() java.util.List+add(E) java.util.List+add(E) org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) processing.mode.java.pdex.ASTGenerator+checkForTypes(ASTNode) processing.mode.java.pdex.ASTGenerator+checkForTypes(ASTNode) java.lang.String+startsWith(String) java.lang.String+toLowerCase() processing.mode.java.pdex.CompletionCandidate+getElementName() processing.mode.java.pdex.CompletionCandidate+getElementName() java.lang.String+toLowerCase() java.lang.String+startsWith(String) java.lang.String+toLowerCase() java.lang.String+toLowerCase() java.util.List+add(E) java.util.List+add(E) org.eclipse.jdt.core.dom.ASTNode+getParent() org.eclipse.jdt.core.dom.ASTNode+getParent() processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) com.google.classpath.RegExpResourceFilter+RegExpResourceFilter(Pattern,Pattern) java.util.regex.Pattern+compile(String) java.util.regex.Pattern+compile(String) java.util.regex.Pattern+compile(String,int) java.util.regex.Pattern+compile(String,int) com.google.classpath.ClassPath+findResources(String,ResourceFilter) com.google.classpath.ClassPath+findResources(String,ResourceFilter) java.lang.String+replace(char,char) java.lang.String+replace(char,char) java.lang.String+substring(int,int) java.lang.String+substring(int,int) java.lang.String+length() java.lang.String+length() java.lang.String+lastIndexOf(int) java.lang.String+lastIndexOf(int) processing.mode.java.pdex.ErrorCheckerService+ignorableSuggestionImport(PreprocessedSketch,String) processing.mode.java.pdex.ErrorCheckerService+ignorableSuggestionImport(PreprocessedSketch,String) java.lang.String+substring(int) java.lang.String+substring(int) java.lang.String+substring(int,int) java.lang.String+substring(int,int) java.util.List+add(E) java.util.List+add(E) processing.mode.java.pdex.CompletionCandidate+CompletionCandidate(String,String,String,int) processing.app.Messages+loge(String) processing.app.Messages+loge(String) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+getChildExpression(ASTNode) processing.mode.java.pdex.ASTGenerator+getChildExpression(ASTNode) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+getParentExpression(ASTNode) processing.mode.java.pdex.ASTGenerator+getParentExpression(ASTNode) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.mode.java.pdex.ASTGenerator+getParentExpression(ASTNode) processing.mode.java.pdex.ASTGenerator+getParentExpression(ASTNode) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.mode.java.pdex.ASTGenerator+resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) processing.mode.java.pdex.ASTGenerator+resolveExpression3rdParty(PreprocessedSketch,ASTNode,ASTNode,boolean) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) java.lang.Class+isArray() java.lang.Class+isArray() org.eclipse.jdt.core.dom.ASTNode+getNodeType() org.eclipse.jdt.core.dom.ASTNode+getNodeType() processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator.ClassMember+toString() processing.mode.java.pdex.ASTGenerator.ClassMember+toString() org.eclipse.jdt.core.dom.ASTNode+toString() org.eclipse.jdt.core.dom.ASTNode+toString() processing.mode.java.pdex.ASTGenerator+getMembersForType(PreprocessedSketch,ClassMember,String,boolean,boolean) processing.mode.java.pdex.ASTGenerator+getMembersForType(PreprocessedSketch,ClassMember,String,boolean,boolean)",processing.mode.java.pdex.PreprocessedSketch+compilationUnit processing.mode.java.pdex.ASTGenerator+lastPredictedPhrase processing.mode.java.pdex.ASTGenerator+lastPredictedPhrase processing.mode.java.pdex.ASTGenerator+lastPredictedPhrase processing.mode.java.pdex.ASTGenerator+candidates processing.mode.java.pdex.ASTGenerator+candidates processing.mode.java.pdex.ASTGenerator+candidates processing.mode.java.pdex.ASTGenerator+candidates processing.mode.java.pdex.ASTGenerator+lastPredictedPhrase processing.mode.java.pdex.ASTGenerator+candidates org.eclipse.jdt.core.dom.AST+JLS8 org.eclipse.jdt.core.dom.ASTParser+K_EXPRESSION processing.mode.java.pdex.ASTGenerator+candidates processing.mode.java.pdex.ASTGenerator+lastPredictedPhrase org.eclipse.jdt.core.dom.TypeDeclaration+SUPERCLASS_TYPE_PROPERTY org.eclipse.jdt.core.dom.TypeDeclaration+SUPERCLASS_TYPE_PROPERTY processing.mode.java.pdex.ASTGenerator+candidates processing.mode.java.pdex.ASTGenerator+candidates processing.mode.java.pdex.ASTGenerator+candidates processing.mode.java.pdex.PreprocessedSketch+classPath java.util.regex.Pattern+CASE_INSENSITIVE processing.mode.java.pdex.ASTGenerator+candidates processing.mode.java.pdex.CompletionCandidate+PREDEF_CLASS processing.mode.java.pdex.ASTGenerator.ClassMember+thisclass processing.mode.java.pdex.ASTGenerator.ClassMember+thisclass processing.mode.java.pdex.ASTGenerator.ClassMember+astNode processing.mode.java.pdex.ASTGenerator.ClassMember+astNode org.eclipse.jdt.core.dom.ASTNode+SIMPLE_TYPE processing.mode.java.pdex.ASTGenerator.ClassMember+method processing.mode.java.pdex.ASTGenerator+candidates processing.mode.java.pdex.ASTGenerator+candidates,8787,203,1,"/** 
 * The main function that calculates possible code completion candidates
 * @param pdePhrase
 * @param line
 * @param lineStartNonWSOffset
 */
","/**
   * The main function that calculates possible code completion candidates
   *
   * @param pdePhrase
   * @param line
   * @param lineStartNonWSOffset
   */
  public List<CompletionCandidate> preparePredictions(final PreprocessedSketch ps,
                                                      final String pdePhrase,
                                                      final int lineNumber) {
    Messages.log(""* preparePredictions"");

    ASTNode astRootNode = (ASTNode) ps.compilationUnit.types().get(0);

    // If the parsed code contains pde enhancements, take 'em out.
    // TODO: test this
    TextTransform transform = new TextTransform(pdePhrase);
    transform.addAll(SourceUtils.replaceTypeConstructors(pdePhrase));
    transform.addAll(SourceUtils.replaceHexLiterals(pdePhrase));
    transform.addAll(SourceUtils.replaceColorRegex(pdePhrase));
    transform.addAll(SourceUtils.fixFloatsRegex(pdePhrase));
    String phrase = transform.apply();

    //After typing 'arg.' all members of arg type are to be listed. This one is a flag for it
    boolean noCompare = phrase.endsWith(""."");

    if (noCompare) {
      phrase = phrase.substring(0, phrase.length() - 1);
    }

    boolean incremental = !noCompare &&
        phrase.length() > lastPredictedPhrase.length() &&
        phrase.startsWith(lastPredictedPhrase);


    if (incremental) {
      log(pdePhrase + "" starts with "" + lastPredictedPhrase);
      log(""Don't recalc"");

      if (phrase.contains(""."")) {
        int x = phrase.lastIndexOf('.');
        candidates = trimCandidates(phrase.substring(x + 1), candidates);
      } else {
        candidates = trimCandidates(phrase, candidates);
      }
      lastPredictedPhrase = phrase;
      return candidates;
    }

    // Ensure that we're not inside a comment. TODO: Binary search

    /*for (Comment comm : getCodeComments()) {
      int commLineNo = PdeToJavaLineNumber(compilationUnit
          .getLineNumber(comm.getStartPosition()));
      if(commLineNo == lineNumber){
        log(""Found a comment line "" + comm);
        log(""Comment LSO ""
            + javaCodeOffsetToLineStartOffset(compilationUnit
          .getLineNumber(comm.getStartPosition()),
                                              comm.getStartPosition()));
        break;
      }
    }*/

    // Now parse the expression into an ASTNode object
    ASTNode nearestNode;
    ASTParser parser = ASTParser.newParser(AST.JLS8);
    parser.setKind(ASTParser.K_EXPRESSION);
    parser.setSource(phrase.toCharArray());
    ASTNode testnode = parser.createAST(null);
    //Base.loge(""PREDICTION PARSER PROBLEMS: "" + parser);
    // Find closest ASTNode of the document to this word
    Messages.loge(""Typed: "" + phrase + ""|"" + "" temp Node type: "" + testnode.getClass().getSimpleName());
    if(testnode instanceof MethodInvocation){
      MethodInvocation mi = (MethodInvocation)testnode;
      log(mi.getName() + "","" + mi.getExpression() + "","" + mi.typeArguments().size());
    }

    // find nearest ASTNode
    nearestNode = findClosestNode(lineNumber, astRootNode);
    if (nearestNode == null) {
      // Make sure nearestNode is not NULL if couldn't find a closest node
      nearestNode = astRootNode;
    }
    Messages.loge(lineNumber + "" Nearest ASTNode to PRED ""
                      + getNodeAsString(nearestNode));

    candidates = new ArrayList<>();
    lastPredictedPhrase = phrase;
    // Determine the expression typed

    if (testnode instanceof SimpleName && !noCompare) {
      Messages.loge(""One word expression "" + getNodeAsString(testnode));
      //==> Simple one word exprssion - so is just an identifier

      // Bottom up traversal of the AST to look for possible definitions at
      // higher levels.
      //nearestNode = nearestNode.getParent();
      while (nearestNode != null) {
        // If the current class has a super class, look inside it for
        // definitions.
        if (nearestNode instanceof TypeDeclaration) {
          TypeDeclaration td = (TypeDeclaration) nearestNode;
          if (td.getStructuralProperty(TypeDeclaration.SUPERCLASS_TYPE_PROPERTY) != null) {
            SimpleType st = (SimpleType) td.getStructuralProperty(TypeDeclaration.SUPERCLASS_TYPE_PROPERTY);
            log(""Superclass "" + st.getName());
            ArrayList<CompletionCandidate> tempCandidates =
                getMembersForType(ps, st.getName().toString(), phrase, false, false);
            for (CompletionCandidate can : tempCandidates) {
              candidates.add(can);
            }
            //findDeclaration(st.getName())
          }
        }
        List<StructuralPropertyDescriptor> sprops =
            nearestNode.structuralPropertiesForType();
        for (StructuralPropertyDescriptor sprop : sprops) {
          ASTNode cnode;
          if (!sprop.isChildListProperty()) {
            if (nearestNode.getStructuralProperty(sprop) instanceof ASTNode) {
              cnode = (ASTNode) nearestNode.getStructuralProperty(sprop);
              CompletionCandidate[] types = checkForTypes(cnode);
              if (types != null) {
                for (CompletionCandidate type : types) {
                  if (type.getElementName().toLowerCase().startsWith(phrase.toLowerCase()))
                    candidates.add(type);
                }
              }
            }
          } else {
            // Childlist prop
            List<ASTNode> nodelist =
                (List<ASTNode>) nearestNode.getStructuralProperty(sprop);
            for (ASTNode clnode : nodelist) {
              CompletionCandidate[] types = checkForTypes(clnode);
              if (types != null) {
                for (CompletionCandidate type : types) {
                  if (type.getElementName().toLowerCase().startsWith(phrase.toLowerCase()))
                    candidates.add(type);
                }
              }
            }
          }
        }
        nearestNode = nearestNode.getParent();
      }
      // We're seeing a simple name that's not defined locally or in
      // the parent class. So most probably a pre-defined type.
      log(""Empty can. "" + phrase);
      ClassPath classPath = ps.classPath;
      if (classPath != null) {
        RegExpResourceFilter regExpResourceFilter =
            new RegExpResourceFilter(Pattern.compile("".*""),
                                     Pattern.compile(phrase + ""[a-zA-Z_0-9]*.class"",
                                                     Pattern.CASE_INSENSITIVE));
        String[] resources = classPath.findResources("""", regExpResourceFilter);

        for (String matchedClass2 : resources) {
          matchedClass2 = matchedClass2.replace('/', '.'); //package name
          String matchedClass = matchedClass2.substring(0, matchedClass2.length() - 6);
          int d = matchedClass.lastIndexOf('.');
          if (!ErrorCheckerService.ignorableSuggestionImport(ps, matchedClass)) {
            matchedClass = matchedClass.substring(d + 1); //class name
            // display package name in grey
            String html = ""<html>"" + matchedClass + "" : <font color=#777777>"" +
                matchedClass2.substring(0, d) + ""</font></html>"";
            candidates.add(new CompletionCandidate(matchedClass, html,
                                                   matchedClass,
                                                   CompletionCandidate.PREDEF_CLASS));
          }
        }
      }
    } else {
      // ==> Complex expression of type blah.blah2().doIt,etc
      // Have to resolve it by carefully traversing AST of testNode
      Messages.loge(""Complex expression "" + getNodeAsString(testnode));
      log(""candidates empty"");
      ASTNode childExpr = getChildExpression(testnode);
      log(""Parent expression : "" + getParentExpression(testnode));
      log(""Child expression : "" + childExpr);
      if (!noCompare) {
        log(""Original testnode "" + getNodeAsString(testnode));
        testnode = getParentExpression(testnode);
        log(""Corrected testnode "" + getNodeAsString(testnode));
      }
      ClassMember expr =
          resolveExpression3rdParty(ps, nearestNode, testnode, noCompare);
      if (expr == null) {
        log(""Expr is null"");
      } else {
        boolean isArray = expr.thisclass != null && expr.thisclass.isArray();
        boolean isSimpleType = (expr.astNode != null) &&
            expr.astNode.getNodeType() == ASTNode.SIMPLE_TYPE;
        boolean isMethod = expr.method != null;
        boolean staticOnly = !isMethod && !isArray && !isSimpleType;
        log(""Expr is "" + expr.toString());
        String lookFor = (noCompare || (childExpr == null)) ?
            """" : childExpr.toString();
        candidates = getMembersForType(ps, expr, lookFor, noCompare, staticOnly);
      }
    }
    return candidates;
  }",False,False,"The function of this method is to prepare code completion candidates based on the given preprocessed sketch, PDE phrase, and line number. It performs various transformations on the PDE phrase, checks for incremental typing, ensures that the code is not inside a comment, parses the expression into an ASTNode object, finds the nearest ASTNode to the given line number, and determines the expression typed. Finally, it retrieves the completion candidates based on the expression and returns them as a list.","This code defines a method called ""preparePredictions"" that takes in a preprocessed sketch, a PDE phrase, and a line number as parameters. It calculates possible code completion candidates based on the given inputs, including parsing the expression into an ASTNode object and finding the nearest ASTNode to the given line number. The method returns a list of completion candidates."
45,filterPredictions(List<CompletionCandidate>),filter predictions candidates ,Method,,processing.mode.java.pdex.JavaTextArea+fetchPhrase(),"processing.app.Messages+log(String) processing.app.Messages+log(String) java.util.List+isEmpty() java.util.List+isEmpty() java.lang.String+equals(Object) processing.mode.java.pdex.CompletionCandidate+getElementName() java.util.List+get(int) java.util.List+get(int) processing.mode.java.pdex.CompletionCandidate+getElementName() java.lang.String+equals(Object) processing.mode.java.pdex.CompletionCandidate+getElementName() java.util.List+get(int) java.util.List+get(int) java.util.List+size() java.util.List+size() processing.mode.java.pdex.CompletionCandidate+getElementName() processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.CompletionCandidate+getElementName() java.util.List+get(int) java.util.List+get(int) processing.mode.java.pdex.CompletionCandidate+getElementName() java.util.List+size() java.util.List+size() processing.mode.java.pdex.CompletionCandidate+withRegeneratedCompString() java.util.List+get(int) java.util.List+get(int) processing.mode.java.pdex.CompletionCandidate+withRegeneratedCompString() java.util.List+set(int,E) java.util.List+set(int,E) javax.swing.DefaultListModel+addElement(E) javax.swing.DefaultListModel+addElement(E) java.util.List+size() java.util.List+size() java.lang.String+equals(Object) processing.mode.java.pdex.CompletionCandidate+getElementName() java.util.List+get(int) java.util.List+get(int) processing.mode.java.pdex.CompletionCandidate+getElementName() java.lang.String+equals(Object) processing.mode.java.pdex.CompletionCandidate+getElementName() java.util.List+get(int) java.util.List+get(int) processing.mode.java.pdex.CompletionCandidate+getElementName() processing.mode.java.pdex.CompletionCandidate+getType() java.util.List+get(int) java.util.List+get(int) processing.mode.java.pdex.CompletionCandidate+getType() processing.mode.java.pdex.CompletionCandidate+getType() java.util.List+get(int) java.util.List+get(int) processing.mode.java.pdex.CompletionCandidate+getType() java.util.List+get(int) java.util.List+get(int) processing.mode.java.pdex.CompletionCandidate+getLabel() processing.mode.java.pdex.CompletionCandidate+getLabel() java.lang.String+lastIndexOf(int) java.lang.String+lastIndexOf(int) processing.mode.java.pdex.CompletionCandidate+getType() java.util.List+get(int) java.util.List+get(int) processing.mode.java.pdex.CompletionCandidate+getType() java.lang.String+contains(CharSequence) processing.mode.java.pdex.CompletionCandidate+getLabel() processing.mode.java.pdex.CompletionCandidate+getLabel() java.lang.String+contains(CharSequence) processing.mode.java.pdex.CompletionCandidate+getElementName() processing.mode.java.pdex.CompletionCandidate+getElementName() java.lang.String+substring(int) java.lang.String+substring(int) processing.mode.java.pdex.CompletionCandidate+getElementName() processing.mode.java.pdex.CompletionCandidate+getElementName() java.lang.String+substring(int) java.lang.String+substring(int) processing.mode.java.pdex.CompletionCandidate+getElementName() processing.mode.java.pdex.CompletionCandidate+getElementName() java.util.List+set(int,E) java.util.List+set(int,E) processing.mode.java.pdex.CompletionCandidate+withLabelAndCompString(String,String) processing.mode.java.pdex.CompletionCandidate+withLabelAndCompString(String,String) javax.swing.DefaultListModel+addElement(E) javax.swing.DefaultListModel+addElement(E) java.util.List+get(int) java.util.List+get(int) processing.mode.java.pdex.ASTGenerator+log(Object) processing.mode.java.pdex.ASTGenerator+log(Object)",processing.mode.java.pdex.CompletionCandidate+LOCAL_METHOD processing.mode.java.pdex.CompletionCandidate+PREDEF_METHOD processing.mode.java.pdex.CompletionCandidate+PREDEF_METHOD,2105,46,12,,"protected static DefaultListModel<CompletionCandidate> filterPredictions(List<CompletionCandidate> candidates) {
    Messages.log(""* filterPredictions"");
    DefaultListModel<CompletionCandidate> defListModel = new DefaultListModel<>();
    if (candidates.isEmpty())
      return defListModel;
    // check if first & last CompCandidate are the same methods, only then show all overloaded methods
    if (candidates.get(0).getElementName()
        .equals(candidates.get(candidates.size() - 1).getElementName())) {
      log(""All CC are methods only: "" + candidates.get(0).getElementName());
      for (int i = 0; i < candidates.size(); i++) {
        CompletionCandidate cc = candidates.get(i).withRegeneratedCompString();
        candidates.set(i, cc);
        defListModel.addElement(cc);
      }
    }
    else {
      boolean ignoredSome = false;
      for (int i = 0; i < candidates.size(); i++) {
        if(i > 0 && (candidates.get(i).getElementName()
            .equals(candidates.get(i - 1).getElementName()))){
          if (candidates.get(i).getType() == CompletionCandidate.LOCAL_METHOD
              || candidates.get(i).getType() == CompletionCandidate.PREDEF_METHOD) {
            CompletionCandidate cc = candidates.get(i - 1);
            String label = cc.getLabel();
            int x = label.lastIndexOf(')');
            String newLabel;
            if (candidates.get(i).getType() == CompletionCandidate.PREDEF_METHOD) {
              newLabel = (cc.getLabel().contains(""<html>"") ? ""<html>"" : """")
                  + cc.getElementName() + ""(...)"" + label.substring(x + 1);
            } else {
              newLabel = cc.getElementName() + ""(...)"" + label.substring(x + 1);
            }
            String newCompString = cc.getElementName() + ""("";
            candidates.set(i - 1, cc.withLabelAndCompString(newLabel, newCompString));
            ignoredSome = true;
            continue;
          }
        }
        defListModel.addElement(candidates.get(i));
      }
      if (ignoredSome) {
        log(""Some suggestions hidden"");
      }
    }
    return defListModel;
  }",False,False,"The function filters a list of completion candidates based on certain conditions. If the first and last candidates have the same element name, it modifies the candidates and adds them to a default list model. Otherwise, it checks for duplicate element names and modifies the label and completion string of the previous candidate if it is a method. Finally, it returns the modified default list model.","The code defines a method called `filterPredictions` that takes a list of `CompletionCandidate` objects as input and returns a `DefaultListModel` object. It filters the input list based on certain conditions and adds the filtered candidates to the `DefaultListModel` object, which is then returned."
46,jdocMap,jdoc map ,Field,,,,,42,1,4,,"protected TreeMap<String, String> jdocMap;",False,False,,
47,loadJavaDoc(),load java doc ,Method,,,java.lang.Thread+start() java.lang.Thread+Thread(Runnable) +() +run(),processing.mode.java.pdex.ASTGenerator+jdocMap,435,16,4,,"protected void loadJavaDoc() {
    jdocMap = new TreeMap<>();

    // presently loading only p5 reference for PApplet
    // TODO: use something like ExecutorService here [jv]
    new Thread(new Runnable() {
      @Override
      public void run() {
        try {
          loadJavaDoc(jdocMap, editor.getMode().getReferenceFolder());
        } catch (Exception e) {
          e.printStackTrace();
        }
      }
    }).start();
  }",False,False,The function of the given method is to load the JavaDoc for a specific reference folder in a separate thread using a TreeMap data structure.,"The code defines a protected method called `loadJavaDoc()` that loads a JavaDoc map in a separate thread. The method initializes a TreeMap, creates a new thread, and within the thread, it calls the `loadJavaDoc()` method passing the TreeMap and a reference folder obtained from the editor's mode. Any exceptions that occur during the loading process are printed to the console."
48,"loadJavaDoc(TreeMap<String,String>,File)",load java doc jdoc map reference folder ,Method,,,+() +accept(File),,1468,38,8,,"static void loadJavaDoc(TreeMap<String, String> jdocMap,
                          File referenceFolder) throws IOException {
    Document doc;

    FileFilter fileFilter = new FileFilter() {
      @Override
      public boolean accept(File file) {
        if(!file.getName().endsWith(""_.html""))
          return false;
        int k = 0;
        for (int i = 0; i < file.getName().length(); i++) {
          if(file.getName().charAt(i)== '_')
            k++;
          if(k > 1)
            return false;
        }
        return true;
      }
    };

    for (File docFile : referenceFolder.listFiles(fileFilter)) {
      doc = Jsoup.parse(docFile, null);
      Elements elm = doc.getElementsByClass(""ref-item"");
      String msg = """";
      String methodName = docFile.getName().substring(0, docFile.getName().indexOf('_'));
      //System.out.println(methodName);
      for (org.jsoup.nodes.Element ele : elm) {
        msg = ""<html><body> <strong><div style=\""width: 300px; text-justification: justify;\""></strong><table cellpadding=\""0\"" cellspacing=\""0\"" border=\""0\"" class=\""ref-item\"">""
            + ele.html() + ""</table></div></html></body></html>"";
        //mat.replaceAll("""");
        msg = msg.replaceAll(""img src=\"""", ""img src=\""""
            + referenceFolder.toURI().toURL().toString() + ""/"");
        //System.out.println(ele.text());
      }
      jdocMap.put(methodName, msg);
    }
    //System.out.println(""JDoc loaded "" + jdocMap.size());
  }",False,False,This method loads JavaDoc files from a specified folder into a TreeMap. It filters the files based on their names and parses them using Jsoup. It then extracts relevant information from the parsed files and stores it in the TreeMap.,"The code defines a method called `loadJavaDoc` that takes a `TreeMap` and a `File` as parameters. It reads HTML files from the specified `referenceFolder`, parses them using Jsoup, extracts specific elements with the class ""ref-item"", and stores them in the `jdocMap` with the method name as the key."
49,updateDebugTree(PreprocessedSketch),update debug tree ps ,Method,,,"java.util.List+isEmpty() org.eclipse.jdt.core.dom.CompilationUnit+types() org.eclipse.jdt.core.dom.CompilationUnit+types() java.util.List+isEmpty() processing.app.Messages+loge(String) processing.app.Messages+loge(String) java.util.List+get(int) org.eclipse.jdt.core.dom.CompilationUnit+types() org.eclipse.jdt.core.dom.CompilationUnit+types() java.util.List+get(int) javax.swing.tree.DefaultMutableTreeNode+DefaultMutableTreeNode(Object) processing.mode.java.pdex.ASTGenerator+visitRecur(ASTNode,DefaultMutableTreeNode) processing.mode.java.pdex.ASTGenerator+visitRecur(ASTNode,DefaultMutableTreeNode) java.awt.EventQueue+invokeLater(Runnable) java.awt.EventQueue+invokeLater(Runnable) processing.mode.java.pdex.ASTGenerator.GUI+updateDebugTree(DefaultMutableTreeNode) processing.mode.java.pdex.ASTGenerator.GUI+updateDebugTree(DefaultMutableTreeNode)",processing.mode.java.pdex.PreprocessedSketch+compilationUnit processing.mode.java.pdex.ASTGenerator+gui,1080,32,4,,"protected void updateDebugTree(PreprocessedSketch ps) {
    CompilationUnit cu = ps.compilationUnit;
    if (cu.types().isEmpty()){
      Messages.loge(""No Type found in CU"");
      return;
    }

    ASTNode type0 = (ASTNode) cu.types().get(0);
    DefaultMutableTreeNode codeTree = new DefaultMutableTreeNode(type0);
    visitRecur(type0, codeTree);
    EventQueue.invokeLater(() -> gui.updateDebugTree(codeTree));

    // TODO: figure out what this is
//    if (codeTree != null) {
//      if (!frameAutoComp.isVisible()) {
//
//        frameAutoComp.setVisible(true);
//
//      }
//      if (!frmJavaDoc.isVisible()) {
//        long t = System.currentTimeMillis();
//        loadJavaDoc();
//        log(""Time taken: ""
//            + (System.currentTimeMillis() - t));
//        frmJavaDoc.setBounds(new Rectangle(ecs.getEditor()
//            .getX() + ecs.getEditor().getWidth(),
//                                           ecs.getEditor()
//                                               .getY(), 450, 600));
//        frmJavaDoc.setVisible(true);
//      }
//    }
  }",True,True,"The function of this method is to update a debug tree based on a preprocessed sketch. It creates a code tree, visits the nodes of the code tree, and then updates the debug tree in the GUI.","The `updateDebugTree` method takes a `PreprocessedSketch` object as input and updates a debug tree in the GUI. It first checks if the compilation unit has any types, logs an error message if not, and returns. Then, it creates a tree node for the first type in the compilation unit, visits the type and its children recursively to populate the tree, and finally updates the debug tree in the GUI using the `gui.updateDebugTree` method."
50,"visitRecur(ASTNode,DefaultMutableTreeNode)",visit recur node tnode generates ast swing component param node param tnode ,Method,"updateDebugTree(PreprocessedSketch) visitRecur(ASTNode,DefaultMutableTreeNode) visitRecur(ASTNode,DefaultMutableTreeNode) visitRecur(ASTNode,DefaultMutableTreeNode)",,"java.util.List+iterator() org.eclipse.jdt.core.dom.ASTNode+structuralPropertiesForType() org.eclipse.jdt.core.dom.ASTNode+structuralPropertiesForType() java.util.List+iterator() java.util.Iterator+hasNext() java.util.Iterator+hasNext() java.util.Iterator+next() java.util.Iterator+next() org.eclipse.jdt.core.dom.StructuralPropertyDescriptor+isChildProperty() org.eclipse.jdt.core.dom.StructuralPropertyDescriptor+isChildProperty() org.eclipse.jdt.core.dom.StructuralPropertyDescriptor+isSimpleProperty() org.eclipse.jdt.core.dom.StructuralPropertyDescriptor+isSimpleProperty() org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) processing.mode.java.pdex.ASTGenerator+isAddableASTNode(ASTNode) processing.mode.java.pdex.ASTGenerator+isAddableASTNode(ASTNode) javax.swing.tree.DefaultMutableTreeNode+DefaultMutableTreeNode(Object) org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) javax.swing.tree.DefaultMutableTreeNode+add(MutableTreeNode) javax.swing.tree.DefaultMutableTreeNode+add(MutableTreeNode) processing.mode.java.pdex.ASTGenerator+visitRecur(ASTNode,DefaultMutableTreeNode) processing.mode.java.pdex.ASTGenerator+visitRecur(ASTNode,DefaultMutableTreeNode) javax.swing.tree.DefaultMutableTreeNode+add(MutableTreeNode) javax.swing.tree.DefaultMutableTreeNode+add(MutableTreeNode) javax.swing.tree.DefaultMutableTreeNode+DefaultMutableTreeNode(Object) org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) org.eclipse.jdt.core.dom.StructuralPropertyDescriptor+isChildListProperty() org.eclipse.jdt.core.dom.StructuralPropertyDescriptor+isChildListProperty() org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) org.eclipse.jdt.core.dom.ASTNode+getStructuralProperty(StructuralPropertyDescriptor) processing.mode.java.pdex.ASTGenerator+isAddableASTNode(ASTNode) processing.mode.java.pdex.ASTGenerator+isAddableASTNode(ASTNode) javax.swing.tree.DefaultMutableTreeNode+DefaultMutableTreeNode(Object) javax.swing.tree.DefaultMutableTreeNode+add(MutableTreeNode) javax.swing.tree.DefaultMutableTreeNode+add(MutableTreeNode) processing.mode.java.pdex.ASTGenerator+visitRecur(ASTNode,DefaultMutableTreeNode) processing.mode.java.pdex.ASTGenerator+visitRecur(ASTNode,DefaultMutableTreeNode) processing.mode.java.pdex.ASTGenerator+visitRecur(ASTNode,DefaultMutableTreeNode) processing.mode.java.pdex.ASTGenerator+visitRecur(ASTNode,DefaultMutableTreeNode)",,1638,44,9,"/** 
 * Generates AST Swing component
 * @param node
 * @param tnode
 */
","/**
   * Generates AST Swing component
   * @param node
   * @param tnode
   */
  public static void visitRecur(ASTNode node, DefaultMutableTreeNode tnode) {
    Iterator<StructuralPropertyDescriptor> it =
        node.structuralPropertiesForType().iterator();
    //Base.loge(""Props of "" + node.getClass().getName());
    DefaultMutableTreeNode ctnode;
    while (it.hasNext()) {
      StructuralPropertyDescriptor prop = it.next();

      if (prop.isChildProperty() || prop.isSimpleProperty()) {
        if (node.getStructuralProperty(prop) != null) {
//          System.out
//              .println(node.getStructuralProperty(prop) + "" -> "" + (prop));
          if (node.getStructuralProperty(prop) instanceof ASTNode) {
            ASTNode cnode = (ASTNode) node.getStructuralProperty(prop);
            if (isAddableASTNode(cnode)) {
              ctnode = new DefaultMutableTreeNode(node.getStructuralProperty(prop));
              tnode.add(ctnode);
              visitRecur(cnode, ctnode);
            }
          } else {
            tnode.add(new DefaultMutableTreeNode(node
                                                     .getStructuralProperty(prop)));
          }
        }
      } else if (prop.isChildListProperty()) {
        List<ASTNode> nodelist = (List<ASTNode>)
            node.getStructuralProperty(prop);
        for (ASTNode cnode : nodelist) {
          if (isAddableASTNode(cnode)) {
            ctnode = new DefaultMutableTreeNode(cnode);
            tnode.add(ctnode);
            visitRecur(cnode, ctnode);
          } else {
            visitRecur(cnode, tnode);
          }
        }
      }
    }
  }",True,True,This method generates an Abstract Syntax Tree (AST) Swing component by recursively visiting the nodes of the AST and adding them to a DefaultMutableTreeNode.,"The given code defines a method called `visitRecur` that generates an Abstract Syntax Tree (AST) Swing component. It recursively visits the nodes of the AST and adds them to a `DefaultMutableTreeNode` object, creating a tree-like structure."
51,isAddableASTNode(ASTNode),is addable ast node node ,Method,"visitRecur(ASTNode,DefaultMutableTreeNode) visitRecur(ASTNode,DefaultMutableTreeNode)",,org.eclipse.jdt.core.dom.ASTNode+getNodeType() org.eclipse.jdt.core.dom.ASTNode+getNodeType(),,295,11,9,,"public static boolean isAddableASTNode(ASTNode node) {
    switch (node.getNodeType()) {
//    case ASTNode.STRING_LITERAL:
//    case ASTNode.NUMBER_LITERAL:
//    case ASTNode.BOOLEAN_LITERAL:
//    case ASTNode.NULL_LITERAL:
//      return false;
      default:
        return true;
    }
  }",True,True,"This method checks if an ASTNode is addable by returning true if the node's type is not a string, number, boolean, or null literal.","The given code is a method named ""isAddableASTNode"" that takes an ASTNode as input and returns a boolean value. It checks the node's type and returns true if it is any type other than STRING_LITERAL, NUMBER_LITERAL, BOOLEAN_LITERAL, or NULL_LITERAL, otherwise it returns false."
52,"handleCtrlClick(int,int)",handle ctrl click tab index offset ,Method,,processing.mode.java.pdex.JavaTextAreaPainter+handleCtrlClick(MouseEvent),"processing.app.Messages+log(String) processing.app.Messages+log(String) processing.mode.java.pdex.ErrorCheckerService+acceptWhenDone(Consumer<PreprocessedSketch>) processing.mode.java.pdex.ErrorCheckerService+acceptWhenDone(Consumer<PreprocessedSketch>) processing.mode.java.pdex.PreprocessedSketch+tabOffsetToJavaOffset(int,int) processing.mode.java.pdex.PreprocessedSketch+tabOffsetToJavaOffset(int,int) processing.mode.java.pdex.ASTGenerator+getSimpleNameAt(ASTNode,int,int) processing.mode.java.pdex.ASTGenerator+getSimpleNameAt(ASTNode,int,int) processing.app.Messages+log(String) processing.app.Messages+log(String) processing.mode.java.pdex.ASTGenerator+resolveBinding(SimpleName) processing.mode.java.pdex.ASTGenerator+resolveBinding(SimpleName) processing.app.Messages+log(String) processing.app.Messages+log(String) org.eclipse.jdt.core.dom.IBinding+getKey() org.eclipse.jdt.core.dom.IBinding+getKey() org.eclipse.jdt.core.dom.CompilationUnit+findDeclaringNode(String) org.eclipse.jdt.core.dom.CompilationUnit+findDeclaringNode(String) processing.app.Messages+log(String) processing.app.Messages+log(String) processing.mode.java.pdex.ASTGenerator+handleShowUsage(PreprocessedSketch,IBinding) processing.mode.java.pdex.ASTGenerator+handleShowUsage(PreprocessedSketch,IBinding) org.eclipse.jdt.core.dom.IBinding+getKind() org.eclipse.jdt.core.dom.IBinding+getKind() org.eclipse.jdt.core.dom.AbstractTypeDeclaration+getName() org.eclipse.jdt.core.dom.AbstractTypeDeclaration+getName() org.eclipse.jdt.core.dom.MethodDeclaration+getName() org.eclipse.jdt.core.dom.MethodDeclaration+getName() org.eclipse.jdt.core.dom.VariableDeclaration+getName() org.eclipse.jdt.core.dom.VariableDeclaration+getName() processing.app.Messages+log(String) processing.app.Messages+log(String) org.eclipse.jdt.core.dom.ASTNode+equals(Object) org.eclipse.jdt.core.dom.ASTNode+equals(Object) processing.mode.java.pdex.ASTGenerator+handleShowUsage(PreprocessedSketch,IBinding) processing.mode.java.pdex.ASTGenerator+handleShowUsage(PreprocessedSketch,IBinding) processing.app.Messages+log(String) processing.app.Messages+log(String) org.eclipse.jdt.core.dom.ASTNode+getStartPosition() org.eclipse.jdt.core.dom.ASTNode+getStartPosition() processing.mode.java.pdex.ASTGenerator+highlightNode(PreprocessedSketch,ASTNode) processing.mode.java.pdex.ASTGenerator+highlightNode(PreprocessedSketch,ASTNode)",processing.mode.java.pdex.ASTGenerator+ecs processing.mode.java.pdex.PreprocessedSketch+compilationUnit processing.mode.java.pdex.PreprocessedSketch+compilationUnit org.eclipse.jdt.core.dom.IBinding+TYPE org.eclipse.jdt.core.dom.IBinding+METHOD org.eclipse.jdt.core.dom.IBinding+VARIABLE,1561,50,1,,"public void handleCtrlClick(int tabIndex, int offset) {
    Messages.log(""* handleCtrlClick"");

    // TODO: don't run the heavy lifting on EDT

    ecs.acceptWhenDone(ps -> {
      ASTNode root = ps.compilationUnit;

      int javaOffset = ps.tabOffsetToJavaOffset(tabIndex, offset);

      SimpleName simpleName = getSimpleNameAt(root, javaOffset, javaOffset);

      if (simpleName == null) {
        Messages.log(""nothing found"");
        return;
      }

      IBinding binding = resolveBinding(simpleName);
      if (binding == null) {
        Messages.log(""binding not resolved"");
        return;
      }

      String key = binding.getKey();
      ASTNode decl = ps.compilationUnit.findDeclaringNode(key);
      if (decl == null) {
        Messages.log(""decl not found, showing usage instead"");
        handleShowUsage(ps, binding);
        return;
      }

      SimpleName declName = null;
      switch (binding.getKind()) {
        case IBinding.TYPE: declName = ((TypeDeclaration) decl).getName(); break;
        case IBinding.METHOD: declName = ((MethodDeclaration) decl).getName(); break;
        case IBinding.VARIABLE: declName = ((VariableDeclaration) decl).getName(); break;
      }
      if (declName == null) {
        Messages.log(""decl name not found "" + decl);
        return;
      }

      if (declName.equals(simpleName)) {
        handleShowUsage(ps, binding);
      } else {
        Messages.log(""found declaration, offset "" + decl.getStartPosition() + "", name: "" + declName);
        highlightNode(ps, declName);
      }
    });
  }",True,True,"The function of the given method is to handle a control click event. It performs various operations such as resolving bindings, finding declarations, and highlighting nodes based on the clicked position.","The `handleCtrlClick` method handles the logic for when a user performs a Ctrl+Click action. It resolves the binding of the clicked element, finds the declaration node, and either shows the usage or highlights the declaration depending on whether the declaration matches the clicked element. The heavy lifting is suggested to be done on a separate thread."
53,"highlightNode(PreprocessedSketch,ASTNode)",highlight node ps node ,Method,"handleCtrlClick(int,int) GUI.addDebugTreeListener()",,"processing.mode.java.pdex.PreprocessedSketch+mapJavaToSketch(ASTNode) processing.mode.java.pdex.PreprocessedSketch+mapJavaToSketch(ASTNode) java.awt.EventQueue+invokeLater(Runnable) java.awt.EventQueue+invokeLater(Runnable) processing.mode.java.JavaEditor+highlight(int,int,int) processing.mode.java.JavaEditor+highlight(int,int,int)",processing.mode.java.pdex.ASTGenerator+editor processing.mode.java.pdex.PreprocessedSketch.SketchInterval+tabIndex processing.mode.java.pdex.PreprocessedSketch.SketchInterval+startTabOffset processing.mode.java.pdex.PreprocessedSketch.SketchInterval+stopTabOffset,235,6,1,,"public void highlightNode(PreprocessedSketch ps, ASTNode node) {
    SketchInterval si = ps.mapJavaToSketch(node);
    EventQueue.invokeLater(() -> {
      editor.highlight(si.tabIndex, si.startTabOffset, si.stopTabOffset);
    });
  }",False,True,"This method highlights a specific node in a code editor. It takes a preprocessed sketch and an ASTNode as parameters, maps the node to a SketchInterval, and then uses the editor to highlight the corresponding code.","The code defines a method called ""highlightNode"" that takes a preprocessed sketch and an ASTNode as input. It maps the ASTNode to a SketchInterval using the preprocessed sketch, and then asynchronously highlights the corresponding code in an editor using the ""highlight"" method."
54,GUI,gui ,MemberClass,,,"processing.mode.java.pdex.ASTGenerator.GUI+GUI(JavaEditor,ASTGenerator) processing.mode.java.pdex.ASTGenerator+updateDebugTree(PreprocessedSketch) processing.mode.java.pdex.ASTGenerator.GUI+reloadShowUsage(PreprocessedSketch) processing.mode.java.pdex.ASTGenerator.GUI+setupGUI() processing.mode.java.pdex.ASTGenerator.GUI+setupGUI() processing.mode.java.pdex.ASTGenerator.GUI+addListeners() processing.mode.java.pdex.ASTGenerator.GUI+addListeners() processing.mode.java.pdex.ASTGenerator.GUI+setupGUI() processing.mode.java.pdex.ASTGenerator.GUI+initDebugWindow() processing.mode.java.pdex.ASTGenerator.GUI+initDebugWindow() javax.swing.JDialog+JDialog(Frame) java.awt.Dialog+setTitle(String) java.awt.Dialog+setTitle(String) javax.swing.JDialog+setDefaultCloseOperation(int) javax.swing.JDialog+setDefaultCloseOperation(int) java.awt.Dialog+setModal(boolean) java.awt.Dialog+setModal(boolean) java.awt.Dialog+setResizable(boolean) java.awt.Dialog+setResizable(boolean) java.awt.Component+addComponentListener(ComponentListener) java.awt.Component+addComponentListener(ComponentListener) +() +componentHidden(ComponentEvent) java.awt.Window+setSize(int,int) java.awt.Window+setSize(int,int) javax.swing.JDialog+setLayout(LayoutManager) javax.swing.JDialog+setLayout(LayoutManager) javax.swing.BoxLayout+BoxLayout(Container,int) javax.swing.JDialog+getContentPane() javax.swing.JDialog+getContentPane() processing.app.ui.Toolkit+setIcon(Window) processing.app.ui.Toolkit+setIcon(Window) javax.swing.JTextField+JTextField() javax.swing.JComponent+setPreferredSize(Dimension) javax.swing.JComponent+setPreferredSize(Dimension) java.awt.Dimension+Dimension(int,int) javax.swing.JLabel+JLabel() javax.swing.JLabel+setText(String) javax.swing.JLabel+setText(String) javax.swing.JPanel+JPanel() java.awt.Container+setLayout(LayoutManager) java.awt.Container+setLayout(LayoutManager) javax.swing.BoxLayout+BoxLayout(Container,int) javax.swing.JComponent+setBorder(Border) javax.swing.JComponent+setBorder(Border) javax.swing.BorderFactory+createEmptyBorder(int,int,int,int) javax.swing.BorderFactory+createEmptyBorder(int,int,int,int) java.awt.Container+add(Component) java.awt.Container+add(Component) java.awt.Container+add(Component) java.awt.Container+add(Component) javax.swing.Box+createRigidArea(Dimension) javax.swing.Box+createRigidArea(Dimension) java.awt.Dimension+Dimension(int,int) java.awt.Container+add(Component) java.awt.Container+add(Component) java.awt.Container+add(Component) java.awt.Container+add(Component) javax.swing.JButton+JButton(String) javax.swing.JButton+JButton(String) javax.swing.JPanel+JPanel() java.awt.Container+setLayout(LayoutManager) java.awt.Container+setLayout(LayoutManager) javax.swing.BoxLayout+BoxLayout(Container,int) javax.swing.JComponent+setBorder(Border) javax.swing.JComponent+setBorder(Border) javax.swing.BorderFactory+createEmptyBorder(int,int,int,int) javax.swing.BorderFactory+createEmptyBorder(int,int,int,int) java.awt.Container+add(Component) java.awt.Container+add(Component) javax.swing.Box+createHorizontalGlue() javax.swing.Box+createHorizontalGlue() java.awt.Container+add(Component) java.awt.Container+add(Component) java.awt.Container+add(Component) java.awt.Container+add(Component) javax.swing.Box+createRigidArea(Dimension) javax.swing.Box+createRigidArea(Dimension) java.awt.Dimension+Dimension(int,int) java.awt.Container+add(Component) java.awt.Container+add(Component) java.awt.Container+add(Component) java.awt.Container+add(Component) java.awt.Window+setMinimumSize(Dimension) java.awt.Window+setMinimumSize(Dimension) java.awt.Component+getSize() java.awt.Component+getSize() java.awt.Window+setLocation(int,int) java.awt.Window+setLocation(int,int) java.awt.Component+getX() java.awt.Component+getX() java.awt.Component+getWidth() java.awt.Component+getWidth() java.awt.Component+getWidth() java.awt.Component+getWidth() java.awt.Component+getY() java.awt.Component+getY() java.awt.Component+getHeight() java.awt.Component+getHeight() java.awt.Component+getHeight() java.awt.Component+getHeight() javax.swing.JDialog+JDialog(Frame) javax.swing.JDialog+setDefaultCloseOperation(int) javax.swing.JDialog+setDefaultCloseOperation(int) java.awt.Window+setAutoRequestFocus(boolean) java.awt.Window+setAutoRequestFocus(boolean) java.awt.Component+addComponentListener(ComponentListener) java.awt.Component+addComponentListener(ComponentListener) +() +componentHidden(ComponentEvent) javax.swing.JTree+setModel(TreeModel) javax.swing.JTree+setModel(TreeModel) processing.mode.java.pdex.ErrorCheckerService+unregisterDoneListener(Consumer<PreprocessedSketch>) processing.mode.java.pdex.ErrorCheckerService+unregisterDoneListener(Consumer<PreprocessedSketch>) +componentShown(ComponentEvent) processing.mode.java.pdex.ErrorCheckerService+registerDoneListener(Consumer<PreprocessedSketch>) processing.mode.java.pdex.ErrorCheckerService+registerDoneListener(Consumer<PreprocessedSketch>) java.awt.Window+setSize(int,int) java.awt.Window+setSize(int,int) processing.app.ui.Toolkit+setIcon(Window) processing.app.ui.Toolkit+setIcon(Window) javax.swing.JScrollPane+JScrollPane() javax.swing.JTree+JTree() javax.swing.JTree+getCellRenderer() javax.swing.JTree+getCellRenderer() javax.swing.tree.DefaultTreeCellRenderer+setLeafIcon(Icon) javax.swing.tree.DefaultTreeCellRenderer+setLeafIcon(Icon) javax.swing.tree.DefaultTreeCellRenderer+setClosedIcon(Icon) javax.swing.tree.DefaultTreeCellRenderer+setClosedIcon(Icon) javax.swing.tree.DefaultTreeCellRenderer+setOpenIcon(Icon) javax.swing.tree.DefaultTreeCellRenderer+setOpenIcon(Icon) javax.swing.JScrollPane+setViewportView(Component) javax.swing.JScrollPane+setViewportView(Component) java.awt.Container+add(Component) java.awt.Container+add(Component) processing.mode.java.pdex.ASTGenerator.GUI+addListeners() processing.mode.java.pdex.ASTGenerator.GUI+addDebugTreeListener() processing.mode.java.pdex.ASTGenerator.GUI+addDebugTreeListener() javax.swing.AbstractButton+addActionListener(ActionListener) javax.swing.AbstractButton+addActionListener(ActionListener) java.lang.String+length() javax.swing.text.JTextComponent+getText() javax.swing.text.JTextComponent+getText() java.lang.String+length() java.lang.String+trim() javax.swing.text.JTextComponent+getText() javax.swing.text.JTextComponent+getText() java.lang.String+trim() java.lang.String+length() java.lang.String+length() java.util.stream.IntStream+allMatch(IntPredicate) java.util.stream.IntStream+limit(long) java.lang.String+chars() java.lang.String+chars() java.util.stream.IntStream+limit(long) java.util.stream.IntStream+allMatch(IntPredicate) java.lang.Character+isUnicodeIdentifierStart(int) java.util.stream.IntStream+allMatch(IntPredicate) java.util.stream.IntStream+skip(long) java.lang.String+chars() java.lang.String+chars() java.util.stream.IntStream+skip(long) java.util.stream.IntStream+allMatch(IntPredicate) java.lang.Character+isUnicodeIdentifierPart(int) javax.swing.JOptionPane+showMessageDialog(Component,Object,String,int) javax.swing.JOptionPane+showMessageDialog(Component,Object,String,int) javax.swing.JFrame+JFrame() processing.mode.java.pdex.ASTGenerator+handleRename(PreprocessedSketch,IBinding,String) processing.mode.java.pdex.ASTGenerator+handleRename(PreprocessedSketch,IBinding,String) java.awt.Dialog+setVisible(boolean) java.awt.Dialog+setVisible(boolean) javax.swing.AbstractButton+addActionListener(ActionListener) javax.swing.AbstractButton+addActionListener(ActionListener) processing.mode.java.pdex.ASTGenerator+handleShowUsage(PreprocessedSketch,IBinding) processing.mode.java.pdex.ASTGenerator+handleShowUsage(PreprocessedSketch,IBinding) java.awt.Dialog+setVisible(boolean) java.awt.Dialog+setVisible(boolean) javax.swing.JTree+addTreeSelectionListener(TreeSelectionListener) javax.swing.JTree+addTreeSelectionListener(TreeSelectionListener) javax.swing.JTree+getLastSelectedPathComponent() javax.swing.JTree+getLastSelectedPathComponent() javax.swing.JTree+getLastSelectedPathComponent() javax.swing.JTree+getLastSelectedPathComponent() javax.swing.tree.DefaultMutableTreeNode+getUserObject() javax.swing.tree.DefaultMutableTreeNode+getUserObject() javax.swing.tree.DefaultMutableTreeNode+getUserObject() javax.swing.tree.DefaultMutableTreeNode+getUserObject() processing.mode.java.JavaEditor+highlight(int,int,int) processing.mode.java.JavaEditor+highlight(int,int,int) processing.mode.java.pdex.ASTGenerator.GUI+handleRename(PreprocessedSketch,IBinding) java.awt.Component+isVisible() java.awt.Component+isVisible() java.awt.Window+setLocation(int,int) java.awt.Window+setLocation(int,int) java.awt.Component+getX() java.awt.Component+getX() java.awt.Component+getWidth() java.awt.Component+getWidth() java.awt.Component+getWidth() java.awt.Component+getWidth() java.awt.Component+getY() java.awt.Component+getY() java.awt.Component+getHeight() java.awt.Component+getHeight() java.awt.Component+getHeight() java.awt.Component+getHeight() javax.swing.JLabel+setText(String) javax.swing.JLabel+setText(String) org.eclipse.jdt.core.dom.IBinding+getName() org.eclipse.jdt.core.dom.IBinding+getName() javax.swing.text.JTextComponent+setText(String) javax.swing.text.JTextComponent+setText(String) org.eclipse.jdt.core.dom.IBinding+getName() org.eclipse.jdt.core.dom.IBinding+getName() javax.swing.JComponent+requestFocus() javax.swing.JComponent+requestFocus() javax.swing.text.JTextComponent+selectAll() javax.swing.text.JTextComponent+selectAll() java.awt.Dialog+setVisible(boolean) java.awt.Dialog+setVisible(boolean) java.awt.Window+toFront() java.awt.Window+toFront() processing.mode.java.pdex.ASTGenerator.GUI+handleShowUsage(PreprocessedSketch,IBinding,List<SketchInterval>) org.eclipse.jdt.core.dom.IBinding+getKind() org.eclipse.jdt.core.dom.IBinding+getKind() org.eclipse.jdt.core.dom.IMethodBinding+isConstructor() org.eclipse.jdt.core.dom.IMethodBinding+isConstructor() org.eclipse.jdt.core.dom.IVariableBinding+isField() org.eclipse.jdt.core.dom.IVariableBinding+isField() org.eclipse.jdt.core.dom.IVariableBinding+isParameter() org.eclipse.jdt.core.dom.IVariableBinding+isParameter() org.eclipse.jdt.core.dom.IVariableBinding+isEnumConstant() org.eclipse.jdt.core.dom.IVariableBinding+isEnumConstant() javax.swing.tree.DefaultMutableTreeNode+DefaultMutableTreeNode(Object) org.eclipse.jdt.core.dom.IBinding+getName() org.eclipse.jdt.core.dom.IBinding+getName() java.util.stream.Stream+collect(Collector) java.util.stream.Stream+map(Function) java.util.stream.Stream+filter(Predicate) java.util.Collection+stream() java.util.Collection+stream() java.util.stream.Stream+filter(Predicate) java.util.stream.Stream+map(Function) processing.mode.java.pdex.ASTGenerator.ShowUsageTreeNode+fromSketchInterval(PreprocessedSketch,SketchInterval) processing.mode.java.pdex.ASTGenerator.ShowUsageTreeNode+fromSketchInterval(PreprocessedSketch,SketchInterval) java.util.stream.Stream+collect(Collector) java.util.stream.Collectors+groupingBy(Function) java.util.stream.Collectors+groupingBy(Function) java.util.stream.Stream+sorted(Comparator) java.util.Collection+stream() java.util.Map+entrySet() java.util.Map+entrySet() java.util.Collection+stream() java.util.stream.Stream+sorted(Comparator) java.util.Comparator+comparing(Function) java.util.Comparator+comparing(Function) javax.swing.tree.DefaultMutableTreeNode+add(MutableTreeNode) javax.swing.tree.DefaultTreeModel+DefaultTreeModel(TreeNode) javax.swing.JTree+setModel(TreeModel) javax.swing.JTree+setModel(TreeModel) javax.swing.JTree+getRowCount() javax.swing.JTree+getRowCount() javax.swing.JTree+expandRow(int) javax.swing.JTree+expandRow(int) javax.swing.JTree+setRootVisible(boolean) javax.swing.JTree+setRootVisible(boolean) java.awt.Component+isVisible() java.awt.Component+isVisible() java.awt.Dialog+setVisible(boolean) java.awt.Dialog+setVisible(boolean) java.awt.GraphicsEnvironment+getLocalGraphicsEnvironment() java.awt.GraphicsEnvironment+getLocalGraphicsEnvironment() java.awt.GraphicsEnvironment+getDefaultScreenDevice() java.awt.GraphicsEnvironment+getDefaultScreenDevice() java.awt.GraphicsConfiguration+getBounds() java.awt.GraphicsDevice+getDefaultConfiguration() java.awt.GraphicsDevice+getDefaultConfiguration() java.awt.GraphicsConfiguration+getBounds() java.awt.geom.RectangularShape+getMaxX() java.awt.geom.RectangularShape+getMaxX() java.awt.Component+getWidth() java.awt.Component+getWidth() java.lang.Math+min(int,int) java.lang.Math+min(int,int) java.awt.Component+getX() java.awt.Component+getX() java.awt.Component+getWidth() java.awt.Component+getWidth() java.awt.Component+getY() java.awt.Component+getY() java.awt.Window+setLocation(int,int) java.awt.Window+setLocation(int,int) java.awt.Window+toFront() java.awt.Window+toFront() java.awt.Dialog+setTitle(String) java.awt.Dialog+setTitle(String) org.eclipse.jdt.core.dom.IBinding+getName() org.eclipse.jdt.core.dom.IBinding+getName() java.util.List+size() java.util.List+size() processing.mode.java.pdex.ASTGenerator.GUI+reloadShowUsage(PreprocessedSketch) processing.mode.java.pdex.ASTGenerator+handleShowUsage(PreprocessedSketch,IBinding) processing.mode.java.pdex.ASTGenerator+handleShowUsage(PreprocessedSketch,IBinding) processing.mode.java.pdex.ASTGenerator.GUI+disposeAllWindows() processing.app.Messages+log(String) processing.app.Messages+log(String) processing.mode.java.pdex.ASTGenerator.GUI+disposeWindow(Window[]) processing.mode.java.pdex.ASTGenerator.GUI+disposeWindow(Window[]) processing.mode.java.pdex.ASTGenerator.GUI+disposeWindow(Window[]) processing.mode.java.pdex.ASTGenerator.GUI+disposeWindow(Window[]) processing.mode.java.pdex.ASTGenerator.GUI+disposeWindow(Window[]) java.awt.Window+dispose() java.awt.Window+dispose() processing.mode.java.pdex.ASTGenerator.GUI+initDebugWindow() javax.swing.JFrame+JFrame() +() +convertValueToText(Object,boolean,boolean,boolean,int,boolean) javax.swing.tree.DefaultMutableTreeNode+getUserObject() javax.swing.tree.DefaultMutableTreeNode+getUserObject() processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) processing.mode.java.pdex.ASTGenerator+getNodeAsString(ASTNode) javax.swing.JTree+convertValueToText(Object,boolean,boolean,boolean,int,boolean) java.awt.Component+addComponentListener(ComponentListener) java.awt.Component+addComponentListener(ComponentListener) +() +componentHidden(ComponentEvent) processing.mode.java.pdex.ErrorCheckerService+unregisterDoneListener(Consumer<PreprocessedSketch>) processing.mode.java.pdex.ErrorCheckerService+unregisterDoneListener(Consumer<PreprocessedSketch>) javax.swing.JFrame+setDefaultCloseOperation(int) javax.swing.JFrame+setDefaultCloseOperation(int) java.awt.Window+setBounds(Rectangle) java.awt.Window+setBounds(Rectangle) java.awt.Rectangle+Rectangle(int,int,int,int) java.awt.Frame+setTitle(String) java.awt.Frame+setTitle(String) processing.app.Sketch+getName() processing.app.ui.Editor+getSketch() processing.app.ui.Editor+getSketch() processing.app.Sketch+getName() javax.swing.JScrollPane+JScrollPane() javax.swing.JScrollPane+setViewportView(Component) javax.swing.JScrollPane+setViewportView(Component) java.awt.Container+add(Component) java.awt.Container+add(Component) processing.mode.java.pdex.ErrorCheckerService+registerDoneListener(Consumer<PreprocessedSketch>) processing.mode.java.pdex.ErrorCheckerService+registerDoneListener(Consumer<PreprocessedSketch>) processing.mode.java.pdex.ASTGenerator.GUI+updateDebugTree(DefaultMutableTreeNode) java.awt.Component+hasFocus() java.awt.Component+hasFocus() java.awt.Component+hasFocus() java.awt.Component+hasFocus() javax.swing.JTree+setModel(TreeModel) javax.swing.JTree+setModel(TreeModel) javax.swing.tree.DefaultTreeModel+DefaultTreeModel(TreeNode) javax.swing.tree.DefaultTreeModel+reload() javax.swing.JTree+getModel() javax.swing.JTree+getModel() javax.swing.tree.DefaultTreeModel+reload() java.awt.Container+validate() java.awt.Container+validate() java.awt.Component+isVisible() java.awt.Component+isVisible() java.awt.Window+setVisible(boolean) java.awt.Window+setVisible(boolean) processing.mode.java.pdex.ASTGenerator.GUI+addDebugTreeListener() javax.swing.JTree+addTreeSelectionListener(TreeSelectionListener) javax.swing.JTree+addTreeSelectionListener(TreeSelectionListener) javax.swing.JTree+getLastSelectedPathComponent() javax.swing.JTree+getLastSelectedPathComponent() javax.swing.JTree+getLastSelectedPathComponent() javax.swing.JTree+getLastSelectedPathComponent() javax.swing.tree.DefaultMutableTreeNode+getUserObject() javax.swing.tree.DefaultMutableTreeNode+getUserObject() javax.swing.tree.DefaultMutableTreeNode+getUserObject() javax.swing.tree.DefaultMutableTreeNode+getUserObject() processing.mode.java.pdex.ErrorCheckerService+acceptWhenDone(Consumer<PreprocessedSketch>) processing.mode.java.pdex.ErrorCheckerService+acceptWhenDone(Consumer<PreprocessedSketch>) processing.mode.java.pdex.ASTGenerator+highlightNode(PreprocessedSketch,ASTNode) processing.mode.java.pdex.ASTGenerator+highlightNode(PreprocessedSketch,ASTNode)",processing.mode.java.pdex.ASTGenerator.GUI+renameWindow processing.mode.java.pdex.ASTGenerator.GUI+renameTextField processing.mode.java.pdex.ASTGenerator.GUI+renameOldNameLabel processing.mode.java.pdex.ASTGenerator.GUI+showUsageButton processing.mode.java.pdex.ASTGenerator.GUI+renameButton processing.mode.java.pdex.ASTGenerator.GUI+renameBinding processing.mode.java.pdex.ASTGenerator.GUI+ps processing.mode.java.pdex.ASTGenerator.GUI+showUsageWindow processing.mode.java.pdex.ASTGenerator.GUI+showUsageTree processing.mode.java.pdex.ASTGenerator.GUI+showUsageBinding processing.mode.java.pdex.ASTGenerator.GUI+editor processing.mode.java.pdex.ASTGenerator.GUI+astGen processing.mode.java.pdex.ASTGenerator.GUI+updateDebugTreeListener processing.mode.java.pdex.ASTGenerator.GUI+reloadShowUsageListener processing.mode.java.pdex.ASTGenerator.GUI+editor processing.mode.java.pdex.ASTGenerator.GUI+astGen processing.mode.java.pdex.ASTGenerator.GUI+updateDebugTreeListener processing.mode.java.pdex.ASTGenerator.GUI+reloadShowUsageListener processing.mode.java.pdex.ASTGenerator+SHOW_DEBUG_TREE processing.mode.java.pdex.ASTGenerator.GUI+renameWindow processing.mode.java.pdex.ASTGenerator.GUI+editor processing.mode.java.pdex.ASTGenerator.GUI+renameWindow processing.mode.java.pdex.ASTGenerator.GUI+renameWindow javax.swing.WindowConstants+HIDE_ON_CLOSE processing.mode.java.pdex.ASTGenerator.GUI+renameWindow processing.mode.java.pdex.ASTGenerator.GUI+renameWindow processing.mode.java.pdex.ASTGenerator.GUI+renameWindow processing.mode.java.pdex.ASTGenerator.GUI+renameBinding processing.mode.java.pdex.ASTGenerator.GUI+ps processing.mode.java.pdex.ASTGenerator.GUI+renameWindow processing.mode.java.pdex.ASTGenerator.GUI+renameWindow processing.mode.java.pdex.ASTGenerator.GUI+renameWindow javax.swing.BoxLayout+Y_AXIS processing.mode.java.pdex.ASTGenerator.GUI+renameWindow processing.mode.java.pdex.ASTGenerator.GUI+renameTextField processing.mode.java.pdex.ASTGenerator.GUI+renameTextField processing.mode.java.pdex.ASTGenerator.GUI+renameOldNameLabel processing.mode.java.pdex.ASTGenerator.GUI+renameOldNameLabel javax.swing.BoxLayout+Y_AXIS processing.mode.java.pdex.ASTGenerator.GUI+renameTextField processing.mode.java.pdex.ASTGenerator.GUI+renameOldNameLabel processing.mode.java.pdex.ASTGenerator.GUI+renameWindow processing.mode.java.pdex.ASTGenerator.GUI+showUsageButton processing.mode.java.pdex.ASTGenerator.GUI+renameButton javax.swing.BoxLayout+X_AXIS processing.mode.java.pdex.ASTGenerator.GUI+showUsageButton processing.mode.java.pdex.ASTGenerator.GUI+renameButton processing.mode.java.pdex.ASTGenerator.GUI+renameWindow processing.mode.java.pdex.ASTGenerator.GUI+renameWindow processing.mode.java.pdex.ASTGenerator.GUI+renameWindow processing.mode.java.pdex.ASTGenerator.GUI+renameWindow processing.mode.java.pdex.ASTGenerator.GUI+editor processing.mode.java.pdex.ASTGenerator.GUI+editor processing.mode.java.pdex.ASTGenerator.GUI+renameWindow processing.mode.java.pdex.ASTGenerator.GUI+editor processing.mode.java.pdex.ASTGenerator.GUI+editor processing.mode.java.pdex.ASTGenerator.GUI+renameWindow processing.mode.java.pdex.ASTGenerator.GUI+showUsageWindow processing.mode.java.pdex.ASTGenerator.GUI+editor processing.mode.java.pdex.ASTGenerator.GUI+showUsageWindow javax.swing.WindowConstants+HIDE_ON_CLOSE processing.mode.java.pdex.ASTGenerator.GUI+showUsageWindow processing.mode.java.pdex.ASTGenerator.GUI+showUsageWindow processing.mode.java.pdex.ASTGenerator.GUI+showUsageBinding processing.mode.java.pdex.ASTGenerator.GUI+showUsageTree processing.mode.java.pdex.ASTGenerator.GUI+astGen processing.mode.java.pdex.ASTGenerator+ecs processing.mode.java.pdex.ASTGenerator.GUI+reloadShowUsageListener processing.mode.java.pdex.ASTGenerator.GUI+astGen processing.mode.java.pdex.ASTGenerator+ecs processing.mode.java.pdex.ASTGenerator.GUI+reloadShowUsageListener processing.mode.java.pdex.ASTGenerator.GUI+showUsageWindow processing.mode.java.pdex.ASTGenerator.GUI+showUsageWindow processing.mode.java.pdex.ASTGenerator.GUI+showUsageTree processing.mode.java.pdex.ASTGenerator.GUI+showUsageTree processing.mode.java.pdex.ASTGenerator.GUI+showUsageTree processing.mode.java.pdex.ASTGenerator.GUI+showUsageWindow processing.mode.java.pdex.ASTGenerator+SHOW_DEBUG_TREE processing.mode.java.pdex.ASTGenerator.GUI+renameButton processing.mode.java.pdex.ASTGenerator.GUI+renameTextField processing.mode.java.pdex.ASTGenerator.GUI+renameTextField javax.swing.JOptionPane+PLAIN_MESSAGE processing.mode.java.pdex.ASTGenerator.GUI+astGen processing.mode.java.pdex.ASTGenerator.GUI+ps processing.mode.java.pdex.ASTGenerator.GUI+renameBinding processing.mode.java.pdex.ASTGenerator.GUI+renameWindow processing.mode.java.pdex.ASTGenerator.GUI+showUsageButton processing.mode.java.pdex.ASTGenerator.GUI+astGen processing.mode.java.pdex.ASTGenerator.GUI+ps processing.mode.java.pdex.ASTGenerator.GUI+renameBinding processing.mode.java.pdex.ASTGenerator.GUI+renameWindow processing.mode.java.pdex.ASTGenerator.GUI+showUsageTree processing.mode.java.pdex.ASTGenerator.GUI+showUsageTree processing.mode.java.pdex.ASTGenerator.GUI+showUsageTree processing.mode.java.pdex.ASTGenerator.GUI+editor processing.mode.java.pdex.ASTGenerator.ShowUsageTreeNode+tabIndex processing.mode.java.pdex.ASTGenerator.ShowUsageTreeNode+startTabOffset processing.mode.java.pdex.ASTGenerator.ShowUsageTreeNode+stopTabOffset processing.mode.java.pdex.ASTGenerator.GUI+renameWindow processing.mode.java.pdex.ASTGenerator.GUI+ps processing.mode.java.pdex.ASTGenerator.GUI+renameBinding processing.mode.java.pdex.ASTGenerator.GUI+renameWindow processing.mode.java.pdex.ASTGenerator.GUI+editor processing.mode.java.pdex.ASTGenerator.GUI+editor processing.mode.java.pdex.ASTGenerator.GUI+renameWindow processing.mode.java.pdex.ASTGenerator.GUI+editor processing.mode.java.pdex.ASTGenerator.GUI+editor processing.mode.java.pdex.ASTGenerator.GUI+renameWindow processing.mode.java.pdex.ASTGenerator.GUI+renameOldNameLabel processing.mode.java.pdex.ASTGenerator.GUI+renameTextField processing.mode.java.pdex.ASTGenerator.GUI+renameTextField processing.mode.java.pdex.ASTGenerator.GUI+renameTextField processing.mode.java.pdex.ASTGenerator.GUI+renameWindow processing.mode.java.pdex.ASTGenerator.GUI+renameWindow processing.mode.java.pdex.ASTGenerator.GUI+showUsageBinding org.eclipse.jdt.core.dom.IBinding+METHOD org.eclipse.jdt.core.dom.IBinding+TYPE org.eclipse.jdt.core.dom.IBinding+VARIABLE processing.mode.java.pdex.ASTGenerator.GUI+showUsageTree processing.mode.java.pdex.ASTGenerator.GUI+showUsageTree processing.mode.java.pdex.ASTGenerator.GUI+showUsageTree processing.mode.java.pdex.ASTGenerator.GUI+showUsageTree processing.mode.java.pdex.ASTGenerator.GUI+showUsageWindow processing.mode.java.pdex.ASTGenerator.GUI+showUsageWindow processing.mode.java.pdex.ASTGenerator.GUI+showUsageWindow processing.mode.java.pdex.ASTGenerator.GUI+editor processing.mode.java.pdex.ASTGenerator.GUI+editor processing.mode.java.pdex.ASTGenerator.GUI+editor processing.mode.java.pdex.ASTGenerator.GUI+showUsageWindow processing.mode.java.pdex.ASTGenerator.GUI+showUsageWindow processing.mode.java.pdex.ASTGenerator.GUI+showUsageWindow processing.mode.java.pdex.ASTGenerator.GUI+showUsageBinding processing.mode.java.pdex.ASTGenerator.GUI+astGen processing.mode.java.pdex.ASTGenerator.GUI+showUsageBinding processing.mode.java.pdex.ASTGenerator.GUI+showUsageWindow processing.mode.java.pdex.ASTGenerator.GUI+renameWindow processing.mode.java.pdex.ASTGenerator.GUI+debugTreeWindow processing.mode.java.pdex.ASTGenerator.GUI+debugTreeWindow processing.mode.java.pdex.ASTGenerator.GUI+debugTreeWindow processing.mode.java.pdex.ASTGenerator.GUI+debugTree processing.mode.java.pdex.ASTGenerator.GUI+debugTreeWindow processing.mode.java.pdex.ASTGenerator.GUI+debugTree processing.mode.java.pdex.ASTGenerator.GUI+debugTreeWindow processing.mode.java.pdex.ASTGenerator.GUI+astGen processing.mode.java.pdex.ASTGenerator+ecs processing.mode.java.pdex.ASTGenerator.GUI+updateDebugTreeListener processing.mode.java.pdex.ASTGenerator.GUI+debugTreeWindow javax.swing.WindowConstants+HIDE_ON_CLOSE processing.mode.java.pdex.ASTGenerator.GUI+debugTreeWindow processing.mode.java.pdex.ASTGenerator.GUI+debugTreeWindow processing.mode.java.pdex.ASTGenerator.GUI+editor processing.mode.java.pdex.ASTGenerator.GUI+debugTree processing.mode.java.pdex.ASTGenerator.GUI+debugTreeWindow processing.mode.java.pdex.ASTGenerator.GUI+astGen processing.mode.java.pdex.ASTGenerator+ecs processing.mode.java.pdex.ASTGenerator.GUI+updateDebugTreeListener processing.mode.java.pdex.ASTGenerator.GUI+debugTree processing.mode.java.pdex.ASTGenerator.GUI+debugTreeWindow processing.mode.java.pdex.ASTGenerator.GUI+debugTree processing.mode.java.pdex.ASTGenerator.GUI+debugTree processing.mode.java.pdex.ASTGenerator.GUI+debugTree processing.mode.java.pdex.ASTGenerator.GUI+debugTreeWindow processing.mode.java.pdex.ASTGenerator.GUI+debugTreeWindow processing.mode.java.pdex.ASTGenerator.GUI+debugTree processing.mode.java.pdex.ASTGenerator.GUI+debugTree processing.mode.java.pdex.ASTGenerator.GUI+debugTree processing.mode.java.pdex.ASTGenerator.GUI+astGen processing.mode.java.pdex.ASTGenerator+ecs processing.mode.java.pdex.ASTGenerator.GUI+astGen,13683,375,12,,"protected static class GUI {

    // Rename window
    protected JDialog renameWindow;
    protected JTextField renameTextField;
    protected JLabel renameOldNameLabel;
    protected JButton showUsageButton;
    protected JButton renameButton;
    protected IBinding renameBinding;
    protected PreprocessedSketch ps;

    // Show usage window
    protected JDialog showUsageWindow;
    protected JTree showUsageTree;
    protected IBinding showUsageBinding;

    protected final JavaEditor editor;
    protected final ASTGenerator astGen;

    protected Consumer<PreprocessedSketch> updateDebugTreeListener;
    protected Consumer<PreprocessedSketch> reloadShowUsageListener;


    protected GUI(JavaEditor editor, ASTGenerator astGen) {
      this.editor = editor;
      this.astGen = astGen;

      updateDebugTreeListener = astGen::updateDebugTree;
      reloadShowUsageListener = this::reloadShowUsage;

      setupGUI();
      addListeners();

    }

    protected void setupGUI() {

      if (SHOW_DEBUG_TREE) initDebugWindow();

      { // Rename window
        renameWindow = new JDialog(editor);
        renameWindow.setTitle(""Enter new name:"");
        renameWindow.setDefaultCloseOperation(JFrame.HIDE_ON_CLOSE);
        renameWindow.setModal(true);
        renameWindow.setResizable(false);
        renameWindow.addComponentListener(new ComponentAdapter() {
          @Override
          public void componentHidden(ComponentEvent e) {
            renameBinding = null;
            ps = null;
          }
        });
        renameWindow.setSize(250, 130);
        renameWindow.setLayout(new BoxLayout(renameWindow.getContentPane(), BoxLayout.Y_AXIS));
        Toolkit.setIcon(renameWindow);

        { // Top panel

          // Text field
          renameTextField = new JTextField();
          renameTextField.setPreferredSize(new Dimension(150, 60));

          // Old name label
          renameOldNameLabel = new JLabel();
          renameOldNameLabel.setText(""Old Name: "");

          // Top panel
          JPanel panelTop = new JPanel();
          panelTop.setLayout(new BoxLayout(panelTop, BoxLayout.Y_AXIS));
          panelTop.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
          panelTop.add(renameTextField);
          panelTop.add(Box.createRigidArea(new Dimension(0, 10)));
          panelTop.add(renameOldNameLabel);
          renameWindow.add(panelTop);
        }

        { // Bottom panel
          showUsageButton = new JButton(""Show Usage"");
          renameButton = new JButton(""Rename"");

          JPanel panelBottom = new JPanel();
          panelBottom.setLayout(new BoxLayout(panelBottom, BoxLayout.X_AXIS));
          panelBottom.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
          panelBottom.add(Box.createHorizontalGlue());
          panelBottom.add(showUsageButton);
          panelBottom.add(Box.createRigidArea(new Dimension(15, 0)));
          panelBottom.add(renameButton);
          renameWindow.add(panelBottom);
        }

        //renameWindow.setVisible(true);
        renameWindow.setMinimumSize(renameWindow.getSize());
        renameWindow.setLocation(editor.getX()
                                     + (editor.getWidth() - renameWindow.getWidth()) / 2,
                                 editor.getY()
                                     + (editor.getHeight() - renameWindow.getHeight())
                                     / 2);
      }

      { // Show Usage window
        showUsageWindow = new JDialog(editor);
        showUsageWindow.setDefaultCloseOperation(JFrame.HIDE_ON_CLOSE);
        showUsageWindow.setAutoRequestFocus(false);
        showUsageWindow.addComponentListener(new ComponentAdapter() {
          @Override
          public void componentHidden(ComponentEvent e) {
            // Delete references to ASTNodes so that whole AST can be GC'd
            showUsageBinding = null;
            showUsageTree.setModel(null);
            astGen.ecs.unregisterDoneListener(reloadShowUsageListener);
          }

          @Override
          public void componentShown(ComponentEvent e) {
            astGen.ecs.registerDoneListener(reloadShowUsageListener);
          }
        });
        showUsageWindow.setSize(300, 400);
        Toolkit.setIcon(showUsageWindow);
        JScrollPane sp2 = new JScrollPane();
        showUsageTree = new JTree();
        DefaultTreeCellRenderer renderer = (DefaultTreeCellRenderer) showUsageTree.getCellRenderer();
        renderer.setLeafIcon(null);
        renderer.setClosedIcon(null);
        renderer.setOpenIcon(null);
        sp2.setViewportView(showUsageTree);
        showUsageWindow.add(sp2);
      }
    }


    protected void addListeners() {

      if (SHOW_DEBUG_TREE) {
        addDebugTreeListener();
      }

      renameButton.addActionListener(e -> {
        if (renameTextField.getText().length() == 0) {
          return;
        }
        String newName = renameTextField.getText().trim();
        boolean isNewNameValid = newName.length() >= 1 &&
            newName.chars().limit(1).allMatch(Character::isUnicodeIdentifierStart) &&
            newName.chars().skip(1).allMatch(Character::isUnicodeIdentifierPart);
        if (!isNewNameValid) {
          JOptionPane.showMessageDialog(new JFrame(), ""'"" + newName
              + ""' isn't a valid name."", ""Uh oh.."", JOptionPane.PLAIN_MESSAGE);
        } else {
          astGen.handleRename(ps, renameBinding, newName);
          renameWindow.setVisible(false);
        }
      });

      showUsageButton.addActionListener(e -> {
        astGen.handleShowUsage(ps, renameBinding);
        renameWindow.setVisible(false);
      });

      showUsageTree.addTreeSelectionListener(e -> {
        if (showUsageTree.getLastSelectedPathComponent() == null) {
          return;
        }
        DefaultMutableTreeNode tnode = (DefaultMutableTreeNode) showUsageTree
            .getLastSelectedPathComponent();

        if (tnode.getUserObject() instanceof ShowUsageTreeNode) {
          ShowUsageTreeNode node = (ShowUsageTreeNode) tnode.getUserObject();
          editor.highlight(node.tabIndex, node.startTabOffset, node.stopTabOffset);
        }
      });
    }


    public void handleRename(PreprocessedSketch ps, IBinding binding) {
      if (!renameWindow.isVisible()){
        this.ps = ps;
        renameBinding = binding;
        renameWindow.setLocation(editor.getX()
                                     + (editor.getWidth() - renameWindow.getWidth()) / 2,
                                 editor.getY()
                                     + (editor.getHeight() - renameWindow.getHeight())
                                     / 2);
        renameOldNameLabel.setText(""Current name: "" + binding.getName());
        renameTextField.setText(binding.getName());
        renameTextField.requestFocus();
        renameTextField.selectAll();
        renameWindow.setVisible(true);
        renameWindow.toFront();
      }
    }


    public void handleShowUsage(PreprocessedSketch ps, IBinding binding, List<SketchInterval> occurrences) {
      showUsageBinding = binding;

      String bindingType = """";
      switch (binding.getKind()) {
        case IBinding.METHOD:
          IMethodBinding method = (IMethodBinding) binding;
          if (method.isConstructor()) bindingType = ""Constructor"";
          else bindingType = ""Method"";
          break;
        case IBinding.TYPE: bindingType = ""Type""; break;
        case IBinding.VARIABLE:
          IVariableBinding variable = (IVariableBinding) binding;
          if (variable.isField()) bindingType = ""Field"";
          else if (variable.isParameter()) bindingType = ""Parameter"";
          else if (variable.isEnumConstant()) bindingType = ""Enum constant"";
          else bindingType = ""Local variable"";
          break;
      }

      DefaultMutableTreeNode rootNode =
          new DefaultMutableTreeNode(bindingType + "": "" + binding.getName());

      Map<Integer, List<ShowUsageTreeNode>> tabGroupedTreeNodes = occurrences.stream()
          // TODO: this has to be fixed with better token mapping
          // remove occurrences which fall into generated header
          .filter(in -> in.tabIndex != 0 ||
              (in.startTabOffset >= 0 && in.stopTabOffset > 0))
          // Convert to TreeNodes
          .map(in -> ShowUsageTreeNode.fromSketchInterval(ps, in))
          // Group by tab
          .collect(Collectors.groupingBy(node -> node.tabIndex));

      tabGroupedTreeNodes.entrySet().stream()
          // Sort by tab index
          .sorted(Comparator.comparing(Map.Entry::getKey))
          .map(entry -> {
            Integer tabIndex = entry.getKey();
            List<ShowUsageTreeNode> nodes = entry.getValue();

            int count = nodes.size();
            String usageLabel = count == 1 ? ""usage"" : ""usages"";

            // Create new DefaultMutableTreeNode for this tab
            String tabLabel = ""<html><font color=#222222>"" +
                ps.sketch.getCode(tabIndex).getPrettyName() +
                ""</font> <font color=#999999>"" + count + "" "" + usageLabel + ""</font></html>"";
            DefaultMutableTreeNode tabNode = new DefaultMutableTreeNode(tabLabel);

            nodes.stream()
                // Convert TreeNodes to DefaultMutableTreeNodes
                .map(DefaultMutableTreeNode::new)
                // Add all as children of tab node
                .forEach(tabNode::add);
            return tabNode;
          })
          // Add all tab nodes as children of root node
          .forEach(rootNode::add);

      DefaultTreeModel model = new DefaultTreeModel(rootNode);
      showUsageTree.setModel(model);

      // Expand all nodes
      for (int i = 0; i < showUsageTree.getRowCount(); i++) {
        showUsageTree.expandRow(i);
      }

      showUsageTree.setRootVisible(true);

      if (!showUsageWindow.isVisible()) {
        showUsageWindow.setVisible(true);
        GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
        GraphicsDevice defaultScreen = ge.getDefaultScreenDevice();
        Rectangle rect = defaultScreen.getDefaultConfiguration().getBounds();
        int maxX = (int) rect.getMaxX() - showUsageWindow.getWidth();
        int x = Math.min(editor.getX() + editor.getWidth(), maxX);
        int y = (x == maxX) ? 10 : editor.getY();
        showUsageWindow.setLocation(x, y);
      }
      showUsageWindow.toFront();
      showUsageWindow.setTitle(""Usage of \"""" + binding.getName() + ""\"" : ""
                                   + occurrences.size() + "" time(s)"");
    }


    // Thread: worker
    public void reloadShowUsage(PreprocessedSketch ps) {
      if (showUsageBinding != null) {
        astGen.handleShowUsage(ps, showUsageBinding);
      }
    }


    public void disposeAllWindows() {
      Messages.log(""* disposeAllWindows"");
      disposeWindow(showUsageWindow, renameWindow);

      if (debugTreeWindow != null) disposeWindow(debugTreeWindow);
    }


    public static void disposeWindow(Window... w) {
      for (Window window : w) {
        if (window != null)
          window.dispose();
      }
    }


    /// DEBUG --------------------------------------------------------------------


    protected JFrame debugTreeWindow;

    /** Swing component wrapper for AST, used for internal testing */
    protected JTree debugTree;


    protected void initDebugWindow() {
      debugTreeWindow = new JFrame();

      debugTree = new JTree() {
        @Override
        public String convertValueToText(Object value, boolean selected,
                                         boolean expanded, boolean leaf,
                                         int row, boolean hasFocus) {
          if (value instanceof DefaultMutableTreeNode) {
            DefaultMutableTreeNode treeNode = (DefaultMutableTreeNode) value;
            Object o = treeNode.getUserObject();
            if (o instanceof ASTNode) {
              ASTNode node = (ASTNode) o;
              return getNodeAsString(node);
            }
          }
          return super.convertValueToText(value, selected, expanded, leaf, row, hasFocus);
        }
      };
      debugTreeWindow.addComponentListener(new ComponentAdapter() {
        @Override
        public void componentHidden(ComponentEvent e) {
          astGen.ecs.unregisterDoneListener(updateDebugTreeListener);
        }
      });
      debugTreeWindow.setDefaultCloseOperation(JFrame.HIDE_ON_CLOSE);
      debugTreeWindow.setBounds(new Rectangle(680, 100, 460, 620));
      debugTreeWindow.setTitle(""AST View - "" + editor.getSketch().getName());
      JScrollPane sp = new JScrollPane();
      sp.setViewportView(debugTree);
      debugTreeWindow.add(sp);
      astGen.ecs.registerDoneListener(updateDebugTreeListener);
    }


    protected void updateDebugTree(DefaultMutableTreeNode codeTree) {
      if (debugTree.hasFocus() || debugTreeWindow.hasFocus()) {
        return;
      }
      debugTree.setModel(new DefaultTreeModel(codeTree));
      ((DefaultTreeModel) debugTree.getModel()).reload();
      debugTree.validate();
      if (!debugTreeWindow.isVisible()) {
        debugTreeWindow.setVisible(true);
      }
    }


    protected void addDebugTreeListener() {
      debugTree.addTreeSelectionListener(e -> {
        if (debugTree.getLastSelectedPathComponent() == null) {
          return;
        }
        DefaultMutableTreeNode tnode =
            (DefaultMutableTreeNode) debugTree.getLastSelectedPathComponent();
        if (tnode.getUserObject() instanceof ASTNode) {
          ASTNode node = (ASTNode) tnode.getUserObject();

          astGen.ecs.acceptWhenDone(ps1 -> astGen.highlightNode(ps1, node));
        }
      });
    }

  }",False,True,,
55,ShowUsageTreeNode,show usage tree node ,MemberClass,,,"processing.mode.java.pdex.ASTGenerator.ShowUsageTreeNode+fromSketchInterval(PreprocessedSketch,SketchInterval) java.lang.String+lastIndexOf(int,int) java.lang.String+lastIndexOf(int,int) java.lang.String+indexOf(int,int) java.lang.String+indexOf(int,int) java.lang.String+length() java.lang.String+length() processing.mode.java.pdex.PreprocessedSketch+tabOffsetToTabLine(int,int) processing.mode.java.pdex.PreprocessedSketch+tabOffsetToTabLine(int,int) java.lang.String+substring(int,int) java.lang.String+substring(int,int) java.lang.String+replace(CharSequence,CharSequence) java.lang.String+replace(CharSequence,CharSequence) java.lang.String+replace(CharSequence,CharSequence) java.lang.String+substring(int,int) java.lang.String+substring(int,int) java.lang.String+replace(CharSequence,CharSequence) java.lang.String+replace(CharSequence,CharSequence) java.lang.String+replace(CharSequence,CharSequence) java.lang.String+replace(CharSequence,CharSequence) java.lang.String+replace(CharSequence,CharSequence) java.lang.String+replace(CharSequence,CharSequence) java.lang.String+substring(int,int) java.lang.String+substring(int,int) java.lang.String+replace(CharSequence,CharSequence) java.lang.String+replace(CharSequence,CharSequence) java.lang.String+replace(CharSequence,CharSequence) java.lang.String+replace(CharSequence,CharSequence) java.lang.String+replace(CharSequence,CharSequence) java.lang.String+replace(CharSequence,CharSequence) java.lang.String+substring(int) java.lang.String+substring(int) java.lang.String+replace(CharSequence,CharSequence) java.lang.String+replace(CharSequence,CharSequence) java.lang.String+replace(CharSequence,CharSequence) java.lang.String+trim() java.lang.String+trim() processing.mode.java.pdex.ASTGenerator.ShowUsageTreeNode+ShowUsageTreeNode() processing.mode.java.pdex.ASTGenerator.ShowUsageTreeNode+toString()",processing.mode.java.pdex.ASTGenerator.ShowUsageTreeNode+tabIndex processing.mode.java.pdex.ASTGenerator.ShowUsageTreeNode+startTabOffset processing.mode.java.pdex.ASTGenerator.ShowUsageTreeNode+stopTabOffset processing.mode.java.pdex.ASTGenerator.ShowUsageTreeNode+text processing.mode.java.pdex.PreprocessedSketch+pdeCode processing.mode.java.pdex.PreprocessedSketch.SketchInterval+startPdeOffset processing.mode.java.pdex.PreprocessedSketch+pdeCode processing.mode.java.pdex.PreprocessedSketch.SketchInterval+stopPdeOffset processing.mode.java.pdex.PreprocessedSketch+pdeCode processing.mode.java.pdex.PreprocessedSketch.SketchInterval+startPdeOffset processing.mode.java.pdex.PreprocessedSketch.SketchInterval+stopPdeOffset processing.mode.java.pdex.PreprocessedSketch.SketchInterval+tabIndex processing.mode.java.pdex.PreprocessedSketch.SketchInterval+startTabOffset processing.mode.java.pdex.PreprocessedSketch+pdeCode processing.mode.java.pdex.ASTGenerator.ShowUsageTreeNode+tabIndex processing.mode.java.pdex.PreprocessedSketch.SketchInterval+tabIndex processing.mode.java.pdex.ASTGenerator.ShowUsageTreeNode+startTabOffset processing.mode.java.pdex.PreprocessedSketch.SketchInterval+startTabOffset processing.mode.java.pdex.ASTGenerator.ShowUsageTreeNode+stopTabOffset processing.mode.java.pdex.PreprocessedSketch.SketchInterval+stopTabOffset processing.mode.java.pdex.ASTGenerator.ShowUsageTreeNode+text processing.mode.java.pdex.ASTGenerator.ShowUsageTreeNode+text,1742,45,12,,"protected static class ShowUsageTreeNode {

    int tabIndex;
    int startTabOffset;
    int stopTabOffset;

    String text;

    public static ShowUsageTreeNode fromSketchInterval(PreprocessedSketch ps, SketchInterval in) {
      int lineStartPdeOffset = ps.pdeCode.lastIndexOf('\n', in.startPdeOffset) + 1;
      int lineStopPdeOffset = ps.pdeCode.indexOf('\n', in.stopPdeOffset);
      if (lineStopPdeOffset == -1) lineStopPdeOffset = ps.pdeCode.length();

      int highlightStartOffset = in.startPdeOffset - lineStartPdeOffset;
      int highlightStopOffset = in.stopPdeOffset - lineStartPdeOffset;

      int tabLine = ps.tabOffsetToTabLine(in.tabIndex, in.startTabOffset);

      // TODO: what a mess
      String line = ps.pdeCode.substring(lineStartPdeOffset, lineStopPdeOffset);
      String pre = line.substring(0, highlightStartOffset)
          .replace(""&"", ""&amp;"").replace("">"", ""&gt;"").replace(""<"", ""&lt;"");
      String highlight = line.substring(highlightStartOffset, highlightStopOffset)
          .replace(""&"", ""&amp;"").replace("">"", ""&gt;"").replace(""<"", ""&lt;"");
      String post = line.substring(highlightStopOffset)
          .replace(""&"", ""&amp;"").replace("">"", ""&gt;"").replace(""<"", ""&lt;"");
      line = pre + ""<font color=#222222><b>"" + highlight + ""</b></font>"" + post;
      line = line.trim();

      ShowUsageTreeNode node = new ShowUsageTreeNode();
      node.tabIndex = in.tabIndex;
      node.startTabOffset = in.startTabOffset;
      node.stopTabOffset = in.stopTabOffset;

      node.text = ""<html><font color=#bbbbbb>"" +
          (tabLine + 1) + ""</font> <font color=#777777>"" + line + ""</font></html>"";

      return node;
    }

    @Override
    public String toString() {
      return text;
    }
  }",False,True,,
