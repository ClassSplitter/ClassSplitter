index,name,document,type,inner invocations,external invocations,calls,visits,length,lines,modifier,commit,full text,moved,removed,gpt text,gpt response,code summary
1,LOG,log ,Field,,,,,103,2,26,,"private static final Logger LOG = LoggerFactory
      .getLogger(MethodHandles.lookup().lookupClass());",False,False,,False,
2,http,http ,Field,,,,,22,1,2,,private Protocol http;,True,True,,False,
3,server,server ,Field,,,,,28,1,2,,private ServerSocket server;,True,True,,False,
4,conf,conf ,Field,,,,,27,1,2,,private Configuration conf;,True,True,,False,
5,port,port ,Field,,,,,25,1,2,,private int port = 47506;,False,True,,False,
6,responseHeader,response header ,Field,,,,,67,1,26,,"private static final String responseHeader = ""HTTP/1.1 200 OK\r\n"";",True,True,,False,
7,simpleContent,simple content ,Field,,,,,93,1,26,,"private static final String simpleContent = ""Content-Type: text/html\r\n\r\nThis is a text."";",True,True,,False,
8,setUp(),set up ,Method,testBadHttpServer() testRequestNotStartingWithSlash() testContentLengthNotANumber() testHeaderWithColon() testHeaderSpellChecking() testIgnoreErrorInRedirectPayload() testNoStatusLine() testMultiLineHeader() testOverlongHeader() testChunkedContent() testTruncationMarking() testTruncationMarkingGzip() testPartialContentTruncated() testNoContentLimit() testHttpStatusNoMessage(),,org.apache.nutch.util.NutchConfiguration+create() org.apache.nutch.util.NutchConfiguration+create() org.apache.nutch.protocol.ProtocolFactory+getProtocolById(String) org.apache.nutch.protocol.ProtocolFactory+ProtocolFactory(Configuration) org.apache.nutch.protocol.ProtocolFactory+getProtocolById(String),org.apache.nutch.protocol.okhttp.TestBadServerResponses+conf org.apache.nutch.protocol.okhttp.TestBadServerResponses+conf org.apache.nutch.protocol.okhttp.TestBadServerResponses+conf org.apache.nutch.protocol.okhttp.TestBadServerResponses+conf org.apache.nutch.protocol.okhttp.TestBadServerResponses+http org.apache.nutch.protocol.okhttp.TestBadServerResponses+conf,416,11,1,,"public void setUp() throws Exception {
    conf = NutchConfiguration.create();
    conf.addResource(""nutch-default.xml"");
    // plugin tests specific config file - adds protocol-okhttp to
    // plugin.includes
    conf.addResource(""nutch-site-test.xml"");
    conf.setBoolean(""store.http.headers"", true);

    http = new ProtocolFactory(conf)
        .getProtocolById(""org.apache.nutch.protocol.okhttp.OkHttp"");
  }",False,True,"The function of this method is to set up the configuration for Nutch, including adding resource files, setting a boolean value, and initializing the HTTP protocol using the OkHttp library.",True,The code sets up the configuration for Nutch web crawler by creating a new configuration object and adding default and test-specific configuration files. It also enables storing HTTP headers and initializes the HTTP protocol using the OkHttp library.
9,tearDown(),tear down ,Method,,,java.net.ServerSocket+close() java.net.ServerSocket+close(),org.apache.nutch.protocol.okhttp.TestBadServerResponses+server,74,4,1,,"@After
  public void tearDown() throws Exception {
    server.close();
  }",True,True,This method is used to clean up or tear down any resources that were used during the test. It closes the server that was opened before the test.,True,"The code snippet defines a method named ""tearDown"" that is annotated with ""@After"". This method is executed after each test case and is responsible for closing the server."
10,getHeaders(ProtocolOutput),get headers response ,Method,"getHeader(ProtocolOutput,String) testMultiLineHeader() testHttpStatusNoMessage()",,org.apache.nutch.metadata.Metadata+get(String) org.apache.nutch.protocol.Content+getMetadata() org.apache.nutch.protocol.ProtocolOutput+getContent() org.apache.nutch.protocol.ProtocolOutput+getContent() org.apache.nutch.protocol.Content+getMetadata() org.apache.nutch.metadata.Metadata+get(String),org.apache.nutch.net.protocols.Response+RESPONSE_HEADERS,141,3,9,,"public static String getHeaders(ProtocolOutput response) {
    return response.getContent().getMetadata().get(Response.RESPONSE_HEADERS);
  }",False,True,This method returns the response headers from the given ProtocolOutput object.,True,"The given code defines a static method named ""getHeaders"" that takes a ProtocolOutput object as input. It retrieves the response headers from the ProtocolOutput object and returns them as a String."
11,"getHeader(ProtocolOutput,String)",get header response header ,Method,testIgnoreErrorInRedirectPayload() testIgnoreErrorInRedirectPayload() testMultiLineHeader() testMultiLineHeader(),,"java.lang.String+split(String) org.apache.nutch.protocol.okhttp.TestBadServerResponses+getHeaders(ProtocolOutput) org.apache.nutch.protocol.okhttp.TestBadServerResponses+getHeaders(ProtocolOutput) java.lang.String+split(String) java.lang.String+split(String,int) java.lang.String+split(String,int) java.lang.String+equals(Object) java.lang.String+equals(Object)",,274,9,9,,"public static String getHeader(ProtocolOutput response, String header) {
    for (String line : getHeaders(response).split(""\r\n"")) {
      String[] parts = line.split("": "", 1);
      if (parts[0].equals(header)) {
        return parts[1];
      }
    }
    return null;
  }",True,True,"This method retrieves a specific header value from a given ProtocolOutput response. It splits the headers by line, then splits each line by "": "" to separate the header and its value. If the header matches the given input, it returns the corresponding value. If no match is found, it returns null.",True,"The given code is a method named ""getHeader"" that takes a ProtocolOutput object and a header name as input. It splits the headers of the response object by line, then splits each line by "": "" to separate the header name and value. If the header name matches the input header, it returns the corresponding value. If no match is found, it returns null."
12,"runServer(int,byte[])",run server port response starts the test server at a specified port and constant response param portno port number param response response sent on every request ,Method,,,"java.net.ServerSocket+ServerSocket() java.net.ServerSocket+bind(SocketAddress) java.net.ServerSocket+bind(SocketAddress) java.net.InetSocketAddress+InetSocketAddress(String,int) java.util.regex.Pattern+compile(String) java.util.regex.Pattern+compile(String) java.net.ServerSocket+accept() java.net.ServerSocket+accept() java.io.BufferedReader+BufferedReader(Reader) java.io.InputStreamReader+InputStreamReader(InputStream,Charset) java.net.Socket+getInputStream() java.net.Socket+getInputStream() java.io.BufferedReader+readLine() java.io.BufferedReader+readLine() java.lang.String+isEmpty() java.lang.String+trim() java.lang.String+trim() java.lang.String+isEmpty() java.util.regex.Pattern+matcher(CharSequence) java.util.regex.Pattern+matcher(CharSequence) java.util.regex.Matcher+find() java.util.regex.Matcher+find() java.util.regex.Matcher+group(int) java.util.regex.Matcher+group(int) java.lang.String+startsWith(String) java.util.regex.Matcher+group(int) java.util.regex.Matcher+group(int) java.lang.String+startsWith(String) java.lang.String+getBytes(Charset) java.lang.String+getBytes(Charset) java.io.OutputStream+write(byte[]) java.net.Socket+getOutputStream() java.net.Socket+getOutputStream() java.io.OutputStream+write(byte[])",org.apache.nutch.protocol.okhttp.TestBadServerResponses+server org.apache.nutch.protocol.okhttp.TestBadServerResponses+server org.apache.nutch.protocol.okhttp.TestBadServerResponses+LOG org.apache.nutch.protocol.okhttp.TestBadServerResponses+server org.apache.nutch.protocol.okhttp.TestBadServerResponses+LOG java.nio.charset.StandardCharsets+UTF_8 org.apache.nutch.protocol.okhttp.TestBadServerResponses+LOG org.apache.nutch.protocol.okhttp.TestBadServerResponses+LOG java.nio.charset.StandardCharsets+UTF_8 org.apache.nutch.protocol.okhttp.TestBadServerResponses+LOG,1372,40,2,"/** 
 * Starts the test server at a specified port and constant response.
 * @param portno Port number.
 * @param response response sent on every request
 */
","/**
     * Starts the test server at a specified port and constant response.
     * 
     * @param portno
     *          Port number.
     * @param response
     *          response sent on every request
     */
  private void runServer(int port, byte[] response) throws Exception {
    server = new ServerSocket();
    server.bind(new InetSocketAddress(""127.0.0.1"", port));
    Pattern requestPattern = Pattern.compile(""(?i)^GET\\s+(\\S+)"");
    while (true) {
      LOG.info(""Listening on port {}"", port);
      Socket socket = server.accept();
      LOG.info(""Connection received"");
      try (
          BufferedReader in = new BufferedReader(new InputStreamReader(
              socket.getInputStream(), StandardCharsets.UTF_8))) {

        String line;
        while ((line = in.readLine()) != null) {
          LOG.info(""Request: {}"", line);
          if (line.trim().isEmpty()) {
            break;
          }
          Matcher m = requestPattern.matcher(line);
          if (m.find()) {
            LOG.info(""Requested {}"", m.group(1));
            if (!m.group(1).startsWith(""/"")) {
              response = ""HTTP/1.1 400 Bad request\r\n\r\n"".getBytes(StandardCharsets.UTF_8);
            }
          }
        }
        socket.getOutputStream().write(response);
      } catch (Exception e) {
        LOG.warn(""Exception in test server:"", e);
      }
    }
  }",True,True,The function of this method is to start a test server at a specified port and respond to requests with a constant response.,True,"This code defines a method called `runServer` that starts a test server on a specified port. It listens for incoming connections, reads the request, and sends a constant response back to the client."
13,launchServer(String),launch server response ,Method,testBadHttpServer() testRequestNotStartingWithSlash() testContentLengthNotANumber() testHeaderWithColon() testHeaderSpellChecking() testIgnoreErrorInRedirectPayload() testNoStatusLine() testNoStatusLine() testMultiLineHeader() testOverlongHeader() testChunkedContent() testTruncationMarking() testPartialContentTruncated() testNoContentLimit() testHttpStatusNoMessage(),,org.apache.nutch.protocol.okhttp.TestBadServerResponses+launchServer(byte[]) org.apache.nutch.protocol.okhttp.TestBadServerResponses+launchServer(byte[]) java.lang.String+getBytes(Charset) java.lang.String+getBytes(Charset),java.nio.charset.StandardCharsets+UTF_8,137,3,2,,"private void launchServer(String response) throws InterruptedException {
    launchServer(response.getBytes(StandardCharsets.UTF_8));
  }",True,True,The function of the given method is to launch a server by converting the given response string into bytes using the UTF-8 character encoding and then calling another method to launch the server with the byte array as input.,True,"The given code snippet defines a private method named ""launchServer"" that takes a string parameter ""response"". It converts the response string into bytes using UTF-8 encoding and then calls another overloaded version of the same method with the byte array as an argument. The method throws an InterruptedException."
14,launchServer(byte[]),launch server response ,Method,launchServer(String) testTruncationMarkingGzip(),,"java.lang.Thread+Thread(Runnable) org.apache.nutch.protocol.okhttp.TestBadServerResponses+runServer(int,byte[]) org.apache.nutch.protocol.okhttp.TestBadServerResponses+runServer(int,byte[]) java.lang.Thread+start() java.lang.Thread+start() java.lang.Thread+sleep(long) java.lang.Thread+sleep(long)",org.apache.nutch.protocol.okhttp.TestBadServerResponses+port org.apache.nutch.protocol.okhttp.TestBadServerResponses+LOG,304,11,2,,"private void launchServer(byte[] response) throws InterruptedException {
    Thread serverThread = new Thread(() -> {
      try {
        runServer(port, response);
      } catch (Exception e) {
        LOG.warn(""Test server died:"", e);
      }
    });
    serverThread.start();
    Thread.sleep(50);
  }",False,True,The function of this method is to launch a server in a separate thread and wait for it to start running before continuing execution.,True,"The `launchServer` method launches a server in a separate thread, passing a response as a parameter. It catches any exceptions that occur during the server's execution and logs them as warnings. The method also pauses the main thread for 50 milliseconds before continuing."
15,"fetchPage(String,int)",fetch page page expected code fetches the specified page from the local test server and checks whether the http response status code matches with the expected code param page page to be fetched param expected code http response status code expected while fetching the page ,Method,testBadHttpServer() testRequestNotStartingWithSlash() testContentLengthNotANumber() testHeaderWithColon() testHeaderSpellChecking() testIgnoreErrorInRedirectPayload() testNoStatusLine() testNoStatusLine() testMultiLineHeader() testOverlongHeader() testChunkedContent() testTruncationMarking() testTruncationMarkingGzip() testPartialContentTruncated() testNoContentLimit() testHttpStatusNoMessage(),,"java.net.URL+URL(String,String,int,String) org.apache.nutch.crawl.CrawlDatum+CrawlDatum() org.apache.nutch.protocol.Protocol+getProtocolOutput(Text,CrawlDatum) org.apache.nutch.protocol.Protocol+getProtocolOutput(Text,CrawlDatum) java.net.URL+toString() java.net.URL+toString() org.apache.nutch.crawl.CrawlDatum+getMetaData() org.apache.nutch.crawl.CrawlDatum+getMetaData() java.lang.Integer+parseInt(String) java.lang.Integer+parseInt(String) org.apache.nutch.crawl.CrawlDatum+getMetaData() org.apache.nutch.crawl.CrawlDatum+getMetaData()",org.apache.nutch.protocol.okhttp.TestBadServerResponses+port org.apache.nutch.protocol.okhttp.TestBadServerResponses+LOG org.apache.nutch.protocol.okhttp.TestBadServerResponses+http org.apache.nutch.metadata.Nutch+PROTOCOL_STATUS_CODE_KEY org.apache.nutch.metadata.Nutch+PROTOCOL_STATUS_CODE_KEY,1003,27,2,"/** 
 * Fetches the specified <code>page</code> from the local test server and checks whether the HTTP response status code matches with the expected code.
 * @param page Page to be fetched.
 * @param expectedCode HTTP response status code expected while fetching the page.
 */
","/**
   * Fetches the specified <code>page</code> from the local test server and
   * checks whether the HTTP response status code matches with the expected
   * code.
   * 
   * @param page
   *          Page to be fetched.
   * @param expectedCode
   *          HTTP response status code expected while fetching the page.
   */
  private ProtocolOutput fetchPage(String page, int expectedCode)
      throws MalformedURLException {
    URL url = new URL(""http"", ""127.0.0.1"", port, page);
    LOG.info(""Fetching {}"", url);
    CrawlDatum crawlDatum = new CrawlDatum();
    ProtocolOutput out = http.getProtocolOutput(new Text(url.toString()),
        crawlDatum);
    int httpStatusCode = -1;
    if (crawlDatum.getMetaData().containsKey(Nutch.PROTOCOL_STATUS_CODE_KEY)) {
      httpStatusCode = Integer.parseInt(crawlDatum.getMetaData()
          .get(Nutch.PROTOCOL_STATUS_CODE_KEY).toString());
    }

    assertEquals(""HTTP Status Code for "" + url, expectedCode, httpStatusCode);

    return out;
  }",True,True,This method fetches a specified page from a local test server and checks whether the HTTP response status code matches the expected code. It returns the protocol output.,True,"The code defines a private method called ""fetchPage"" that fetches a specified page from a local test server and checks whether the HTTP response status code matches the expected code. It takes the page URL and expected code as parameters and returns a ProtocolOutput object."
16,testBadHttpServer(),test bad http server ,Method,,,"org.apache.nutch.protocol.okhttp.TestBadServerResponses+setUp() org.apache.nutch.protocol.okhttp.TestBadServerResponses+setUp() org.apache.nutch.protocol.okhttp.TestBadServerResponses+launchServer(String) org.apache.nutch.protocol.okhttp.TestBadServerResponses+launchServer(String) org.apache.nutch.protocol.okhttp.TestBadServerResponses+fetchPage(String,int) org.apache.nutch.protocol.okhttp.TestBadServerResponses+fetchPage(String,int)",org.apache.nutch.protocol.okhttp.TestBadServerResponses+responseHeader org.apache.nutch.protocol.okhttp.TestBadServerResponses+simpleContent,241,8,1,,"@Test
  public void testBadHttpServer() throws Exception {
    setUp();
    // test with trivial well-formed content, to make sure the server is
    // responding
    launchServer(responseHeader + simpleContent);
    fetchPage(""/"", 200);
  }",False,False,"This method is a unit test that checks if a bad HTTP server is responding correctly. It sets up the server, launches it, and fetches a page to ensure it returns a 200 status code.",False,"The code is a test method that verifies the functionality of a bad HTTP server. It sets up the test environment, launches the server with a response header and simple content, and then fetches the root page to ensure a successful response with a status code of 200."
17,testRequestNotStartingWithSlash(),test request not starting with slash nutch 2555 url normalization problem path not starting with a ,Method,,,"org.apache.nutch.protocol.okhttp.TestBadServerResponses+setUp() org.apache.nutch.protocol.okhttp.TestBadServerResponses+setUp() org.apache.nutch.protocol.okhttp.TestBadServerResponses+launchServer(String) org.apache.nutch.protocol.okhttp.TestBadServerResponses+launchServer(String) org.apache.nutch.protocol.okhttp.TestBadServerResponses+fetchPage(String,int) org.apache.nutch.protocol.okhttp.TestBadServerResponses+fetchPage(String,int)",org.apache.nutch.protocol.okhttp.TestBadServerResponses+responseHeader org.apache.nutch.protocol.okhttp.TestBadServerResponses+simpleContent,251,9,1,"/** 
 * NUTCH-2555 URL normalization problem: path not starting with a '/'
 */
","/**
   * NUTCH-2555 URL normalization problem: path not starting with a '/'
   */
  @Test
  public void testRequestNotStartingWithSlash() throws Exception {
    setUp();
    launchServer(responseHeader + simpleContent);
    fetchPage(""?171"", 200);
  }",False,False,The function of the method is to test the behavior of the system when a request is made with a URL that does not start with a '/'.,False,"The code is a test method that checks for a URL normalization problem where the path does not start with a '/'. It sets up a server, launches it with a response header and simple content, and then fetches a page with a query parameter of ""?171"" and expects a 200 response code."
18,testContentLengthNotANumber(),test content length not a number nutch 2564 protocol http throws an error when the content length header is not a number ,Method,,,"org.apache.nutch.protocol.okhttp.TestBadServerResponses+setUp() org.apache.nutch.protocol.okhttp.TestBadServerResponses+setUp() org.apache.nutch.protocol.okhttp.TestBadServerResponses+launchServer(String) org.apache.nutch.protocol.okhttp.TestBadServerResponses+launchServer(String) org.apache.nutch.protocol.okhttp.TestBadServerResponses+fetchPage(String,int) org.apache.nutch.protocol.okhttp.TestBadServerResponses+fetchPage(String,int)",org.apache.nutch.protocol.okhttp.TestBadServerResponses+responseHeader org.apache.nutch.protocol.okhttp.TestBadServerResponses+simpleContent,312,11,1,"/** 
 * NUTCH-2564 protocol-http throws an error when the content-length header is not a number
 */
","/**
   * NUTCH-2564 protocol-http throws an error when the content-length header is
   * not a number
   */
  @Test
  public void testContentLengthNotANumber() throws Exception {
    setUp();
    launchServer(
        responseHeader + ""Content-Length: thousand\r\n"" + simpleContent);
    fetchPage(""/"", 200);
  }",False,False,"The function of the method is to test the behavior of the protocol-http when the content-length header is not a number. It sets up the necessary environment, launches a server with a response containing a non-numeric content-length header, and fetches a page to verify the expected response code.",False,"The given code is a test method named ""testContentLengthNotANumber"" that is part of a larger codebase related to the NUTCH-2564 protocol-http. It sets up a server with a response header containing a content-length value that is not a number (in this case, ""thousand""), and then fetches a page with a 200 status code. The purpose of this test is to verify that the protocol-http handles the scenario where the content-length header is not a number correctly."
19,testHeaderWithColon(),test header with colon nutch 2559 protocol http cannot handle colons after the http status code ,Method,,,"org.apache.nutch.protocol.okhttp.TestBadServerResponses+setUp() org.apache.nutch.protocol.okhttp.TestBadServerResponses+setUp() org.apache.nutch.protocol.okhttp.TestBadServerResponses+launchServer(String) org.apache.nutch.protocol.okhttp.TestBadServerResponses+launchServer(String) org.apache.nutch.protocol.okhttp.TestBadServerResponses+fetchPage(String,int) org.apache.nutch.protocol.okhttp.TestBadServerResponses+fetchPage(String,int)",org.apache.nutch.protocol.okhttp.TestBadServerResponses+simpleContent,288,10,1,"/** 
 * NUTCH-2559 protocol-http cannot handle colons after the HTTP status code
 */
","/**
   * NUTCH-2559 protocol-http cannot handle colons after the HTTP status code
   */
  @Ignore(""Fails with okhttp 3.10.0"")
  @Test
  public void testHeaderWithColon() throws Exception {
    setUp();
    launchServer(""HTTP/1.1 200: OK\r\n"" + simpleContent);
    fetchPage(""/"", 200);
  }",False,False,"The function of the method is to test the handling of HTTP headers with colons in the protocol-http of NUTCH-2559. It sets up the test environment, launches a server with a specific HTTP response, and fetches a page with a 200 status code.",False,"The code is a test method that verifies the behavior of the protocol-http in handling HTTP responses with colons after the status code. It is marked as ignored due to a known failure with okhttp 3.10.0. The method sets up a server with a specific response and then fetches a page, expecting a 200 status code."
20,testHeaderSpellChecking(),test header spell checking nutch 2563 http header spellchecking issues ,Method,,,"org.apache.nutch.protocol.okhttp.TestBadServerResponses+setUp() org.apache.nutch.protocol.okhttp.TestBadServerResponses+setUp() org.apache.nutch.protocol.okhttp.TestBadServerResponses+launchServer(String) org.apache.nutch.protocol.okhttp.TestBadServerResponses+launchServer(String) org.apache.nutch.protocol.okhttp.TestBadServerResponses+fetchPage(String,int) org.apache.nutch.protocol.okhttp.TestBadServerResponses+fetchPage(String,int)",org.apache.nutch.protocol.okhttp.TestBadServerResponses+responseHeader org.apache.nutch.protocol.okhttp.TestBadServerResponses+simpleContent,267,10,1,"/** 
 * NUTCH-2563 HTTP header spellchecking issues
 */
","/**
   * NUTCH-2563 HTTP header spellchecking issues
   */
  @Test
  public void testHeaderSpellChecking() throws Exception {
    setUp();
    launchServer(responseHeader + ""Client-Transfer-Encoding: chunked\r\n""
        + simpleContent);
    fetchPage(""/"", 200);
  }",False,False,"The function of the method is to test the spellchecking of HTTP headers. It sets up the test, launches the server with specific response headers, and fetches a page to check if the spellchecking is working correctly.",False,"The code is a test method named ""testHeaderSpellChecking"" that verifies the spellchecking functionality of HTTP headers. It sets up a server with a specific response header and content, then fetches a page and expects a 200 status code."
21,testIgnoreErrorInRedirectPayload(),test ignore error in redirect payload nutch 2557 protocol http fails to follow redirections when an http response body is invalid ,Method,,,"org.apache.nutch.protocol.okhttp.TestBadServerResponses+setUp() org.apache.nutch.protocol.okhttp.TestBadServerResponses+setUp() org.apache.nutch.protocol.okhttp.TestBadServerResponses+launchServer(String) org.apache.nutch.protocol.okhttp.TestBadServerResponses+launchServer(String) org.apache.nutch.protocol.okhttp.TestBadServerResponses+fetchPage(String,int) org.apache.nutch.protocol.okhttp.TestBadServerResponses+fetchPage(String,int) org.apache.nutch.protocol.okhttp.TestBadServerResponses+getHeader(ProtocolOutput,String) org.apache.nutch.protocol.okhttp.TestBadServerResponses+getHeader(ProtocolOutput,String) org.apache.nutch.protocol.okhttp.TestBadServerResponses+getHeader(ProtocolOutput,String) org.apache.nutch.protocol.okhttp.TestBadServerResponses+getHeader(ProtocolOutput,String)",,619,15,1,"/** 
 * NUTCH-2557 protocol-http fails to follow redirections when an HTTP response body is invalid
 */
","/**
   * NUTCH-2557 protocol-http fails to follow redirections when an HTTP response
   * body is invalid
   */
  @Ignore(""Fails with okhttp 3.10.0"")
  @Test
  public void testIgnoreErrorInRedirectPayload() throws Exception {
    setUp();
    launchServer(""HTTP/1.1 302 Found\r\nLocation: http://example.com/\r\n""
        + ""Transfer-Encoding: chunked\r\n\r\nNot a valid chunk."");
    ProtocolOutput fetched = fetchPage(""/"", 302);
    assertNotNull(""No redirect Location."", getHeader(fetched, ""Location""));
    assertEquals(""Wrong redirect Location."", ""http://example.com/"",
        getHeader(fetched, ""Location""));
  }",False,False,The function of the method is to test the behavior of the protocol-http when encountering a redirection with an invalid HTTP response body.,False,"The code is a test method that checks if the protocol-http correctly follows redirections when the HTTP response body is invalid. It launches a server with a 302 Found response and a non-valid chunk in the body, then fetches the page and asserts that the redirect location is correct."
22,testNoStatusLine(),test no status line nutch 2558 protocol http cannot handle a missing http status line ,Method,,,"org.apache.nutch.protocol.okhttp.TestBadServerResponses+setUp() org.apache.nutch.protocol.okhttp.TestBadServerResponses+setUp() org.apache.nutch.protocol.okhttp.TestBadServerResponses+launchServer(String) org.apache.nutch.protocol.okhttp.TestBadServerResponses+launchServer(String) org.apache.nutch.protocol.okhttp.TestBadServerResponses+fetchPage(String,int) org.apache.nutch.protocol.okhttp.TestBadServerResponses+fetchPage(String,int) java.lang.String+String(byte[],Charset) org.apache.nutch.protocol.Content+getContent() org.apache.nutch.protocol.ProtocolOutput+getContent() org.apache.nutch.protocol.ProtocolOutput+getContent() org.apache.nutch.protocol.Content+getContent() java.net.ServerSocket+close() java.net.ServerSocket+close() org.apache.nutch.protocol.okhttp.TestBadServerResponses+launchServer(String) org.apache.nutch.protocol.okhttp.TestBadServerResponses+launchServer(String) org.apache.nutch.protocol.okhttp.TestBadServerResponses+fetchPage(String,int) org.apache.nutch.protocol.okhttp.TestBadServerResponses+fetchPage(String,int) java.lang.String+String(byte[],Charset) org.apache.nutch.protocol.Content+getContent() org.apache.nutch.protocol.ProtocolOutput+getContent() org.apache.nutch.protocol.ProtocolOutput+getContent() org.apache.nutch.protocol.Content+getContent()",java.nio.charset.StandardCharsets+UTF_8 org.apache.nutch.protocol.okhttp.TestBadServerResponses+server java.nio.charset.StandardCharsets+UTF_8,1032,23,1,"/** 
 * NUTCH-2558 protocol-http cannot handle a missing HTTP status line
 */
","/**
   * NUTCH-2558 protocol-http cannot handle a missing HTTP status line
   */
  @Ignore(""Fails with okhttp 3.10.0"")
  @Test
  public void testNoStatusLine() throws Exception {
    setUp();
    String text = ""This is a text containing non-ASCII characters: \u00e4\u00f6\u00fc\u00df"";
    launchServer(text);
    ProtocolOutput fetched = fetchPage(""/"", 200);
    assertEquals(""Wrong text returned for response with no status line."", text,
        new String(fetched.getContent().getContent(), StandardCharsets.UTF_8));
    server.close();
    text = ""<!DOCTYPE html>\n<html>\n<head>\n""
        + ""<title>Testing no HTTP header ‚Äö√Ñ√∂‚àö√ë‚àö‚àÇ‚Äö√†√∂‚Äö√Ñ‚Ä†‚Äö√†√∂‚Äö√†√á¬¨¬®¬¨¬Æ‚Äö√†√∂‚àö√∫‚Äö√Ñ√∂‚àö√ë‚àö‚àÇ‚Äö√†√∂‚Äö√Ñ‚Ä†‚Äö√†√∂‚Äö√†√á¬¨¬®¬¨¬Æ¬¨¬®¬¨¬©‚Äö√Ñ√∂‚àö√ë‚àö‚àÇ‚Äö√†√∂‚Äö√Ñ‚Ä†‚Äö√†√∂‚Äö√†√á¬¨¬®¬¨¬Æ¬¨¬®¬¨¬¢</title>\n""
        + ""<meta charset=\""utf-8\"">\n""
        + ""</head>\n<body>This is a text containing non-ASCII characters:""
        + ""\u00e4\u00f6\u00fc\u00df</body>\n</html"";
    launchServer(text);
    fetched = fetchPage(""/"", 200);
    assertEquals(""Wrong text returned for response with no status line."", text,
        new String(fetched.getContent().getContent(), StandardCharsets.UTF_8));
  }",False,False,"The function of the given method is to test the behavior of the protocol-http when handling a missing HTTP status line. It sets up a server, sends a request to fetch a page, and asserts that the returned content matches the expected text.",False,"The code is a test method that verifies the behavior of the `fetchPage` method when handling a response with no HTTP status line. It launches a server with a given text, fetches the page using `fetchPage` method, and asserts that the returned content matches the expected text."
23,testMultiLineHeader(),test multi line header nutch 2560 protocol http throws an error when an http header spans over multiple lines ,Method,,,"org.apache.nutch.protocol.okhttp.TestBadServerResponses+setUp() org.apache.nutch.protocol.okhttp.TestBadServerResponses+setUp() org.apache.nutch.protocol.okhttp.TestBadServerResponses+launchServer(String) org.apache.nutch.protocol.okhttp.TestBadServerResponses+launchServer(String) org.apache.nutch.protocol.okhttp.TestBadServerResponses+fetchPage(String,int) org.apache.nutch.protocol.okhttp.TestBadServerResponses+fetchPage(String,int) org.apache.nutch.protocol.okhttp.TestBadServerResponses+getHeaders(ProtocolOutput) org.apache.nutch.protocol.okhttp.TestBadServerResponses+getHeaders(ProtocolOutput) org.apache.nutch.protocol.okhttp.TestBadServerResponses+getHeader(ProtocolOutput,String) org.apache.nutch.protocol.okhttp.TestBadServerResponses+getHeader(ProtocolOutput,String) java.lang.String+contains(CharSequence) org.apache.nutch.protocol.okhttp.TestBadServerResponses+getHeader(ProtocolOutput,String) org.apache.nutch.protocol.okhttp.TestBadServerResponses+getHeader(ProtocolOutput,String) java.lang.String+contains(CharSequence)",org.apache.nutch.protocol.okhttp.TestBadServerResponses+responseHeader org.apache.nutch.protocol.okhttp.TestBadServerResponses+simpleContent org.apache.nutch.protocol.okhttp.TestBadServerResponses+LOG,703,18,1,"/** 
 * NUTCH-2560 protocol-http throws an error when an http header spans over multiple lines
 */
","/**
   * NUTCH-2560 protocol-http throws an error when an http header spans over
   * multiple lines
   */
  @Ignore(""Fails with okhttp 3.10.0"")
  @Test
  public void testMultiLineHeader() throws Exception {
    setUp();
    launchServer(responseHeader
        + ""Set-Cookie: UserID=JohnDoe;\r\n  Max-Age=3600;\r\n  Version=1\r\n""
        + simpleContent);
    ProtocolOutput fetched = fetchPage(""/"", 200);
    LOG.info(""Headers: {}"", getHeaders(fetched));
    assertNotNull(""Failed to set multi-line \""Set-Cookie\"" header."",
        getHeader(fetched, ""Set-Cookie""));
    assertTrue(""Failed to set multi-line \""Set-Cookie\"" header."",
        getHeader(fetched, ""Set-Cookie"").contains(""Version=1""));
  }",False,False,"The function of this method is to test the behavior of the protocol-http when an HTTP header spans over multiple lines. It sets up a server with a response header containing a multi-line ""Set-Cookie"" header, fetches a page, and checks if the ""Set-Cookie"" header is correctly set with the expected value.",False,"The code is a test method that verifies the behavior of the `testMultiLineHeader` method. It sets up a server with a response header containing a multi-line ""Set-Cookie"" header and fetches the page. It then checks if the fetched page contains the expected multi-line ""Set-Cookie"" header with the specified version."
24,testOverlongHeader(),test overlong header nutch 2561 protocol http can be made to read arbitrarily large http responses ,Method,,,"org.apache.nutch.protocol.okhttp.TestBadServerResponses+setUp() org.apache.nutch.protocol.okhttp.TestBadServerResponses+setUp() java.lang.StringBuilder+StringBuilder() java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(char) java.lang.StringBuilder+append(char) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) org.apache.nutch.protocol.okhttp.TestBadServerResponses+launchServer(String) org.apache.nutch.protocol.okhttp.TestBadServerResponses+launchServer(String) java.lang.StringBuilder+toString() java.lang.StringBuilder+toString() org.apache.nutch.protocol.okhttp.TestBadServerResponses+fetchPage(String,int) org.apache.nutch.protocol.okhttp.TestBadServerResponses+fetchPage(String,int)",org.apache.nutch.protocol.okhttp.TestBadServerResponses+responseHeader org.apache.nutch.protocol.okhttp.TestBadServerResponses+simpleContent,620,20,1,"/** 
 * NUTCH-2561 protocol-http can be made to read arbitrarily large HTTP responses
 */
","/**
   * NUTCH-2561 protocol-http can be made to read arbitrarily large HTTP
   * responses
   */
  public void testOverlongHeader() throws Exception {
    setUp();
    StringBuilder response = new StringBuilder();
    response.append(responseHeader);
    for (int i = 0; i < 80; i++) {
      response.append(""X-Custom-Header-"");
      for (int j = 0; j < 10000; j++) {
        response.append('x');
      }
      response.append("": hello\r\n"");
    }
    response.append(""\r\n"" + simpleContent);
    launchServer(response.toString());
    // should throw exception because of overlong header
    fetchPage(""/"", -1);
  }",False,False,The function of the method is to test the ability of the protocol-http to read HTTP responses that have arbitrarily large headers. It does this by creating a response with overlong headers and launching a server to handle the response. The method then fetches a page and expects an exception to be thrown due to the overlong header.,False,The code is a test method that checks if the protocol-http can handle reading large HTTP responses. It creates a response with overlong headers and launches a server with that response. It then fetches a page and expects an exception to be thrown due to the overlong header.
25,testChunkedContent(),test chunked content nutch 2562 protocol http fails to read large chunked http responses nutch 2575 protocol http does not respect the maximum content size for chunked responses also test whether truncations of chunked content are properly marked ,Method,,,"org.apache.nutch.protocol.okhttp.TestBadServerResponses+setUp() org.apache.nutch.protocol.okhttp.TestBadServerResponses+setUp() java.lang.StringBuilder+StringBuilder() java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(Object) java.lang.StringBuilder+append(Object) java.lang.String+format(String,Object[]) java.lang.String+format(String,Object[]) java.lang.StringBuilder+append(char) java.lang.StringBuilder+append(char) java.lang.StringBuilder+append(Object) java.lang.StringBuilder+append(Object) java.lang.String+format(String,Object[]) java.lang.String+format(String,Object[]) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) org.apache.nutch.protocol.okhttp.TestBadServerResponses+launchServer(String) org.apache.nutch.protocol.okhttp.TestBadServerResponses+launchServer(String) java.lang.StringBuilder+toString() java.lang.StringBuilder+toString() org.apache.nutch.protocol.okhttp.TestBadServerResponses+fetchPage(String,int) org.apache.nutch.protocol.okhttp.TestBadServerResponses+fetchPage(String,int) org.apache.nutch.protocol.Content+getContent() org.apache.nutch.protocol.ProtocolOutput+getContent() org.apache.nutch.protocol.ProtocolOutput+getContent() org.apache.nutch.protocol.Content+getContent() org.apache.nutch.metadata.Metadata+get(String) org.apache.nutch.protocol.Content+getMetadata() org.apache.nutch.protocol.ProtocolOutput+getContent() org.apache.nutch.protocol.ProtocolOutput+getContent() org.apache.nutch.protocol.Content+getMetadata() org.apache.nutch.metadata.Metadata+get(String) org.apache.nutch.metadata.Metadata+get(String) org.apache.nutch.protocol.Content+getMetadata() org.apache.nutch.protocol.ProtocolOutput+getContent() org.apache.nutch.protocol.ProtocolOutput+getContent() org.apache.nutch.protocol.Content+getMetadata() org.apache.nutch.metadata.Metadata+get(String)",org.apache.nutch.protocol.okhttp.TestBadServerResponses+responseHeader org.apache.nutch.net.protocols.Response+TRUNCATED_CONTENT org.apache.nutch.net.protocols.Response+TruncatedContentReason org.apache.nutch.net.protocols.Response+TRUNCATED_CONTENT_REASON,1527,35,1,"/** 
 * NUTCH-2562 protocol-http fails to read large chunked HTTP responses, NUTCH-2575 protocol-http does not respect the maximum content-size for chunked responses. Also test whether truncations of chunked content are properly marked.
 */
","/**
   * NUTCH-2562 protocol-http fails to read large chunked HTTP responses,
   * NUTCH-2575 protocol-http does not respect the maximum content-size for
   * chunked responses. Also test whether truncations of chunked content are
   * properly marked.
   */
  @Test
  public void testChunkedContent() throws Exception {
    setUp();
    StringBuilder response = new StringBuilder();
    response.append(responseHeader);
    response.append(""Content-Type: text/html\r\n"");
    response.append(""Transfer-Encoding: chunked\r\n"");
    // 81920 bytes (80 chunks, 1024 bytes each)
    // > 65536 (http.content.limit defined in nutch-site-test.xml)
    for (int i = 0; i < 80; i++) {
      response.append(String.format(""\r\n400\r\n%02x\r\n"", i));
      for (int j = 0; j < 1012; j++) {
        response.append('x');
      }
      response.append(String.format(""\r\n%02x\r\n"", i));
      response.append(""\r\n"");
    }
    response.append(""\r\n0\r\n\r\n"");
    launchServer(response.toString());
    ProtocolOutput fetched = fetchPage(""/"", 200);
    assertEquals(
        ""Chunked content not truncated according to http.content.limit"", 65536,
        fetched.getContent().getContent().length);
    assertNotNull(""Content truncation not marked"",
        fetched.getContent().getMetadata().get(Response.TRUNCATED_CONTENT));
    assertEquals(""Content truncation not marked"",
        Response.TruncatedContentReason.LENGTH.toString().toLowerCase(),
        fetched.getContent().getMetadata().get(Response.TRUNCATED_CONTENT_REASON));
  }",False,False,"The function of the given method is to test the behavior of the protocol-http in handling large chunked HTTP responses. It checks whether the protocol properly reads and respects the maximum content size for chunked responses, and whether truncations of chunked content are correctly marked.",False,"The code is a unit test that verifies the behavior of the `testChunkedContent()` method. It tests whether the `protocol-http` correctly handles large chunked HTTP responses, respects the maximum content size for chunked responses, and properly marks truncations of chunked content."
26,testTruncationMarking(),test truncation marking nutch 2729 check for http content limit defined in nutch site test xml whether content is truncated to the configured 64 k b and whether it is properly marked as truncated ,Method,,,"org.apache.nutch.protocol.okhttp.TestBadServerResponses+setUp() org.apache.nutch.protocol.okhttp.TestBadServerResponses+setUp() java.lang.StringBuilder+StringBuilder() java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) org.apache.nutch.protocol.okhttp.TestBadServerResponses+launchServer(String) org.apache.nutch.protocol.okhttp.TestBadServerResponses+launchServer(String) java.lang.StringBuilder+toString() java.lang.StringBuilder+toString() org.apache.nutch.protocol.okhttp.TestBadServerResponses+fetchPage(String,int) org.apache.nutch.protocol.okhttp.TestBadServerResponses+fetchPage(String,int) java.lang.Math+min(int,int) java.lang.Math+min(int,int) org.apache.nutch.protocol.Content+getContent() org.apache.nutch.protocol.ProtocolOutput+getContent() org.apache.nutch.protocol.ProtocolOutput+getContent() org.apache.nutch.protocol.Content+getContent() org.apache.nutch.metadata.Metadata+get(String) org.apache.nutch.protocol.Content+getMetadata() org.apache.nutch.protocol.ProtocolOutput+getContent() org.apache.nutch.protocol.ProtocolOutput+getContent() org.apache.nutch.protocol.Content+getMetadata() org.apache.nutch.metadata.Metadata+get(String) org.apache.nutch.metadata.Metadata+get(String) org.apache.nutch.protocol.Content+getMetadata() org.apache.nutch.protocol.ProtocolOutput+getContent() org.apache.nutch.protocol.ProtocolOutput+getContent() org.apache.nutch.protocol.Content+getMetadata() org.apache.nutch.metadata.Metadata+get(String) java.net.ServerSocket+close() java.net.ServerSocket+close()",org.apache.nutch.protocol.okhttp.TestBadServerResponses+responseHeader org.apache.nutch.net.protocols.Response+TRUNCATED_CONTENT org.apache.nutch.net.protocols.Response+TruncatedContentReason org.apache.nutch.net.protocols.Response+TRUNCATED_CONTENT_REASON org.apache.nutch.protocol.okhttp.TestBadServerResponses+server,1504,35,1,"/** 
 * NUTCH-2729 Check for http.content.limit defined in nutch-site-test.xml: whether content is truncated to the configured 64 kB and whether it is properly marked as truncated.
 */
","/**
   * NUTCH-2729 Check for http.content.limit defined in nutch-site-test.xml:
   * whether content is truncated to the configured 64 kB and whether it is
   * properly marked as truncated.
   */
  @Test
  public void testTruncationMarking() throws Exception {
    setUp();
    int[] kBs = { 63, 64, 65 };
    for (int kB : kBs) {
      StringBuilder response = new StringBuilder();
      response.append(responseHeader);
      response.append(""Content-Type: text/plain\r\nContent-Length: ""
          + (kB * 1024) + ""\r\n\r\n"");
      for (int i = 0; i < kB; i++) {
        for (int j = 0; j < 16; j++) {
          // 16 chunks a 64 bytes = 1 kB
          response.append(
              ""abcdefghijklmnopqurstuvxyz0123456789-ABCDEFGHIJKLMNOPQURSTUVXYZ\n"");
        }
      }
      launchServer(response.toString());
      ProtocolOutput fetched = fetchPage(""/"", 200);
      assertEquals(""Content not truncated according to http.content.limit"",
          Math.min(kB * 1024, 65536), fetched.getContent().getContent().length);
      if (kB * 1024 > 65536) {
        assertNotNull(""Content truncation not marked"",
            fetched.getContent().getMetadata().get(Response.TRUNCATED_CONTENT));
        assertEquals(""Content truncation not marked"",
            Response.TruncatedContentReason.LENGTH.toString().toLowerCase(),
            fetched.getContent().getMetadata().get(Response.TRUNCATED_CONTENT_REASON));
      }
      server.close(); // need to close server before next loop iteration
    }
  }",False,False,"The function of this method is to test whether the content of a webpage is properly truncated to a configured limit of 64 kB and whether it is marked as truncated. It does this by creating a response with a specified content length, launching a server with the response, fetching the page, and then checking if the content is truncated and marked correctly.",False,The code is a test method that checks if content is properly truncated and marked as truncated according to the configured limit. It iterates over different content lengths and verifies if the content is truncated correctly and if the truncation is marked with the appropriate metadata.
27,testTruncationMarkingGzip(),test truncation marking gzip nutch 2729 check for http content limit defined in nutch site test xml whether content is truncated to the configured 64 k b and whether it is properly marked as truncated ,Method,,,"org.apache.nutch.protocol.okhttp.TestBadServerResponses+setUp() org.apache.nutch.protocol.okhttp.TestBadServerResponses+setUp() java.lang.StringBuilder+StringBuilder() java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.io.ByteArrayOutputStream+ByteArrayOutputStream() java.util.zip.GZIPOutputStream+GZIPOutputStream(OutputStream) java.io.FilterOutputStream+write(byte[]) java.io.FilterOutputStream+write(byte[]) java.lang.String+getBytes(Charset) java.lang.StringBuilder+toString() java.lang.StringBuilder+toString() java.lang.String+getBytes(Charset) java.util.zip.DeflaterOutputStream+close() java.util.zip.DeflaterOutputStream+close() java.lang.StringBuilder+StringBuilder() java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.io.ByteArrayOutputStream+size() java.io.ByteArrayOutputStream+size() java.io.ByteArrayOutputStream+ByteArrayOutputStream() java.io.OutputStream+write(byte[]) java.io.OutputStream+write(byte[]) java.lang.String+getBytes(Charset) java.lang.StringBuilder+toString() java.lang.StringBuilder+toString() java.lang.String+getBytes(Charset) java.io.OutputStream+write(byte[]) java.io.OutputStream+write(byte[]) java.io.ByteArrayOutputStream+toByteArray() java.io.ByteArrayOutputStream+toByteArray() org.apache.nutch.protocol.okhttp.TestBadServerResponses+launchServer(byte[]) org.apache.nutch.protocol.okhttp.TestBadServerResponses+launchServer(byte[]) java.io.ByteArrayOutputStream+toByteArray() java.io.ByteArrayOutputStream+toByteArray() org.apache.nutch.protocol.okhttp.TestBadServerResponses+fetchPage(String,int) org.apache.nutch.protocol.okhttp.TestBadServerResponses+fetchPage(String,int) java.lang.Math+min(int,int) java.lang.Math+min(int,int) org.apache.nutch.protocol.Content+getContent() org.apache.nutch.protocol.ProtocolOutput+getContent() org.apache.nutch.protocol.ProtocolOutput+getContent() org.apache.nutch.protocol.Content+getContent() org.apache.nutch.metadata.Metadata+get(String) org.apache.nutch.protocol.Content+getMetadata() org.apache.nutch.protocol.ProtocolOutput+getContent() org.apache.nutch.protocol.ProtocolOutput+getContent() org.apache.nutch.protocol.Content+getMetadata() org.apache.nutch.metadata.Metadata+get(String) org.apache.nutch.metadata.Metadata+get(String) org.apache.nutch.protocol.Content+getMetadata() org.apache.nutch.protocol.ProtocolOutput+getContent() org.apache.nutch.protocol.ProtocolOutput+getContent() org.apache.nutch.protocol.Content+getMetadata() org.apache.nutch.metadata.Metadata+get(String) java.net.ServerSocket+close() java.net.ServerSocket+close()",java.nio.charset.StandardCharsets+UTF_8 org.apache.nutch.protocol.okhttp.TestBadServerResponses+responseHeader java.nio.charset.StandardCharsets+UTF_8 org.apache.nutch.net.protocols.Response+TRUNCATED_CONTENT org.apache.nutch.net.protocols.Response+TruncatedContentReason org.apache.nutch.net.protocols.Response+TRUNCATED_CONTENT_REASON org.apache.nutch.protocol.okhttp.TestBadServerResponses+server,2007,44,1,"/** 
 * NUTCH-2729 Check for http.content.limit defined in nutch-site-test.xml: whether content is truncated to the configured 64 kB and whether it is properly marked as truncated.
 */
","/**
   * NUTCH-2729 Check for http.content.limit defined in nutch-site-test.xml:
   * whether content is truncated to the configured 64 kB and whether it is
   * properly marked as truncated.
   */
  @Test
  public void testTruncationMarkingGzip() throws Exception {
    setUp();
    int[] kBs = { 63, 64, 65 };
    for (int kB : kBs) {
      StringBuilder payload = new StringBuilder();
      for (int i = 0; i < kB; i++) {
        for (int j = 0; j < 16; j++) {
          // 16 chunks a 64 bytes = 1 kB
          payload.append(
              ""abcdefghijklmnopqurstuvxyz0123456789-ABCDEFGHIJKLMNOPQURSTUVXYZ\n"");
        }
      }
      ByteArrayOutputStream bytes = new ByteArrayOutputStream();
      GZIPOutputStream gzip = new GZIPOutputStream(bytes);
      gzip.write(payload.toString().getBytes(StandardCharsets.UTF_8));
      gzip.close();
      StringBuilder responseHead = new StringBuilder();
      responseHead.append(responseHeader);
      responseHead.append(""Content-Type: text/plain\r\nContent-Length: ""
          + bytes.size() + ""\r\nContent-Encoding: gzip\r\n\r\n"");
      ByteArrayOutputStream response = new ByteArrayOutputStream();
      response.write(responseHead.toString().getBytes(StandardCharsets.UTF_8));
      response.write(bytes.toByteArray());

      launchServer(response.toByteArray());
      ProtocolOutput fetched = fetchPage(""/"", 200);
      assertEquals(""Content not truncated according to http.content.limit"",
          Math.min(kB * 1024, 65536), fetched.getContent().getContent().length);
      if (kB * 1024 > 65536) {
        assertNotNull(""Content truncation not marked"",
            fetched.getContent().getMetadata().get(Response.TRUNCATED_CONTENT));
        assertEquals(""Content truncation not marked"",
            Response.TruncatedContentReason.LENGTH.toString().toLowerCase(),
            fetched.getContent().getMetadata().get(Response.TRUNCATED_CONTENT_REASON));
      }
      server.close(); // need to close server before next loop iteration
    }
  }",False,False,"The function of this method is to test whether the content of a webpage is properly truncated to a configured limit of 64 kB and whether it is marked as truncated. It does this by creating a payload of a specified size, compressing it using GZIP, and then simulating a server response with the compressed payload. The method then fetches the webpage and checks if the content length matches the expected truncation limit. If the content length exceeds the limit, it also checks if the truncation is properly marked.",False,"The code is a test method that checks if content is properly truncated and marked as truncated when the configured content limit is reached. It creates a payload of varying sizes, compresses it using GZIP, and sends it as a response to a server. The method then fetches the page and verifies if the content length is truncated correctly and if the truncation is marked appropriately."
28,testPartialContentTruncated(),test partial content truncated force an exception after all content has been fetched by sending a wrong content length header and check whether the content is stored anyway if http partial truncated true ,Method,,,"org.apache.nutch.protocol.okhttp.TestBadServerResponses+setUp() org.apache.nutch.protocol.okhttp.TestBadServerResponses+setUp() org.apache.nutch.protocol.okhttp.TestBadServerResponses+launchServer(String) org.apache.nutch.protocol.okhttp.TestBadServerResponses+launchServer(String) org.apache.nutch.protocol.okhttp.TestBadServerResponses+fetchPage(String,int) org.apache.nutch.protocol.okhttp.TestBadServerResponses+fetchPage(String,int) java.lang.String+String(byte[],Charset) org.apache.nutch.protocol.Content+getContent() org.apache.nutch.protocol.ProtocolOutput+getContent() org.apache.nutch.protocol.ProtocolOutput+getContent() org.apache.nutch.protocol.Content+getContent() org.apache.nutch.metadata.Metadata+get(String) org.apache.nutch.protocol.Content+getMetadata() org.apache.nutch.protocol.ProtocolOutput+getContent() org.apache.nutch.protocol.ProtocolOutput+getContent() org.apache.nutch.protocol.Content+getMetadata() org.apache.nutch.metadata.Metadata+get(String)",org.apache.nutch.protocol.okhttp.TestBadServerResponses+conf org.apache.nutch.protocol.okhttp.TestBadServerResponses+http org.apache.nutch.protocol.okhttp.TestBadServerResponses+conf org.apache.nutch.protocol.okhttp.TestBadServerResponses+responseHeader java.nio.charset.StandardCharsets+UTF_8 org.apache.nutch.net.protocols.Response+TRUNCATED_CONTENT,824,19,1,"/** 
 * Force an exception after all content has been fetched by sending a wrong `Content-Length` header and check whether the content is stored anyway if http.partial.truncated == true
 */
","/**
   * Force an exception after all content has been fetched by sending a wrong
   * `Content-Length` header and check whether the content is stored anyway if
   * http.partial.truncated == true
   */
  @Test
  public void testPartialContentTruncated() throws Exception {
    setUp();
    conf.setBoolean(""http.partial.truncated"", true);
    http.setConf(conf);
    String testContent = ""This is a text."";
    launchServer(
        responseHeader + ""Content-Length: 50000\r\n\r\n"" + testContent);
    ProtocolOutput fetched = fetchPage(""/"", 200);
    assertEquals(""Content not saved as truncated"", testContent,
        new String(fetched.getContent().getContent(), StandardCharsets.UTF_8));
    assertNotNull(""Content truncation not marked"",
        fetched.getContent().getMetadata().get(Response.TRUNCATED_CONTENT));
  }",False,False,"The function of the method is to test whether the content is stored even if a wrong `Content-Length` header is sent, and the `http.partial.truncated` property is set to true. It launches a server with a response containing a specified test content, fetches the page, and checks if the content is saved as truncated and marked as such.",False,"The code is a test method that checks whether content is stored correctly even if the `Content-Length` header is incorrect and the `http.partial.truncated` configuration property is set to true. It launches a server with a response containing a specific content length, fetches the page, and verifies that the content is saved correctly and marked as truncated if necessary."
29,testNoContentLimit(),test no content limit ,Method,,,"org.apache.nutch.protocol.okhttp.TestBadServerResponses+setUp() org.apache.nutch.protocol.okhttp.TestBadServerResponses+setUp() java.lang.StringBuilder+StringBuilder() java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) org.apache.nutch.protocol.okhttp.TestBadServerResponses+launchServer(String) org.apache.nutch.protocol.okhttp.TestBadServerResponses+launchServer(String) java.lang.StringBuilder+toString() java.lang.StringBuilder+toString() org.apache.nutch.protocol.okhttp.TestBadServerResponses+fetchPage(String,int) org.apache.nutch.protocol.okhttp.TestBadServerResponses+fetchPage(String,int) org.apache.nutch.protocol.Content+getContent() org.apache.nutch.protocol.ProtocolOutput+getContent() org.apache.nutch.protocol.ProtocolOutput+getContent() org.apache.nutch.protocol.Content+getContent()",org.apache.nutch.protocol.okhttp.TestBadServerResponses+conf org.apache.nutch.protocol.okhttp.TestBadServerResponses+http org.apache.nutch.protocol.okhttp.TestBadServerResponses+conf org.apache.nutch.protocol.okhttp.TestBadServerResponses+responseHeader,907,24,1,,"@Test
  public void testNoContentLimit() throws Exception {
    setUp();
    conf.setInt(""http.content.limit"", -1);
    http.setConf(conf);
    StringBuilder response = new StringBuilder();
    response.append(responseHeader);
    // Even 128 kB content shouldn't cause any truncation because
    // http.content.limit == -1
    int kB = 128;
    response.append(""Content-Type: text/plain\r\nContent-Length: "" + (kB * 1024)
        + ""\r\n\r\n"");
    for (int i = 0; i < kB; i++) {
      for (int j = 0; j < 16; j++) {
        // 16 chunks a 64 bytes = 1 kB
        response.append(
            ""abcdefghijklmnopqurstuvxyz0123456789-ABCDEFGHIJKLMNOPQURSTUVXYZ\n"");
      }
    }
    launchServer(response.toString());
    ProtocolOutput fetched = fetchPage(""/"", 200);
    assertEquals(""Content truncated although http.content.limit == -1"",
        (kB * 1024), fetched.getContent().getContent().length);
  }",False,False,"The function of this method is to test that there is no content limit when fetching a page. It sets up the necessary configurations, creates a response with a specified content length, launches a server with the response, fetches the page, and asserts that the content length matches the expected value.",False,"The code is a JUnit test method that tests the behavior of a web server when the content limit is set to -1, indicating no limit. It sets up the server with a response containing a large amount of content and verifies that the content is not truncated by comparing its length to the expected length."
30,testHttpStatusNoMessage(),test http status no message nutch 2763 store http headers add whitespace in status line after status code also when message is empty ,Method,,,"org.apache.nutch.protocol.okhttp.TestBadServerResponses+setUp() org.apache.nutch.protocol.okhttp.TestBadServerResponses+setUp() org.apache.nutch.protocol.okhttp.TestBadServerResponses+launchServer(String) org.apache.nutch.protocol.okhttp.TestBadServerResponses+launchServer(String) org.apache.nutch.protocol.okhttp.TestBadServerResponses+fetchPage(String,int) org.apache.nutch.protocol.okhttp.TestBadServerResponses+fetchPage(String,int) java.lang.String+startsWith(String) org.apache.nutch.protocol.okhttp.TestBadServerResponses+getHeaders(ProtocolOutput) org.apache.nutch.protocol.okhttp.TestBadServerResponses+getHeaders(ProtocolOutput) java.lang.String+startsWith(String)",org.apache.nutch.protocol.okhttp.TestBadServerResponses+simpleContent,551,14,1,"/** 
 * NUTCH-2763 store.http.headers: add whitespace in status line after status code also when message is empty
 */
","/**
   * NUTCH-2763 store.http.headers: add whitespace in status line after status
   * code also when message is empty
   */
  @Test
  public void testHttpStatusNoMessage() throws Exception {
    setUp();
    String statusLineNoMessage = ""HTTP/1.1 200 \r\n"";
    launchServer(statusLineNoMessage + simpleContent);
    ProtocolOutput fetched = fetchPage(""/"", 200);
    assertTrue(
        ""Invalid HTTP status line (see NUTCH-2763, missing whitespace between status code and message)"",
        getHeaders(fetched).startsWith(statusLineNoMessage));
  }",False,False,"The function of the given method is to test the behavior of the HTTP status line when the message is empty. It sets up the necessary environment, launches a server with a specific status line, fetches a page, and checks if the HTTP status line is valid.",False,"The code is a test method that verifies the behavior of the HTTP status line in a specific scenario. It sets up a server with a given status line and content, fetches a page from the server, and checks if the retrieved HTTP headers start with the expected status line. This test is related to a bug fix for adding whitespace in the status line after the status code, even when the message is empty."
