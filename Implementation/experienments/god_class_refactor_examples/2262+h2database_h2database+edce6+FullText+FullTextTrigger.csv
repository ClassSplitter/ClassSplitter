index,name,document,type,inner invocations,external invocations,calls,visits,length,lines,modifier,commit,full text,moved,removed,gpt text,gpt response,code summary
1,TRIGGER_PREFIX,trigger prefix ,Field,,,,,51,1,26,,"private static final String TRIGGER_PREFIX = ""FT_"";",False,False,,False,
2,SCHEMA,schema ,Field,,,,,42,1,26,,"private static final String SCHEMA = ""FT"";",False,False,,False,
3,FIELD_QUERY,field query the column name of the result set returned by the search method ,Field,,,,,138,4,26,"/** 
 * The column name of the result set returned by the search method.
 */
","/**
     * The column name of the result set returned by the search method.
     */
    private static final String FIELD_QUERY = ""QUERY"";",False,False,"/** 
 * The column name of the result set returned by the search method.
 */
",False,"/** 
 * The column name of the result set returned by the search method.
 */
"
4,FIELD_SCHEMA,field schema a column name of the result set returned by the search data method ,Field,,,,,142,4,26,"/** 
 * A column name of the result set returned by the searchData method.
 */
","/**
     * A column name of the result set returned by the searchData method.
     */
    private static final String FIELD_SCHEMA = ""SCHEMA"";",False,False,"/** 
 * A column name of the result set returned by the searchData method.
 */
",False,"/** 
 * A column name of the result set returned by the searchData method.
 */
"
5,FIELD_TABLE,field table a column name of the result set returned by the search data method ,Field,,,,,140,4,26,"/** 
 * A column name of the result set returned by the searchData method.
 */
","/**
     * A column name of the result set returned by the searchData method.
     */
    private static final String FIELD_TABLE = ""TABLE"";",False,False,"/** 
 * A column name of the result set returned by the searchData method.
 */
",False,"/** 
 * A column name of the result set returned by the searchData method.
 */
"
6,FIELD_COLUMNS,field columns a column name of the result set returned by the search data method ,Field,,,,,144,4,26,"/** 
 * A column name of the result set returned by the searchData method.
 */
","/**
     * A column name of the result set returned by the searchData method.
     */
    private static final String FIELD_COLUMNS = ""COLUMNS"";",False,False,"/** 
 * A column name of the result set returned by the searchData method.
 */
",False,"/** 
 * A column name of the result set returned by the searchData method.
 */
"
7,FIELD_KEYS,field keys a column name of the result set returned by the search data method ,Field,,,,,138,4,26,"/** 
 * A column name of the result set returned by the searchData method.
 */
","/**
     * A column name of the result set returned by the searchData method.
     */
    private static final String FIELD_KEYS = ""KEYS"";",False,False,"/** 
 * A column name of the result set returned by the searchData method.
 */
",False,"/** 
 * A column name of the result set returned by the searchData method.
 */
"
8,setting,setting ,Field,,,,,33,1,2,,private FullTextSettings setting;,True,True,,False,
9,index,index ,Field,,,,,24,1,2,,private IndexInfo index;,True,True,,False,
10,dataTypes,data types ,Field,,,,,24,1,2,,private int[] dataTypes;,False,True,,False,
11,prepInsertWord,prep insert word ,Field,,,,,71,1,2,,"private PreparedStatement prepInsertWord, prepInsertRow, prepInsertMap;",False,True,,False,
12,prepInsertRow,prep insert row ,Field,,,,,71,1,2,,"private PreparedStatement prepInsertWord, prepInsertRow, prepInsertMap;",True,True,,False,
13,prepInsertMap,prep insert map ,Field,,,,,71,1,2,,"private PreparedStatement prepInsertWord, prepInsertRow, prepInsertMap;",True,True,,False,
14,prepDeleteRow,prep delete row ,Field,,,,,55,1,2,,"private PreparedStatement prepDeleteRow, prepDeleteMap;",True,True,,False,
15,prepDeleteMap,prep delete map ,Field,,,,,55,1,2,,"private PreparedStatement prepDeleteRow, prepDeleteMap;",False,True,,False,
16,prepSelectRow,prep select row ,Field,,,,,40,1,2,,private PreparedStatement prepSelectRow;,True,True,,False,
17,"createIndex(Connection,String,String,String)",create index conn schema table column list create a new full text index for a table and column list each table may only have one index at any time param conn the connection param schema the schema name of the table case sensitive param table the table name case sensitive param column list the column list null for all columns ,Method,,org.h2.test.db.TestFullText+testCreateDrop(),"org.h2.fulltext.FullText+init(Connection) org.h2.fulltext.FullText+init(Connection) java.sql.Connection+prepareStatement(String) java.sql.Connection+prepareStatement(String) java.sql.PreparedStatement+setString(int,String) java.sql.PreparedStatement+setString(int,String) java.sql.PreparedStatement+setString(int,String) java.sql.PreparedStatement+setString(int,String) java.sql.PreparedStatement+setString(int,String) java.sql.PreparedStatement+setString(int,String) java.sql.PreparedStatement+execute() java.sql.PreparedStatement+execute() org.h2.fulltext.FullText+createTrigger(Connection,String,String) org.h2.fulltext.FullText+createTrigger(Connection,String,String) org.h2.fulltext.FullText+indexExistingRows(Connection,String,String) org.h2.fulltext.FullText+indexExistingRows(Connection,String,String)",org.h2.fulltext.FullText+SCHEMA,877,20,9,"/** 
 * Create a new full text index for a table and column list. Each table may only have one index at any time.
 * @param conn the connection
 * @param schema the schema name of the table (case sensitive)
 * @param table the table name (case sensitive)
 * @param columnList the column list (null for all columns)
 */
","/**
     * Create a new full text index for a table and column list. Each table may
     * only have one index at any time.
     *
     * @param conn the connection
     * @param schema the schema name of the table (case sensitive)
     * @param table the table name (case sensitive)
     * @param columnList the column list (null for all columns)
     */
    public static void createIndex(Connection conn, String schema, String table, String columnList) throws SQLException {
        init(conn);
        PreparedStatement prep = conn.prepareStatement(""INSERT INTO "" + SCHEMA
                + "".INDEXES(SCHEMA, TABLE, COLUMNS) VALUES(?, ?, ?)"");
        prep.setString(1, schema);
        prep.setString(2, table);
        prep.setString(3, columnList);
        prep.execute();
        createTrigger(conn, schema, table);
        indexExistingRows(conn, schema, table);
    }",False,False,"This method creates a new full text index for a specified table and column list. It inserts the index information into a database table, creates a trigger, and indexes existing rows in the table.",False,"This code creates a new full text index for a specified table and column list. It inserts the index information into a database table, creates a trigger, and indexes existing rows in the table."
18,"dropIndex(Connection,String,String)",drop index conn schema table drop an existing full text index for a table this method returns silently if no index for this table exists param conn the connection param schema the schema name of the table case sensitive param table the table name case sensitive ,Method,,org.h2.test.db.TestFullText+testCreateDrop(),"org.h2.fulltext.FullText+init(Connection) org.h2.fulltext.FullText+init(Connection) java.sql.Connection+prepareStatement(String) java.sql.Connection+prepareStatement(String) java.sql.PreparedStatement+setString(int,String) java.sql.PreparedStatement+setString(int,String) java.sql.PreparedStatement+setString(int,String) java.sql.PreparedStatement+setString(int,String) java.sql.PreparedStatement+executeQuery() java.sql.PreparedStatement+executeQuery() java.sql.ResultSet+next() java.sql.ResultSet+next() java.sql.ResultSet+getInt(int) java.sql.ResultSet+getInt(int) java.sql.Connection+prepareStatement(String) java.sql.Connection+prepareStatement(String) java.sql.PreparedStatement+setInt(int,int) java.sql.PreparedStatement+setInt(int,int) java.sql.PreparedStatement+execute() java.sql.PreparedStatement+execute() org.h2.fulltext.FullText+createOrDropTrigger(Connection,String,String,boolean) org.h2.fulltext.FullText+createOrDropTrigger(Connection,String,String,boolean) java.sql.Connection+prepareStatement(String) java.sql.Connection+prepareStatement(String) java.sql.PreparedStatement+setInt(int,int) java.sql.PreparedStatement+setInt(int,int) java.sql.PreparedStatement+executeUpdate() java.sql.PreparedStatement+executeUpdate() java.sql.Connection+prepareStatement(String) java.sql.Connection+prepareStatement(String) java.sql.PreparedStatement+executeUpdate() java.sql.PreparedStatement+executeUpdate()",org.h2.fulltext.FullText+SCHEMA org.h2.fulltext.FullText+SCHEMA org.h2.fulltext.FullText+SCHEMA org.h2.fulltext.FullText+SCHEMA org.h2.fulltext.FullText+SCHEMA,1628,42,9,"/** 
 * Drop an existing full text index for a table. This method returns silently if no index for this table exists.
 * @param conn the connection
 * @param schema the schema name of the table (case sensitive)
 * @param table the table name (case sensitive)
 */
","/**
     * Drop an existing full text index for a table. This method returns
     * silently if no index for this table exists.
     *
     * @param conn the connection
     * @param schema the schema name of the table (case sensitive)
     * @param table the table name (case sensitive)
     */
    public static void dropIndex(Connection conn, String schema, String table) throws SQLException {
        init(conn);
        PreparedStatement prep = conn.prepareStatement(""SELECT ID FROM "" + SCHEMA
                + "".INDEXES WHERE SCHEMA=? AND TABLE=?"");
        prep.setString(1, schema);
        prep.setString(2, table);
        ResultSet rs = prep.executeQuery();
        if (!rs.next()) {
            return;
        }
        int indexId = rs.getInt(1);
        prep = conn.prepareStatement(""DELETE FROM "" + SCHEMA
                + "".INDEXES WHERE ID=?"");
        prep.setInt(1, indexId);
        prep.execute();
        createOrDropTrigger(conn, schema, table, false);
        prep = conn.prepareStatement(""DELETE FROM "" + SCHEMA +
                "".ROWS WHERE INDEXID=? AND ROWNUM<10000"");
        while (true) {
            prep.setInt(1, indexId);
            int deleted = prep.executeUpdate();
            if (deleted == 0) {
                break;
            }
        }
        prep = conn.prepareStatement(""DELETE FROM "" + SCHEMA + "".MAP M "" +
                ""WHERE NOT EXISTS (SELECT * FROM "" + SCHEMA + "".ROWS R WHERE R.ID=M.ROWID) AND ROWID<10000"");
        while (true) {
            int deleted = prep.executeUpdate();
            if (deleted == 0) {
                break;
            }
        }
    }",False,False,"The function of this method is to drop an existing full text index for a table. It checks if an index exists for the specified table, and if so, it deletes the index and associated rows and maps.",False,"This code defines a method called `dropIndex` that drops an existing full-text index for a table in a database. It first checks if the index exists, deletes the index, deletes related rows and mappings, and finally drops a trigger associated with the index."
19,"createTrigger(Connection,String,String)",create trigger conn schema table ,Method,"createIndex(Connection,String,String,String) reindex(Connection)",,"org.h2.fulltext.FullText+createOrDropTrigger(Connection,String,String,boolean) org.h2.fulltext.FullText+createOrDropTrigger(Connection,String,String,boolean)",,163,3,10,,"private static void createTrigger(Connection conn, String schema, String table) throws SQLException {
        createOrDropTrigger(conn, schema, table, true);
    }",False,False,"The function of the given method is to create a trigger in a database table using the provided connection, schema, and table name.",False,"The code snippet defines a private static method called ""createTrigger"" that takes a database connection, schema, and table as parameters. It calls another method called ""createOrDropTrigger"" with the same parameters and a boolean value of true, indicating that a trigger should be created. The method throws a SQLException if an error occurs."
20,"createOrDropTrigger(Connection,String,String,boolean)",create or drop trigger conn schema table create ,Method,"dropIndex(Connection,String,String) createTrigger(Connection,String,String)",,java.sql.Connection+createStatement() java.sql.Connection+createStatement() org.h2.util.StringUtils+quoteIdentifier(String) org.h2.util.StringUtils+quoteIdentifier(String) org.h2.util.StringUtils+quoteIdentifier(String) org.h2.util.StringUtils+quoteIdentifier(String) java.sql.Statement+execute(String) java.sql.Statement+execute(String) java.lang.StringBuffer+StringBuffer(String) java.lang.StringBuffer+append(String) java.lang.StringBuffer+append(String) java.lang.StringBuffer+append(String) java.lang.StringBuffer+append(String) java.lang.StringBuffer+append(String) java.lang.StringBuffer+append(String) org.h2.util.StringUtils+quoteIdentifier(String) org.h2.util.StringUtils+quoteIdentifier(String) org.h2.util.StringUtils+quoteIdentifier(String) org.h2.util.StringUtils+quoteIdentifier(String) java.lang.StringBuffer+append(String) java.lang.StringBuffer+append(String) java.lang.StringBuffer+append(String) java.lang.StringBuffer+append(String) java.lang.Class+getName() java.lang.Class+getName() java.lang.StringBuffer+append(String) java.lang.StringBuffer+append(String) java.sql.Statement+execute(String) java.sql.Statement+execute(String) java.lang.StringBuffer+toString() java.lang.StringBuffer+toString(),org.h2.fulltext.FullText+TRIGGER_PREFIX,866,16,10,,"private static void createOrDropTrigger(Connection conn, String schema, String table, boolean create) throws SQLException {
        Statement stat = conn.createStatement();
        String trigger = StringUtils.quoteIdentifier(schema) + "".""
                + StringUtils.quoteIdentifier(TRIGGER_PREFIX + table);
        stat.execute(""DROP TRIGGER IF EXISTS "" + trigger);
        if (create) {
            StringBuffer buff = new StringBuffer(""CREATE TRIGGER IF NOT EXISTS "");
            buff.append(trigger);
            buff.append("" AFTER INSERT, UPDATE, DELETE ON "");
            buff.append(StringUtils.quoteIdentifier(schema) + ""."" + StringUtils.quoteIdentifier(table));
            buff.append("" FOR EACH ROW CALL \"""");
            buff.append(FullText.class.getName());
            buff.append(""\"""");
            stat.execute(buff.toString());
        }
    }",False,False,"This method creates or drops a trigger in a database schema and table. It takes a connection, schema name, table name, and a boolean flag indicating whether to create or drop the trigger. If the flag is true, it creates the trigger using the FullText class. If the flag is false, it drops the trigger if it exists.",False,"This code defines a method called `createOrDropTrigger` that takes a database connection, schema name, table name, and a boolean flag as parameters. It drops an existing trigger if it exists and creates a new trigger if the `create` flag is true. The trigger is created to execute the `FullText` class after an insert, update, or delete operation on the specified schema and table."
21,"indexExistingRows(Connection,String,String)",index existing rows conn schema table ,Method,"createIndex(Connection,String,String,String) reindex(Connection)",,"org.h2.fulltext.FullText+FullText() org.h2.fulltext.FullText+init(Connection,String,String,String,boolean,int) org.h2.fulltext.FullText+init(Connection,String,String,String,boolean,int) java.lang.StringBuffer+StringBuffer(String) java.lang.StringBuffer+append(String) java.lang.StringBuffer+append(String) org.h2.util.StringUtils+quoteIdentifier(String) org.h2.util.StringUtils+quoteIdentifier(String) org.h2.util.StringUtils+quoteIdentifier(String) org.h2.util.StringUtils+quoteIdentifier(String) java.sql.Statement+executeQuery(String) java.sql.Connection+createStatement() java.sql.Connection+createStatement() java.sql.Statement+executeQuery(String) java.lang.StringBuffer+toString() java.lang.StringBuffer+toString() java.sql.ResultSetMetaData+getColumnCount() java.sql.ResultSet+getMetaData() java.sql.ResultSet+getMetaData() java.sql.ResultSetMetaData+getColumnCount() java.sql.ResultSet+next() java.sql.ResultSet+next() java.sql.ResultSet+getObject(int) java.sql.ResultSet+getObject(int) org.h2.fulltext.FullText+fire(Connection,Object[],Object[]) org.h2.fulltext.FullText+fire(Connection,Object[],Object[])",org.h2.api.Trigger+INSERT,769,15,10,,"private static void indexExistingRows(Connection conn, String schema, String table) throws SQLException {
        FullText existing = new FullText();
        existing.init(conn, schema, null, table, false, INSERT);
        StringBuffer buff = new StringBuffer(""SELECT * FROM "");
        buff.append(StringUtils.quoteIdentifier(schema) + ""."" + StringUtils.quoteIdentifier(table));
        ResultSet rs = conn.createStatement().executeQuery(buff.toString());
        int columnCount = rs.getMetaData().getColumnCount();
        while (rs.next()) {
            Object[] row = new Object[columnCount];
            for (int i = 0; i < columnCount; i++) {
                row[i] = rs.getObject(i + 1);
            }
            existing.fire(conn, null, row);
        }
    }",False,False,"This method indexes existing rows in a database table for full-text search. It retrieves the rows from the specified schema and table, and then iterates through each row to extract the column values. Finally, it calls the ""fire"" method of the ""existing"" object to index the row.",False,"This code is a method that indexes existing rows in a database table using a FullText object. It retrieves the rows from the table, creates an array of objects for each row, and then calls the fire method of the FullText object to index the row."
22,reindex(Connection),reindex conn re creates the full text index for this database param conn the connection ,Method,,,"org.h2.fulltext.FullText+init(Connection) org.h2.fulltext.FullText+init(Connection) org.h2.fulltext.FullText+removeAllTriggers(Connection) org.h2.fulltext.FullText+removeAllTriggers(Connection) org.h2.fulltext.FullTextSettings+getInstance(Connection) org.h2.fulltext.FullTextSettings+getInstance(Connection) java.util.HashMap+clear() org.h2.fulltext.FullTextSettings+getWordList() org.h2.fulltext.FullTextSettings+getWordList() java.util.HashMap+clear() java.sql.Connection+createStatement() java.sql.Connection+createStatement() java.sql.Statement+execute(String) java.sql.Statement+execute(String) java.sql.Statement+execute(String) java.sql.Statement+execute(String) java.sql.Statement+execute(String) java.sql.Statement+execute(String) java.sql.Statement+executeQuery(String) java.sql.Statement+executeQuery(String) java.sql.ResultSet+next() java.sql.ResultSet+next() java.sql.ResultSet+getString(String) java.sql.ResultSet+getString(String) java.sql.ResultSet+getString(String) java.sql.ResultSet+getString(String) org.h2.fulltext.FullText+createTrigger(Connection,String,String) org.h2.fulltext.FullText+createTrigger(Connection,String,String) org.h2.fulltext.FullText+indexExistingRows(Connection,String,String) org.h2.fulltext.FullText+indexExistingRows(Connection,String,String)",org.h2.fulltext.FullText+SCHEMA org.h2.fulltext.FullText+SCHEMA org.h2.fulltext.FullText+SCHEMA org.h2.fulltext.FullText+SCHEMA,898,22,9,"/** 
 * Re-creates the full text index for this database
 * @param conn the connection
 */
","/**
     * Re-creates the full text index for this database
     *
     * @param conn the connection
     */
    public static void reindex(Connection conn) throws SQLException {
        init(conn);
        removeAllTriggers(conn);
        FullTextSettings setting = FullTextSettings.getInstance(conn);
        setting.getWordList().clear();
        Statement stat = conn.createStatement();
        stat.execute(""TRUNCATE TABLE "" + SCHEMA + "".WORDS"");
        stat.execute(""TRUNCATE TABLE "" + SCHEMA + "".ROWS"");
        stat.execute(""TRUNCATE TABLE "" + SCHEMA + "".MAP"");
        ResultSet rs = stat.executeQuery(""SELECT * FROM "" + SCHEMA + "".INDEXES"");
        while (rs.next()) {
            String schema = rs.getString(""SCHEMA"");
            String table = rs.getString(""TABLE"");
            createTrigger(conn, schema, table);
            indexExistingRows(conn, schema, table);
        }
    }",False,False,"The function of this method is to re-create the full text index for a database. It initializes the connection, removes all triggers, clears the word list, truncates the WORDS, ROWS, and MAP tables, and then selects all indexes from the INDEXES table to create triggers and index existing rows.",False,"This code is a method called ""reindex"" that re-creates the full text index for a database. It takes a connection as a parameter, initializes the necessary settings, removes all triggers, clears the word list, truncates certain tables, and then loops through the indexes to create triggers and index existing rows."
23,"setIgnoreList(Connection,String)",set ignore list conn comma separated list change the ignore list the ignore list is a comma separated list of common words that must not be indexed the default ignore list is empty if indexes already exist at the time this list is changed reindex must be called param conn the connection param comma separated list the list ,Method,,,"org.h2.fulltext.FullText+init(Connection) org.h2.fulltext.FullText+init(Connection) org.h2.fulltext.FullTextSettings+getInstance(Connection) org.h2.fulltext.FullTextSettings+getInstance(Connection) org.h2.fulltext.FullText+setIgnoreList(FullTextSettings,String) org.h2.fulltext.FullText+setIgnoreList(FullTextSettings,String) java.sql.Connection+createStatement() java.sql.Connection+createStatement() java.sql.Statement+execute(String) java.sql.Statement+execute(String) java.sql.Connection+prepareStatement(String) java.sql.Connection+prepareStatement(String) java.sql.PreparedStatement+setString(int,String) java.sql.PreparedStatement+setString(int,String) java.sql.PreparedStatement+execute() java.sql.PreparedStatement+execute()",org.h2.fulltext.FullText+SCHEMA org.h2.fulltext.FullText+SCHEMA,892,19,9,"/** 
 * Change the ignore list. The ignore list is a comma separated list of common words that must not be indexed. The default ignore list is empty. If indexes already exist at the time this list is changed, reindex must be called.
 * @param conn the connection
 * @param commaSeparatedList the list
 */
","/**
     * Change the ignore list. The ignore list is a comma separated list of
     * common words that must not be indexed. The default ignore list is empty.
     * If indexes already exist at the time this list is changed, reindex must
     * be called.
     *
     * @param conn the connection
     * @param commaSeparatedList the list
     */
    public static void setIgnoreList(Connection conn, String commaSeparatedList) throws SQLException {
        init(conn);
        FullTextSettings setting = FullTextSettings.getInstance(conn);
        setIgnoreList(setting, commaSeparatedList);
        Statement stat = conn.createStatement();
        stat.execute(""TRUNCATE TABLE "" + SCHEMA + "".IGNORELIST"");
        PreparedStatement prep = conn.prepareStatement(""INSERT INTO "" + SCHEMA + "".IGNORELIST VALUES(?)"");
        prep.setString(1, commaSeparatedList);
        prep.execute();
    }",False,True,"The function of this method is to change the ignore list for indexing. It takes a connection and a comma-separated list of common words as parameters. It initializes the connection, sets the ignore list, truncates the IGNORELIST table, and inserts the new ignore list into the table.",False,"This code defines a method called `setIgnoreList` that allows the user to change the ignore list of common words that should not be indexed. It initializes the necessary settings, truncates the existing ignore list table, and inserts the new comma-separated list into the table."
24,"setIgnoreList(FullTextSettings,String)",set ignore list setting comma separated list ,Method,"setIgnoreList(Connection,String) init(Connection)",,"org.h2.util.StringUtils+arraySplit(String,char,boolean) org.h2.util.StringUtils+arraySplit(String,char,boolean) org.h2.fulltext.FullTextSettings+getIgnoreList() org.h2.fulltext.FullTextSettings+getIgnoreList() org.h2.fulltext.FullTextSettings+convertWord(String) org.h2.fulltext.FullTextSettings+convertWord(String) java.util.HashSet+add(E) java.util.HashSet+add(E)",,439,11,10,,"private static void setIgnoreList(FullTextSettings setting, String commaSeparatedList) {
        String[] list = StringUtils.arraySplit(commaSeparatedList, ',', true);
        HashSet set = setting.getIgnoreList();
        for (int i = 0; i < list.length; i++) {
            String word = list[i];
            word = setting.convertWord(word);
            if (word != null) {
                set.add(list[i]);
            }
        }
    }",False,True,"This method sets the ignore list in the FullTextSettings object. It splits the comma-separated list into an array, converts each word using the setting's convertWord method, and adds non-null words to the ignore list.",False,"The code defines a private static method called ""setIgnoreList"" that takes in a FullTextSettings object and a comma-separated list of words. It splits the list into an array, converts each word using a convertWord method from the FullTextSettings object, and adds the converted words to a HashSet if they are not null."
25,removeAllTriggers(Connection),remove all triggers conn ,Method,reindex(Connection) dropAll(Connection),,java.sql.Connection+createStatement() java.sql.Connection+createStatement() java.sql.Statement+executeQuery(String) java.sql.Statement+executeQuery(String) java.sql.Connection+createStatement() java.sql.Connection+createStatement() java.sql.ResultSet+next() java.sql.ResultSet+next() java.sql.ResultSet+getString(String) java.sql.ResultSet+getString(String) java.sql.ResultSet+getString(String) java.sql.ResultSet+getString(String) java.lang.String+startsWith(String) java.lang.String+startsWith(String) org.h2.util.StringUtils+quoteIdentifier(String) org.h2.util.StringUtils+quoteIdentifier(String) org.h2.util.StringUtils+quoteIdentifier(String) org.h2.util.StringUtils+quoteIdentifier(String) java.sql.Statement+execute(String) java.sql.Statement+execute(String),org.h2.fulltext.FullText+TRIGGER_PREFIX,644,13,10,,"private static void removeAllTriggers(Connection conn) throws SQLException {
        Statement stat = conn.createStatement();
        ResultSet rs = stat.executeQuery(""SELECT * FROM INFORMATION_SCHEMA.TRIGGERS"");
        Statement stat2 = conn.createStatement();
        while (rs.next()) {
            String schema = rs.getString(""TRIGGER_SCHEMA"");
            String name = rs.getString(""TRIGGER_NAME"");
            if (name.startsWith(TRIGGER_PREFIX)) {
                name = StringUtils.quoteIdentifier(schema) + ""."" + StringUtils.quoteIdentifier(name);
                stat2.execute(""DROP TRIGGER "" + name);
            }
        }
    }",False,True,"The function of this method is to remove all triggers from a database connection by executing a SQL query to select all triggers from the INFORMATION_SCHEMA.TRIGGERS table, and then dropping each trigger that has a name starting with a specified prefix.",False,The code defines a method called `removeAllTriggers` that takes a `Connection` object as a parameter. It retrieves all triggers from the database using a SQL query and drops any triggers that have a name starting with a specific prefix.
26,dropAll(Connection),drop all conn drops all full text indexes from the database param conn the connection ,Method,,,org.h2.fulltext.FullText+init(Connection) org.h2.fulltext.FullText+init(Connection) java.sql.Connection+createStatement() java.sql.Connection+createStatement() java.sql.Statement+execute(String) java.sql.Statement+execute(String) org.h2.fulltext.FullText+removeAllTriggers(Connection) org.h2.fulltext.FullText+removeAllTriggers(Connection) org.h2.fulltext.FullTextSettings+getInstance(Connection) org.h2.fulltext.FullTextSettings+getInstance(Connection) org.h2.fulltext.FullTextSettings+removeAllIndexes() org.h2.fulltext.FullTextSettings+removeAllIndexes() java.util.HashSet+clear() org.h2.fulltext.FullTextSettings+getIgnoreList() org.h2.fulltext.FullTextSettings+getIgnoreList() java.util.HashSet+clear() java.util.HashMap+clear() org.h2.fulltext.FullTextSettings+getWordList() org.h2.fulltext.FullTextSettings+getWordList() java.util.HashMap+clear(),org.h2.fulltext.FullText+SCHEMA,528,15,9,"/** 
 * Drops all full text indexes from the database.
 * @param conn the connection
 */
","/**
     * Drops all full text indexes from the database.
     *
     * @param conn the connection
     */
    public static void dropAll(Connection conn) throws SQLException {
        init(conn);
        Statement stat = conn.createStatement();
        stat.execute(""DROP SCHEMA IF EXISTS "" + SCHEMA);
        removeAllTriggers(conn);
        FullTextSettings setting = FullTextSettings.getInstance(conn);
        setting.removeAllIndexes();
        setting.getIgnoreList().clear();
        setting.getWordList().clear();
    }",False,True,"The function of this method is to drop all full text indexes from the database. It initializes the connection, creates a statement, and executes SQL commands to drop the schema, remove all triggers, and clear the full text settings.",False,"The given code is a method named ""dropAll"" that is used to drop all full text indexes from a database. It takes a connection as a parameter and performs various operations such as dropping a schema, removing triggers, and clearing settings related to full text indexes."
27,init(Connection),init conn initializes full text search functionality for this database this adds the following java functions to the database ft create index schema name string table name string column list string ft search query string limit int offset int result set ft reindex ft drop all it also adds a schema fulltext to the database where bookkeeping information is stored this function may be called from a java application or by using the sql statements create alias if not exists fulltext init for quot org h2 fulltext full text init quot call fulltext init param conn the connection ,Method,"createIndex(Connection,String,String,String) dropIndex(Connection,String,String) reindex(Connection) setIgnoreList(Connection,String) dropAll(Connection)",,"java.sql.Connection+createStatement() java.sql.Connection+createStatement() java.sql.Statement+execute(String) java.sql.Statement+execute(String) java.sql.Statement+execute(String) java.sql.Statement+execute(String) java.sql.Statement+execute(String) java.sql.Statement+execute(String) java.sql.Statement+execute(String) java.sql.Statement+execute(String) java.sql.Statement+execute(String) java.sql.Statement+execute(String) java.sql.Statement+execute(String) java.sql.Statement+execute(String) java.sql.Statement+execute(String) java.sql.Statement+execute(String) java.lang.Class+getName() java.lang.Class+getName() java.sql.Statement+execute(String) java.sql.Statement+execute(String) java.lang.Class+getName() java.lang.Class+getName() java.sql.Statement+execute(String) java.sql.Statement+execute(String) java.lang.Class+getName() java.lang.Class+getName() java.sql.Statement+execute(String) java.sql.Statement+execute(String) java.lang.Class+getName() java.lang.Class+getName() java.sql.Statement+execute(String) java.sql.Statement+execute(String) java.lang.Class+getName() java.lang.Class+getName() java.sql.Statement+execute(String) java.sql.Statement+execute(String) java.lang.Class+getName() java.lang.Class+getName() org.h2.fulltext.FullTextSettings+getInstance(Connection) org.h2.fulltext.FullTextSettings+getInstance(Connection) java.sql.Statement+executeQuery(String) java.sql.Statement+executeQuery(String) java.sql.ResultSet+next() java.sql.ResultSet+next() java.sql.ResultSet+getString(int) java.sql.ResultSet+getString(int) org.h2.fulltext.FullText+setIgnoreList(FullTextSettings,String) org.h2.fulltext.FullText+setIgnoreList(FullTextSettings,String) java.sql.Statement+executeQuery(String) java.sql.Statement+executeQuery(String) org.h2.fulltext.FullTextSettings+getWordList() org.h2.fulltext.FullTextSettings+getWordList() java.sql.ResultSet+next() java.sql.ResultSet+next() java.sql.ResultSet+getString(String) java.sql.ResultSet+getString(String) java.sql.ResultSet+getInt(String) java.sql.ResultSet+getInt(String) org.h2.fulltext.FullTextSettings+convertWord(String) org.h2.fulltext.FullTextSettings+convertWord(String) java.util.HashMap+put(K,V) java.util.HashMap+put(K,V) org.h2.util.ObjectUtils+getInteger(int) org.h2.util.ObjectUtils+getInteger(int)",org.h2.fulltext.FullText+SCHEMA org.h2.fulltext.FullText+SCHEMA org.h2.fulltext.FullText+SCHEMA org.h2.fulltext.FullText+SCHEMA org.h2.fulltext.FullText+SCHEMA org.h2.fulltext.FullText+SCHEMA org.h2.fulltext.FullText+SCHEMA org.h2.fulltext.FullText+SCHEMA,3118,57,9,"/** 
 * Initializes full text search functionality for this database. This adds the following Java functions to the database: <ul> <li>FT_CREATE_INDEX(schemaNameString, tableNameString, columnListString) </li><li>FT_SEARCH(queryString, limitInt, offsetInt): result set </li><li>FT_REINDEX() </li><li>FT_DROP_ALL() </li></ul> It also adds a schema FULLTEXT to the database where bookkeeping information is stored. This function may be called from a Java application, or by using the SQL statements: <pre> CREATE ALIAS IF NOT EXISTS FULLTEXT_INIT FOR &quot;org.h2.fulltext.FullText.init&quot;; CALL FULLTEXT_INIT(); </pre>
 * @param conn the connection
 */
","/**
     * Initializes full text search functionality for this database. This adds
     * the following Java functions to the database:
     * <ul>
     * <li>FT_CREATE_INDEX(schemaNameString, tableNameString, columnListString)
     * </li><li>FT_SEARCH(queryString, limitInt, offsetInt): result set
     * </li><li>FT_REINDEX()
     * </li><li>FT_DROP_ALL()
     * </li></ul>
     * It also adds a schema FULLTEXT to the database where bookkeeping
     * information is stored. This function may be called from a Java
     * application, or by using the SQL statements:
     * <pre>
     * CREATE ALIAS IF NOT EXISTS FULLTEXT_INIT FOR
     *      &quot;org.h2.fulltext.FullText.init&quot;;
     * CALL FULLTEXT_INIT();
     * </pre>
     *
     * @param conn the connection
     */
    public static void init(Connection conn) throws SQLException {
        Statement stat = conn.createStatement();
        stat.execute(""CREATE SCHEMA IF NOT EXISTS "" + SCHEMA);
        stat.execute(""CREATE TABLE IF NOT EXISTS "" + SCHEMA
                        + "".INDEXES(ID INT AUTO_INCREMENT PRIMARY KEY, SCHEMA VARCHAR, TABLE VARCHAR, COLUMNS VARCHAR, UNIQUE(SCHEMA, TABLE))"");
        stat.execute(""CREATE TABLE IF NOT EXISTS "" + SCHEMA
                + "".WORDS(ID INT AUTO_INCREMENT PRIMARY KEY, NAME VARCHAR, UNIQUE(NAME))"");
        stat.execute(""CREATE TABLE IF NOT EXISTS "" + SCHEMA
                + "".ROWS(ID IDENTITY, HASH INT, INDEXID INT, KEY VARCHAR, UNIQUE(HASH, INDEXID, KEY))"");

        stat.execute(""CREATE TABLE IF NOT EXISTS "" + SCHEMA
                        + "".MAP(ROWID INT, WORDID INT, PRIMARY KEY(WORDID, ROWID))"");

        stat.execute(""CREATE TABLE IF NOT EXISTS "" + SCHEMA + "".IGNORELIST(LIST VARCHAR)"");
        stat.execute(""CREATE ALIAS IF NOT EXISTS FT_CREATE_INDEX FOR \"""" + FullText.class.getName() + "".createIndex\"""");
        stat.execute(""CREATE ALIAS IF NOT EXISTS FT_DROP_INDEX FOR \"""" + FullText.class.getName() + "".dropIndex\"""");
        stat.execute(""CREATE ALIAS IF NOT EXISTS FT_SEARCH FOR \"""" + FullText.class.getName() + "".search\"""");
        stat.execute(""CREATE ALIAS IF NOT EXISTS FT_SEARCH_DATA FOR \"""" + FullText.class.getName() + "".searchData\"""");
        stat.execute(""CREATE ALIAS IF NOT EXISTS FT_REINDEX FOR \"""" + FullText.class.getName() + "".reindex\"""");
        stat.execute(""CREATE ALIAS IF NOT EXISTS FT_DROP_ALL FOR \"""" + FullText.class.getName() + "".dropAll\"""");
        FullTextSettings setting = FullTextSettings.getInstance(conn);
        ResultSet rs = stat.executeQuery(""SELECT * FROM "" + SCHEMA + "".IGNORELIST"");
        while (rs.next()) {
            String commaSeparatedList = rs.getString(1);
            setIgnoreList(setting, commaSeparatedList);
        }
        rs = stat.executeQuery(""SELECT * FROM "" + SCHEMA + "".WORDS"");
        HashMap map = setting.getWordList();
        while (rs.next()) {
            String word = rs.getString(""NAME"");
            int id = rs.getInt(""ID"");
            word = setting.convertWord(word);
            if (word != null) {
                map.put(word, ObjectUtils.getInteger(id));
            }
        }
    }",False,True,"The function of this method is to initialize full text search functionality for a database. It creates necessary tables and schemas, adds Java functions to the database, and sets up bookkeeping information.",False,The `init` method initializes full text search functionality for a database by creating necessary tables and aliases. It also retrieves and sets the ignore list and word list from the database.
28,"init(Connection,String,String,String,boolean,int)",init conn schema name trigger name table name before type interna l ,Method,"indexExistingRows(Connection,String,String)",,"org.h2.fulltext.FullTextSettings+getInstance(Connection) org.h2.fulltext.FullTextSettings+getInstance(Connection) java.util.ArrayList+ArrayList() java.sql.Connection+getMetaData() java.sql.Connection+getMetaData() java.sql.DatabaseMetaData+getColumns(String,String,String,String) java.sql.DatabaseMetaData+getColumns(String,String,String,String) java.util.ArrayList+ArrayList() java.sql.ResultSet+next() java.sql.ResultSet+next() java.util.ArrayList+add(E) java.util.ArrayList+add(E) java.sql.ResultSet+getString(String) java.sql.ResultSet+getString(String) java.util.ArrayList+size() java.util.ArrayList+size() org.h2.fulltext.IndexInfo+IndexInfo() java.util.ArrayList+size() java.util.ArrayList+size() java.util.ArrayList+toArray(T[]) java.util.ArrayList+toArray(T[]) java.sql.DatabaseMetaData+getColumns(String,String,String,String) java.sql.DatabaseMetaData+getColumns(String,String,String,String) java.sql.ResultSet+next() java.sql.ResultSet+next() java.sql.ResultSet+getInt(String) java.sql.ResultSet+getInt(String) java.util.ArrayList+size() java.util.ArrayList+size() java.sql.DatabaseMetaData+getPrimaryKeys(String,String,String) java.sql.DatabaseMetaData+getPrimaryKeys(String,String,String) java.sql.ResultSet+next() java.sql.ResultSet+next() java.util.ArrayList+add(E) java.util.ArrayList+add(E) java.sql.ResultSet+getString(String) java.sql.ResultSet+getString(String) java.util.ArrayList+size() java.util.ArrayList+size() java.sql.SQLException+SQLException(String) java.util.ArrayList+ArrayList() java.sql.Connection+prepareStatement(String) java.sql.Connection+prepareStatement(String) java.sql.PreparedStatement+setString(int,String) java.sql.PreparedStatement+setString(int,String) java.sql.PreparedStatement+setString(int,String) java.sql.PreparedStatement+setString(int,String) java.sql.PreparedStatement+executeQuery() java.sql.PreparedStatement+executeQuery() java.sql.ResultSet+next() java.sql.ResultSet+next() java.sql.ResultSet+getInt(int) java.sql.ResultSet+getInt(int) java.sql.ResultSet+getString(int) java.sql.ResultSet+getString(int) org.h2.util.StringUtils+arraySplit(String,char,boolean) org.h2.util.StringUtils+arraySplit(String,char,boolean) java.util.ArrayList+add(E) java.util.ArrayList+add(E) java.util.ArrayList+size() java.util.ArrayList+size() java.util.ArrayList+addAll(Collection) java.util.ArrayList+addAll(Collection) java.util.ArrayList+size() java.util.ArrayList+size() org.h2.fulltext.FullText+setColumns(int[],ArrayList,ArrayList) org.h2.fulltext.FullText+setColumns(int[],ArrayList,ArrayList) java.util.ArrayList+size() java.util.ArrayList+size() org.h2.fulltext.FullText+setColumns(int[],ArrayList,ArrayList) org.h2.fulltext.FullText+setColumns(int[],ArrayList,ArrayList) org.h2.fulltext.FullTextSettings+addIndexInfo(IndexInfo) org.h2.fulltext.FullTextSettings+addIndexInfo(IndexInfo) java.sql.Connection+prepareStatement(String) java.sql.Connection+prepareStatement(String) java.sql.Connection+prepareStatement(String) java.sql.Connection+prepareStatement(String) java.sql.Connection+prepareStatement(String) java.sql.Connection+prepareStatement(String) java.sql.Connection+prepareStatement(String) java.sql.Connection+prepareStatement(String) java.sql.Connection+prepareStatement(String) java.sql.Connection+prepareStatement(String) java.sql.Connection+prepareStatement(String) java.sql.Connection+prepareStatement(String) java.sql.Connection+prepareStatement(String) java.sql.Connection+prepareStatement(String) java.sql.Connection+prepareStatement(String) java.sql.Connection+prepareStatement(String) org.h2.fulltext.FullTextSettings+setPrepSelectMapByWordId(PreparedStatement) org.h2.fulltext.FullTextSettings+setPrepSelectMapByWordId(PreparedStatement) org.h2.fulltext.FullTextSettings+setPrepSelectRowById(PreparedStatement) org.h2.fulltext.FullTextSettings+setPrepSelectRowById(PreparedStatement)",org.h2.fulltext.FullText+setting org.h2.fulltext.FullText+dataTypes org.h2.fulltext.FullText+index org.h2.fulltext.FullText+index org.h2.fulltext.IndexInfo+schemaName org.h2.fulltext.FullText+index org.h2.fulltext.IndexInfo+tableName org.h2.fulltext.FullText+index org.h2.fulltext.IndexInfo+columnNames org.h2.fulltext.FullText+index org.h2.fulltext.IndexInfo+columnNames org.h2.fulltext.FullText+dataTypes org.h2.fulltext.FullText+SCHEMA org.h2.fulltext.FullText+index org.h2.fulltext.IndexInfo+id org.h2.fulltext.FullText+index org.h2.fulltext.IndexInfo+keys org.h2.fulltext.FullText+index org.h2.fulltext.IndexInfo+keys org.h2.fulltext.FullText+index org.h2.fulltext.IndexInfo+indexColumns org.h2.fulltext.FullText+index org.h2.fulltext.IndexInfo+indexColumns org.h2.fulltext.FullText+setting org.h2.fulltext.FullText+index org.h2.fulltext.FullText+prepInsertWord org.h2.fulltext.FullText+SCHEMA org.h2.fulltext.FullText+prepInsertRow org.h2.fulltext.FullText+SCHEMA org.h2.fulltext.FullText+prepInsertMap org.h2.fulltext.FullText+SCHEMA org.h2.fulltext.FullText+prepDeleteRow org.h2.fulltext.FullText+SCHEMA org.h2.fulltext.FullText+prepDeleteMap org.h2.fulltext.FullText+SCHEMA org.h2.fulltext.FullText+prepSelectRow org.h2.fulltext.FullText+SCHEMA org.h2.fulltext.FullText+SCHEMA org.h2.fulltext.FullText+SCHEMA org.h2.fulltext.FullText+setting org.h2.fulltext.FullText+setting,3518,75,1,"/** 
 * INTERNAL
 */
","/**
     * INTERNAL
     */
    public void init(Connection conn, String schemaName, String triggerName, String tableName, boolean before, int type) throws SQLException {
        setting = FullTextSettings.getInstance(conn);
        ArrayList keyList = new ArrayList();
        DatabaseMetaData meta = conn.getMetaData();
        ResultSet rs = meta.getColumns(null, schemaName, tableName, null);
        ArrayList columnList = new ArrayList();
        while (rs.next()) {
            columnList.add(rs.getString(""COLUMN_NAME""));
        }
        dataTypes = new int[columnList.size()];
        index = new IndexInfo();
        index.schemaName = schemaName;
        index.tableName = tableName;
        index.columnNames = new String[columnList.size()];
        columnList.toArray(index.columnNames);
        rs = meta.getColumns(null, schemaName, tableName, null);
        for (int i = 0; rs.next(); i++) {
            dataTypes[i] = rs.getInt(""DATA_TYPE"");
        }
        if (keyList.size() == 0) {
            rs = meta.getPrimaryKeys(null, schemaName, tableName);
            while (rs.next()) {
                keyList.add(rs.getString(""COLUMN_NAME""));
            }
        }
        if (keyList.size() == 0) {
            throw new SQLException(""No primary key for table "" + tableName);
        }
        ArrayList indexList = new ArrayList();
        PreparedStatement prep = conn.prepareStatement(
                ""SELECT ID, COLUMNS FROM "" + SCHEMA + "".INDEXES WHERE SCHEMA=? AND TABLE=?"");
        prep.setString(1, schemaName);
        prep.setString(2, tableName);
        rs = prep.executeQuery();
        if (rs.next()) {
            index.id = rs.getInt(1);
            String columns = rs.getString(2);
            if (columns != null) {
                String[] list = StringUtils.arraySplit(columns, ',', true);
                for (int i = 0; i < list.length; i++) {
                    indexList.add(list[i]);
                }
            }
        }
        if (indexList.size() == 0) {
            indexList.addAll(columnList);
        }
        index.keys = new int[keyList.size()];
        setColumns(index.keys, keyList, columnList);
        index.indexColumns = new int[indexList.size()];
        setColumns(index.indexColumns, indexList, columnList);
        setting.addIndexInfo(index);
        prepInsertWord = conn.prepareStatement(
                ""INSERT INTO "" + SCHEMA + "".WORDS(NAME) VALUES(?)"");
        prepInsertRow = conn.prepareStatement(
                ""INSERT INTO "" + SCHEMA + "".ROWS(HASH, INDEXID, KEY) VALUES(?, ?, ?)"");
        prepInsertMap = conn.prepareStatement(
                ""INSERT INTO "" + SCHEMA + "".MAP(ROWID, WORDID) VALUES(?, ?)"");
        prepDeleteRow = conn.prepareStatement(
                ""DELETE FROM "" + SCHEMA + "".ROWS WHERE HASH=? AND INDEXID=? AND KEY=?"");
        prepDeleteMap = conn.prepareStatement(
                ""DELETE FROM "" + SCHEMA + "".MAP WHERE ROWID=? AND WORDID=?"");
        prepSelectRow = conn.prepareStatement(
                ""SELECT ID FROM "" + SCHEMA + "".ROWS WHERE HASH=? AND INDEXID=? AND KEY=?"");

        PreparedStatement prepSelectMapByWordId = conn.prepareStatement(
                ""SELECT ROWID FROM "" + SCHEMA + "".MAP WHERE WORDID=?"");
        PreparedStatement prepSelectRowById = conn.prepareStatement(
                ""SELECT KEY, INDEXID FROM "" + SCHEMA + "".ROWS WHERE ID=?"");
        setting.setPrepSelectMapByWordId(prepSelectMapByWordId);
        setting.setPrepSelectRowById(prepSelectRowById);
    }",True,True,"This method initializes the connection and sets up various prepared statements and data structures for performing full-text search operations on a database table. It retrieves metadata about the table, including column names and data types, and sets up index information. It also prepares SQL statements for inserting, deleting, and selecting rows and maps related to the full-text search.",False,"The code initializes the settings and retrieves metadata information from a database connection. It populates various lists and arrays with column names, data types, primary keys, and index information. It also prepares SQL statements for inserting, deleting, and selecting data from different tables in the database."
29,"setColumns(int[],ArrayList,ArrayList)",set columns index keys columns ,Method,"init(Connection,String,String,String,boolean,int) init(Connection,String,String,String,boolean,int)",,"java.util.ArrayList+size() java.util.ArrayList+size() java.util.ArrayList+get(int) java.util.ArrayList+get(int) java.util.ArrayList+size() java.util.ArrayList+size() java.util.ArrayList+get(int) java.util.ArrayList+get(int) java.lang.String+equals(Object) java.lang.String+equals(Object) java.sql.SQLException+SQLException(String,String)",,617,16,2,,"private void setColumns(int[] index, ArrayList keys, ArrayList columns) throws SQLException {
        for (int i = 0; i < keys.size(); i++) {
            String key = (String) keys.get(i);
            int found = -1;
            for (int j = 0; found == -1 && j < columns.size(); j++) {
                String column = (String) columns.get(j);
                if (column.equals(key)) {
                    found = j;
                }
            }
            if (found < 0) {
                throw new SQLException(""FULLTEXT"", ""Column not found: "" + key);
            }
            index[i] = found;
        }
    }",False,True,"The function of this method is to set the index values for each key in the given ArrayList of keys based on their corresponding position in the ArrayList of columns. If a key is not found in the columns, it throws a SQLException.",False,"This code is a private method that sets the index values for an array based on matching keys and columns. It iterates through the keys and columns, comparing them, and throws a SQLException if a matching column is not found. The index values are then set based on the found column index."
30,"fire(Connection,Object[],Object[])",fire conn old row new row interna l ,Method,"indexExistingRows(Connection,String,String)",,"org.h2.fulltext.FullText+delete(FullTextSettings,Object[]) org.h2.fulltext.FullText+delete(FullTextSettings,Object[]) org.h2.fulltext.FullText+insert(FullTextSettings,Object[]) org.h2.fulltext.FullText+insert(FullTextSettings,Object[])",org.h2.fulltext.FullText+setting org.h2.fulltext.FullText+setting,281,11,1,"/** 
 * INTERNAL
 */
","/**
     * INTERNAL
     */
    public void fire(Connection conn, Object[] oldRow, Object[] newRow) throws SQLException {
        if (oldRow != null) {
            delete(setting, oldRow);
        }
        if (newRow != null) {
            insert(setting, newRow);
        }
    }",True,True,"This method is used internally to fire a connection, delete the old row if it exists, and insert the new row if it exists. It throws a SQLException if there is an error.",False,"The given code is a method named ""fire"" that is used internally. It takes a database connection, an old row, and a new row as parameters. If the old row is not null, it calls the ""delete"" method with the old row. If the new row is not null, it calls the ""insert"" method with the new row."
31,getKey(Object[]),get key row ,Method,"insert(FullTextSettings,Object[]) delete(FullTextSettings,Object[])",,"java.lang.StringBuffer+StringBuffer() java.lang.StringBuffer+append(String) java.lang.StringBuffer+append(String) java.lang.StringBuffer+append(String) java.lang.StringBuffer+append(String) org.h2.util.StringUtils+quoteIdentifier(String) org.h2.util.StringUtils+quoteIdentifier(String) java.lang.StringBuffer+append(String) java.lang.StringBuffer+append(String) java.lang.StringBuffer+append(String) java.lang.StringBuffer+append(String) java.lang.StringBuffer+append(String) java.lang.StringBuffer+append(String) org.h2.fulltext.FullText+quoteSQL(Object,int) org.h2.fulltext.FullText+quoteSQL(Object,int) java.lang.StringBuffer+toString() java.lang.StringBuffer+toString()",org.h2.fulltext.FullText+index org.h2.fulltext.IndexInfo+keys org.h2.fulltext.FullText+index org.h2.fulltext.IndexInfo+keys org.h2.fulltext.FullText+index org.h2.fulltext.IndexInfo+columnNames org.h2.fulltext.FullText+dataTypes,687,19,2,,"private String getKey(Object[] row) throws SQLException {
        StringBuffer buff = new StringBuffer();
        for (int i = 0; i < index.keys.length; i++) {
            if (i > 0) {
                buff.append("" AND "");
            }
            int columnIndex = index.keys[i];
            buff.append(StringUtils.quoteIdentifier(index.columnNames[columnIndex]));
            Object o = row[columnIndex];
            if (o == null) {
                buff.append("" IS NULL"");
            } else {
                buff.append(""="");
                buff.append(quoteSQL(o, dataTypes[columnIndex]));
            }
        }
        String key = buff.toString();
        return key;
    }",True,True,"The function of the given method is to generate a key string based on the values in the input row array. The key string is created by concatenating column names and their corresponding values, separated by ""AND"" for each column.",False,"This code defines a private method named ""getKey"" that takes an array of objects as input and returns a string. It iterates over the array, constructs a SQL query string based on the values in the array, and returns the resulting string. The method also throws a SQLException if an error occurs."
32,quoteString(String),quote string data ,Method,"quoteSQL(Object,int)",,java.lang.String+indexOf(int) java.lang.String+indexOf(int) java.lang.StringBuffer+StringBuffer(int) java.lang.String+length() java.lang.String+length() java.lang.StringBuffer+append(char) java.lang.StringBuffer+append(char) java.lang.String+length() java.lang.String+length() java.lang.String+charAt(int) java.lang.String+charAt(int) java.lang.StringBuffer+append(char) java.lang.StringBuffer+append(char) java.lang.StringBuffer+append(char) java.lang.StringBuffer+append(char) java.lang.StringBuffer+append(char) java.lang.StringBuffer+append(char) java.lang.StringBuffer+toString() java.lang.StringBuffer+toString(),,487,16,2,,"private String quoteString(String data) {
        if (data.indexOf('\'') < 0) {
            return ""'"" + data + ""'"";
        }
        StringBuffer buff = new StringBuffer(data.length() + 2);
        buff.append('\'');
        for (int i = 0; i < data.length(); i++) {
            char ch = data.charAt(i);
            if (ch == '\'') {
                buff.append(ch);
            }
            buff.append(ch);
        }
        buff.append('\'');
        return buff.toString();
    }",False,True,"The function of this method is to add single quotes around a given string, and escape any existing single quotes within the string by doubling them.",False,"The code defines a method called `quoteString` that takes a string as input and returns a quoted version of the string. If the input string does not contain a single quote, it adds single quotes at the beginning and end of the string. If the input string contains single quotes, it duplicates them to escape them properly."
33,quoteBinary(byte[]),quote binary data ,Method,"quoteSQL(Object,int)",,org.h2.util.ByteUtils+convertBytesToString(byte[]) org.h2.util.ByteUtils+convertBytesToString(byte[]),,112,3,2,,"private String quoteBinary(byte[] data) {
        return ""'"" + ByteUtils.convertBytesToString(data) + ""'"";
    }",False,True,"The function of the method is to convert a byte array into a binary string representation, and then wrap it with single quotes.",False,"The code defines a private method called `quoteBinary` that takes in a byte array as input. It converts the byte array to a string using a utility method called `convertBytesToString` from the `ByteUtils` class, and then returns the string enclosed in single quotes."
34,"asString(Object,int)",as string data type internal convert the object to a string param data the object param type the sql type return the string ,Method,"getWordIds(FullTextSettings,Object[])",org.h2.fulltext.FullTextLucene+insert(Object[]),"java.lang.Object+toString() java.lang.Object+toString() java.sql.Clob+getCharacterStream() java.sql.Clob+getCharacterStream() org.h2.util.IOUtils+readStringAndClose(Reader,int) org.h2.util.IOUtils+readStringAndClose(Reader,int) org.h2.message.Message+convert(Throwable) org.h2.message.Message+convert(Throwable) java.sql.SQLException+SQLException(String,String)",java.sql.Types+BIT org.h2.value.DataType+TYPE_BOOLEAN java.sql.Types+INTEGER java.sql.Types+BIGINT java.sql.Types+DECIMAL java.sql.Types+DOUBLE java.sql.Types+FLOAT java.sql.Types+NUMERIC java.sql.Types+REAL java.sql.Types+SMALLINT java.sql.Types+TINYINT java.sql.Types+DATE java.sql.Types+TIME java.sql.Types+TIMESTAMP java.sql.Types+LONGVARCHAR java.sql.Types+CHAR java.sql.Types+VARCHAR java.sql.Types+CLOB java.sql.Types+VARBINARY java.sql.Types+LONGVARBINARY java.sql.Types+BINARY java.sql.Types+JAVA_OBJECT java.sql.Types+OTHER java.sql.Types+BLOB java.sql.Types+STRUCT java.sql.Types+REF java.sql.Types+NULL java.sql.Types+ARRAY org.h2.value.DataType+TYPE_DATALINK java.sql.Types+DISTINCT,1659,57,12,"/** 
 * INTERNAL. Convert the object to a string.
 * @param data the object
 * @param type the SQL type
 * @return the string
 */
","/**
     * INTERNAL.
     * Convert the object to a string.
     *
     * @param data the object
     * @param type the SQL type
     * @return the string
     */
    protected static String asString(Object data, int type) throws SQLException {
        if (data == null) {
            return ""NULL"";
        }
        switch (type) {
        case Types.BIT:
        case DataType.TYPE_BOOLEAN:
        case Types.INTEGER:
        case Types.BIGINT:
        case Types.DECIMAL:
        case Types.DOUBLE:
        case Types.FLOAT:
        case Types.NUMERIC:
        case Types.REAL:
        case Types.SMALLINT:
        case Types.TINYINT:
        case Types.DATE:
        case Types.TIME:
        case Types.TIMESTAMP:
        case Types.LONGVARCHAR:
        case Types.CHAR:
        case Types.VARCHAR:
            return data.toString();
        case Types.CLOB:
            try {
                if (data instanceof Clob) {
                    data = ((Clob) data).getCharacterStream();
                }
                return IOUtils.readStringAndClose((Reader) data, -1);
            } catch (IOException e) {
                throw Message.convert(e);
            }
        case Types.VARBINARY:
        case Types.LONGVARBINARY:
        case Types.BINARY:
        case Types.JAVA_OBJECT:
        case Types.OTHER:
        case Types.BLOB:
        case Types.STRUCT:
        case Types.REF:
        case Types.NULL:
        case Types.ARRAY:
        case DataType.TYPE_DATALINK:
        case Types.DISTINCT:
            throw new SQLException(""FULLTEXT"", ""Unsupported column data type: "" + type);
        default:
            return """";
        }
    }",False,False,"This method converts an object to a string based on its SQL type. It handles various SQL types and returns the appropriate string representation. If the SQL type is not supported, it throws a SQLException.",False,"The code defines a method called ""asString"" that converts an object to a string based on its SQL type. It handles various SQL types and returns the string representation of the object. If the SQL type is not supported, it throws a SQLException."
35,"quoteSQL(Object,int)",quote sql data type ,Method,getKey(Object[]),,"java.lang.Object+toString() java.lang.Object+toString() org.h2.fulltext.FullText+quoteString(String) org.h2.fulltext.FullText+quoteString(String) java.lang.Object+toString() java.lang.Object+toString() org.h2.fulltext.FullText+quoteBinary(byte[]) org.h2.fulltext.FullText+quoteBinary(byte[]) java.sql.SQLException+SQLException(String,String)",java.sql.Types+BIT org.h2.value.DataType+TYPE_BOOLEAN java.sql.Types+INTEGER java.sql.Types+BIGINT java.sql.Types+DECIMAL java.sql.Types+DOUBLE java.sql.Types+FLOAT java.sql.Types+NUMERIC java.sql.Types+REAL java.sql.Types+SMALLINT java.sql.Types+TINYINT java.sql.Types+DATE java.sql.Types+TIME java.sql.Types+TIMESTAMP java.sql.Types+LONGVARCHAR java.sql.Types+CHAR java.sql.Types+VARCHAR java.sql.Types+VARBINARY java.sql.Types+LONGVARBINARY java.sql.Types+BINARY java.sql.Types+CLOB java.sql.Types+JAVA_OBJECT java.sql.Types+OTHER java.sql.Types+BLOB java.sql.Types+STRUCT java.sql.Types+REF java.sql.Types+NULL java.sql.Types+ARRAY org.h2.value.DataType+TYPE_DATALINK java.sql.Types+DISTINCT,1269,43,2,,"private String quoteSQL(Object data, int type) throws SQLException {
        if (data == null) {
            return ""NULL"";
        }
        switch (type) {
        case Types.BIT:
        case DataType.TYPE_BOOLEAN:
        case Types.INTEGER:
        case Types.BIGINT:
        case Types.DECIMAL:
        case Types.DOUBLE:
        case Types.FLOAT:
        case Types.NUMERIC:
        case Types.REAL:
        case Types.SMALLINT:
        case Types.TINYINT:
            return data.toString();
        case Types.DATE:
        case Types.TIME:
        case Types.TIMESTAMP:
        case Types.LONGVARCHAR:
        case Types.CHAR:
        case Types.VARCHAR:
            return quoteString(data.toString());
        case Types.VARBINARY:
        case Types.LONGVARBINARY:
        case Types.BINARY:
            return quoteBinary((byte[]) data);
        case Types.CLOB:
        case Types.JAVA_OBJECT:
        case Types.OTHER:
        case Types.BLOB:
        case Types.STRUCT:
        case Types.REF:
        case Types.NULL:
        case Types.ARRAY:
        case DataType.TYPE_DATALINK:
        case Types.DISTINCT:
            throw new SQLException(""FULLTEXT"", ""Unsupported key data type: "" + type);
        default:
            return """";
        }
    }",False,False,"The function of this method is to quote and format data for use in SQL queries. It takes an object and a type as parameters, and based on the type, it returns the quoted and formatted version of the data. If the type is not supported, it throws a SQLException.",False,"The code defines a private method called `quoteSQL` that takes an object and a type as parameters and returns a string. It checks the type of the object and performs different operations based on the type, returning the appropriate string representation. If the type is unsupported, it throws a `SQLException` with an error message."
36,"addWords(FullTextSettings,HashSet,String)",add words setting set text ,Method,"getWordIds(FullTextSettings,Object[]) search(Connection,String,int,int,boolean)",,"java.util.StringTokenizer+StringTokenizer(String,String) java.util.StringTokenizer+hasMoreTokens() java.util.StringTokenizer+hasMoreTokens() java.util.StringTokenizer+nextToken() java.util.StringTokenizer+nextToken() org.h2.fulltext.FullTextSettings+convertWord(String) org.h2.fulltext.FullTextSettings+convertWord(String) java.util.HashSet+add(E) java.util.HashSet+add(E)",,419,10,10,,"private static void addWords(FullTextSettings setting, HashSet set, String text) {
        StringTokenizer tokenizer = new StringTokenizer(text, "" \t\n\r\f+\""*%&/()=?'!,.;:-_#@|^~`{}[]"");
        while (tokenizer.hasMoreTokens()) {
            String word = tokenizer.nextToken();
            word = setting.convertWord(word);
            if (word != null) {
                set.add(word);
            }
        }
    }",False,True,"This method adds words from a given text to a HashSet, after converting each word using a specified FullTextSettings object. It uses a StringTokenizer to split the text into individual words, and ignores certain characters.",False,"The code defines a method called ""addWords"" that takes in a FullTextSettings object, a HashSet, and a String. It tokenizes the input text using various delimiters, converts each word using a method from the FullTextSettings object, and adds the converted words to the HashSet."
37,"getWordIds(FullTextSettings,Object[])",get word ids setting row ,Method,"insert(FullTextSettings,Object[]) delete(FullTextSettings,Object[])",,"java.util.HashSet+HashSet() org.h2.fulltext.FullText+asString(Object,int) org.h2.fulltext.FullText+asString(Object,int) org.h2.fulltext.FullText+addWords(FullTextSettings,HashSet,String) org.h2.fulltext.FullText+addWords(FullTextSettings,HashSet,String) org.h2.fulltext.FullTextSettings+getWordList() org.h2.fulltext.FullTextSettings+getWordList() java.util.HashSet+size() java.util.HashSet+size() java.util.HashSet+iterator() java.util.HashSet+iterator() java.util.Iterator+hasNext() java.util.Iterator+hasNext() java.util.Iterator+next() java.util.Iterator+next() java.util.HashMap+get(Object) java.util.HashMap+get(Object) java.sql.PreparedStatement+setString(int,String) java.sql.PreparedStatement+setString(int,String) java.sql.PreparedStatement+execute() java.sql.PreparedStatement+execute() org.h2.util.JdbcUtils+getGeneratedKeys(Statement) org.h2.util.JdbcUtils+getGeneratedKeys(Statement) java.sql.ResultSet+next() java.sql.ResultSet+next() java.sql.ResultSet+getInt(int) java.sql.ResultSet+getInt(int) java.util.HashMap+put(K,V) java.util.HashMap+put(K,V) org.h2.util.ObjectUtils+getInteger(int) org.h2.util.ObjectUtils+getInteger(int) java.lang.Integer+intValue() java.lang.Integer+intValue() java.util.Arrays+sort(int[]) java.util.Arrays+sort(int[])",org.h2.fulltext.FullText+index org.h2.fulltext.IndexInfo+indexColumns org.h2.fulltext.FullText+index org.h2.fulltext.IndexInfo+indexColumns org.h2.fulltext.FullText+dataTypes org.h2.fulltext.FullText+prepInsertWord org.h2.fulltext.FullText+prepInsertWord org.h2.fulltext.FullText+prepInsertWord,1168,29,2,,"private int[] getWordIds(FullTextSettings setting, Object[] row) throws SQLException {
        HashSet words = new HashSet();
        for (int i = 0; i < index.indexColumns.length; i++) {
            int idx = index.indexColumns[i];
            String data = asString(row[idx], dataTypes[idx]);
            addWords(setting, words, data);
        }
        HashMap allWords = setting.getWordList();
        int[] wordIds = new int[words.size()];
        Iterator it = words.iterator();
        for (int i = 0; it.hasNext(); i++) {
            String word = (String) it.next();
            Integer wId = (Integer) allWords.get(word);
            int wordId;
            if (wId == null) {
                prepInsertWord.setString(1, word);
                prepInsertWord.execute();
                ResultSet rs = JdbcUtils.getGeneratedKeys(prepInsertWord);
                rs.next();
                wordId = rs.getInt(1);
                allWords.put(word, ObjectUtils.getInteger(wordId));
            } else {
                wordId = wId.intValue();
            }
            wordIds[i] = wordId;
        }
        Arrays.sort(wordIds);
        return wordIds;
    }",True,True,"This method takes a FullTextSettings object and an array of Objects as parameters. It iterates through the indexColumns array, converts the data at each index in the row array to a String, and adds the words to a HashSet. It then retrieves a HashMap of all words from the FullTextSettings object. It creates an array of integers with the size of the HashSet, and iterates through the HashSet. For each word, it checks if it exists in the HashMap. If it does not, it inserts the word into the database and retrieves the generated wordId. If it does exist, it retrieves the wordId from the HashMap. It assigns the wordId to the corresponding index in the wordIds array. Finally, it sorts the wordIds array and returns it.",False,"This code is a private method that takes a FullTextSettings object and an array of objects as parameters. It iterates over the index columns, converts the data to a string, and adds the words to a HashSet. It then retrieves the word list from the settings object, inserts new words into the database if they don't exist, retrieves the word IDs, sorts them, and returns the array of word IDs."
38,"insert(FullTextSettings,Object[])",insert setting row ,Method,"fire(Connection,Object[],Object[])",,"org.h2.fulltext.FullText+getKey(Object[]) org.h2.fulltext.FullText+getKey(Object[]) java.lang.String+hashCode() java.lang.String+hashCode() java.sql.PreparedStatement+setInt(int,int) java.sql.PreparedStatement+setInt(int,int) java.sql.PreparedStatement+setInt(int,int) java.sql.PreparedStatement+setInt(int,int) java.sql.PreparedStatement+setString(int,String) java.sql.PreparedStatement+setString(int,String) java.sql.PreparedStatement+execute() java.sql.PreparedStatement+execute() org.h2.util.JdbcUtils+getGeneratedKeys(Statement) org.h2.util.JdbcUtils+getGeneratedKeys(Statement) java.sql.ResultSet+next() java.sql.ResultSet+next() java.sql.ResultSet+getInt(int) java.sql.ResultSet+getInt(int) java.sql.PreparedStatement+setInt(int,int) java.sql.PreparedStatement+setInt(int,int) org.h2.fulltext.FullText+getWordIds(FullTextSettings,Object[]) org.h2.fulltext.FullText+getWordIds(FullTextSettings,Object[]) java.sql.PreparedStatement+setInt(int,int) java.sql.PreparedStatement+setInt(int,int) java.sql.PreparedStatement+execute() java.sql.PreparedStatement+execute()",org.h2.fulltext.FullText+prepInsertRow org.h2.fulltext.FullText+prepInsertRow org.h2.fulltext.FullText+index org.h2.fulltext.IndexInfo+id org.h2.fulltext.FullText+prepInsertRow org.h2.fulltext.FullText+prepInsertRow org.h2.fulltext.FullText+prepInsertRow org.h2.fulltext.FullText+prepInsertMap org.h2.fulltext.FullText+prepInsertMap org.h2.fulltext.FullText+prepInsertMap,668,17,2,,"private void insert(FullTextSettings setting, Object[] row) throws SQLException {
        String key = getKey(row);
        int hash = key.hashCode();
        prepInsertRow.setInt(1, hash);
        prepInsertRow.setInt(2, index.id);
        prepInsertRow.setString(3, key);
        prepInsertRow.execute();
        ResultSet rs = JdbcUtils.getGeneratedKeys(prepInsertRow);
        rs.next();
        int rowId = rs.getInt(1);
        prepInsertMap.setInt(1, rowId);
        int[] wordIds = getWordIds(setting, row);
        for (int i = 0; i < wordIds.length; i++) {
            prepInsertMap.setInt(2, wordIds[i]);
            prepInsertMap.execute();
        }
    }",True,True,"The function of this method is to insert a row of data into a database table. It takes a FullTextSettings object and an array of objects as parameters, generates a key from the row, calculates a hash code for the key, and then inserts the hash code, index id, and key into the table. It then retrieves the generated keys, gets the row id, and inserts the row id and word ids into another table.",False,"The given code is a private method that inserts data into a database table. It takes a FullTextSettings object and an array of objects as parameters, generates a key from the array, inserts a row with the key and index ID, retrieves the generated row ID, and then inserts mappings between the row ID and word IDs into another table."
39,"delete(FullTextSettings,Object[])",delete setting row ,Method,"fire(Connection,Object[],Object[])",,"org.h2.fulltext.FullText+getKey(Object[]) org.h2.fulltext.FullText+getKey(Object[]) java.lang.String+hashCode() java.lang.String+hashCode() java.sql.PreparedStatement+setInt(int,int) java.sql.PreparedStatement+setInt(int,int) java.sql.PreparedStatement+setInt(int,int) java.sql.PreparedStatement+setInt(int,int) java.sql.PreparedStatement+setString(int,String) java.sql.PreparedStatement+setString(int,String) java.sql.PreparedStatement+executeQuery() java.sql.PreparedStatement+executeQuery() java.sql.ResultSet+next() java.sql.ResultSet+next() java.sql.ResultSet+getInt(int) java.sql.ResultSet+getInt(int) java.sql.PreparedStatement+setInt(int,int) java.sql.PreparedStatement+setInt(int,int) org.h2.fulltext.FullText+getWordIds(FullTextSettings,Object[]) org.h2.fulltext.FullText+getWordIds(FullTextSettings,Object[]) java.sql.PreparedStatement+setInt(int,int) java.sql.PreparedStatement+setInt(int,int) java.sql.PreparedStatement+executeUpdate() java.sql.PreparedStatement+executeUpdate() java.sql.PreparedStatement+setInt(int,int) java.sql.PreparedStatement+setInt(int,int) java.sql.PreparedStatement+setInt(int,int) java.sql.PreparedStatement+setInt(int,int) java.sql.PreparedStatement+setString(int,String) java.sql.PreparedStatement+setString(int,String) java.sql.PreparedStatement+executeUpdate() java.sql.PreparedStatement+executeUpdate()",org.h2.fulltext.FullText+prepSelectRow org.h2.fulltext.FullText+prepSelectRow org.h2.fulltext.FullText+index org.h2.fulltext.IndexInfo+id org.h2.fulltext.FullText+prepSelectRow org.h2.fulltext.FullText+prepSelectRow org.h2.fulltext.FullText+prepDeleteMap org.h2.fulltext.FullText+prepDeleteMap org.h2.fulltext.FullText+prepDeleteMap org.h2.fulltext.FullText+prepDeleteRow org.h2.fulltext.FullText+prepDeleteRow org.h2.fulltext.FullText+index org.h2.fulltext.IndexInfo+id org.h2.fulltext.FullText+prepDeleteRow org.h2.fulltext.FullText+prepDeleteRow,850,21,2,,"private void delete(FullTextSettings setting, Object[] row) throws SQLException {
        String key = getKey(row);
        int hash = key.hashCode();
        prepSelectRow.setInt(1, hash);
        prepSelectRow.setInt(2, index.id);
        prepSelectRow.setString(3, key);
        ResultSet rs = prepSelectRow.executeQuery();
        if (rs.next()) {
            int rowId = rs.getInt(1);
            prepDeleteMap.setInt(1, rowId);
            int[] wordIds = getWordIds(setting, row);
            for (int i = 0; i < wordIds.length; i++) {
                prepDeleteMap.setInt(2, wordIds[i]);
                prepDeleteMap.executeUpdate();
            }
            prepDeleteRow.setInt(1, hash);
            prepDeleteRow.setInt(2, index.id);
            prepDeleteRow.setString(3, key);
            prepDeleteRow.executeUpdate();
        }
    }",True,True,"This method deletes a row from a database table based on a given key. It first retrieves the row ID using the key, then deletes the corresponding entries in the mapping table. Finally, it deletes the row itself from the main table.",False,"This code defines a private method called ""delete"" that takes a FullTextSettings object and an array of objects as parameters. It performs a series of database operations to delete a row based on a given key, including deleting associated word mappings and the row itself if it exists in the database."
40,"searchData(Connection,String,int,int)",search data conn text limit offset searches from the full text index for this database the result contains the primary key data as an array the returned result set has the following columns schema varchar the schema name example public table varchar the table name example test columns array of varchar comma separated list of quoted column names the column names are quoted if necessary example id keys array of values comma separated list of values example 1 param conn the connection param text the search query param limit the maximum number of rows or 0 for no limit param offset the offset or 0 for no offset return the result set ,Method,,,"org.h2.fulltext.FullText+search(Connection,String,int,int,boolean) org.h2.fulltext.FullText+search(Connection,String,int,int,boolean)",,992,22,9,"/** 
 * Searches from the full text index for this database. The result contains the primary key data as an array. The returned result set has the following columns: <ul> <li>SCHEMA (varchar): The schema name. Example: PUBLIC </li> <li>TABLE (varchar): The table name. Example: TEST </li> <li>COLUMNS (array of varchar): Comma separated list of quoted column names. The column names are quoted if necessary. Example: (ID) </li> <li>KEYS (array of values): Comma separated list of values. Example: (1) </li> </ul>
 * @param conn the connection
 * @param text the search query
 * @param limit the maximum number of rows or 0 for no limit
 * @param offset the offset or 0 for no offset
 * @return the result set
 */
","/**
     * Searches from the full text index for this database. The result contains
     * the primary key data as an array. The returned result set has the
     * following columns:
     * <ul>
     * <li>SCHEMA (varchar): The schema name. Example: PUBLIC </li>
     * <li>TABLE (varchar): The table name. Example: TEST </li>
     * <li>COLUMNS (array of varchar): Comma separated list of quoted column
     * names. The column names are quoted if necessary. Example: (ID) </li>
     * <li>KEYS (array of values): Comma separated list of values. Example: (1)
     * </li>
     * </ul>
     *
     * @param conn the connection
     * @param text the search query
     * @param limit the maximum number of rows or 0 for no limit
     * @param offset the offset or 0 for no offset
     * @return the result set
     */
    public static ResultSet searchData(Connection conn, String text, int limit, int offset) throws SQLException {
        return search(conn, text, limit, offset, true);
    }",False,True,"The function of this method is to search for data in a database using a full text index. It returns a result set containing the primary key data for the matching rows. The method takes parameters for the connection, search query, limit on the number of rows, and offset for pagination.",False,"This code defines a method called `searchData` that searches for a given text in a full-text index of a database. It returns a result set containing the primary key data of the matching rows, including the schema name, table name, column names, and corresponding values. The method takes a connection object, search query, limit, and offset as parameters."
41,"search(Connection,String,int,int)",search conn text limit offset searches from the full text index for this database the returned result set has the following column query varchar the query to use to get the data the query does not include select from example public test where id 1 param conn the connection param text the search query param limit the maximum number of rows or 0 for no limit param offset the offset or 0 for no offset return the result set ,Method,,,"org.h2.fulltext.FullText+search(Connection,String,int,int,boolean) org.h2.fulltext.FullText+search(Connection,String,int,int,boolean)",,701,17,9,"/** 
 * Searches from the full text index for this database. The returned result set has the following column: <ul><li>QUERY (varchar): The query to use to get the data. The query does not include 'SELECT * FROM '. Example: PUBLIC.TEST WHERE ID = 1 </li></ul>
 * @param conn the connection
 * @param text the search query
 * @param limit the maximum number of rows or 0 for no limit
 * @param offset the offset or 0 for no offset
 * @return the result set
 */
","/**
     * Searches from the full text index for this database.
     * The returned result set has the following column:
     * <ul><li>QUERY (varchar): The query to use to get the data.
     * The query does not include 'SELECT * FROM '. Example:
     * PUBLIC.TEST WHERE ID = 1
     * </li></ul>
     *
     * @param conn the connection
     * @param text the search query
     * @param limit the maximum number of rows or 0 for no limit
     * @param offset the offset or 0 for no offset
     * @return the result set
     */
    public static ResultSet search(Connection conn, String text, int limit, int offset) throws SQLException {
        return search(conn, text, limit, offset, false);
    }",False,True,"The function serves to search for a given text in the full text index of a database. It takes a connection, search query, limit, and offset as parameters, and returns a result set.",False,"This code defines a method called ""search"" that takes a database connection, a search query, a limit for the number of rows to return, and an offset for the starting position of the result set. It returns a result set containing the query to use to retrieve the data from the full text index of the database."
42,createResultSet(boolean),create result set data create an empty search result and initialize the columns param data true if the result set should contain the primary key data asan array return the empty result set ,Method,"search(Connection,String,int,int,boolean)","org.h2.fulltext.FullTextLucene+search(Connection,String,int,int,boolean)","org.h2.tools.SimpleResultSet+SimpleResultSet() org.h2.tools.SimpleResultSet+addColumn(String,int,int,int) org.h2.tools.SimpleResultSet+addColumn(String,int,int,int) org.h2.tools.SimpleResultSet+addColumn(String,int,int,int) org.h2.tools.SimpleResultSet+addColumn(String,int,int,int) org.h2.tools.SimpleResultSet+addColumn(String,int,int,int) org.h2.tools.SimpleResultSet+addColumn(String,int,int,int) org.h2.tools.SimpleResultSet+addColumn(String,int,int,int) org.h2.tools.SimpleResultSet+addColumn(String,int,int,int) org.h2.tools.SimpleResultSet+addColumn(String,int,int,int) org.h2.tools.SimpleResultSet+addColumn(String,int,int,int)",org.h2.fulltext.FullText+FIELD_SCHEMA java.sql.Types+VARCHAR org.h2.fulltext.FullText+FIELD_TABLE java.sql.Types+VARCHAR org.h2.fulltext.FullText+FIELD_COLUMNS java.sql.Types+ARRAY org.h2.fulltext.FullText+FIELD_KEYS java.sql.Types+ARRAY org.h2.fulltext.FullText+FIELD_QUERY java.sql.Types+VARCHAR,802,19,8,"/** 
 * Create an empty search result and initialize the columns.
 * @param data true if the result set should contain the primary key data asan array.
 * @return the empty result set
 */
","/**
     * Create an empty search result and initialize the columns.
     *
     * @param data true if the result set should contain the primary key data as
     *            an array.
     * @return the empty result set
     */
    static SimpleResultSet createResultSet(boolean data) throws SQLException {
        SimpleResultSet result = new SimpleResultSet();
        if (data) {
            result.addColumn(FullText.FIELD_SCHEMA, Types.VARCHAR, 0, 0);
            result.addColumn(FullText.FIELD_TABLE, Types.VARCHAR, 0, 0);
            result.addColumn(FullText.FIELD_COLUMNS, Types.ARRAY, 0, 0);
            result.addColumn(FullText.FIELD_KEYS, Types.ARRAY, 0, 0);
        } else {
            result.addColumn(FullText.FIELD_QUERY, Types.VARCHAR, 0, 0);
        }
        return result;
    }",False,False,"This method creates an empty search result set and initializes the columns based on the given boolean parameter. If the parameter is true, it adds columns for primary key data. If the parameter is false, it adds a column for the search query. The method then returns the empty result set.",False,"This code defines a static method called `createResultSet` that creates and returns an empty `SimpleResultSet` object. The method takes a boolean parameter `data` to determine whether the result set should contain primary key data or a query field. If `data` is true, the method adds columns for schema, table, columns, and keys to the result set; otherwise, it adds a column for the query field."
43,"search(Connection,String,int,int,boolean)",search conn text limit offset data ,Method,"searchData(Connection,String,int,int) search(Connection,String,int,int)",,"org.h2.fulltext.FullText+createResultSet(boolean) org.h2.fulltext.FullText+createResultSet(boolean) java.lang.String+startsWith(String) java.sql.DatabaseMetaData+getURL() java.sql.Connection+getMetaData() java.sql.Connection+getMetaData() java.sql.DatabaseMetaData+getURL() java.lang.String+startsWith(String) org.h2.fulltext.FullTextSettings+getInstance(Connection) org.h2.fulltext.FullTextSettings+getInstance(Connection) java.util.HashSet+HashSet() org.h2.fulltext.FullText+addWords(FullTextSettings,HashSet,String) org.h2.fulltext.FullText+addWords(FullTextSettings,HashSet,String) org.h2.fulltext.FullTextSettings+getWordList() org.h2.fulltext.FullTextSettings+getWordList() org.h2.fulltext.FullTextSettings+getPrepSelectMapByWordId() org.h2.fulltext.FullTextSettings+getPrepSelectMapByWordId() java.util.HashSet+iterator() java.util.HashSet+iterator() java.util.Iterator+hasNext() java.util.Iterator+hasNext() java.util.HashSet+HashSet() java.util.Iterator+next() java.util.Iterator+next() java.util.HashMap+get(Object) java.util.HashMap+get(Object) java.sql.PreparedStatement+setInt(int,int) java.sql.PreparedStatement+setInt(int,int) java.lang.Integer+intValue() java.lang.Integer+intValue() java.sql.PreparedStatement+executeQuery() java.sql.PreparedStatement+executeQuery() java.sql.ResultSet+next() java.sql.ResultSet+next() org.h2.util.ObjectUtils+getInteger(int) org.h2.util.ObjectUtils+getInteger(int) java.sql.ResultSet+getInt(int) java.sql.ResultSet+getInt(int) java.util.HashSet+contains(Object) java.util.HashSet+contains(Object) java.util.HashSet+add(E) java.util.HashSet+add(E) java.util.HashSet+size() java.util.HashSet+size() org.h2.fulltext.FullTextSettings+getPrepSelectRowById() org.h2.fulltext.FullTextSettings+getPrepSelectRowById() java.util.HashSet+iterator() java.util.HashSet+iterator() java.util.Iterator+hasNext() java.util.Iterator+hasNext() java.lang.Integer+intValue() java.util.Iterator+next() java.util.Iterator+next() java.lang.Integer+intValue() java.sql.PreparedStatement+setInt(int,int) java.sql.PreparedStatement+setInt(int,int) java.sql.PreparedStatement+executeQuery() java.sql.PreparedStatement+executeQuery() java.sql.ResultSet+next() java.sql.ResultSet+next() java.sql.ResultSet+getString(int) java.sql.ResultSet+getString(int) java.sql.ResultSet+getInt(int) java.sql.ResultSet+getInt(int) org.h2.fulltext.FullTextSettings+getIndexInfo(long) org.h2.fulltext.FullTextSettings+getIndexInfo(long) org.h2.fulltext.FullText+parseKey(Connection,String) org.h2.fulltext.FullText+parseKey(Connection,String) org.h2.tools.SimpleResultSet+addRow(Object[]) org.h2.tools.SimpleResultSet+addRow(Object[]) java.lang.StringBuffer+StringBuffer() java.lang.StringBuffer+append(String) java.lang.StringBuffer+append(String) org.h2.util.StringUtils+quoteIdentifier(String) org.h2.util.StringUtils+quoteIdentifier(String) java.lang.StringBuffer+append(char) java.lang.StringBuffer+append(char) java.lang.StringBuffer+append(String) java.lang.StringBuffer+append(String) org.h2.util.StringUtils+quoteIdentifier(String) org.h2.util.StringUtils+quoteIdentifier(String) java.lang.StringBuffer+append(String) java.lang.StringBuffer+append(String) java.lang.StringBuffer+append(String) java.lang.StringBuffer+append(String) java.lang.StringBuffer+toString() java.lang.StringBuffer+toString() org.h2.tools.SimpleResultSet+addRow(Object[]) org.h2.tools.SimpleResultSet+addRow(Object[])",org.h2.fulltext.IndexInfo+schemaName org.h2.fulltext.IndexInfo+tableName org.h2.fulltext.IndexInfo+schemaName org.h2.fulltext.IndexInfo+tableName,3113,75,10,,"private static ResultSet search(Connection conn, String text, int limit, int offset, boolean data) throws SQLException {
        SimpleResultSet result = createResultSet(data);
        if (conn.getMetaData().getURL().startsWith(""jdbc:columnlist:"")) {
            // this is just to query the result set columns
            return result;
        }
        FullTextSettings setting = FullTextSettings.getInstance(conn);
        HashSet words = new HashSet();
        addWords(setting, words, text);
        HashSet rIds = null, lastRowIds = null;
        HashMap allWords = setting.getWordList();

        PreparedStatement prepSelectMapByWordId = setting.getPrepSelectMapByWordId();
        for (Iterator it = words.iterator(); it.hasNext();) {
            lastRowIds = rIds;
            rIds = new HashSet();
            String word = (String) it.next();
            Integer wId = (Integer) allWords.get(word);
            if (wId == null) {
                continue;
            }
            prepSelectMapByWordId.setInt(1, wId.intValue());
            ResultSet rs = prepSelectMapByWordId.executeQuery();
            while (rs.next()) {
                Integer rId = ObjectUtils.getInteger(rs.getInt(1));
                if (lastRowIds == null || lastRowIds.contains(rId)) {
                    rIds.add(rId);
                }
            }
        }
        if (rIds == null || rIds.size() == 0) {
            return result;
        }
        PreparedStatement prepSelectRowById = setting.getPrepSelectRowById();
        int rowCount = 0;
        for (Iterator it = rIds.iterator(); it.hasNext();) {
            int rowId = ((Integer) it.next()).intValue();
            prepSelectRowById.setInt(1, rowId);
            ResultSet rs = prepSelectRowById.executeQuery();
            if (!rs.next()) {
                continue;
            }
            if (offset > 0) {
                offset--;
            } else {
                String key = rs.getString(1);
                int indexId = rs.getInt(2);
                IndexInfo index = setting.getIndexInfo(indexId);
                if (data) {
                    Object[][] columnData = parseKey(conn, key);
                    Object[] row = new Object[] {
                        index.schemaName,
                        index.tableName,
                        columnData[0],
                        columnData[1]
                    };
                    result.addRow(row);
                } else {
                    StringBuffer buff = new StringBuffer();
                    buff.append(StringUtils.quoteIdentifier(index.schemaName));
                    buff.append('.');
                    buff.append(StringUtils.quoteIdentifier(index.tableName));
                    buff.append("" WHERE "");
                    buff.append(key);
                    String query = buff.toString();
                    result.addRow(new String[] { query });
                }
                rowCount++;
                if (limit > 0 && rowCount >= limit) {
                    break;
                }
            }
        }
        return result;
    }",False,False,"This method serves to search for rows in a database based on a given text. It takes in a connection, the text to search for, a limit on the number of rows to return, an offset for pagination, and a flag indicating whether to include data in the result set. It uses full-text search settings and a word list to find matching rows, and constructs a result set with the matching rows.",False,"This code is a method that performs a full-text search on a database connection using a given text query. It retrieves the search results based on the specified limit and offset, and returns a result set containing the matching rows."
44,"parseKey(Connection,String)",parse key conn key parse a primary key condition into the primary key columns param conn the database connection param key the primary key condition as a string return an array containing the column name list and the data list ,Method,"search(Connection,String,int,int,boolean)","org.h2.fulltext.FullTextLucene+search(Connection,String,int,int,boolean)","java.util.ArrayList+ArrayList() java.util.ArrayList+ArrayList() org.h2.jdbc.JdbcConnection+getSession() org.h2.jdbc.JdbcConnection+getSession() org.h2.command.Parser+Parser(Session) org.h2.command.Parser+parseExpression(String) org.h2.command.Parser+parseExpression(String) org.h2.fulltext.FullText+addColumnData(ArrayList,ArrayList,Expression) org.h2.fulltext.FullText+addColumnData(ArrayList,ArrayList,Expression) java.util.ArrayList+size() java.util.ArrayList+size() java.util.ArrayList+toArray(T[]) java.util.ArrayList+toArray(T[]) java.util.ArrayList+size() java.util.ArrayList+size() java.util.ArrayList+toArray(T[]) java.util.ArrayList+toArray(T[])",,940,24,8,"/** 
 * Parse a primary key condition into the primary key columns.
 * @param conn the database connection
 * @param key the primary key condition as a string
 * @return an array containing the column name list and the data list
 */
","/**
     * Parse a primary key condition into the primary key columns.
     *
     * @param conn the database connection
     * @param key the primary key condition as a string
     * @return an array containing the column name list and the data list
     */
    static Object[][] parseKey(Connection conn, String key) throws SQLException {
        ArrayList columns = new ArrayList();
        ArrayList data = new ArrayList();
        JdbcConnection c = (JdbcConnection) conn;
        Session session = (Session) c.getSession();
        Parser p = new Parser(session);
        Expression expr = p.parseExpression(key);
        addColumnData(columns, data, expr);
        Object[] col = new Object[columns.size()];
        columns.toArray(col);
        Object[] dat = new Object[columns.size()];
        data.toArray(dat);
        Object[][] columnData = new Object[][] {
                col, dat
        };
        return columnData;
    }",False,False,"This method serves to parse a primary key condition into the primary key columns. It takes a database connection and a primary key condition as input, and returns an array containing the column name list and the data list.",False,"This code is a method that parses a primary key condition into the primary key columns. It takes a database connection and a key as input, and returns an array containing the column name list and the data list extracted from the key."
45,"addColumnData(ArrayList,ArrayList,Expression)",add column data columns data expr ,Method,"parseKey(Connection,String) addColumnData(ArrayList,ArrayList,Expression) addColumnData(ArrayList,ArrayList,Expression)",,"org.h2.expression.ConditionAndOr+getExpression(boolean) org.h2.expression.ConditionAndOr+getExpression(boolean) org.h2.expression.ConditionAndOr+getExpression(boolean) org.h2.expression.ConditionAndOr+getExpression(boolean) org.h2.fulltext.FullText+addColumnData(ArrayList,ArrayList,Expression) org.h2.fulltext.FullText+addColumnData(ArrayList,ArrayList,Expression) org.h2.fulltext.FullText+addColumnData(ArrayList,ArrayList,Expression) org.h2.fulltext.FullText+addColumnData(ArrayList,ArrayList,Expression) org.h2.expression.Comparison+getExpression(boolean) org.h2.expression.Comparison+getExpression(boolean) org.h2.expression.Comparison+getExpression(boolean) org.h2.expression.Comparison+getExpression(boolean) org.h2.expression.ExpressionColumn+getColumnName() org.h2.expression.ExpressionColumn+getColumnName() java.util.ArrayList+add(E) java.util.ArrayList+add(E) java.util.ArrayList+add(E) java.util.ArrayList+add(E) java.util.ArrayList+add(E) java.util.ArrayList+add(E) org.h2.value.Value+getString() org.h2.expression.ValueExpression+getValue(Session) org.h2.expression.ValueExpression+getValue(Session) org.h2.value.Value+getString()",,880,20,10,,"private static void addColumnData(ArrayList columns, ArrayList data, Expression expr) {
        if (expr instanceof ConditionAndOr) {
            ConditionAndOr and = (ConditionAndOr) expr;
            Expression left = and.getExpression(true);
            Expression right = and.getExpression(false);
            addColumnData(columns, data, left);
            addColumnData(columns, data, right);
        } else {
            Comparison comp = (Comparison) expr;
            ExpressionColumn ec = (ExpressionColumn) comp.getExpression(true);
            ValueExpression ev = (ValueExpression) comp.getExpression(false);
            String columnName = ec.getColumnName();
            columns.add(columnName);
            if (ev == null) {
                data.add(null);
            } else {
                data.add(ev.getValue(null).getString());
            }
        }
    }",False,False,"The function adds column data to an ArrayList based on the given Expression. If the Expression is a ConditionAndOr, it recursively calls the function for the left and right expressions. Otherwise, it extracts the column name and value from the Comparison expression and adds them to the respective ArrayLists.",False,"The code defines a method called ""addColumnData"" that takes in three parameters: an ArrayList of columns, an ArrayList of data, and an Expression. The method recursively traverses the Expression object and extracts column names and corresponding values, adding them to the respective ArrayLists."
46,close(),close interna l ,Method,,,org.h2.fulltext.FullTextSettings+removeIndexInfo(IndexInfo) org.h2.fulltext.FullTextSettings+removeIndexInfo(IndexInfo),org.h2.fulltext.FullText+setting org.h2.fulltext.FullText+index,119,6,1,"/** 
 * INTERNAL
 */
","/**
     * INTERNAL
     */
    public void close() throws SQLException {
        setting.removeIndexInfo(index);
    }",True,True,The function of this method is to close the connection and remove the index information associated with it.,False,"The given code snippet represents a method named ""close"" that is used internally. It throws a SQLException and its purpose is to remove index information from a setting object."
47,remove(),remove interna l ,Method,,,org.h2.fulltext.FullTextSettings+removeIndexInfo(IndexInfo) org.h2.fulltext.FullTextSettings+removeIndexInfo(IndexInfo),org.h2.fulltext.FullText+setting org.h2.fulltext.FullText+index,120,6,1,"/** 
 * INTERNAL
 */
","/**
     * INTERNAL
     */
    public void remove() throws SQLException {
        setting.removeIndexInfo(index);
    }",True,True,This method serves to remove index information from the setting. It throws a SQLException if there is an error during the removal process.,False,"The code represents a method called ""remove"" that is used internally. It throws a SQLException and is responsible for removing index information by calling the ""removeIndexInfo"" method on the ""setting"" object."
