index,name,document,type,inner invocations,external invocations,calls,visits,length,lines,modifier,commit,full text,moved,removed,gpt text,gpt response,code summary
1,OpType,op type ,Field,,,,,18,1,1,,public enum OpType,False,False,,False,
2,opType,op type this operation represents a modulus as in 5 2 ,Field,"BinaryOperation(OpType,Expression,Expression)",,,,22,1,2,"/** 
 * This operation represents a modulus as in 5 % 2.
 */
",private OpType opType;,False,False,"/** 
 * This operation represents a modulus as in 5 % 2.
 */
",False,"/** 
 * This operation represents a modulus as in 5 % 2.
 */
"
3,left,left ,Field,"BinaryOperation(OpType,Expression,Expression)",,,,31,1,2,,"private Expression left, right;",True,True,,False,
4,right,right ,Field,"BinaryOperation(OpType,Expression,Expression)",,,,31,1,2,,"private Expression left, right;",True,True,,False,
5,type,type ,Field,,,,,22,1,2,,private TypeInfo type;,True,True,,False,
6,forcedType,forced type ,Field,setForcedType(TypeInfo),,,,28,1,2,,private TypeInfo forcedType;,False,False,,False,
7,convertRight,convert right ,Field,,,,,36,1,2,,private boolean convertRight = true;,False,False,,False,
8,"BinaryOperation(OpType,Expression,Expression)",binary operation op type left right ,Method,,,,org.h2.expression.BinaryOperation+opType org.h2.expression.BinaryOperation+opType org.h2.expression.BinaryOperation+left org.h2.expression.BinaryOperation+left org.h2.expression.BinaryOperation+right org.h2.expression.BinaryOperation+right,164,5,1,,"public BinaryOperation(OpType opType, Expression left, Expression right) {
        this.opType = opType;
        this.left = left;
        this.right = right;
    }",False,False,"The function of the method is to initialize a BinaryOperation object with the specified operation type, left expression, and right expression.",True,"The given code defines a constructor for a BinaryOperation class that takes in an operation type, a left expression, and a right expression as parameters. It initializes the instance variables of the class with the provided values."
9,setForcedType(TypeInfo),set forced type forced type sets a forced data type of a datetime minus datetime operation param forced type the forced data type ,Method,,,org.h2.expression.BinaryOperation+getUnexpectedForcedTypeException() org.h2.expression.BinaryOperation+getUnexpectedForcedTypeException(),org.h2.expression.BinaryOperation+opType org.h2.expression.BinaryOperation+OpType org.h2.expression.BinaryOperation+forcedType org.h2.expression.BinaryOperation+forcedType,334,11,1,"/** 
 * Sets a forced data type of a datetime minus datetime operation.
 * @param forcedType the forced data type
 */
","/**
     * Sets a forced data type of a datetime minus datetime operation.
     *
     * @param forcedType the forced data type
     */
    public void setForcedType(TypeInfo forcedType) {
        if (opType != OpType.MINUS) {
            throw getUnexpectedForcedTypeException();
        }
        this.forcedType = forcedType;
    }",False,False,This method sets a forced data type for a datetime minus datetime operation. It throws an exception if the operation type is not minus.,False,"This code defines a method called ""setForcedType"" that sets a forced data type for a datetime minus datetime operation. It takes a parameter called ""forcedType"" of type ""TypeInfo"" and throws an exception if the operation type is not ""MINUS"". The method then assigns the ""forcedType"" parameter to the ""this.forcedType"" variable."
10,"getSQL(StringBuilder,int)",get sql builder sql flags ,Method,getUnexpectedForcedTypeException(),,"java.lang.StringBuilder+append(char) java.lang.StringBuilder+append(char) java.lang.StringBuilder+append(char) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(char) org.h2.util.HasSQL+getSQL(StringBuilder,int) org.h2.util.HasSQL+getSQL(StringBuilder,int) java.lang.StringBuilder+append(char) java.lang.StringBuilder+append(String) org.h2.expression.BinaryOperation+getOperationToken() org.h2.expression.BinaryOperation+getOperationToken() java.lang.StringBuilder+append(char) java.lang.StringBuilder+append(char) org.h2.util.HasSQL+getSQL(StringBuilder,int) org.h2.util.HasSQL+getSQL(StringBuilder,int) java.lang.StringBuilder+append(char)",org.h2.expression.BinaryOperation+left org.h2.expression.BinaryOperation+right,382,8,1,,"@Override
    public StringBuilder getSQL(StringBuilder builder, int sqlFlags) {
        // don't remove the space, otherwise it might end up some thing like
        // --1 which is a line remark
        builder.append('(');
        left.getSQL(builder, sqlFlags).append(' ').append(getOperationToken()).append(' ');
        return right.getSQL(builder, sqlFlags).append(')');
    }",False,False,"This method appends SQL code to a StringBuilder object. It takes a StringBuilder object and an integer as parameters, and returns the modified StringBuilder object.",True,"This code is an implementation of the `getSQL` method, which is overridden from a superclass. It appends a left expression, an operation token, and a right expression to a `StringBuilder` object, enclosed in parentheses. The resulting SQL string represents a query with the specified SQL flags."
11,getOperationToken(),get operation token ,Method,"getSQL(StringBuilder,int) getUnsupported(int,int)",,org.h2.message.DbException+throwInternalError(String) org.h2.message.DbException+throwInternalError(String),org.h2.expression.BinaryOperation+opType org.h2.expression.BinaryOperation+opType,390,16,2,,"private String getOperationToken() {
        switch (opType) {
        case PLUS:
            return ""+"";
        case MINUS:
            return ""-"";
        case MULTIPLY:
            return ""*"";
        case DIVIDE:
            return ""/"";
        case MODULUS:
            return ""%"";
        default:
            throw DbException.throwInternalError(""opType="" + opType);
        }
    }",False,False,"This method returns the corresponding operation token based on the value of the opType variable. It returns ""+"" for PLUS, ""-"" for MINUS, ""*"" for MULTIPLY, ""/"" for DIVIDE, ""%"" for MODULUS, and throws an error for any other value.",False,"The code defines a private method called ""getOperationToken"" that returns a string representing the operation type based on the value of the ""opType"" variable. It uses a switch statement to determine the appropriate token and throws an exception if the ""opType"" value is not recognized."
12,getValue(Session),get value session ,Method,optimize(Session),,"org.h2.value.Value+convertTo(TypeInfo,CastDataProvider) org.h2.expression.Expression+getValue(Session) org.h2.expression.Expression+getValue(Session) org.h2.value.Value+convertTo(TypeInfo,CastDataProvider) org.h2.expression.Expression+getValue(Session) org.h2.expression.Expression+getValue(Session) org.h2.value.Value+convertTo(TypeInfo,CastDataProvider) org.h2.value.Value+convertTo(TypeInfo,CastDataProvider) org.h2.value.Value+add(Value) org.h2.value.Value+add(Value) org.h2.value.Value+subtract(Value) org.h2.value.Value+subtract(Value) org.h2.value.Value+multiply(Value) org.h2.value.Value+multiply(Value) org.h2.value.Value+divide(Value,long) org.h2.value.Value+divide(Value,long) org.h2.value.TypeInfo+getPrecision() org.h2.expression.Expression+getType() org.h2.expression.Expression+getType() org.h2.value.TypeInfo+getPrecision() org.h2.value.Value+modulus(Value) org.h2.value.Value+modulus(Value) org.h2.message.DbException+throwInternalError(String) org.h2.message.DbException+throwInternalError(String)",org.h2.expression.BinaryOperation+left org.h2.expression.BinaryOperation+type org.h2.expression.BinaryOperation+right org.h2.expression.BinaryOperation+convertRight org.h2.expression.BinaryOperation+type org.h2.expression.BinaryOperation+opType org.h2.value.ValueNull+INSTANCE org.h2.value.ValueNull+INSTANCE org.h2.value.ValueNull+INSTANCE org.h2.value.ValueNull+INSTANCE org.h2.value.ValueNull+INSTANCE org.h2.value.ValueNull+INSTANCE org.h2.value.ValueNull+INSTANCE org.h2.value.ValueNull+INSTANCE org.h2.value.ValueNull+INSTANCE org.h2.value.ValueNull+INSTANCE org.h2.value.ValueNull+INSTANCE org.h2.value.ValueNull+INSTANCE org.h2.expression.BinaryOperation+right org.h2.value.ValueNull+INSTANCE org.h2.value.ValueNull+INSTANCE org.h2.value.ValueNull+INSTANCE org.h2.expression.BinaryOperation+opType,1307,37,1,,"@Override
    public Value getValue(Session session) {
        Value l = left.getValue(session).convertTo(type, session);
        Value r = right.getValue(session);
        if (convertRight) {
            r = r.convertTo(type, session);
        }
        switch (opType) {
        case PLUS:
            if (l == ValueNull.INSTANCE || r == ValueNull.INSTANCE) {
                return ValueNull.INSTANCE;
            }
            return l.add(r);
        case MINUS:
            if (l == ValueNull.INSTANCE || r == ValueNull.INSTANCE) {
                return ValueNull.INSTANCE;
            }
            return l.subtract(r);
        case MULTIPLY:
            if (l == ValueNull.INSTANCE || r == ValueNull.INSTANCE) {
                return ValueNull.INSTANCE;
            }
            return l.multiply(r);
        case DIVIDE:
            if (l == ValueNull.INSTANCE || r == ValueNull.INSTANCE) {
                return ValueNull.INSTANCE;
            }
            return l.divide(r, right.getType().getPrecision());
        case MODULUS:
            if (l == ValueNull.INSTANCE || r == ValueNull.INSTANCE) {
                return ValueNull.INSTANCE;
            }
            return l.modulus(r);
        default:
            throw DbException.throwInternalError(""type="" + opType);
        }
    }",False,False,"This method returns the result of performing a mathematical operation (addition, subtraction, multiplication, division, modulus) on two values. If either value is null, it returns null.",True,"This code defines a method that evaluates an arithmetic operation based on the operator type. It retrieves the left and right values, performs the operation, and returns the result. If either value is null, it returns a null value."
13,"mapColumns(ColumnResolver,int,int)",map columns resolver level state ,Method,,,"org.h2.expression.Expression+mapColumns(ColumnResolver,int,int) org.h2.expression.Expression+mapColumns(ColumnResolver,int,int) org.h2.expression.Expression+mapColumns(ColumnResolver,int,int) org.h2.expression.Expression+mapColumns(ColumnResolver,int,int)",org.h2.expression.BinaryOperation+left org.h2.expression.BinaryOperation+right,190,5,1,,"@Override
    public void mapColumns(ColumnResolver resolver, int level, int state) {
        left.mapColumns(resolver, level, state);
        right.mapColumns(resolver, level, state);
    }",True,True,"This method is used to map the columns of the left and right nodes in a tree structure, using a given column resolver, level, and state.",True,"The given code is a method named ""mapColumns"" that overrides a superclass method. It takes a ColumnResolver object, an integer level, and an integer state as parameters. It calls the mapColumns method on the ""left"" and ""right"" objects, passing the same parameters."
14,optimize(Session),optimize session ,Method,,"org.h2.expression.analysis.WindowFrame+getCompareRow(Session,ArrayList<Value[]>,SortOrder,int,WindowFrameBound,boolean) org.h2.test.unit.TestBinaryOperation+assertPrecisionScale(int,int,BinaryOperation.OpType,int,int,int,int)","org.h2.expression.Expression+optimize(Session) org.h2.expression.Expression+optimize(Session) org.h2.expression.Expression+optimize(Session) org.h2.expression.Expression+optimize(Session) org.h2.expression.Expression+getType() org.h2.expression.Expression+getType() org.h2.expression.Expression+getType() org.h2.expression.Expression+getType() org.h2.value.TypeInfo+getValueType() org.h2.value.TypeInfo+getValueType() org.h2.value.TypeInfo+getValueType() org.h2.value.TypeInfo+getValueType() org.h2.engine.Database+getMode() org.h2.engine.Session+getDatabase() org.h2.engine.Session+getDatabase() org.h2.engine.Database+getMode() org.h2.expression.ConcatenationOperation+optimize(Session) org.h2.expression.ConcatenationOperation+ConcatenationOperation(Expression,Expression) org.h2.expression.ConcatenationOperation+optimize(Session) org.h2.value.DataType+isIntervalType(int) org.h2.value.DataType+isIntervalType(int) org.h2.value.DataType+isIntervalType(int) org.h2.value.DataType+isIntervalType(int) org.h2.expression.BinaryOperation+getUnexpectedForcedTypeException() org.h2.expression.BinaryOperation+getUnexpectedForcedTypeException() org.h2.expression.BinaryOperation+optimizeInterval(Session,int,int) org.h2.expression.BinaryOperation+optimizeInterval(Session,int,int) org.h2.value.DataType+isDateTimeType(int) org.h2.value.DataType+isDateTimeType(int) org.h2.value.DataType+isDateTimeType(int) org.h2.value.DataType+isDateTimeType(int) org.h2.expression.BinaryOperation+optimizeDateTime(Session,int,int) org.h2.expression.BinaryOperation+optimizeDateTime(Session,int,int) org.h2.expression.BinaryOperation+getUnexpectedForcedTypeException() org.h2.expression.BinaryOperation+getUnexpectedForcedTypeException() org.h2.value.Value+getHigherOrder(int,int) org.h2.value.Value+getHigherOrder(int,int) org.h2.expression.BinaryOperation+optimizeNumeric(TypeInfo,TypeInfo) org.h2.expression.BinaryOperation+optimizeNumeric(TypeInfo,TypeInfo) org.h2.value.DataType+isStringType(int) org.h2.value.DataType+isStringType(int) org.h2.engine.Database+getMode() org.h2.engine.Session+getDatabase() org.h2.engine.Session+getDatabase() org.h2.engine.Database+getMode() org.h2.expression.ConcatenationOperation+optimize(Session) org.h2.expression.ConcatenationOperation+ConcatenationOperation(Expression,Expression) org.h2.expression.ConcatenationOperation+optimize(Session) org.h2.value.TypeInfo+getTypeInfo(int) org.h2.value.TypeInfo+getTypeInfo(int) org.h2.expression.Expression+isConstant() org.h2.expression.Expression+isConstant() org.h2.expression.Expression+isConstant() org.h2.expression.Expression+isConstant() org.h2.expression.ValueExpression+get(Value) org.h2.expression.ValueExpression+get(Value) org.h2.expression.BinaryOperation+getValue(Session) org.h2.expression.BinaryOperation+getValue(Session)",org.h2.expression.BinaryOperation+left org.h2.expression.BinaryOperation+left org.h2.expression.BinaryOperation+right org.h2.expression.BinaryOperation+right org.h2.expression.BinaryOperation+left org.h2.expression.BinaryOperation+right org.h2.value.Value+NULL org.h2.value.Value+NULL org.h2.value.Value+UNKNOWN org.h2.value.Value+UNKNOWN org.h2.expression.BinaryOperation+opType org.h2.expression.BinaryOperation+OpType org.h2.engine.Mode+allowPlusForStringConcat org.h2.engine.Mode+allowPlusForStringConcat org.h2.expression.BinaryOperation+left org.h2.expression.BinaryOperation+right org.h2.expression.BinaryOperation+type org.h2.value.TypeInfo+TYPE_NUMERIC_FLOATING_POINT org.h2.expression.BinaryOperation+forcedType org.h2.expression.BinaryOperation+forcedType org.h2.value.Value+NUMERIC org.h2.value.Value+ENUM org.h2.expression.BinaryOperation+type org.h2.value.TypeInfo+TYPE_INTEGER org.h2.expression.BinaryOperation+opType org.h2.expression.BinaryOperation+OpType org.h2.engine.Mode+allowPlusForStringConcat org.h2.engine.Mode+allowPlusForStringConcat org.h2.expression.BinaryOperation+left org.h2.expression.BinaryOperation+right org.h2.expression.BinaryOperation+type org.h2.expression.BinaryOperation+left org.h2.expression.BinaryOperation+right,2030,41,1,,"@Override
    public Expression optimize(Session session) {
        left = left.optimize(session);
        right = right.optimize(session);
        TypeInfo leftType = left.getType(), rightType = right.getType();
        int l = leftType.getValueType(), r = rightType.getValueType();
        if ((l == Value.NULL && r == Value.NULL) || (l == Value.UNKNOWN && r == Value.UNKNOWN)) {
            // (? + ?) - use decimal by default (the most safe data type) or
            // string when text concatenation with + is enabled
            if (opType == OpType.PLUS && session.getDatabase().getMode().allowPlusForStringConcat) {
                return new ConcatenationOperation(left, right).optimize(session);
            } else {
                type = TypeInfo.TYPE_NUMERIC_FLOATING_POINT;
            }
        } else if (DataType.isIntervalType(l) || DataType.isIntervalType(r)) {
            if (forcedType != null) {
                throw getUnexpectedForcedTypeException();
            }
            return optimizeInterval(session, l, r);
        } else if (DataType.isDateTimeType(l) || DataType.isDateTimeType(r)) {
            return optimizeDateTime(session, l, r);
        } else if (forcedType != null) {
            throw getUnexpectedForcedTypeException();
        } else {
            int dataType = Value.getHigherOrder(l, r);
            if (dataType == Value.NUMERIC) {
                optimizeNumeric(leftType, rightType);
            } else if (dataType == Value.ENUM) {
                type = TypeInfo.TYPE_INTEGER;
            } else if (DataType.isStringType(dataType)
                    && opType == OpType.PLUS && session.getDatabase().getMode().allowPlusForStringConcat) {
                return new ConcatenationOperation(left, right).optimize(session);
            } else {
                type = TypeInfo.getTypeInfo(dataType);
            }
        }
        if (left.isConstant() && right.isConstant()) {
            return ValueExpression.get(getValue(session));
        }
        return this;
    }",False,False,"The function of this method is to optimize an expression by performing various checks and transformations based on the types of the left and right operands. It handles cases such as null values, unknown values, interval types, date/time types, numeric types, enum types, and string concatenation. It also checks for constant operands and returns the optimized expression.",True,"This code is an implementation of the `optimize` method in a Java class. It takes a `Session` object as a parameter and performs various optimizations on the expressions `left` and `right`. It handles different data types, including intervals, date/time, numeric, and string concatenation, and returns the optimized expression."
15,"optimizeNumeric(TypeInfo,TypeInfo)",optimize numeric left type right type ,Method,optimize(Session),,"org.h2.value.TypeInfo+toNumericType() org.h2.value.TypeInfo+toNumericType() org.h2.value.TypeInfo+toNumericType() org.h2.value.TypeInfo+toNumericType() org.h2.value.TypeInfo+getPrecision() org.h2.value.TypeInfo+getPrecision() org.h2.value.TypeInfo+getPrecision() org.h2.value.TypeInfo+getPrecision() org.h2.value.TypeInfo+getScale() org.h2.value.TypeInfo+getScale() org.h2.value.TypeInfo+getScale() org.h2.value.TypeInfo+getScale() java.lang.Math+max(long,long) java.lang.Math+max(long,long) org.h2.value.ValueNumeric+getQuotientScale(int,long,int) org.h2.value.ValueNumeric+getQuotientScale(int,long,int) org.h2.message.DbException+throwInternalError(String) org.h2.message.DbException+throwInternalError(String) org.h2.value.TypeInfo+getTypeInfo(int,long,int,ExtTypeInfo) org.h2.value.TypeInfo+getTypeInfo(int,long,int,ExtTypeInfo)",org.h2.expression.BinaryOperation+opType org.h2.expression.BinaryOperation+opType org.h2.expression.BinaryOperation+type org.h2.value.Value+NUMERIC,2141,49,2,,"private void optimizeNumeric(TypeInfo leftType, TypeInfo rightType) {
        leftType = leftType.toNumericType();
        rightType = rightType.toNumericType();
        long leftPrecision = leftType.getPrecision(), rightPrecision = rightType.getPrecision();
        int leftScale = leftType.getScale(), rightScale = rightType.getScale();
        long precision;
        int scale;
        switch (opType) {
        case PLUS:
        case MINUS:
            // Precision is implementation-defined.
            // Scale must be max(leftScale, rightScale).
            // Choose the largest scale and adjust the precision of other
            // argument.
            if (leftScale < rightScale) {
                leftPrecision += rightScale - leftScale;
                scale = rightScale;
            } else {
                rightPrecision += leftScale - rightScale;
                scale = leftScale;
            }
            // Add one extra digit to the largest precision.
            precision = Math.max(leftPrecision, rightPrecision) + 1;
            break;
        case MULTIPLY:
            // Precision is implementation-defined.
            // Scale must be leftScale + rightScale.
            // Use sum of precisions.
            precision = leftPrecision + rightPrecision;
            scale = leftScale + rightScale;
            break;
        case DIVIDE:
            // Precision and scale are implementation-defined.
            scale = ValueNumeric.getQuotientScale(leftScale, rightPrecision, rightScale);
            // Divider can be effectively multiplied by no more than
            // 10^rightScale, so add rightScale to its precision and adjust the
            // result to the changes in scale.
            precision = leftPrecision + rightScale - leftScale + scale;
            break;
        case MODULUS:
            // Non-standard operation.
            precision = rightPrecision;
            scale = rightScale;
            break;
        default:
            throw DbException.throwInternalError(""type="" + opType);
        }
        type = TypeInfo.getTypeInfo(Value.NUMERIC, precision, scale, null);
    }",False,False,"The function optimizes the numeric types of the left and right operands based on the operation type. It adjusts the precision and scale of the operands according to the rules defined for each operation type, and sets the resulting type for the operation.",False,"This code is a private method that optimizes the numeric types used in mathematical operations. It adjusts the precision and scale of the numeric types based on the operation being performed (addition, subtraction, multiplication, division, or modulus) and returns the optimized type."
16,"optimizeInterval(Session,int,int)",optimize interval session l r ,Method,optimize(Session),,"org.h2.value.DataType+isIntervalType(int) org.h2.value.DataType+isIntervalType(int) org.h2.value.DataType+isNumericType(int) org.h2.value.DataType+isNumericType(int) org.h2.value.DataType+isDateTimeType(int) org.h2.value.DataType+isDateTimeType(int) org.h2.expression.BinaryOperation+getUnsupported(int,int) org.h2.expression.BinaryOperation+getUnsupported(int,int) org.h2.value.DataType+isIntervalType(int) org.h2.value.DataType+isIntervalType(int) org.h2.value.DataType+isNumericType(int) org.h2.value.DataType+isNumericType(int) org.h2.value.DataType+isDateTimeType(int) org.h2.value.DataType+isDateTimeType(int) org.h2.expression.BinaryOperation+getUnsupported(int,int) org.h2.expression.BinaryOperation+getUnsupported(int,int) org.h2.value.DataType+isYearMonthIntervalType(int) org.h2.value.DataType+isYearMonthIntervalType(int) org.h2.value.DataType+isYearMonthIntervalType(int) org.h2.value.DataType+isYearMonthIntervalType(int) org.h2.expression.IntervalOperation+IntervalOperation(IntervalOpType,Expression,Expression) org.h2.value.DataType+isYearMonthIntervalType(int) org.h2.value.DataType+isYearMonthIntervalType(int) org.h2.expression.IntervalOperation+IntervalOperation(IntervalOpType,Expression,Expression) org.h2.value.DataType+isYearMonthIntervalType(int) org.h2.value.DataType+isYearMonthIntervalType(int) org.h2.expression.IntervalOperation+IntervalOperation(IntervalOpType,Expression,Expression) org.h2.value.DataType+isYearMonthIntervalType(int) org.h2.value.DataType+isYearMonthIntervalType(int) org.h2.value.DataType+isYearMonthIntervalType(int) org.h2.value.DataType+isYearMonthIntervalType(int) org.h2.expression.IntervalOperation+IntervalOperation(IntervalOpType,Expression,Expression) org.h2.value.DataType+isYearMonthIntervalType(int) org.h2.value.DataType+isYearMonthIntervalType(int) org.h2.expression.IntervalOperation+IntervalOperation(IntervalOpType,Expression,Expression) org.h2.expression.IntervalOperation+IntervalOperation(IntervalOpType,Expression,Expression) org.h2.expression.IntervalOperation+IntervalOperation(IntervalOpType,Expression,Expression) org.h2.expression.IntervalOperation+IntervalOperation(IntervalOpType,Expression,Expression) org.h2.value.DataType+isYearMonthIntervalType(int) org.h2.value.DataType+isYearMonthIntervalType(int) org.h2.value.DataType+isYearMonthIntervalType(int) org.h2.value.DataType+isYearMonthIntervalType(int) org.h2.expression.IntervalOperation+IntervalOperation(IntervalOpType,Expression,Expression) org.h2.expression.BinaryOperation+getUnsupported(int,int) org.h2.expression.BinaryOperation+getUnsupported(int,int)",org.h2.expression.BinaryOperation+opType org.h2.expression.BinaryOperation+left org.h2.expression.BinaryOperation+right org.h2.value.Value+TIME org.h2.expression.BinaryOperation+right org.h2.expression.BinaryOperation+left org.h2.value.Value+TIME org.h2.expression.BinaryOperation+left org.h2.expression.BinaryOperation+right org.h2.expression.BinaryOperation+left org.h2.expression.BinaryOperation+right org.h2.value.Value+TIME org.h2.expression.BinaryOperation+left org.h2.expression.BinaryOperation+right org.h2.expression.BinaryOperation+left org.h2.expression.BinaryOperation+right org.h2.expression.BinaryOperation+right org.h2.expression.BinaryOperation+left org.h2.expression.BinaryOperation+left org.h2.expression.BinaryOperation+right org.h2.expression.BinaryOperation+left org.h2.expression.BinaryOperation+right,3175,72,2,,"private Expression optimizeInterval(Session session, int l, int r) {
        boolean lInterval = false, lNumeric = false, lDateTime = false;
        if (DataType.isIntervalType(l)) {
            lInterval = true;
        } else if (DataType.isNumericType(l)) {
            lNumeric = true;
        } else if (DataType.isDateTimeType(l)) {
            lDateTime = true;
        } else {
            throw getUnsupported(l, r);
        }
        boolean rInterval = false, rNumeric = false, rDateTime = false;
        if (DataType.isIntervalType(r)) {
            rInterval = true;
        } else if (DataType.isNumericType(r)) {
            rNumeric = true;
        } else if (DataType.isDateTimeType(r)) {
            rDateTime = true;
        } else {
            throw getUnsupported(l, r);
        }
        switch (opType) {
        case PLUS:
            if (lInterval && rInterval) {
                if (DataType.isYearMonthIntervalType(l) == DataType.isYearMonthIntervalType(r)) {
                    return new IntervalOperation(IntervalOpType.INTERVAL_PLUS_INTERVAL, left, right);
                }
            } else if (lInterval && rDateTime) {
                if (r == Value.TIME && DataType.isYearMonthIntervalType(l)) {
                    break;
                }
                return new IntervalOperation(IntervalOpType.DATETIME_PLUS_INTERVAL, right, left);
            } else if (lDateTime && rInterval) {
                if (l == Value.TIME && DataType.isYearMonthIntervalType(r)) {
                    break;
                }
                return new IntervalOperation(IntervalOpType.DATETIME_PLUS_INTERVAL, left, right);
            }
            break;
        case MINUS:
            if (lInterval && rInterval) {
                if (DataType.isYearMonthIntervalType(l) == DataType.isYearMonthIntervalType(r)) {
                    return new IntervalOperation(IntervalOpType.INTERVAL_MINUS_INTERVAL, left, right);
                }
            } else if (lDateTime && rInterval) {
                if (l == Value.TIME && DataType.isYearMonthIntervalType(r)) {
                    break;
                }
                return new IntervalOperation(IntervalOpType.DATETIME_MINUS_INTERVAL, left, right);
            }
            break;
        case MULTIPLY:
            if (lInterval && rNumeric) {
                return new IntervalOperation(IntervalOpType.INTERVAL_MULTIPLY_NUMERIC, left, right);
            } else if (lNumeric && rInterval) {
                return new IntervalOperation(IntervalOpType.INTERVAL_MULTIPLY_NUMERIC, right, left);
            }
            break;
        case DIVIDE:
            if (lInterval) {
                if (rNumeric) {
                    return new IntervalOperation(IntervalOpType.INTERVAL_DIVIDE_NUMERIC, left, right);
                } else if (rInterval && DataType.isYearMonthIntervalType(l) == DataType.isYearMonthIntervalType(r)) {
                    // Non-standard
                    return new IntervalOperation(IntervalOpType.INTERVAL_DIVIDE_INTERVAL, left, right);
                }
            }
            break;
        default:
        }
        throw getUnsupported(l, r);
    }",False,False,"This method takes in a session and two integers, l and r. It checks the data type of l and r and sets corresponding boolean variables. Then, based on the opType, it returns an Expression object representing the optimized interval operation. If none of the cases match, it throws an exception.",True,"The given code is a private method called `optimizeInterval` that takes a session, and two integer parameters `l` and `r`. It checks the data types of `l` and `r` and performs different operations based on the operator type (`PLUS`, `MINUS`, `MULTIPLY`, `DIVIDE`). It returns an `Expression` object based on the conditions met, otherwise throws an exception."
17,"optimizeDateTime(Session,int,int)",optimize date time session l r ,Method,optimize(Session),,"org.h2.value.Value+getHigherOrder(int,int) org.h2.value.Value+getHigherOrder(int,int) org.h2.expression.BinaryOperation+swap() org.h2.expression.BinaryOperation+swap() org.h2.expression.function.Function+getFunctionWithArgs(Database,int,Expression[]) org.h2.expression.function.Function+getFunctionWithArgs(Database,int,Expression[]) org.h2.engine.Session+getDatabase() org.h2.engine.Session+getDatabase() org.h2.expression.ValueExpression+get(Value) org.h2.expression.ValueExpression+get(Value) org.h2.value.ValueInteger+get(int) org.h2.value.ValueInteger+get(int) org.h2.expression.function.Function+getFunctionWithArgs(Database,int,Expression[]) org.h2.expression.function.Function+getFunctionWithArgs(Database,int,Expression[]) org.h2.engine.Session+getDatabase() org.h2.engine.Session+getDatabase() org.h2.expression.ValueExpression+get(Value) org.h2.expression.ValueExpression+get(Value) org.h2.value.ValueInteger+get(int) org.h2.value.ValueInteger+get(int) org.h2.expression.BinaryOperation+BinaryOperation(OpType,Expression,Expression) org.h2.expression.ValueExpression+get(Value) org.h2.expression.ValueExpression+get(Value) org.h2.value.ValueInteger+get(int) org.h2.value.ValueInteger+get(int) org.h2.value.DataType+isDateTimeType(int) org.h2.value.DataType+isDateTimeType(int) org.h2.expression.CompatibilityDatePlusTimeOperation+optimize(Session) org.h2.expression.CompatibilityDatePlusTimeOperation+CompatibilityDatePlusTimeOperation(Expression,Expression) org.h2.expression.CompatibilityDatePlusTimeOperation+optimize(Session) org.h2.expression.BinaryOperation+getUnexpectedForcedTypeException() org.h2.expression.BinaryOperation+getUnexpectedForcedTypeException() org.h2.expression.function.Function+getFunctionWithArgs(Database,int,Expression[]) org.h2.expression.function.Function+getFunctionWithArgs(Database,int,Expression[]) org.h2.engine.Session+getDatabase() org.h2.engine.Session+getDatabase() org.h2.expression.ValueExpression+get(Value) org.h2.expression.ValueExpression+get(Value) org.h2.value.ValueInteger+get(int) org.h2.value.ValueInteger+get(int) org.h2.expression.UnaryOperation+UnaryOperation(Expression) org.h2.expression.BinaryOperation+getUnexpectedForcedTypeException() org.h2.expression.BinaryOperation+getUnexpectedForcedTypeException() org.h2.expression.function.Function+getFunctionWithArgs(Database,int,Expression[]) org.h2.expression.function.Function+getFunctionWithArgs(Database,int,Expression[]) org.h2.engine.Session+getDatabase() org.h2.engine.Session+getDatabase() org.h2.expression.ValueExpression+get(Value) org.h2.expression.ValueExpression+get(Value) org.h2.value.ValueInteger+get(int) org.h2.value.ValueInteger+get(int) org.h2.expression.UnaryOperation+UnaryOperation(Expression) org.h2.expression.BinaryOperation+BinaryOperation(OpType,Expression,Expression) org.h2.expression.ValueExpression+get(Value) org.h2.expression.ValueExpression+get(Value) org.h2.value.ValueInteger+get(int) org.h2.value.ValueInteger+get(int) org.h2.expression.IntervalOperation+IntervalOperation(IntervalOpType,Expression,Expression,TypeInfo) org.h2.value.DataType+isDateTimeType(int) org.h2.value.DataType+isDateTimeType(int) org.h2.expression.IntervalOperation+IntervalOperation(IntervalOpType,Expression,Expression,TypeInfo) org.h2.expression.BinaryOperation+swap() org.h2.expression.BinaryOperation+swap() org.h2.expression.BinaryOperation+getUnsupported(int,int) org.h2.expression.BinaryOperation+getUnsupported(int,int)",org.h2.expression.BinaryOperation+opType org.h2.value.Value+INTEGER org.h2.expression.function.Function+DATEADD org.h2.expression.function.DateTimeFunctions+DAY org.h2.expression.BinaryOperation+left org.h2.expression.BinaryOperation+right org.h2.value.Value+NUMERIC org.h2.value.Value+REAL org.h2.value.Value+DOUBLE org.h2.expression.function.Function+DATEADD org.h2.expression.function.DateTimeFunctions+SECOND org.h2.expression.BinaryOperation+OpType org.h2.expression.BinaryOperation+left org.h2.expression.BinaryOperation+right org.h2.value.Value+TIME org.h2.value.Value+TIME_TZ org.h2.expression.BinaryOperation+right org.h2.expression.BinaryOperation+left org.h2.value.Value+DATE org.h2.value.Value+TIMESTAMP org.h2.value.Value+TIMESTAMP_TZ org.h2.value.Value+INTEGER org.h2.expression.BinaryOperation+forcedType org.h2.expression.function.Function+DATEADD org.h2.expression.function.DateTimeFunctions+DAY org.h2.expression.BinaryOperation+right org.h2.expression.BinaryOperation+left org.h2.value.Value+NUMERIC org.h2.value.Value+REAL org.h2.value.Value+DOUBLE org.h2.expression.BinaryOperation+forcedType org.h2.expression.function.Function+DATEADD org.h2.expression.function.DateTimeFunctions+SECOND org.h2.expression.BinaryOperation+OpType org.h2.expression.BinaryOperation+right org.h2.expression.BinaryOperation+left org.h2.value.Value+TIME org.h2.value.Value+TIME_TZ org.h2.value.Value+DATE org.h2.value.Value+TIMESTAMP org.h2.value.Value+TIMESTAMP_TZ org.h2.expression.BinaryOperation+left org.h2.expression.BinaryOperation+right org.h2.expression.BinaryOperation+forcedType org.h2.value.Value+TIME org.h2.value.Value+TIME_TZ org.h2.expression.BinaryOperation+left org.h2.expression.BinaryOperation+right org.h2.expression.BinaryOperation+forcedType org.h2.value.Value+TIME org.h2.expression.BinaryOperation+type org.h2.value.TypeInfo+TYPE_TIME org.h2.expression.BinaryOperation+convertRight org.h2.value.Value+TIME org.h2.expression.BinaryOperation+type org.h2.value.TypeInfo+TYPE_TIME org.h2.expression.BinaryOperation+convertRight org.h2.value.Value+TIME org.h2.expression.BinaryOperation+type org.h2.value.TypeInfo+TYPE_TIME org.h2.expression.BinaryOperation+convertRight,4243,101,2,,"private Expression optimizeDateTime(Session session, int l, int r) {
        switch (opType) {
        case PLUS:
            if (r != Value.getHigherOrder(l, r)) {
                // order left and right: INT < TIME < DATE < TIMESTAMP
                swap();
                int t = l;
                l = r;
                r = t;
            }
            switch (l) {
            case Value.INTEGER:
                // Oracle date add
                return Function.getFunctionWithArgs(session.getDatabase(), Function.DATEADD,
                        ValueExpression.get(ValueInteger.get(DateTimeFunctions.DAY)), left, right).optimize(session);
            case Value.NUMERIC:
            case Value.REAL:
            case Value.DOUBLE:
                // Oracle date add
                return Function
                        .getFunctionWithArgs(session.getDatabase(), Function.DATEADD,
                                ValueExpression.get(ValueInteger.get(DateTimeFunctions.SECOND)),
                                new BinaryOperation(OpType.MULTIPLY,
                                        ValueExpression.get(ValueInteger.get(60 * 60 * 24)), left),
                                right)
                        .optimize(session);
            case Value.TIME:
            case Value.TIME_TZ:
                if (DataType.isDateTimeType(r)) {
                    return new CompatibilityDatePlusTimeOperation(right, left).optimize(session);
                }
            }
            break;
        case MINUS:
            switch (l) {
            case Value.DATE:
            case Value.TIMESTAMP:
            case Value.TIMESTAMP_TZ:
                switch (r) {
                case Value.INTEGER: {
                    if (forcedType != null) {
                        throw getUnexpectedForcedTypeException();
                    }
                    // Oracle date subtract
                    return Function.getFunctionWithArgs(session.getDatabase(), Function.DATEADD,
                            ValueExpression.get(ValueInteger.get(DateTimeFunctions.DAY)), //
                            new UnaryOperation(right), //
                            left).optimize(session);
                }
                case Value.NUMERIC:
                case Value.REAL:
                case Value.DOUBLE: {
                    if (forcedType != null) {
                        throw getUnexpectedForcedTypeException();
                    }
                    // Oracle date subtract
                    return Function.getFunctionWithArgs(session.getDatabase(), Function.DATEADD,
                                ValueExpression.get(ValueInteger.get(DateTimeFunctions.SECOND)),
                                new UnaryOperation(new BinaryOperation(OpType.MULTIPLY, //
                                        ValueExpression.get(ValueInteger.get(60 * 60 * 24)), right)), //
                                left).optimize(session);
                }
                case Value.TIME:
                case Value.TIME_TZ:
                case Value.DATE:
                case Value.TIMESTAMP:
                case Value.TIMESTAMP_TZ:
                    return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right, forcedType);
                }
                break;
            case Value.TIME:
            case Value.TIME_TZ:
                if (DataType.isDateTimeType(r)) {
                    return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right, forcedType);
                }
                break;
            }
            break;
        case MULTIPLY:
            if (l == Value.TIME) {
                type = TypeInfo.TYPE_TIME;
                convertRight = false;
                return this;
            } else if (r == Value.TIME) {
                swap();
                type = TypeInfo.TYPE_TIME;
                convertRight = false;
                return this;
            }
            break;
        case DIVIDE:
            if (l == Value.TIME) {
                type = TypeInfo.TYPE_TIME;
                convertRight = false;
                return this;
            }
            break;
        default:
        }
        throw getUnsupported(l, r);
    }",False,False,"The function of this method is to optimize a DateTime expression based on the operation type and the types of the left and right operands. It handles operations such as addition, subtraction, multiplication, and division of DateTime values.",True,"The given code is a method called `optimizeDateTime` that is used to optimize date and time operations in a database session. It handles different cases for addition, subtraction, multiplication, and division of date and time values, and returns the optimized expression for the operation."
18,"getUnsupported(int,int)",get unsupported l r ,Method,"optimizeInterval(Session,int,int) optimizeInterval(Session,int,int) optimizeInterval(Session,int,int) optimizeDateTime(Session,int,int)",,org.h2.message.DbException+getUnsupportedException(String) org.h2.message.DbException+getUnsupportedException(String) org.h2.value.DataType+getDataType(int) org.h2.value.DataType+getDataType(int) org.h2.expression.BinaryOperation+getOperationToken() org.h2.expression.BinaryOperation+getOperationToken() org.h2.value.DataType+getDataType(int) org.h2.value.DataType+getDataType(int),org.h2.value.DataType+name org.h2.value.DataType+name org.h2.value.DataType+name org.h2.value.DataType+name,220,4,2,,"private DbException getUnsupported(int l, int r) {
        return DbException.getUnsupportedException(
                DataType.getDataType(l).name + ' ' + getOperationToken() + ' ' + DataType.getDataType(r).name);
    }",False,False,The function of this method is to return a DbException object with a message indicating that the operation between two data types is not supported.,False,"The code defines a private method named ""getUnsupported"" that takes two integer parameters. It returns a DbException object with a message indicating that the operation between two data types (retrieved using the given integers) is not supported."
19,getUnexpectedForcedTypeException(),get unexpected forced type exception ,Method,"setForcedType(TypeInfo) optimize(Session) optimize(Session) optimizeDateTime(Session,int,int) optimizeDateTime(Session,int,int)",,"org.h2.expression.BinaryOperation+getSQL(StringBuilder,int) org.h2.expression.BinaryOperation+getSQL(StringBuilder,int) java.lang.StringBuilder+StringBuilder() java.lang.StringBuilder+length() java.lang.StringBuilder+length() org.h2.message.DbException+getSyntaxError(String,int,String) org.h2.message.DbException+getSyntaxError(String,int,String) java.lang.StringBuilder+toString() org.h2.expression.IntervalOperation+getForcedTypeSQL(StringBuilder,TypeInfo) org.h2.expression.IntervalOperation+getForcedTypeSQL(StringBuilder,TypeInfo) java.lang.StringBuilder+append(char) java.lang.StringBuilder+append(char) java.lang.StringBuilder+toString()",org.h2.util.HasSQL+TRACE_SQL_FLAGS org.h2.expression.BinaryOperation+forcedType,329,6,2,,"private DbException getUnexpectedForcedTypeException() {
        StringBuilder builder = getSQL(new StringBuilder(), TRACE_SQL_FLAGS);
        int index = builder.length();
        return DbException.getSyntaxError(
                IntervalOperation.getForcedTypeSQL(builder.append(' '), forcedType).toString(), index, """");
    }",False,False,This method returns a DbException with a syntax error message. It appends a forced type to a SQL query string and gets the index of the appended forced type.,False,"The code defines a private method named `getUnexpectedForcedTypeException()` that returns a `DbException`. It constructs a SQL query using a `StringBuilder` and a forced type, and then creates a syntax error exception with the constructed SQL query and an index."
20,swap(),swap ,Method,"optimizeDateTime(Session,int,int) optimizeDateTime(Session,int,int)",,,org.h2.expression.BinaryOperation+left org.h2.expression.BinaryOperation+left org.h2.expression.BinaryOperation+right org.h2.expression.BinaryOperation+right,103,5,2,,"private void swap() {
        Expression temp = left;
        left = right;
        right = temp;
    }",False,False,"The function of the method is to swap the values of the ""left"" and ""right"" variables by using a temporary variable called ""temp"".",False,"The code defines a private method called ""swap"" that swaps the values of two variables, ""left"" and ""right"", of type Expression. This method is used to interchange the values of the variables."
21,"setEvaluatable(TableFilter,boolean)",set evaluatable table filter b ,Method,,,"org.h2.expression.Expression+setEvaluatable(TableFilter,boolean) org.h2.expression.Expression+setEvaluatable(TableFilter,boolean) org.h2.expression.Expression+setEvaluatable(TableFilter,boolean) org.h2.expression.Expression+setEvaluatable(TableFilter,boolean)",org.h2.expression.BinaryOperation+left org.h2.expression.BinaryOperation+right,175,5,1,,"@Override
    public void setEvaluatable(TableFilter tableFilter, boolean b) {
        left.setEvaluatable(tableFilter, b);
        right.setEvaluatable(tableFilter, b);
    }",True,True,This method sets the evaluatable property of both the left and right table filters to the specified boolean value.,True,"The code is implementing the `setEvaluatable` method, which is used to set the evaluatable property of a `TableFilter` object. The method sets the evaluatable property of both the `left` and `right` objects to the specified boolean value."
22,getType(),get type ,Method,,,,org.h2.expression.BinaryOperation+type,68,4,1,,"@Override
    public TypeInfo getType() {
        return type;
    }",False,True,This method serves to return the type of the object.,False,"The code snippet defines an overridden method called ""getType()"" that returns an object of type ""TypeInfo"". It is expected to provide information about the type of an entity."
23,"updateAggregate(Session,int)",update aggregate session stage ,Method,,,"org.h2.expression.Expression+updateAggregate(Session,int) org.h2.expression.Expression+updateAggregate(Session,int) org.h2.expression.Expression+updateAggregate(Session,int) org.h2.expression.Expression+updateAggregate(Session,int)",org.h2.expression.BinaryOperation+left org.h2.expression.BinaryOperation+right,170,5,1,,"@Override
    public void updateAggregate(Session session, int stage) {
        left.updateAggregate(session, stage);
        right.updateAggregate(session, stage);
    }",True,True,This method updates the aggregate values for both the left and right objects using the given session and stage.,True,"The given code snippet represents a method called ""updateAggregate"" that takes a session and a stage as parameters. This method is used to update the aggregate by invoking the ""updateAggregate"" method on both the ""left"" and ""right"" objects."
24,isEverything(ExpressionVisitor),is everything visitor ,Method,,,org.h2.expression.Expression+isEverything(ExpressionVisitor) org.h2.expression.Expression+isEverything(ExpressionVisitor) org.h2.expression.Expression+isEverything(ExpressionVisitor) org.h2.expression.Expression+isEverything(ExpressionVisitor),org.h2.expression.BinaryOperation+left org.h2.expression.BinaryOperation+right,150,4,1,,"@Override
    public boolean isEverything(ExpressionVisitor visitor) {
        return left.isEverything(visitor) && right.isEverything(visitor);
    }",True,True,"The function of the given method is to check if both the left and right expressions satisfy the condition specified by the ExpressionVisitor. It returns true if both expressions pass the condition, otherwise it returns false.",True,"The code defines an overridden method called ""isEverything"" that takes an ExpressionVisitor object as a parameter. It returns a boolean value indicating whether both the ""left"" and ""right"" expressions satisfy the ""isEverything"" condition when visited by the provided visitor object."
25,getCost(),get cost ,Method,,,org.h2.expression.Expression+getCost() org.h2.expression.Expression+getCost() org.h2.expression.Expression+getCost() org.h2.expression.Expression+getCost(),org.h2.expression.BinaryOperation+left org.h2.expression.BinaryOperation+right,95,4,1,,"@Override
    public int getCost() {
        return left.getCost() + right.getCost() + 1;
    }",False,True,"This method returns the sum of the costs of the left and right objects, plus 1.",True,"The `getCost()` method returns the sum of the costs of the `left` and `right` objects, plus 1. It is likely used to calculate the total cost of an operation or calculation involving these objects."
26,getSubexpressionCount(),get subexpression count ,Method,,,,,74,4,1,,"@Override
    public int getSubexpressionCount() {
        return 2;
    }",True,True,This method returns the number of subexpressions in an object.,True,"The code snippet is a method named ""getSubexpressionCount"" that returns an integer value of 2. It is likely a part of a larger class or interface implementation and is used to determine the number of subexpressions present in a certain context or scenario."
27,getSubexpression(int),get subexpression index ,Method,,,java.lang.IndexOutOfBoundsException+IndexOutOfBoundsException(),org.h2.expression.BinaryOperation+left org.h2.expression.BinaryOperation+right,253,11,1,,"@Override
    public Expression getSubexpression(int index) {
        switch (index) {
        case 0:
            return left;
        case 1:
            return right;
        default:
            throw new IndexOutOfBoundsException();
        }
    }",True,True,"This method returns the subexpression at the specified index. If the index is 0, it returns the left subexpression. If the index is 1, it returns the right subexpression. Otherwise, it throws an IndexOutOfBoundsException.",True,"This code is an implementation of the `getSubexpression` method, which returns the subexpression at a given index. It takes an integer index as input and returns the corresponding subexpression (either `left` or `right`). If the index is not 0 or 1, it throws an `IndexOutOfBoundsException`."
28,getOperationType(),get operation type returns the type of this binary operation return the type of this binary operation ,Method,,,,org.h2.expression.BinaryOperation+opType,185,8,1,"/** 
 * Returns the type of this binary operation.
 * @return the type of this binary operation
 */
","/**
     * Returns the type of this binary operation.
     *
     * @return the type of this binary operation
     */
    public OpType getOperationType() {
        return opType;
    }",False,False,This method returns the type of the binary operation.,True,"This code defines a method called ""getOperationType"" that returns the type of a binary operation. The method has no parameters and returns an object of type ""OpType"". The purpose of this method is to provide access to the type of the binary operation."
