index,name,document,type,inner invocations,external invocations,calls,visits,length,lines,modifier,commit,full text,moved,removed,gpt text,gpt response,code summary
1,logger,logger ,Field,,,,,76,1,24,,static final Logger logger = LoggerFactory.getLogger(Http2ClientTest.class);,False,False,,False,
2,server,server ,Field,,,,,30,1,8,,static Undertow server = null;,False,False,,False,
3,sslContext,ssl context ,Field,,,,,29,1,8,,static SSLContext sslContext;,False,False,,False,
4,message,message ,Field,,,,,53,1,26,,"private static final String message = ""Hello World!"";",False,False,,False,
5,MESSAGE,message ,Field,,,,,48,1,25,,"public static final String MESSAGE = ""/message"";",False,False,,False,
6,POST,post ,Field,,,,,42,1,25,,"public static final String POST = ""/post"";",False,False,,False,
7,FORM,form ,Field,,,,,42,1,25,,"public static final String FORM = ""/form"";",False,False,,False,
8,TOKEN,token ,Field,,,,,51,1,25,,"public static final String TOKEN = ""/oauth2/token"";",False,False,,False,
9,API,api ,Field,,,,,40,1,25,,"public static final String API = ""/api"";",False,False,,False,
10,KEY,key ,Field,,,,,47,1,25,,"public static final String KEY = ""/oauth2/key"";",False,False,,False,
11,SERVER_KEY_STORE,server key store ,Field,,,,,69,1,26,,"private static final String SERVER_KEY_STORE = ""tls/server.keystore"";",False,False,,False,
12,SERVER_TRUST_STORE,server trust store ,Field,,,,,73,1,26,,"private static final String SERVER_TRUST_STORE = ""tls/server.truststore"";",False,False,,False,
13,CLIENT_KEY_STORE,client key store ,Field,,,,,69,1,26,,"private static final String CLIENT_KEY_STORE = ""tls/client.keystore"";",False,False,,False,
14,CLIENT_TRUST_STORE,client trust store ,Field,,,,,73,1,26,,"private static final String CLIENT_TRUST_STORE = ""tls/client.truststore"";",False,False,,False,
15,STORE_PASSWORD,store password ,Field,,,,,70,1,26,,"private static final char[] STORE_PASSWORD = ""password"".toCharArray();",False,False,,False,
16,worker,worker ,Field,,,,,33,1,10,,private static XnioWorker worker;,False,False,,False,
17,ADDRESS,address ,Field,,,,,33,1,26,,private static final URI ADDRESS;,False,False,,False,
18,sendMessage(HttpServerExchange),send message exchange ,Method,,,java.lang.String+length() java.lang.String+length(),com.networknt.client.Http2ClientTest+message com.networknt.client.Http2ClientTest+message,294,6,8,,"static void sendMessage(final HttpServerExchange exchange) {
        exchange.setStatusCode(StatusCodes.OK);
        exchange.getResponseHeaders().put(Headers.CONTENT_LENGTH, message.length() + """");
        final Sender sender = exchange.getResponseSender();
        sender.send(message);
    }",False,False,"This method sends a message as a response to an HTTP server exchange. It sets the status code to OK, sets the content length header, and sends the message using the response sender.",True,"The code defines a static method called `sendMessage` that takes an `HttpServerExchange` object as a parameter. It sets the status code of the exchange to OK, adds the content length header to the response, and sends the message using the response sender."
19,beforeClass(),before class ,Method,,,"java.io.PrintStream+println(String) java.io.PrintStream+println(String) com.networknt.client.Http2ClientTest+createSSLContext(KeyStore,KeyStore,boolean) com.networknt.client.Http2ClientTest+createSSLContext(KeyStore,KeyStore,boolean) com.networknt.client.Http2ClientTest+loadKeyStore(String) com.networknt.client.Http2ClientTest+loadKeyStore(String) com.networknt.client.Http2ClientTest+loadKeyStore(String) com.networknt.client.Http2ClientTest+loadKeyStore(String) java.lang.Runtime+availableProcessors() java.lang.Runtime+getRuntime() java.lang.Runtime+getRuntime() java.lang.Runtime+availableProcessors()",com.networknt.client.Http2Client+DEFAULT_OPTIONS com.networknt.client.Http2ClientTest+worker com.networknt.client.Http2ClientTest+server java.lang.System+out com.networknt.client.Http2ClientTest+sslContext com.networknt.client.Http2ClientTest+SERVER_KEY_STORE com.networknt.client.Http2ClientTest+SERVER_TRUST_STORE com.networknt.client.Http2ClientTest+sslContext com.networknt.client.Http2ClientTest+server com.networknt.client.Http2ClientTest+MESSAGE com.networknt.client.Http2ClientTest+KEY com.networknt.client.Http2ClientTest+API com.networknt.client.Http2ClientTest+FORM,5159,83,9,,"@BeforeClass
    public static void beforeClass() throws IOException {
        // Create xnio worker
        final Xnio xnio = Xnio.getInstance();
        final XnioWorker xnioWorker = xnio.createWorker(null, Http2Client.DEFAULT_OPTIONS);
        worker = xnioWorker;

        if(server == null) {
            System.out.println(""starting server"");
            Undertow.Builder builder = Undertow.builder();

            sslContext = createSSLContext(loadKeyStore(SERVER_KEY_STORE), loadKeyStore(SERVER_TRUST_STORE), false);
            builder.addHttpsListener(7778, ""localhost"", sslContext);
            builder.addHttpListener(7777, ""localhost"");

            builder.setServerOption(UndertowOptions.ENABLE_HTTP2, true);


            server = builder
                    .setBufferSize(1024 * 16)
                    .setIoThreads(Runtime.getRuntime().availableProcessors() * 2) //this seems slightly faster in some configurations
                    .setSocketOption(Options.BACKLOG, 10000)
                    .setServerOption(UndertowOptions.ALWAYS_SET_KEEP_ALIVE, false) //don't send a keep-alive header for HTTP/1.1 requests, as it is not required
                    .setServerOption(UndertowOptions.ALWAYS_SET_DATE, true)
                    .setServerOption(UndertowOptions.RECORD_REQUEST_START_TIME, false)
                    .setHandler(new PathHandler()
                            .addExactPath(MESSAGE, exchange -> sendMessage(exchange))
                            .addExactPath(KEY, exchange -> sendMessage(exchange))
                            .addExactPath(API, (exchange) -> {
                                boolean hasScopeToken = exchange.getRequestHeaders().contains(Constants.SCOPE_TOKEN);
                                Assert.assertTrue(hasScopeToken);
                                String scopeToken = exchange.getRequestHeaders().get(Constants.SCOPE_TOKEN, 0);
                                boolean expired = isTokenExpired(scopeToken);
                                Assert.assertFalse(expired);
                                exchange.getResponseHeaders().put(Headers.CONTENT_TYPE, ""application/json"");
                                exchange.getResponseSender().send(ByteBuffer.wrap(
                                        Config.getInstance().getMapper().writeValueAsBytes(
                                                Collections.singletonMap(""message"", ""OK!""))));

                            })
                            .addExactPath(FORM, exchange -> exchange.getRequestReceiver().receiveFullString(new Receiver.FullStringCallback() {
                                @Override
                                public void handle(HttpServerExchange exchange, String message) {
                                    exchange.getResponseSender().send(message);
                                }
                            }))
                            .addExactPath(TOKEN, exchange -> exchange.getRequestReceiver().receiveFullString(new Receiver.FullStringCallback() {
                                @Override
                                public void handle(HttpServerExchange exchange, String message) {
                                    try {
                                        int sleepTime = randInt(1, 3) * 1000;
                                        if(sleepTime >= 2000) {
                                            sleepTime = 3000;
                                        } else {
                                            sleepTime = 1000;
                                        }
                                        Thread.sleep(sleepTime);
                                        // create a token that expired in 5 seconds.
                                        Map<String, Object> map = new HashMap<>();
                                        String token = getJwt(5);
                                        map.put(""access_token"", token);
                                        map.put(""token_type"", ""Bearer"");
                                        map.put(""expires_in"", 5);
                                        exchange.getResponseHeaders().put(Headers.CONTENT_TYPE, ""application/json"");
                                        exchange.getResponseSender().send(ByteBuffer.wrap(
                                                Config.getInstance().getMapper().writeValueAsBytes(map)));
                                    } catch (Exception e) {
                                        e.printStackTrace();
                                    }
                                }
                            }))
                            .addExactPath(POST, exchange -> exchange.getRequestReceiver().receiveFullString(new Receiver.FullStringCallback() {
                                @Override
                                public void handle(HttpServerExchange exchange, String message) {
                                    exchange.getResponseSender().send(message);
                                }
                            })))
                    .setWorkerThreads(200)
                    .build();

            server.start();
        }
    }",False,False,The function of this method is to set up the necessary configurations and start the server for testing purposes.,True,"The code is a `@BeforeClass` method that sets up an Undertow server with HTTP and HTTPS listeners. It configures various server options and adds different handlers for specific paths, including sending messages, handling tokens, and receiving POST requests."
20,afterClass(),after class ,Method,,,java.lang.Thread+sleep(long) java.lang.Thread+sleep(long) java.io.PrintStream+println(String) java.io.PrintStream+println(String) java.lang.Thread+sleep(long) java.lang.Thread+sleep(long),com.networknt.client.Http2ClientTest+worker com.networknt.client.Http2ClientTest+server com.networknt.client.Http2ClientTest+server java.lang.System+out,447,17,9,,"@AfterClass
    public static void afterClass() {
        worker.shutdown();
        if(server != null) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException ignored) {
            }
            server.stop();
            System.out.println(""The server is stopped."");
            try {
                Thread.sleep(100);
            } catch (InterruptedException ignored) {
            }
        }

    }",False,False,"This method is executed after all test classes have finished running. It shuts down a worker, stops a server, and prints a message indicating that the server has been stopped.",True,"The given code is an `@AfterClass` method that is executed after all the test cases in a test class have been run. It shuts down a worker, stops a server (if it exists), and prints a message indicating that the server has been stopped."
21,createClient(),create client ,Method,testMultipleHttpGet() testMultipleHttpPost() testMultipleHttpGetSsl() testMultipleHttp2GetSsl() testMultipleHttpPostSsl() testMultipleHttp2PostSsl() testSingleHttp2PostSsl() testSingleHttp2FormSsl() testConnectionClose() callApiAsync(),,com.networknt.client.Http2ClientTest+createClient(OptionMap) com.networknt.client.Http2ClientTest+createClient(OptionMap),,87,3,8,,"static Http2Client createClient() {
        return createClient(OptionMap.EMPTY);
    }",False,False,The function of the given method is to create a static Http2Client object by calling another method createClient() with an empty OptionMap as a parameter.,True,"The code defines a static method named ""createClient"" that returns an instance of the ""Http2Client"" class. This method has an overloaded version that takes an ""OptionMap"" parameter, but in this case, it calls the overloaded version with an empty ""OptionMap""."
22,createClient(OptionMap),create client options ,Method,createClient(),,com.networknt.client.Http2Client+getInstance() com.networknt.client.Http2Client+getInstance(),,106,3,8,,"static Http2Client createClient(final OptionMap options) {
        return Http2Client.getInstance();
    }",False,False,This method creates and returns an instance of the Http2Client class using the getInstance() method.,True,"The code defines a static method named ""createClient"" that takes an OptionMap as a parameter and returns an instance of the Http2Client class. The method simply calls the getInstance() method of the Http2Client class to create and return a new client instance."
23,testMultipleHttpGet(),test multiple http get ,Method,,,"com.networknt.client.Http2ClientTest+createClient() com.networknt.client.Http2ClientTest+createClient() java.util.concurrent.CountDownLatch+CountDownLatch(int) com.networknt.client.Http2Client+connect(URI,XnioWorker,ByteBufferPool,OptionMap) com.networknt.client.Http2Client+connect(URI,XnioWorker,ByteBufferPool,OptionMap) +() +run()",com.networknt.client.Http2ClientTest+ADDRESS com.networknt.client.Http2ClientTest+worker com.networknt.client.Http2Client+POOL,1569,34,1,,"@Test
    public void testMultipleHttpGet() throws Exception {
        //
        final Http2Client client = createClient();

        final List<AtomicReference<ClientResponse>> references = new CopyOnWriteArrayList<>();
        final CountDownLatch latch = new CountDownLatch(10);
        final ClientConnection connection = client.connect(ADDRESS, worker, Http2Client.POOL, OptionMap.EMPTY).get();
        try {
            connection.getIoThread().execute(new Runnable() {
                @Override
                public void run() {
                    for (int i = 0; i < 10; i++) {
                        AtomicReference<ClientResponse> reference = new AtomicReference<>();
                        references.add(i, reference);
                        final ClientRequest request = new ClientRequest().setMethod(Methods.GET).setPath(MESSAGE);
                        request.getRequestHeaders().put(Headers.HOST, ""localhost"");
                        connection.sendRequest(request, client.createClientCallback(reference, latch));
                    }
                }

            });

            latch.await(10, TimeUnit.SECONDS);

            Assert.assertEquals(10, references.size());
            for (final AtomicReference<ClientResponse> reference : references) {
                Assert.assertEquals(message, reference.get().getAttachment(Http2Client.RESPONSE_BODY));
                Assert.assertEquals(""HTTP/1.1"", reference.get().getProtocol().toString());
            }
        } finally {
            IoUtils.safeClose(connection);
        }
    }",True,True,"The function of this method is to test the functionality of making multiple HTTP GET requests using a Http2Client. It creates a client, establishes a connection, sends 10 GET requests, waits for the responses, and then asserts that the responses are as expected.",True,"This code is a JUnit test method that tests the functionality of making multiple HTTP GET requests using an Http2Client. It creates a client, establishes a connection, sends 10 GET requests, and verifies the responses received, ensuring that the response body matches the expected message and the protocol is HTTP/1.1."
24,testMultipleHttpPost(),test multiple http post ,Method,,,"com.networknt.client.Http2ClientTest+createClient() com.networknt.client.Http2ClientTest+createClient() java.util.concurrent.CountDownLatch+CountDownLatch(int) com.networknt.client.Http2Client+connect(URI,XnioWorker,ByteBufferPool,OptionMap) com.networknt.client.Http2Client+connect(URI,XnioWorker,ByteBufferPool,OptionMap) +() +run()",com.networknt.client.Http2ClientTest+ADDRESS com.networknt.client.Http2ClientTest+worker com.networknt.client.Http2Client+POOL,3289,69,1,,"@Test
    public void testMultipleHttpPost() throws Exception {
        //
        final Http2Client client = createClient();
        final String postMessage = ""This is a post request"";

        final List<String> responses = new CopyOnWriteArrayList<>();
        final CountDownLatch latch = new CountDownLatch(10);
        final ClientConnection connection = client.connect(ADDRESS, worker, Http2Client.POOL, OptionMap.EMPTY).get();
        try {
            connection.getIoThread().execute(new Runnable() {
                @Override
                public void run() {
                    for (int i = 0; i < 10; i++) {
                        final ClientRequest request = new ClientRequest().setMethod(Methods.POST).setPath(POST);
                        request.getRequestHeaders().put(Headers.HOST, ""localhost"");
                        request.getRequestHeaders().put(Headers.TRANSFER_ENCODING, ""chunked"");
                        connection.sendRequest(request, new ClientCallback<ClientExchange>() {
                            @Override
                            public void completed(ClientExchange result) {
                                new StringWriteChannelListener(postMessage).setup(result.getRequestChannel());
                                result.setResponseListener(new ClientCallback<ClientExchange>() {
                                    @Override
                                    public void completed(ClientExchange result) {
                                        new StringReadChannelListener(Http2Client.POOL) {

                                            @Override
                                            protected void stringDone(String string) {
                                                responses.add(string);
                                                latch.countDown();
                                            }

                                            @Override
                                            protected void error(IOException e) {
                                                e.printStackTrace();
                                                latch.countDown();
                                            }
                                        }.setup(result.getResponseChannel());
                                    }

                                    @Override
                                    public void failed(IOException e) {
                                        e.printStackTrace();
                                        latch.countDown();
                                    }
                                });
                            }

                            @Override
                            public void failed(IOException e) {
                                e.printStackTrace();
                                latch.countDown();
                            }
                        });
                    }
                }

            });

            latch.await(10, TimeUnit.SECONDS);

            Assert.assertEquals(10, responses.size());
            for (final String response : responses) {
                Assert.assertEquals(postMessage, response);
            }
        } finally {
            IoUtils.safeClose(connection);
        }
    }",True,True,"The function of this method is to test the functionality of making multiple HTTP POST requests using an HTTP/2 client. It creates a client, sets up the requests, sends them, and verifies the responses.",True,"This code is a JUnit test method that sends multiple HTTP POST requests using an HTTP/2 client. It creates a client connection, sets up the requests with the necessary headers and content, sends the requests, and waits for the responses. The responses are then validated to ensure they match the expected post message."
25,testMultipleHttpGetSsl(),test multiple http get ssl ,Method,,,"com.networknt.client.Http2ClientTest+createClient() com.networknt.client.Http2ClientTest+createClient() java.util.concurrent.CountDownLatch+CountDownLatch(int) com.networknt.client.Http2Client+createSSLContext() com.networknt.client.Http2Client+createSSLContext() java.lang.Object+Object() com.networknt.client.Http2Client+connect(URI,XnioWorker,XnioSsl,ByteBufferPool,OptionMap) com.networknt.client.Http2Client+connect(URI,XnioWorker,XnioSsl,ByteBufferPool,OptionMap) java.net.URI+URI(String) +() +run()",com.networknt.client.Http2ClientTest+worker com.networknt.client.Http2Client+SSL_BUFFER_POOL com.networknt.client.Http2ClientTest+worker com.networknt.client.Http2Client+POOL,1942,42,1,,"@Test
    public void testMultipleHttpGetSsl() throws Exception {
        //
        final Http2Client client = createClient();

        final List<AtomicReference<ClientResponse>> references = new CopyOnWriteArrayList<>();
        final CountDownLatch latch = new CountDownLatch(10);
        SSLContext context = client.createSSLContext();
        XnioSsl ssl = new UndertowXnioSsl(worker.getXnio(), OptionMap.EMPTY, Http2Client.SSL_BUFFER_POOL, context);

        final ClientConnection connection = client.connect(new URI(""https://localhost:7778""), worker, ssl, Http2Client.POOL, OptionMap.EMPTY).get();
        try {
            connection.getIoThread().execute(new Runnable() {
                @Override
                public void run() {
                    for (int i = 0; i < 10; i++) {
                        AtomicReference<ClientResponse> reference = new AtomicReference<>();
                        references.add(i, reference);
                        final ClientRequest request = new ClientRequest().setMethod(Methods.GET).setPath(MESSAGE);
                        request.getRequestHeaders().put(Headers.HOST, ""localhost"");
                        connection.sendRequest(request, client.createClientCallback(reference, latch));
                    }
                }

            });

            latch.await(10, TimeUnit.SECONDS);

            Assert.assertEquals(10, references.size());
            for (final AtomicReference<ClientResponse> reference : references) {
                Assert.assertEquals(message, reference.get().getAttachment(Http2Client.RESPONSE_BODY));
                Assert.assertEquals(""HTTP/1.1"", reference.get().getProtocol().toString());
            }
        } finally {
            connection.getIoThread().execute(new Runnable() {
                @Override
                public void run() {
                    IoUtils.safeClose(connection);
                }
            });
        }
    }",True,True,"This method is a unit test that tests the functionality of making multiple HTTP GET requests over SSL. It creates a client, establishes a connection to a specified URI, sends multiple GET requests, and asserts that the responses are as expected.",True,"This code is a JUnit test method that tests the functionality of making multiple HTTPS GET requests using an HTTP/2 client. It creates a client connection, sends 10 GET requests to a localhost server, and asserts that the responses contain the expected message and use the HTTP/1.1 protocol."
26,testMultipleHttp2GetSsl(),test multiple http2 get ssl ,Method,,,"com.networknt.client.Http2ClientTest+createClient() com.networknt.client.Http2ClientTest+createClient() java.util.concurrent.CountDownLatch+CountDownLatch(int) com.networknt.client.Http2Client+createSSLContext() com.networknt.client.Http2Client+createSSLContext() java.lang.Object+Object() com.networknt.client.Http2Client+connect(URI,XnioWorker,XnioSsl,ByteBufferPool,OptionMap) com.networknt.client.Http2Client+connect(URI,XnioWorker,XnioSsl,ByteBufferPool,OptionMap) java.net.URI+URI(String) +() +run()",com.networknt.client.Http2ClientTest+worker com.networknt.client.Http2Client+SSL_BUFFER_POOL com.networknt.client.Http2ClientTest+worker com.networknt.client.Http2Client+POOL,1980,42,1,,"@Test
    public void testMultipleHttp2GetSsl() throws Exception {
        //
        final Http2Client client = createClient();

        final List<AtomicReference<ClientResponse>> references = new CopyOnWriteArrayList<>();
        final CountDownLatch latch = new CountDownLatch(10);
        SSLContext context = client.createSSLContext();
        XnioSsl ssl = new UndertowXnioSsl(worker.getXnio(), OptionMap.EMPTY, Http2Client.SSL_BUFFER_POOL, context);

        final ClientConnection connection = client.connect(new URI(""https://localhost:7778""), worker, ssl, Http2Client.POOL, OptionMap.create(UndertowOptions.ENABLE_HTTP2, true)).get();
        try {
            connection.getIoThread().execute(new Runnable() {
                @Override
                public void run() {
                    for (int i = 0; i < 10; i++) {
                        AtomicReference<ClientResponse> reference = new AtomicReference<>();
                        references.add(i, reference);
                        final ClientRequest request = new ClientRequest().setMethod(Methods.GET).setPath(MESSAGE);
                        request.getRequestHeaders().put(Headers.HOST, ""localhost"");
                        connection.sendRequest(request, client.createClientCallback(reference, latch));
                    }
                }

            });

            latch.await(10, TimeUnit.SECONDS);

            Assert.assertEquals(10, references.size());
            for (final AtomicReference<ClientResponse> reference : references) {
                Assert.assertEquals(message, reference.get().getAttachment(Http2Client.RESPONSE_BODY));
                Assert.assertEquals(""HTTP/2.0"", reference.get().getProtocol().toString());
            }
        } finally {
            connection.getIoThread().execute(new Runnable() {
                @Override
                public void run() {
                    IoUtils.safeClose(connection);
                }
            });
        }
    }",True,True,"The function of this method is to test multiple HTTP/2 GET requests with SSL. It creates a client, establishes a connection with a server, sends multiple GET requests, waits for the responses, and asserts that the responses are as expected. Finally, it closes the connection.",True,"This code is a JUnit test method that tests the functionality of making multiple HTTP/2 GET requests with SSL encryption. It creates a client connection, sends 10 GET requests to a specified URI, and verifies that the responses contain the expected message and are using the HTTP/2.0 protocol."
27,testMultipleHttpPostSsl(),test multiple http post ssl ,Method,,,"com.networknt.client.Http2ClientTest+createClient() com.networknt.client.Http2ClientTest+createClient() java.util.concurrent.CountDownLatch+CountDownLatch(int) com.networknt.client.Http2Client+createSSLContext() com.networknt.client.Http2Client+createSSLContext() java.lang.Object+Object() com.networknt.client.Http2Client+connect(URI,XnioWorker,XnioSsl,ByteBufferPool,OptionMap) com.networknt.client.Http2Client+connect(URI,XnioWorker,XnioSsl,ByteBufferPool,OptionMap) java.net.URI+URI(String) +() +run()",com.networknt.client.Http2ClientTest+worker com.networknt.client.Http2Client+SSL_BUFFER_POOL com.networknt.client.Http2ClientTest+worker com.networknt.client.Http2Client+POOL,3496,72,1,,"@Test
    public void testMultipleHttpPostSsl() throws Exception {
        //
        final Http2Client client = createClient();
        final String postMessage = ""This is a post request"";

        final List<String> responses = new CopyOnWriteArrayList<>();
        final CountDownLatch latch = new CountDownLatch(10);
        SSLContext context = client.createSSLContext();
        XnioSsl ssl = new UndertowXnioSsl(worker.getXnio(), OptionMap.EMPTY, Http2Client.SSL_BUFFER_POOL, context);

        final ClientConnection connection = client.connect(new URI(""https://localhost:7778""), worker, ssl, Http2Client.POOL, OptionMap.EMPTY).get();
        try {
            connection.getIoThread().execute(new Runnable() {
                @Override
                public void run() {
                    for (int i = 0; i < 10; i++) {
                        final ClientRequest request = new ClientRequest().setMethod(Methods.POST).setPath(POST);
                        request.getRequestHeaders().put(Headers.HOST, ""localhost"");
                        request.getRequestHeaders().put(Headers.TRANSFER_ENCODING, ""chunked"");
                        connection.sendRequest(request, new ClientCallback<ClientExchange>() {
                            @Override
                            public void completed(ClientExchange result) {
                                new StringWriteChannelListener(postMessage).setup(result.getRequestChannel());
                                result.setResponseListener(new ClientCallback<ClientExchange>() {
                                    @Override
                                    public void completed(ClientExchange result) {
                                        new StringReadChannelListener(Http2Client.POOL) {

                                            @Override
                                            protected void stringDone(String string) {
                                                responses.add(string);
                                                latch.countDown();
                                            }

                                            @Override
                                            protected void error(IOException e) {
                                                e.printStackTrace();
                                                latch.countDown();
                                            }
                                        }.setup(result.getResponseChannel());
                                    }

                                    @Override
                                    public void failed(IOException e) {
                                        e.printStackTrace();
                                        latch.countDown();
                                    }
                                });
                            }

                            @Override
                            public void failed(IOException e) {
                                e.printStackTrace();
                                latch.countDown();
                            }
                        });
                    }
                }

            });

            latch.await(10, TimeUnit.SECONDS);

            Assert.assertEquals(10, responses.size());
            for (final String response : responses) {
                Assert.assertEquals(postMessage, response);
            }
        } finally {
            IoUtils.safeClose(connection);
        }
    }",True,True,"The function of this method is to test the functionality of making multiple HTTP POST requests over SSL. It creates a client, establishes a connection to a specified URI, sends multiple POST requests with a specified message, and verifies that the responses received match the sent message.",True,"This code is a JUnit test method that tests the functionality of making multiple HTTP POST requests over SSL using the Http2Client library. It creates a client connection, sends 10 POST requests with a specific message, and verifies that the responses received are equal to the sent message."
28,testMultipleHttp2PostSsl(),test multiple http2 post ssl ,Method,,,"com.networknt.client.Http2ClientTest+createClient() com.networknt.client.Http2ClientTest+createClient() java.util.concurrent.CountDownLatch+CountDownLatch(int) com.networknt.client.Http2Client+createSSLContext() com.networknt.client.Http2Client+createSSLContext() java.lang.Object+Object() com.networknt.client.Http2Client+connect(URI,XnioWorker,XnioSsl,ByteBufferPool,OptionMap) com.networknt.client.Http2Client+connect(URI,XnioWorker,XnioSsl,ByteBufferPool,OptionMap) java.net.URI+URI(String) +() +run()",com.networknt.client.Http2ClientTest+worker com.networknt.client.Http2Client+SSL_BUFFER_POOL com.networknt.client.Http2ClientTest+worker com.networknt.client.Http2Client+POOL,3534,72,1,,"@Test
    public void testMultipleHttp2PostSsl() throws Exception {
        //
        final Http2Client client = createClient();
        final String postMessage = ""This is a post request"";

        final List<String> responses = new CopyOnWriteArrayList<>();
        final CountDownLatch latch = new CountDownLatch(10);
        SSLContext context = client.createSSLContext();
        XnioSsl ssl = new UndertowXnioSsl(worker.getXnio(), OptionMap.EMPTY, Http2Client.SSL_BUFFER_POOL, context);

        final ClientConnection connection = client.connect(new URI(""https://localhost:7778""), worker, ssl, Http2Client.POOL, OptionMap.create(UndertowOptions.ENABLE_HTTP2, true)).get();
        try {
            connection.getIoThread().execute(new Runnable() {
                @Override
                public void run() {
                    for (int i = 0; i < 10; i++) {
                        final ClientRequest request = new ClientRequest().setMethod(Methods.POST).setPath(POST);
                        request.getRequestHeaders().put(Headers.HOST, ""localhost"");
                        request.getRequestHeaders().put(Headers.TRANSFER_ENCODING, ""chunked"");
                        connection.sendRequest(request, new ClientCallback<ClientExchange>() {
                            @Override
                            public void completed(ClientExchange result) {
                                new StringWriteChannelListener(postMessage).setup(result.getRequestChannel());
                                result.setResponseListener(new ClientCallback<ClientExchange>() {
                                    @Override
                                    public void completed(ClientExchange result) {
                                        new StringReadChannelListener(Http2Client.POOL) {

                                            @Override
                                            protected void stringDone(String string) {
                                                responses.add(string);
                                                latch.countDown();
                                            }

                                            @Override
                                            protected void error(IOException e) {
                                                e.printStackTrace();
                                                latch.countDown();
                                            }
                                        }.setup(result.getResponseChannel());
                                    }

                                    @Override
                                    public void failed(IOException e) {
                                        e.printStackTrace();
                                        latch.countDown();
                                    }
                                });
                            }

                            @Override
                            public void failed(IOException e) {
                                e.printStackTrace();
                                latch.countDown();
                            }
                        });
                    }
                }

            });

            latch.await(10, TimeUnit.SECONDS);

            Assert.assertEquals(10, responses.size());
            for (final String response : responses) {
                Assert.assertEquals(postMessage, response);
            }
        } finally {
            IoUtils.safeClose(connection);
        }
    }",True,True,"The function of this method is to test the functionality of making multiple HTTP/2 POST requests over SSL. It creates a client, establishes a connection to a specified URI, sends multiple POST requests with a specified message, and verifies the responses received.",True,"This code is a JUnit test method that tests the functionality of making multiple HTTP/2 POST requests over SSL. It creates a client connection, sends 10 POST requests with a specific message, and verifies that the responses received match the sent message."
29,testSingleHttp2PostSsl(),test single http2 post ssl ,Method,,,"com.networknt.client.Http2ClientTest+createClient() com.networknt.client.Http2ClientTest+createClient() java.util.concurrent.CountDownLatch+CountDownLatch(int) com.networknt.client.Http2Client+createSSLContext() com.networknt.client.Http2Client+createSSLContext() java.lang.Object+Object() com.networknt.client.Http2Client+connect(URI,XnioWorker,XnioSsl,ByteBufferPool,OptionMap) com.networknt.client.Http2Client+connect(URI,XnioWorker,XnioSsl,ByteBufferPool,OptionMap) java.net.URI+URI(String) +() +run()",com.networknt.client.Http2ClientTest+worker com.networknt.client.Http2Client+SSL_BUFFER_POOL com.networknt.client.Http2ClientTest+worker com.networknt.client.Http2Client+POOL,3312,69,1,,"@Test
    public void testSingleHttp2PostSsl() throws Exception {
        //
        final Http2Client client = createClient();
        final String postMessage = ""This is a post request"";

        final List<String> responses = new CopyOnWriteArrayList<>();
        final CountDownLatch latch = new CountDownLatch(1);
        SSLContext context = client.createSSLContext();
        XnioSsl ssl = new UndertowXnioSsl(worker.getXnio(), OptionMap.EMPTY, Http2Client.SSL_BUFFER_POOL, context);

        final ClientConnection connection = client.connect(new URI(""https://localhost:7778""), worker, ssl, Http2Client.POOL, OptionMap.create(UndertowOptions.ENABLE_HTTP2, true)).get();
        try {
            connection.getIoThread().execute(new Runnable() {
                @Override
                public void run() {
                    final ClientRequest request = new ClientRequest().setMethod(Methods.POST).setPath(POST);
                    request.getRequestHeaders().put(Headers.HOST, ""localhost"");
                    request.getRequestHeaders().put(Headers.TRANSFER_ENCODING, ""chunked"");
                    connection.sendRequest(request, new ClientCallback<ClientExchange>() {
                        @Override
                        public void completed(ClientExchange result) {
                            new StringWriteChannelListener(postMessage).setup(result.getRequestChannel());
                            result.setResponseListener(new ClientCallback<ClientExchange>() {
                                @Override
                                public void completed(ClientExchange result) {
                                    new StringReadChannelListener(Http2Client.POOL) {

                                        @Override
                                        protected void stringDone(String string) {
                                            responses.add(string);
                                            latch.countDown();
                                        }

                                        @Override
                                        protected void error(IOException e) {
                                            e.printStackTrace();
                                            latch.countDown();
                                        }
                                    }.setup(result.getResponseChannel());
                                }

                                @Override
                                public void failed(IOException e) {
                                    e.printStackTrace();
                                    latch.countDown();
                                }
                            });
                        }

                        @Override
                        public void failed(IOException e) {
                            e.printStackTrace();
                            latch.countDown();
                        }
                    });
                }
            });

            latch.await(10, TimeUnit.SECONDS);

            Assert.assertEquals(1, responses.size());
            for (final String response : responses) {
                Assert.assertEquals(postMessage, response);
            }
        } finally {
            IoUtils.safeClose(connection);
        }
    }",False,False,"The function of this method is to test a single HTTP/2 POST request with SSL. It creates a client, establishes a connection to a specified URI, sends a POST request with a message, and waits for the response. It then asserts that the response matches the sent message.",True,"This code is a JUnit test method that tests a single HTTP/2 POST request with SSL. It creates a client connection, sends a POST request with a specified message, and waits for the response. The response is then compared to the original message to ensure they match."
30,testSingleHttp2FormSsl(),test single http2 form ssl ,Method,,,"com.networknt.client.Http2ClientTest+createClient() com.networknt.client.Http2ClientTest+createClient() java.util.Map+put(K,V) java.util.Map+put(K,V) java.util.Map+put(K,V) java.util.Map+put(K,V) com.networknt.client.Http2Client+getFormDataString(Map<String,String>) com.networknt.client.Http2Client+getFormDataString(Map<String,String>) java.util.concurrent.CountDownLatch+CountDownLatch(int) com.networknt.client.Http2Client+createSSLContext() com.networknt.client.Http2Client+createSSLContext() java.lang.Object+Object() com.networknt.client.Http2Client+connect(URI,XnioWorker,XnioSsl,ByteBufferPool,OptionMap) com.networknt.client.Http2Client+connect(URI,XnioWorker,XnioSsl,ByteBufferPool,OptionMap) java.net.URI+URI(String) +() +run()",com.networknt.client.Http2ClientTest+worker com.networknt.client.Http2Client+SSL_BUFFER_POOL com.networknt.client.Http2ClientTest+worker com.networknt.client.Http2Client+POOL,3649,75,1,,"@Test
    public void testSingleHttp2FormSsl() throws Exception {
        //
        final Http2Client client = createClient();
        Map<String, String> params = new HashMap<>();
        params.put(""key1"", ""value1"");
        params.put(""key2"", ""value2"");

        final String postMessage = client.getFormDataString(params);

        final List<String> responses = new CopyOnWriteArrayList<>();
        final CountDownLatch latch = new CountDownLatch(1);
        SSLContext context = client.createSSLContext();
        XnioSsl ssl = new UndertowXnioSsl(worker.getXnio(), OptionMap.EMPTY, Http2Client.SSL_BUFFER_POOL, context);

        final ClientConnection connection = client.connect(new URI(""https://localhost:7778""), worker, ssl, Http2Client.POOL, OptionMap.create(UndertowOptions.ENABLE_HTTP2, true)).get();
        try {
            connection.getIoThread().execute(new Runnable() {
                @Override
                public void run() {
                    final ClientRequest request = new ClientRequest().setMethod(Methods.POST).setPath(FORM);
                    request.getRequestHeaders().put(Headers.HOST, ""localhost"");
                    request.getRequestHeaders().put(Headers.TRANSFER_ENCODING, ""chunked"");
                    request.getRequestHeaders().put(Headers.CONTENT_TYPE, ""application/x-www-form-urlencoded"");
                    connection.sendRequest(request, new ClientCallback<ClientExchange>() {
                        @Override
                        public void completed(ClientExchange result) {
                            new StringWriteChannelListener(postMessage).setup(result.getRequestChannel());
                            result.setResponseListener(new ClientCallback<ClientExchange>() {
                                @Override
                                public void completed(ClientExchange result) {
                                    new StringReadChannelListener(Http2Client.POOL) {

                                        @Override
                                        protected void stringDone(String string) {
                                            System.out.println(""string = "" + string);
                                            responses.add(string);
                                            latch.countDown();
                                        }

                                        @Override
                                        protected void error(IOException e) {
                                            e.printStackTrace();
                                            latch.countDown();
                                        }
                                    }.setup(result.getResponseChannel());
                                }

                                @Override
                                public void failed(IOException e) {
                                    e.printStackTrace();
                                    latch.countDown();
                                }
                            });
                        }

                        @Override
                        public void failed(IOException e) {
                            e.printStackTrace();
                            latch.countDown();
                        }
                    });
                }
            });

            latch.await(10, TimeUnit.SECONDS);

            Assert.assertEquals(1, responses.size());
            for (final String response : responses) {
                Assert.assertEquals(postMessage, response);
            }
        } finally {
            IoUtils.safeClose(connection);
        }
    }",False,False,"The function of this method is to test the functionality of sending a single HTTP/2 form with SSL encryption. It creates a client, sets up the form data, establishes a connection with the server, sends the form data, and waits for the response. Finally, it asserts that the response matches the sent form data.",True,"This code is a JUnit test method that tests the functionality of sending a HTTP/2 form request over SSL. It creates a client, sets up the request with form data, sends the request, and waits for the response. The response is then compared to the original form data to ensure correctness."
31,testConnectionClose(),test connection close ,Method,,,"com.networknt.client.Http2ClientTest+createClient() com.networknt.client.Http2ClientTest+createClient() java.util.concurrent.CountDownLatch+CountDownLatch(int) com.networknt.client.Http2Client+connect(URI,XnioWorker,ByteBufferPool,OptionMap) com.networknt.client.Http2Client+connect(URI,XnioWorker,ByteBufferPool,OptionMap) com.networknt.client.Http2Client+createClientCallback(AtomicReference<ClientResponse>,CountDownLatch) com.networknt.client.Http2Client+createClientCallback(AtomicReference<ClientResponse>,CountDownLatch) java.util.concurrent.CountDownLatch+await() java.util.concurrent.CountDownLatch+await()",com.networknt.client.Http2ClientTest+ADDRESS com.networknt.client.Http2ClientTest+worker com.networknt.client.Http2Client+POOL com.networknt.client.Http2ClientTest+MESSAGE com.networknt.client.Http2ClientTest+message com.networknt.client.Http2Client+RESPONSE_BODY,1078,22,1,,"@Test
    public void testConnectionClose() throws Exception {
        //
        final Http2Client client = createClient();

        final CountDownLatch latch = new CountDownLatch(1);
        final ClientConnection connection = client.connect(ADDRESS, worker, Http2Client.POOL, OptionMap.EMPTY).get();
        try {
            ClientRequest request = new ClientRequest().setPath(MESSAGE).setMethod(Methods.GET);
            request.getRequestHeaders().put(Headers.HOST, ""localhost"");
            final AtomicReference<ClientResponse> reference = new AtomicReference<>();
            request.getRequestHeaders().add(Headers.CONNECTION, Headers.CLOSE.toString());
            connection.sendRequest(request, client.createClientCallback(reference, latch));
            latch.await();
            final ClientResponse response = reference.get();
            Assert.assertEquals(message, response.getAttachment(Http2Client.RESPONSE_BODY));
            Assert.assertEquals(false, connection.isOpen());
        } finally {
            IoUtils.safeClose(connection);
        }

    }",False,False,"The function of this method is to test the closing of a client connection. It creates a client, establishes a connection to a specified address, sends a request with the ""Connection: Close"" header, waits for the response, and asserts that the connection is closed after receiving the response.",True,"The code is a JUnit test method that tests the behavior of closing a client connection in an HTTP/2 client. It creates a client, connects to a server, sends a GET request with a ""Connection: CLOSE"" header, waits for the response, and asserts that the connection is closed after receiving the response."
32,testSingleAsych(),test single asych ,Method,,,com.networknt.client.Http2ClientTest+callApiAsync() com.networknt.client.Http2ClientTest+callApiAsync(),,88,4,1,,"@Test
    public void testSingleAsych() throws Exception {
        callApiAsync();
    }",False,False,"The function of the given method is to test the asynchronous behavior of the ""callApiAsync()"" method.",True,"The code is a JUnit test method that calls the `callApiAsync()` method. It is used to test the functionality of the `callApiAsync()` method, which is expected to perform some asynchronous operation."
33,callApiAsync(),call api async ,Method,testSingleAsych(),,"com.networknt.client.Http2ClientTest+createClient() com.networknt.client.Http2ClientTest+createClient() java.util.concurrent.CountDownLatch+CountDownLatch(int) com.networknt.client.Http2Client+connect(URI,XnioWorker,ByteBufferPool,OptionMap) com.networknt.client.Http2Client+connect(URI,XnioWorker,ByteBufferPool,OptionMap) com.networknt.client.Http2Client+populateHeader(ClientRequest,String,String,String) com.networknt.client.Http2Client+populateHeader(ClientRequest,String,String,String) com.networknt.client.Http2Client+createClientCallback(AtomicReference<ClientResponse>,CountDownLatch) com.networknt.client.Http2Client+createClientCallback(AtomicReference<ClientResponse>,CountDownLatch) java.util.concurrent.CountDownLatch+await() java.util.concurrent.CountDownLatch+await()",com.networknt.client.Http2ClientTest+ADDRESS com.networknt.client.Http2ClientTest+worker com.networknt.client.Http2Client+POOL com.networknt.client.Http2ClientTest+API com.networknt.client.Http2Client+RESPONSE_BODY com.networknt.client.Http2Client+RESPONSE_BODY,1205,20,1,,"public String callApiAsync() throws Exception {
        final Http2Client client = createClient();
        final CountDownLatch latch = new CountDownLatch(1);
        final ClientConnection connection = client.connect(ADDRESS, worker, Http2Client.POOL, OptionMap.EMPTY).get();
        final AtomicReference<ClientResponse> reference = new AtomicReference<>();
        try {
            ClientRequest request = new ClientRequest().setPath(API).setMethod(Methods.GET);
            request.getRequestHeaders().put(Headers.HOST, ""localhost"");
            client.populateHeader(request, ""Bearer token"", ""cid"", ""tid"");
            request.getRequestHeaders().add(Headers.CONNECTION, Headers.CLOSE.toString());
            connection.sendRequest(request, client.createClientCallback(reference, latch));
            latch.await();
            final ClientResponse response = reference.get();
            Assert.assertEquals(""{\""message\"":\""OK!\""}"", response.getAttachment(Http2Client.RESPONSE_BODY));
            Assert.assertEquals(false, connection.isOpen());
        } finally {
            IoUtils.safeClose(connection);
        }
        return reference.get().getAttachment(Http2Client.RESPONSE_BODY);
    }",False,False,"The function of this method is to make an asynchronous API call using HTTP/2. It creates a client, establishes a connection, sends a GET request with specific headers, waits for the response, and returns the response body.",True,"The given code is a method that asynchronously calls an API using HTTP/2. It creates a client, establishes a connection, sends a GET request with specific headers, waits for the response, and returns the response body as a string."
34,testAsyncAboutToExpire(),test async about to expire ,Method,,,com.networknt.client.Http2ClientTest+callApiAsyncMultiThread(int) com.networknt.client.Http2ClientTest+callApiAsyncMultiThread(int) java.lang.Thread+sleep(long) java.lang.Thread+sleep(long),com.networknt.client.Http2ClientTest+logger,358,11,1,,"@Test
    public void testAsyncAboutToExpire() throws InterruptedException, ExecutionException {
        for(int i = 0; i < 10; i++) {
            callApiAsyncMultiThread(4);
            logger.info(""called times: "" + i);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException ignored) {
            }
        }
    }",False,False,"The function of this method is to test the behavior of an asynchronous API call when it is about to expire. It calls the API multiple times in separate threads, waits for a certain amount of time, and logs the number of times the API was called.",True,The code is a JUnit test method that calls the method `callApiAsyncMultiThread(4)` 10 times in a loop. It also logs the number of times the method is called and sleeps for 1 second between each call.
35,testAsyncExpired(),test async expired ,Method,,,com.networknt.client.Http2ClientTest+callApiAsyncMultiThread(int) com.networknt.client.Http2ClientTest+callApiAsyncMultiThread(int) java.lang.Thread+sleep(long) java.lang.Thread+sleep(long),com.networknt.client.Http2ClientTest+logger,352,11,1,,"@Test
    public void testAsyncExpired() throws InterruptedException, ExecutionException {
        for(int i = 0; i < 10; i++) {
            callApiAsyncMultiThread(4);
            logger.info(""called times: "" + i);
            try {
                Thread.sleep(6000);
            } catch (InterruptedException ignored) {
            }
        }
    }",False,False,"This method is a unit test that checks the behavior of a method called ""callApiAsyncMultiThread"" when it is called multiple times in a loop. It also logs the number of times the method is called and waits for 6 seconds between each call.",True,"The code is a JUnit test method that calls the method ""callApiAsyncMultiThread"" 10 times in a loop. After each call, it waits for 6 seconds before making the next call. The purpose of the test is to check the behavior of the ""callApiAsyncMultiThread"" method when it is called multiple times with a delay in between."
36,testMixed(),test mixed ,Method,,,"com.networknt.client.Http2ClientTest+callApiAsyncMultiThread(int) com.networknt.client.Http2ClientTest+callApiAsyncMultiThread(int) com.networknt.client.Http2ClientTest+randInt(int,int) com.networknt.client.Http2ClientTest+randInt(int,int) java.lang.Thread+sleep(long) java.lang.Thread+sleep(long)",com.networknt.client.Http2ClientTest+logger,576,18,1,,"@Test
    public void testMixed() throws InterruptedException, ExecutionException {
        for(int i = 0; i < 10; i++) {
            callApiAsyncMultiThread(4
            );
            logger.info(""called times: "" + i);
            try {
                int sleepTime = randInt(1, 6) * 1000;
                if (sleepTime > 3000) {
                    sleepTime = 6000;
                } else {
                    sleepTime = 1000;
                }
                Thread.sleep(sleepTime);
            } catch (InterruptedException ignored) {
            }
        }
    }",False,False,"This method is a test method that tests the functionality of calling an API asynchronously in multiple threads. It calls the ""callApiAsyncMultiThread"" method 10 times, logs the number of times it has been called, and sleeps for a random amount of time between 1 and 6 seconds.",True,The code is a test method that calls the `callApiAsyncMultiThread` method 10 times in a loop. It also logs the number of times it has been called and sleeps for a random amount of time between 1 and 6 seconds before each iteration.
37,callApiAsyncMultiThread(int),call api async multi thread thread count ,Method,testAsyncAboutToExpire() testAsyncExpired() testMixed(),,"com.networknt.client.Http2ClientTest+callApiAsync() java.util.Collections+nCopies(int,T) java.util.Collections+nCopies(int,T) java.util.concurrent.Executors+newFixedThreadPool(int) java.util.concurrent.Executors+newFixedThreadPool(int) java.util.concurrent.ExecutorService+invokeAll(Collection) java.util.concurrent.ExecutorService+invokeAll(Collection) java.util.List+size() java.util.List+size() java.util.List+add(E) java.util.List+add(E) java.util.concurrent.Future+get() java.util.concurrent.Future+get() java.io.PrintStream+println(String) java.io.PrintStream+println(String)",java.lang.System+out,629,11,2,,"private void callApiAsyncMultiThread(final int threadCount) throws InterruptedException, ExecutionException {
        Callable<String> task = this::callApiAsync;
        List<Callable<String>> tasks = Collections.nCopies(threadCount, task);
        ExecutorService executorService = Executors.newFixedThreadPool(threadCount);
        List<Future<String>> futures = executorService.invokeAll(tasks);
        List<String> resultList = new ArrayList<>(futures.size());
        for (Future<String> future : futures) {
            resultList.add(future.get());
        }
        System.out.println(""resultList = "" + resultList);
    }",False,False,"This method calls an API asynchronously using multiple threads. It creates a fixed thread pool with the specified thread count, submits tasks to the pool, waits for all tasks to complete, and collects the results into a list. The list is then printed to the console.",False,The given code defines a method called `callApiAsyncMultiThread` that takes an integer parameter `threadCount`. It creates a fixed thread pool with the specified number of threads and invokes the `callApiAsync` method asynchronously in multiple threads. The results are collected and printed in the `resultList`.
38,loadKeyStore(String),load key store name ,Method,beforeClass() beforeClass(),,"com.networknt.config.Config+getInputStreamFromFile(String) com.networknt.config.Config+getInstance() com.networknt.config.Config+getInstance() com.networknt.config.Config+getInputStreamFromFile(String) java.lang.RuntimeException+RuntimeException(String) java.security.KeyStore+getInstance(String) java.security.KeyStore+getInstance(String) java.security.KeyStore+load(InputStream,char[]) java.security.KeyStore+load(InputStream,char[]) java.io.IOException+IOException(String,Throwable) java.lang.String+format(String,Object[]) java.lang.String+format(String,Object[])",com.networknt.client.Http2ClientTest+STORE_PASSWORD,696,16,10,,"private static KeyStore loadKeyStore(final String name) throws IOException {
        final InputStream stream = Config.getInstance().getInputStreamFromFile(name);
        if(stream == null) {
            throw new RuntimeException(""Could not load keystore"");
        }
        try {
            KeyStore loadedKeystore = KeyStore.getInstance(""JKS"");
            loadedKeystore.load(stream, STORE_PASSWORD);

            return loadedKeystore;
        } catch (KeyStoreException | NoSuchAlgorithmException | CertificateException e) {
            throw new IOException(String.format(""Unable to load KeyStore %s"", name), e);
        } finally {
            IoUtils.safeClose(stream);
        }
    }",False,False,"This method serves to load a KeyStore from a file. It takes the name of the file as input, retrieves an InputStream from the Config class, and uses it to load the KeyStore. If the InputStream is null, it throws a RuntimeException. If any exception occurs during the loading process, it throws an IOException. Finally, it closes the InputStream.",True,"The code defines a private static method called `loadKeyStore` that takes a `name` parameter and returns a `KeyStore` object. It loads a keystore from a file using the `name` parameter, and if the keystore cannot be loaded, it throws a `RuntimeException`. It also handles exceptions related to loading the keystore and ensures that the input stream is closed properly."
39,"createSSLContext(KeyStore,KeyStore,boolean)",create ssl context key store trust store client ,Method,beforeClass(),,"javax.net.ssl.KeyManagerFactory+getInstance(String) javax.net.ssl.KeyManagerFactory+getInstance(String) javax.net.ssl.KeyManagerFactory+getDefaultAlgorithm() javax.net.ssl.KeyManagerFactory+getDefaultAlgorithm() javax.net.ssl.KeyManagerFactory+init(KeyStore,char[]) javax.net.ssl.KeyManagerFactory+init(KeyStore,char[]) javax.net.ssl.KeyManagerFactory+getKeyManagers() javax.net.ssl.KeyManagerFactory+getKeyManagers() java.io.IOException+IOException(String,Throwable) javax.net.ssl.TrustManagerFactory+getInstance(String) javax.net.ssl.TrustManagerFactory+getInstance(String) javax.net.ssl.KeyManagerFactory+getDefaultAlgorithm() javax.net.ssl.KeyManagerFactory+getDefaultAlgorithm() javax.net.ssl.TrustManagerFactory+init(KeyStore) javax.net.ssl.TrustManagerFactory+init(KeyStore) javax.net.ssl.TrustManagerFactory+getTrustManagers() javax.net.ssl.TrustManagerFactory+getTrustManagers() java.io.IOException+IOException(String,Throwable) javax.net.ssl.SSLContext+getInstance(String) javax.net.ssl.SSLContext+getInstance(String) javax.net.ssl.SSLContext+getInstance(String) javax.net.ssl.SSLContext+getInstance(String) javax.net.ssl.SSLContext+init(KeyManager[],TrustManager[],SecureRandom) javax.net.ssl.SSLContext+init(KeyManager[],TrustManager[],SecureRandom) java.io.IOException+IOException(String,Throwable)",com.networknt.client.Http2ClientTest+STORE_PASSWORD,1559,33,10,,"private static SSLContext createSSLContext(final KeyStore keyStore, final KeyStore trustStore, boolean client) throws IOException {
        KeyManager[] keyManagers;
        try {
            KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
            keyManagerFactory.init(keyStore, STORE_PASSWORD);
            keyManagers = keyManagerFactory.getKeyManagers();
        } catch (NoSuchAlgorithmException | UnrecoverableKeyException | KeyStoreException e) {
            throw new IOException(""Unable to initialise KeyManager[]"", e);
        }

        TrustManager[] trustManagers = null;
        try {
            TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
            trustManagerFactory.init(trustStore);
            trustManagers = trustManagerFactory.getTrustManagers();
        } catch (NoSuchAlgorithmException | KeyStoreException e) {
            throw new IOException(""Unable to initialise TrustManager[]"", e);
        }

        SSLContext sslContext;
        try {
            if(!client) {
                sslContext = SSLContext.getInstance(""TLS"");
            } else {
                sslContext = SSLContext.getInstance(""TLS"");
            }
            sslContext.init(keyManagers, trustManagers, null);
        } catch (NoSuchAlgorithmException | KeyManagementException e) {
            throw new IOException(""Unable to create and initialise the SSLContext"", e);
        }

        return sslContext;
    }",False,False,"This method creates and initializes an SSLContext object using the provided KeyStore and TrustStore. It also handles exceptions related to key and trust managers, as well as SSLContext creation and initialization. The SSLContext is then returned.",True,"This code defines a private static method called `createSSLContext` that takes in a key store, trust store, and a boolean flag indicating if it's for a client. It initializes key and trust managers using the provided stores, creates and initializes an SSL context using the managers, and returns the SSL context."
40,"randInt(int,int)",rand int min max ,Method,testMixed(),,java.util.Random+Random() java.util.Random+nextInt(int) java.util.Random+nextInt(int),,138,4,10,,"private static int randInt(int min, int max) {
        Random rand = new Random();
        return rand.nextInt((max-min) + 1) + min;
    }",False,False,"This method generates a random integer between a given minimum and maximum value, inclusive.",False,"The given code is a method named ""randInt"" that takes in two integer parameters, ""min"" and ""max"". It generates a random integer between ""min"" and ""max"" (inclusive) using the Random class and returns the generated value."
41,isTokenExpired(String),is token expired authorization ,Method,,,com.networknt.client.Http2ClientTest+getJwtFromAuthorization(String) com.networknt.client.Http2ClientTest+getJwtFromAuthorization(String),com.networknt.client.Http2ClientTest+logger,1049,27,10,,"private static boolean isTokenExpired(String authorization) {
        boolean expired = false;
        String jwt = getJwtFromAuthorization(authorization);
        if(jwt != null) {
            try {
                JwtConsumer consumer = new JwtConsumerBuilder()
                        .setSkipAllValidators()
                        .setDisableRequireSignature()
                        .setSkipSignatureVerification()
                        .build();

                JwtContext jwtContext = consumer.process(jwt);
                JwtClaims jwtClaims = jwtContext.getJwtClaims();

                try {
                    if ((NumericDate.now().getValue() - 60) >= jwtClaims.getExpirationTime().getValue()) {
                        expired = true;
                    }
                } catch (MalformedClaimException e) {
                    logger.error(""MalformedClaimException:"", e);
                }
            } catch(InvalidJwtException e) {
                e.printStackTrace();
            }
        }
        return expired;
    }",False,False,"The function of this method is to check if a token is expired. It takes an authorization string as input, extracts the JWT from it, and then checks if the expiration time of the JWT has passed. If the token is expired, it returns true; otherwise, it returns false.",True,"The code is a method that checks if a given JWT token is expired by extracting the token from the authorization header, processing it using a JwtConsumer, and comparing the expiration time with the current time minus 60 seconds. It returns a boolean value indicating whether the token is expired or not."
42,getJwt(int),get jwt expired in seconds ,Method,,,com.networknt.client.Http2ClientTest+getTestClaims() com.networknt.client.Http2ClientTest+getTestClaims() java.lang.System+currentTimeMillis() java.lang.System+currentTimeMillis() com.networknt.client.Http2ClientTest+getJwt(JwtClaims) com.networknt.client.Http2ClientTest+getJwt(JwtClaims),,268,5,10,,"private static String getJwt(int expiredInSeconds) throws Exception {
        JwtClaims claims = getTestClaims();
        claims.setExpirationTime(NumericDate.fromMilliseconds(System.currentTimeMillis() + expiredInSeconds * 1000));
        return getJwt(claims);
    }",False,False,"This method generates a JSON Web Token (JWT) with an expiration time based on the input parameter. It uses the ""getTestClaims"" method to get the claims for the token and then sets the expiration time. Finally, it returns the generated JWT.",True,"The code is a private static method named ""getJwt"" that takes an integer parameter ""expiredInSeconds"". It throws an exception and returns a JWT (JSON Web Token) string. It sets the expiration time of the token based on the current time and the provided number of seconds, and then calls another method ""getJwt"" with a JwtClaims object as an argument to generate the token."
43,getTestClaims(),get test claims ,Method,getJwt(int),,java.util.Arrays+asList(T[]) java.util.Arrays+asList(T[]),,931,17,10,,"private static JwtClaims getTestClaims() {
        JwtClaims claims = new JwtClaims();
        claims.setIssuer(""urn:com:networknt:oauth2:v1"");
        claims.setAudience(""urn:com.networknt"");
        claims.setExpirationTimeMinutesInTheFuture(10);
        claims.setGeneratedJwtId(); // a unique identifier for the token
        claims.setIssuedAtToNow();  // when the token was issued/created (now)
        claims.setNotBeforeMinutesInThePast(2); // time before which the token is not yet valid (2 minutes ago)
        claims.setClaim(""version"", ""1.0"");

        claims.setClaim(""user_id"", ""steve"");
        claims.setClaim(""user_type"", ""EMPLOYEE"");
        claims.setClaim(""client_id"", ""aaaaaaaa-1234-1234-1234-bbbbbbbb"");
        List<String> scope = Arrays.asList(""api.r"", ""api.w"");
        claims.setStringListClaim(""scope"", scope); // multi-valued claims work too and will end up as a JSON array
        return claims;
    }",False,False,"The function ""getTestClaims"" returns a JwtClaims object with various claims set, including issuer, audience, expiration time, unique identifier, issued time, not before time, version, user ID, user type, client ID, and scope.",True,"The code defines a method named ""getTestClaims"" that creates and returns a JwtClaims object. The JwtClaims object is populated with various claims such as issuer, audience, expiration time, unique identifier, issued time, and custom claims like user_id, user_type, client_id, and scope."
44,getJwtFromAuthorization(String),get jwt from authorization authorization ,Method,isTokenExpired(String),,"java.lang.String+split(String) java.lang.String+split(String) java.util.regex.Pattern+compile(String,int) java.util.regex.Pattern+compile(String,int) java.util.regex.Matcher+matches() java.util.regex.Pattern+matcher(CharSequence) java.util.regex.Pattern+matcher(CharSequence) java.util.regex.Matcher+matches()",java.util.regex.Pattern+CASE_INSENSITIVE,565,15,9,,"public static String getJwtFromAuthorization(String authorization) {
        String jwt = null;
        if(authorization != null) {
            String[] parts = authorization.split("" "");
            if (parts.length == 2) {
                String scheme = parts[0];
                String credentials = parts[1];
                Pattern pattern = Pattern.compile(""^Bearer$"", Pattern.CASE_INSENSITIVE);
                if (pattern.matcher(scheme).matches()) {
                    jwt = credentials;
                }
            }
        }
        return jwt;
    }",False,False,"This method extracts a JWT (JSON Web Token) from an authorization string. It checks if the authorization string is not null, splits it into two parts, checks if the first part is ""Bearer"", and returns the second part as the JWT if all conditions are met.",True,"This code is a method named ""getJwtFromAuthorization"" that takes an authorization string as input and returns a JWT (JSON Web Token) extracted from it. It checks if the authorization string is in the format ""Bearer <token>"" and returns the token if it matches, otherwise it returns null."
45,getJwt(JwtClaims),get jwt claims ,Method,getJwt(int),,"com.networknt.client.Http2ClientTest+getPrivateKey(String,String,String) com.networknt.client.Http2ClientTest+getPrivateKey(String,String,String)",,1208,27,9,,"public static String getJwt(JwtClaims claims) throws JoseException {
        String jwt;

        RSAPrivateKey privateKey = (RSAPrivateKey) getPrivateKey(
                ""/config/oauth/primary.jks"", ""password"", ""selfsigned"");

        // A JWT is a JWS and/or a JWE with JSON claims as the payload.
        // In this example it is a JWS nested inside a JWE
        // So we first create a JsonWebSignature object.
        JsonWebSignature jws = new JsonWebSignature();

        // The payload of the JWS is JSON content of the JWT Claims
        jws.setPayload(claims.toJson());

        // The JWT is signed using the sender's private key
        jws.setKey(privateKey);
        jws.setKeyIdHeaderValue(""100"");

        // Set the signature algorithm on the JWT/JWS that will integrity protect the claims
        jws.setAlgorithmHeaderValue(AlgorithmIdentifiers.RSA_USING_SHA256);

        // Sign the JWS and produce the compact serialization, which will be the inner JWT/JWS
        // representation, which is a string consisting of three dot ('.') separated
        // base64url-encoded parts in the form Header.Payload.Signature
        jwt = jws.getCompactSerialization();
        return jwt;
    }",False,False,This method generates a JSON Web Token (JWT) using the provided claims and a private key. It signs the JWT using RSA with SHA-256 algorithm and returns the compact serialization of the JWT.,True,This code defines a method called `getJwt` that takes a `JwtClaims` object as input and returns a JSON Web Token (JWT) as a string. The method signs the JWT using a private key and sets the necessary headers and algorithm for the JWT.
46,"getPrivateKey(String,String,String)",get private key filename password key ,Method,getJwt(JwtClaims),,"java.security.KeyStore+getInstance(String) java.security.KeyStore+getInstance(String) java.security.KeyStore+load(InputStream,char[]) java.security.KeyStore+load(InputStream,char[]) java.lang.Class+getResourceAsStream(String) java.lang.Class+getResourceAsStream(String) java.lang.String+toCharArray() java.lang.String+toCharArray() java.security.KeyStore+getKey(String,char[]) java.security.KeyStore+getKey(String,char[]) java.lang.String+toCharArray() java.lang.String+toCharArray()",com.networknt.client.Http2ClientTest+logger com.networknt.client.Http2ClientTest+logger,664,20,10,,"private static PrivateKey getPrivateKey(String filename, String password, String key) {
        PrivateKey privateKey = null;

        try {
            KeyStore keystore = KeyStore.getInstance(""JKS"");
            keystore.load(Http2Client.class.getResourceAsStream(filename),
                    password.toCharArray());

            privateKey = (PrivateKey) keystore.getKey(key,
                    password.toCharArray());
        } catch (Exception e) {
            logger.error(""Exception:"", e);
        }

        if (privateKey == null) {
            logger.error(""Failed to retrieve private key from keystore"");
        }

        return privateKey;
    }",False,False,"This method retrieves a private key from a Java KeyStore (JKS) file using a given filename, password, and key. It returns the private key if successfully retrieved, otherwise it returns null.",True,"This code defines a private static method named ""getPrivateKey"" that takes in a filename, password, and key as parameters. It attempts to load a Java KeyStore file, retrieve a private key from it using the provided password and key, and returns the private key. If the private key cannot be retrieved, an error message is logged."
