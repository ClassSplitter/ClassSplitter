index,name,document,type,inner invocations,external invocations,calls,visits,length,lines,modifier,commit,full text,moved,removed,gpt text,gpt response,code summary
1,mListeners,m listeners ,Field,,,,,77,1,0,,ArrayList<AsyncServerSocket> mListeners = new ArrayList<AsyncServerSocket>();,False,False,,False,
2,stop(),stop ,Method,,com.koushikdutta.async.test.HttpServerTests+tearDown() com.koushikdutta.async.test.MultipartTests+tearDown() com.koushikdutta.async.test.TimeoutTests+tearDown() com.koushikdutta.async.test.WebSocketTests+tearDown(),com.koushikdutta.async.AsyncServerSocket+stop() com.koushikdutta.async.AsyncServerSocket+stop(),com.koushikdutta.async.http.server.AsyncHttpServer+mListeners com.koushikdutta.async.http.server.AsyncHttpServer+mListeners,176,7,1,,"public void stop() {
        if (mListeners != null) {
            for (AsyncServerSocket listener: mListeners) {
                listener.stop();
            }
        }
    }",False,False,The function of this method is to stop all the listeners in the mListeners list by calling the stop() method on each listener.,True,The `stop()` method is used to stop all the listeners in the `mListeners` list. It checks if the list is not null and then iterates through each listener to call its `stop()` method.
3,"onRequest(AsyncHttpServerRequest,AsyncHttpServerResponse)",on request request response ,Method,,,"com.koushikdutta.async.http.Headers+get(String) com.koushikdutta.async.http.server.AsyncHttpServerRequest+getHeaders() com.koushikdutta.async.http.server.AsyncHttpServerRequest+getHeaders() com.koushikdutta.async.http.Headers+get(String) java.lang.String+split(String) java.lang.String+split(String) java.lang.String+equalsIgnoreCase(String) java.lang.String+equalsIgnoreCase(String) java.lang.String+trim() java.lang.String+trim() java.lang.String+equalsIgnoreCase(String) java.lang.String+equalsIgnoreCase(String) com.koushikdutta.async.http.Headers+get(String) com.koushikdutta.async.http.server.AsyncHttpServerRequest+getHeaders() com.koushikdutta.async.http.server.AsyncHttpServerRequest+getHeaders() com.koushikdutta.async.http.Headers+get(String) com.koushikdutta.async.http.server.AsyncHttpServerResponse+code(int) com.koushikdutta.async.http.server.AsyncHttpServerResponse+code(int) com.koushikdutta.async.http.server.AsyncHttpServerResponse+end() com.koushikdutta.async.http.server.AsyncHttpServerResponse+end() com.koushikdutta.async.http.Headers+get(String) com.koushikdutta.async.http.server.AsyncHttpServerRequest+getHeaders() com.koushikdutta.async.http.server.AsyncHttpServerRequest+getHeaders() com.koushikdutta.async.http.Headers+get(String) android.text.TextUtils+equals(CharSequence,CharSequence) android.text.TextUtils+equals(CharSequence,CharSequence) com.koushikdutta.async.http.server.AsyncHttpServerResponse+code(int) com.koushikdutta.async.http.server.AsyncHttpServerResponse+code(int) com.koushikdutta.async.http.server.AsyncHttpServerResponse+end() com.koushikdutta.async.http.server.AsyncHttpServerResponse+end() com.koushikdutta.async.http.server.AsyncHttpServer.WebSocketRequestCallback+onConnected(WebSocket,AsyncHttpServerRequest) com.koushikdutta.async.http.server.AsyncHttpServer.WebSocketRequestCallback+onConnected(WebSocket,AsyncHttpServerRequest) com.koushikdutta.async.http.WebSocketImpl+WebSocketImpl(AsyncHttpServerRequest,AsyncHttpServerResponse) java.util.regex.Matcher+replaceAll(String) com.koushikdutta.async.http.server.AsyncHttpServerRequest+getMatcher() com.koushikdutta.async.http.server.AsyncHttpServerRequest+getMatcher() java.util.regex.Matcher+replaceAll(String) com.koushikdutta.async.http.server.AsyncHttpServer+getAssetStream(Context,String) com.koushikdutta.async.http.server.AsyncHttpServer+getAssetStream(Context,String) com.koushikdutta.async.http.server.AsyncHttpServerResponse+code(int) com.koushikdutta.async.http.server.AsyncHttpServerResponse+code(int) com.koushikdutta.async.http.server.AsyncHttpServerResponse+end() com.koushikdutta.async.http.server.AsyncHttpServerResponse+end() com.koushikdutta.async.http.Headers+set(String,String) com.koushikdutta.async.http.server.AsyncHttpServerResponse+getHeaders() com.koushikdutta.async.http.server.AsyncHttpServerResponse+getHeaders() com.koushikdutta.async.http.Headers+set(String,String) java.lang.String+valueOf(Object) java.lang.String+valueOf(Object) com.koushikdutta.async.http.server.AsyncHttpServerResponse+code(int) com.koushikdutta.async.http.server.AsyncHttpServerResponse+code(int) com.koushikdutta.async.http.Headers+add(String,String) com.koushikdutta.async.http.server.AsyncHttpServerResponse+getHeaders() com.koushikdutta.async.http.server.AsyncHttpServerResponse+getHeaders() com.koushikdutta.async.http.Headers+add(String,String) com.koushikdutta.async.http.server.AsyncHttpServer+getContentType(String) com.koushikdutta.async.http.server.AsyncHttpServer+getContentType(String) com.koushikdutta.async.Util+pump(InputStream,DataSink,CompletedCallback) com.koushikdutta.async.Util+pump(InputStream,DataSink,CompletedCallback) +() +onCompleted(Exception) java.util.regex.Matcher+replaceAll(String) com.koushikdutta.async.http.server.AsyncHttpServerRequest+getMatcher() com.koushikdutta.async.http.server.AsyncHttpServerRequest+getMatcher() java.util.regex.Matcher+replaceAll(String) com.koushikdutta.async.http.server.AsyncHttpServer+getAssetStream(Context,String) com.koushikdutta.async.http.server.AsyncHttpServer+getAssetStream(Context,String) com.koushikdutta.async.http.server.AsyncHttpServerResponse+code(int) com.koushikdutta.async.http.server.AsyncHttpServerResponse+code(int) com.koushikdutta.async.http.server.AsyncHttpServerResponse+end() com.koushikdutta.async.http.server.AsyncHttpServerResponse+end() com.koushikdutta.async.util.StreamUtility+closeQuietly(Closeable[]) com.koushikdutta.async.util.StreamUtility+closeQuietly(Closeable[]) com.koushikdutta.async.http.Headers+set(String,String) com.koushikdutta.async.http.server.AsyncHttpServerResponse+getHeaders() com.koushikdutta.async.http.server.AsyncHttpServerResponse+getHeaders() com.koushikdutta.async.http.Headers+set(String,String) java.lang.String+valueOf(Object) java.lang.String+valueOf(Object) com.koushikdutta.async.http.server.AsyncHttpServerResponse+code(int) com.koushikdutta.async.http.server.AsyncHttpServerResponse+code(int) com.koushikdutta.async.http.Headers+add(String,String) com.koushikdutta.async.http.server.AsyncHttpServerResponse+getHeaders() com.koushikdutta.async.http.server.AsyncHttpServerResponse+getHeaders() com.koushikdutta.async.http.Headers+add(String,String) com.koushikdutta.async.http.server.AsyncHttpServer+getContentType(String) com.koushikdutta.async.http.server.AsyncHttpServer+getContentType(String) com.koushikdutta.async.http.server.AsyncHttpServerResponse+writeHead() com.koushikdutta.async.http.server.AsyncHttpServerResponse+writeHead() com.koushikdutta.async.http.server.AsyncHttpServerResponse+end() com.koushikdutta.async.http.server.AsyncHttpServerResponse+end()",android.util.Pair+second android.util.Pair+second android.util.Pair+first android.util.Pair+second android.util.Pair+second android.util.Pair+first,123,3,4,,"protected boolean onRequest(AsyncHttpServerRequest request, AsyncHttpServerResponse response) {
        return false;
    }",False,False,"The function onRequest serves to handle an incoming HTTP request and generate an HTTP response. It returns false, indicating that the request was not successfully processed.",True,"The code defines a protected method called ""onRequest"" that takes an AsyncHttpServerRequest object and an AsyncHttpServerResponse object as parameters. The method returns a boolean value of false."
4,"onRequest(HttpServerRequestCallback,AsyncHttpServerRequest,AsyncHttpServerResponse)",on request callback request response ,Method,,,"com.koushikdutta.async.http.server.HttpServerRequestCallback+onRequest(AsyncHttpServerRequest,AsyncHttpServerResponse) com.koushikdutta.async.http.server.HttpServerRequestCallback+onRequest(AsyncHttpServerRequest,AsyncHttpServerResponse)",,215,4,4,,"protected void onRequest(HttpServerRequestCallback callback, AsyncHttpServerRequest request, AsyncHttpServerResponse response) {
        if (callback != null)
            callback.onRequest(request, response);
    }",False,False,This method serves to handle an HTTP server request by invoking the provided callback function with the given request and response objects.,True,"The code defines a protected method called ""onRequest"" that takes three parameters: a callback, a request object, and a response object. If the callback is not null, it invokes the ""onRequest"" method of the callback object, passing in the request and response objects as arguments."
5,onUnknownBody(Headers),on unknown body headers ,Method,,,com.koushikdutta.async.http.server.UnknownRequestBody+UnknownRequestBody(String) com.koushikdutta.async.http.Headers+get(String) com.koushikdutta.async.http.Headers+get(String) com.koushikdutta.async.http.server.AsyncHttpServer+onUnknownBody(Headers) com.koushikdutta.async.http.server.AsyncHttpServer+onUnknownBody(Headers),,137,3,4,,"protected AsyncHttpRequestBody onUnknownBody(Headers headers) {
        return new UnknownRequestBody(headers.get(""Content-Type""));
    }",False,False,"The function of the method is to create and return an instance of the UnknownRequestBody class, using the ""Content-Type"" value from the provided Headers object.",True,"The given code snippet defines a protected method named ""onUnknownBody"" that takes in a parameter of type ""Headers"" and returns an object of type ""AsyncHttpRequestBody"". This method creates and returns a new instance of ""UnknownRequestBody"" by passing the value of the ""Content-Type"" header to its constructor."
6,mListenCallback,m listen callback ,Field,,,,,6471,158,0,,"ListenCallback mListenCallback = new ListenCallback() {
        @Override
        public void onAccepted(final AsyncSocket socket) {
            AsyncHttpServerRequestImpl req = new AsyncHttpServerRequestImpl() {
                HttpServerRequestCallback match;
                String fullPath;
                String path;
                boolean responseComplete;
                boolean requestComplete;
                AsyncHttpServerResponseImpl res;
                boolean hasContinued;

                @Override
                protected AsyncHttpRequestBody onUnknownBody(Headers headers) {
                    return AsyncHttpServer.this.onUnknownBody(headers);
                }

                @Override
                protected void onHeadersReceived() {
                    Headers headers = getHeaders();

                    // should the negotiation of 100 continue be here, or in the request impl?
                    // probably here, so AsyncResponse can negotiate a 100 continue.
                    if (!hasContinued && ""100-continue"".equals(headers.get(""Expect""))) {
                        pause();
//                        System.out.println(""continuing..."");
                        Util.writeAll(mSocket, ""HTTP/1.1 100 Continue\r\n\r\n"".getBytes(), new CompletedCallback() {
                            @Override
                            public void onCompleted(Exception ex) {
                                resume();
                                if (ex != null) {
                                    report(ex);
                                    return;
                                }
                                hasContinued = true;
                                onHeadersReceived();
                            }
                        });
                        return;
                    }
//                    System.out.println(headers.toHeaderString());
                    
                    String statusLine = getStatusLine();
                    String[] parts = statusLine.split("" "");
                    fullPath = parts[1];
                    path = fullPath.split(""\\?"")[0];
                    method = parts[0];
                    synchronized (mActions) {
                        ArrayList<Pair> pairs = mActions.get(method);
                        if (pairs != null) {
                            for (Pair p: pairs) {
                                Matcher m = p.regex.matcher(path);
                                if (m.matches()) {
                                    mMatcher = m;
                                    match = p.callback;
                                    break;
                                }
                            }
                        }
                    }
                    res = new AsyncHttpServerResponseImpl(socket, this) {
                        @Override
                        protected void report(Exception e) {
                            super.report(e);
                            if (e != null) {
                                socket.setDataCallback(new NullDataCallback());
                                socket.setEndCallback(new NullCompletedCallback());
                                socket.close();
                            }
                        }

                        @Override
                        protected void onEnd() {
                            super.onEnd();
                            mSocket.setEndCallback(null);
                            responseComplete = true;
                            // reuse the socket for a subsequent request.
                            handleOnCompleted();
                        }
                    };
                    
                    boolean handled = onRequest(this, res);

                    if (match == null && !handled) {
                        res.code(404);
                        res.end();
                        return;
                    }

                    if (!getBody().readFullyOnRequest()) {
                        onRequest(match, this, res);
                    }
                    else if (requestComplete) {
                        onRequest(match, this, res);
                    }
                }

                @Override
                public void onCompleted(Exception e) {
                    // if the protocol was switched off http, ignore this request/response.
                    if (res.code() == 101)
                        return;
                    requestComplete = true;
                    super.onCompleted(e);
                    // no http pipelining, gc trashing if the socket dies
                    // while the request is being sent and is paused or something
                    mSocket.setDataCallback(new NullDataCallback() {
                        @Override
                        public void onDataAvailable(DataEmitter emitter, ByteBufferList bb) {
                            super.onDataAvailable(emitter, bb);
                            mSocket.close();
                        }
                    });
                    handleOnCompleted();

                    if (getBody().readFullyOnRequest()) {
                        onRequest(match, this, res);
                    }
                }
                
                private void handleOnCompleted() {
                    if (requestComplete && responseComplete) {
                        if (HttpUtil.isKeepAlive(Protocol.HTTP_1_1, getHeaders())) {
                            onAccepted(socket);
                        }
                        else {
                            socket.close();
                        }
                    }
                }

                @Override
                public String getPath() {
                    return path;
                }

                @Override
                public Multimap getQuery() {
                    String[] parts = fullPath.split(""\\?"", 2);
                    if (parts.length < 2)
                        return new Multimap();
                    return Multimap.parseQuery(parts[1]);
                }
            };
            req.setSocket(socket);
            socket.resume();
        }

        @Override
        public void onCompleted(Exception error) {
            report(error);
        }

        @Override
        public void onListening(AsyncServerSocket socket) {
            mListeners.add(socket);
        }
    };",False,False,,False,
7,"listen(AsyncServer,int)",listen server port ,Method,listen(int),com.koushikdutta.async.test.TimeoutTests+setUp(),"com.koushikdutta.async.AsyncServer+listen(InetAddress,int,ListenCallback) com.koushikdutta.async.AsyncServer+listen(InetAddress,int,ListenCallback)",com.koushikdutta.async.http.server.AsyncHttpServer+mListenCallback,128,3,1,,"public AsyncServerSocket listen(AsyncServer server, int port) {
        return server.listen(null, port, mListenCallback);
    }",False,False,The function of the method is to listen for incoming connections on a specified port using an AsyncServer object. It returns an AsyncServerSocket object.,True,"The given code defines a method named ""listen"" that takes an AsyncServer object and a port number as parameters. It then calls the ""listen"" method of the AsyncServer object with a null argument, the port number, and a callback function named ""mListenCallback"". The method returns an AsyncServerSocket object."
8,report(Exception),report ex ,Method,,,com.koushikdutta.async.callback.CompletedCallback+onCompleted(Exception) com.koushikdutta.async.callback.CompletedCallback+onCompleted(Exception),com.koushikdutta.async.http.server.AsyncHttpServer+mCompletedCallback com.koushikdutta.async.http.server.AsyncHttpServer+mCompletedCallback,129,4,2,,"private void report(Exception ex) {
        if (mCompletedCallback != null)
            mCompletedCallback.onCompleted(ex);
    }",False,False,"This method reports an exception by calling the onCompleted method of the mCompletedCallback object, if it is not null.",False,"The code defines a private method called ""report"" that takes an Exception as a parameter. It checks if a callback object called ""mCompletedCallback"" is not null, and if so, it invokes the ""onCompleted"" method of the callback object, passing the Exception as an argument."
9,listen(int),listen port ,Method,,com.koushikdutta.async.test.RedirectTests+setUp(),"com.koushikdutta.async.http.server.AsyncHttpServer+listen(AsyncServer,int) com.koushikdutta.async.http.server.AsyncHttpServer+listen(AsyncServer,int) com.koushikdutta.async.AsyncServer+getDefault() com.koushikdutta.async.AsyncServer+getDefault()",,104,3,1,,"public AsyncServerSocket listen(int port) {
        return listen(AsyncServer.getDefault(), port);
    }",False,False,The function of this method is to listen for incoming connections on a specific port using the default AsyncServer. It returns an AsyncServerSocket object.,True,"The given code defines a method named ""listen"" that takes an integer parameter ""port"" and returns an object of type ""AsyncServerSocket"". This method internally calls another ""listen"" method from the ""AsyncServer"" class with the default server instance and the provided port number."
10,"listenSecure(int,SSLContext)",listen secure port ssl context ,Method,,com.koushikdutta.async.test.SSLTests+testKeys(),"com.koushikdutta.async.AsyncServer+listen(InetAddress,int,ListenCallback) com.koushikdutta.async.AsyncServer+getDefault() com.koushikdutta.async.AsyncServer+getDefault() com.koushikdutta.async.AsyncServer+listen(InetAddress,int,ListenCallback) +() +onAccepted(AsyncSocket)",,1001,25,1,,"public void listenSecure(final int port, final SSLContext sslContext) {
        AsyncServer.getDefault().listen(null, port, new ListenCallback() {
            @Override
            public void onAccepted(AsyncSocket socket) {
                AsyncSSLSocketWrapper.handshake(socket, null, port, sslContext.createSSLEngine(), null, null, false,
                new AsyncSSLSocketWrapper.HandshakeCallback() {
                    @Override
                    public void onHandshakeCompleted(Exception e, AsyncSSLSocket socket) {
                        if (socket != null)
                            mListenCallback.onAccepted(socket);
                    }
                });
            }

            @Override
            public void onListening(AsyncServerSocket socket) {
                mListenCallback.onListening(socket);
            }

            @Override
            public void onCompleted(Exception ex) {
                mListenCallback.onCompleted(ex);
            }
        });
    }",False,False,"The function of this method is to listen for incoming connections on a specified port using SSL/TLS encryption. It uses the provided SSLContext to create an SSL engine for the handshake process. Once the handshake is completed, the accepted socket is passed to the callback for further processing.",True,"This code defines a method called ""listenSecure"" that listens for incoming connections on a specified port using SSL/TLS encryption. It uses an SSLContext to create an SSL engine and performs a handshake with the client before accepting the connection."
11,getListenCallback(),get listen callback ,Method,,,,com.koushikdutta.async.http.server.AsyncHttpServer+mListenCallback,81,3,1,,"public ListenCallback getListenCallback() {
        return mListenCallback;
    }",False,False,This method returns the ListenCallback object that is stored in the variable mListenCallback.,True,"The code defines a method named ""getListenCallback"" that returns an object of type ""ListenCallback"". This method retrieves and returns the value of the ""mListenCallback"" variable."
12,mCompletedCallback,m completed callback ,Field,,,,,37,1,0,,CompletedCallback mCompletedCallback;,False,False,,False,
13,setErrorCallback(CompletedCallback),set error callback callback ,Method,,com.koushikdutta.async.test.HttpServerTests+setUp() com.koushikdutta.async.test.MultipartTests+setUp() com.koushikdutta.async.test.WebSocketTests+setUp(),,com.koushikdutta.async.http.server.AsyncHttpServer+mCompletedCallback,111,3,1,,"public void setErrorCallback(CompletedCallback callback) {
        mCompletedCallback = callback;        
    }",False,False,This method sets the error callback function for a specific object.,True,The code defines a method called `setErrorCallback` that takes a `CompletedCallback` object as a parameter. This method assigns the provided callback object to the `mCompletedCallback` variable.
14,getErrorCallback(),get error callback ,Method,,,,com.koushikdutta.async.http.server.AsyncHttpServer+mCompletedCallback,86,3,1,,"public CompletedCallback getErrorCallback() {
        return mCompletedCallback;
    }",False,False,"The method ""getErrorCallback"" returns the value of the variable ""mCompletedCallback"", which is of type ""CompletedCallback"".",True,"The code defines a method named ""getErrorCallback"" that returns a CompletedCallback object. This method retrieves the value of the mCompletedCallback variable and returns it."
15,Pair,pair ,MemberClass,,,,com.koushikdutta.async.http.server.AsyncHttpServer.Pair+regex com.koushikdutta.async.http.server.AsyncHttpServer.Pair+callback,100,4,10,,"private static class Pair {
        Pattern regex;
        HttpServerRequestCallback callback;
    }",False,True,,False,
16,mActions,m actions ,Field,,,,,93,1,16,,"final Hashtable<String, ArrayList<Pair>> mActions = new Hashtable<String, ArrayList<Pair>>();",False,True,,False,
17,"removeAction(String,String)",remove action action regex ,Method,,,java.util.Hashtable+get(Object) java.util.Hashtable+get(Object) java.util.ArrayList+size() java.util.ArrayList+size() java.util.ArrayList+get(int) java.util.ArrayList+get(int) java.lang.String+equals(Object) java.lang.String+equals(Object) java.util.regex.Pattern+toString() java.util.regex.Pattern+toString() java.util.ArrayList+remove(int) java.util.ArrayList+remove(int),com.koushikdutta.async.http.server.AsyncHttpServer+mActions com.koushikdutta.async.http.server.AsyncHttpServer+mActions com.koushikdutta.async.http.server.AsyncHttpServer.Pair+regex,463,14,1,,"public void removeAction(String action, String regex) {
        synchronized (mActions) {
            ArrayList<Pair> pairs = mActions.get(action);
            if (pairs == null)
                return;
            for (int i = 0; i < pairs.size(); i++) {
                Pair p = pairs.get(i);
                if (regex.equals(p.regex.toString())) {
                    pairs.remove(i);
                    return;
                }
            }
        }
    }",True,True,"The function of this method is to remove a specific action from a synchronized ArrayList of pairs, based on a given regex.",True,This code defines a method called `removeAction` that removes a specific action from a synchronized map called `mActions`. It iterates through the list of pairs associated with the given action and removes the pair if the provided regex matches the pair's regex.
18,"addAction(String,String,HttpServerRequestCallback)",add action action regex callback ,Method,"get(String,HttpServerRequestCallback) post(String,HttpServerRequestCallback) directory(Context,String,String)",,"com.koushikdutta.async.http.server.AsyncHttpServer.Pair+Pair() java.util.regex.Pattern+compile(String) java.util.regex.Pattern+compile(String) java.util.Hashtable+get(Object) java.util.Hashtable+get(Object) java.util.ArrayList+ArrayList() java.util.Hashtable+put(K,V) java.util.Hashtable+put(K,V) java.util.ArrayList+add(E) java.util.ArrayList+add(E)",com.koushikdutta.async.http.server.AsyncHttpServer.Pair+regex com.koushikdutta.async.http.server.AsyncHttpServer.Pair+callback com.koushikdutta.async.http.server.AsyncHttpServer+mActions com.koushikdutta.async.http.server.AsyncHttpServer+mActions com.koushikdutta.async.http.server.AsyncHttpServer+mActions,494,14,1,,"public void addAction(String action, String regex, HttpServerRequestCallback callback) {
        Pair p = new Pair();
        p.regex = Pattern.compile(""^"" + regex);
        p.callback = callback;
        
        synchronized (mActions) {
            ArrayList<Pair> pairs = mActions.get(action);
            if (pairs == null) {
                pairs = new ArrayList<AsyncHttpServer.Pair>();
                mActions.put(action, pairs);
            }
            pairs.add(p);
        }
    }",True,True,"The function of this method is to add an action, along with a regular expression and a callback function, to a collection of actions. The method creates a Pair object with the regex and callback, and adds it to the list of pairs associated with the given action.",True,"This code defines a method called `addAction` that adds an action, regex pattern, and callback function to a map of actions. It creates a new `Pair` object with the regex pattern compiled as a regular expression, and adds it to the list of pairs associated with the given action in the map."
19,WebSocketRequestCallback,web socket request callback ,MemberClass,,,"com.koushikdutta.async.http.server.AsyncHttpServer.WebSocketRequestCallback+onConnected(WebSocket,AsyncHttpServerRequest)",,142,3,9,,"public static interface WebSocketRequestCallback {
        public void onConnected(WebSocket webSocket, AsyncHttpServerRequest request);
    }",False,True,,False,
20,"websocket(String,WebSocketRequestCallback)",websocket regex callback ,Method,,com.koushikdutta.async.test.IssueWithWebSocketFuturesTests+testWebSocketFutureWithHandshakeFailureCallback(),"com.koushikdutta.async.http.server.AsyncHttpServer+websocket(String,String,WebSocketRequestCallback) com.koushikdutta.async.http.server.AsyncHttpServer+websocket(String,String,WebSocketRequestCallback)",,126,3,1,,"public void websocket(String regex, final WebSocketRequestCallback callback) {
        websocket(regex, null, callback);
    }",True,True,"This method is a wrapper for another method called ""websocket"". It takes a regular expression and a callback function as parameters, and then calls the ""websocket"" method with these parameters.",True,"The given code is a method named ""websocket"" that takes a regular expression and a WebSocketRequestCallback as parameters. It calls another overloaded version of the same method with the same regular expression, a null value, and the provided callback."
21,"websocket(String,String,WebSocketRequestCallback)",websocket regex protocol callback ,Method,"websocket(String,WebSocketRequestCallback)",,"com.koushikdutta.async.http.server.AsyncHttpServer+get(String,HttpServerRequestCallback) com.koushikdutta.async.http.server.AsyncHttpServer+get(String,HttpServerRequestCallback) +() +onRequest(AsyncHttpServerRequest,AsyncHttpServerResponse)",,1405,30,1,,"public void websocket(String regex, final String protocol, final WebSocketRequestCallback callback) {
        get(regex, new HttpServerRequestCallback() {
            @Override
            public void onRequest(final AsyncHttpServerRequest request, final AsyncHttpServerResponse response) {
                boolean hasUpgrade = false;
                String connection = request.getHeaders().get(""Connection"");
                if (connection != null) {
                    String[] connections = connection.split("","");
                    for (String c: connections) {
                        if (""Upgrade"".equalsIgnoreCase(c.trim())) {
                            hasUpgrade = true;
                            break;
                        }
                    }
                }
                if (!""websocket"".equalsIgnoreCase(request.getHeaders().get(""Upgrade"")) || !hasUpgrade) {
                    response.code(404);
                    response.end();
                    return;
                }
                String peerProtocol = request.getHeaders().get(""Sec-WebSocket-Protocol"");
                if (!TextUtils.equals(protocol, peerProtocol)) {
                    response.code(404);
                    response.end();
                    return;
                }
                callback.onConnected(new WebSocketImpl(request, response), request);
            }
        });
    }",True,True,"The function of this method is to handle WebSocket requests. It checks if the request has the necessary headers for a WebSocket upgrade, and if the protocol matches. If everything is valid, it calls the provided callback to establish a WebSocket connection.",True,"This code defines a method called ""websocket"" that handles WebSocket requests. It checks if the request is a valid WebSocket upgrade request, verifies the requested protocol, and then calls the provided callback function with a WebSocket object and the request."
22,"get(String,HttpServerRequestCallback)",get regex callback ,Method,"websocket(String,String,WebSocketRequestCallback)",com.koushikdutta.async.test.CacheTests+testMaxAgePrivate() com.koushikdutta.async.test.Issue59+testIssue() com.koushikdutta.async.test.RedirectTests+setUp() com.koushikdutta.async.test.SSLTests+testKeys() com.koushikdutta.async.test.TimeoutTests+TimeoutTests(),"com.koushikdutta.async.http.server.AsyncHttpServer+addAction(String,String,HttpServerRequestCallback) com.koushikdutta.async.http.server.AsyncHttpServer+addAction(String,String,HttpServerRequestCallback)",com.koushikdutta.async.http.AsyncHttpGet+METHOD,130,3,1,,"public void get(String regex, HttpServerRequestCallback callback) {
        addAction(AsyncHttpGet.METHOD, regex, callback);
    }",True,True,This method adds an action to perform an HTTP GET request with a specified regex pattern and a callback function to handle the server response.,True,"The code defines a method named ""get"" that takes a regular expression and a callback function as parameters. It adds an action to perform an HTTP GET request with the specified regular expression and callback function."
23,"post(String,HttpServerRequestCallback)",post regex callback ,Method,,,"com.koushikdutta.async.http.server.AsyncHttpServer+addAction(String,String,HttpServerRequestCallback) com.koushikdutta.async.http.server.AsyncHttpServer+addAction(String,String,HttpServerRequestCallback)",com.koushikdutta.async.http.AsyncHttpPost+METHOD,132,3,1,,"public void post(String regex, HttpServerRequestCallback callback) {
        addAction(AsyncHttpPost.METHOD, regex, callback);
    }",True,True,The function of the method is to register a callback function for handling HTTP POST requests that match a specified regular expression.,True,"The code defines a method named ""post"" that takes a regular expression and a callback function as parameters. It adds an action to perform an HTTP POST request with the given regular expression and callback function."
24,"getAssetStream(Context,String)",get asset stream context asset ,Method,,,"android.content.Context+getAssets() android.content.Context+getAssets() android.content.res.AssetManager+open(String) android.content.res.AssetManager+open(String) android.util.Pair+Pair(F,S) java.io.InputStream+available() java.io.InputStream+available()",,380,10,9,,"public static android.util.Pair<Integer, InputStream> getAssetStream(final Context context, String asset) {
        AssetManager am = context.getAssets();
        try {
            InputStream is = am.open(asset);
            return new android.util.Pair<Integer, InputStream>(is.available(), is);
        }
        catch (IOException e) {
            return null;
        }
    }",True,True,"This method returns a Pair object containing the size and InputStream of an asset file in the given Context. If the asset file cannot be opened, it returns null.",False,"This code defines a method named ""getAssetStream"" that takes a Context and a String as parameters. It retrieves an InputStream from the assets folder using the provided asset name and returns a Pair object containing the available size of the stream and the stream itself. If an IOException occurs, it returns null."
25,mContentTypes,m content types ,Field,,,,,81,1,8,,"static Hashtable<String, String> mContentTypes = new Hashtable<String, String>();",False,True,,False,
26,getContentType(String),get content type path ,Method,,com.koushikdutta.async.http.server.AsyncHttpServerResponseImpl+sendFile(File),com.koushikdutta.async.http.server.AsyncHttpServer+tryGetContentType(String) com.koushikdutta.async.http.server.AsyncHttpServer+tryGetContentType(String),,183,6,9,,"public static String getContentType(String path) {
        String type = tryGetContentType(path);
        if (type != null)
            return type;
        return ""text/plain"";
    }",False,True,"The function of the method is to retrieve the content type of a given file path. It first tries to get the content type using the tryGetContentType method, and if it is not found, it returns ""text/plain"" as the default content type.",False,"The given code is a method named ""getContentType"" that takes a string parameter ""path"" and returns a string. It first tries to retrieve the content type based on the given path, and if it is not found, it returns the default content type as ""text/plain""."
27,tryGetContentType(String),try get content type path ,Method,getContentType(String),,java.lang.String+lastIndexOf(String) java.lang.String+lastIndexOf(String) java.lang.String+substring(int) java.lang.String+substring(int) java.util.Hashtable+get(Object) java.util.Hashtable+get(Object),com.koushikdutta.async.http.server.AsyncHttpServer+mContentTypes,311,10,9,,"public static String tryGetContentType(String path) {
        int index = path.lastIndexOf(""."");
        if (index != -1) {
            String e = path.substring(index + 1);
            String ct = mContentTypes.get(e);
            if (ct != null)
                return ct;
        }
        return null;
    }",True,True,"This method tries to get the content type of a file based on its file extension. It takes a file path as input and returns the corresponding content type if it exists in the mContentTypes map, otherwise it returns null.",False,"The given code is a method named ""tryGetContentType"" that takes a file path as input and tries to determine the content type of the file based on its extension. It does this by extracting the file extension from the path, looking it up in a map of content types, and returning the corresponding content type if found."
28,"directory(Context,String,String)",directory context regex asset path ,Method,,,"android.content.Context+getApplicationContext() android.content.Context+getApplicationContext() com.koushikdutta.async.http.server.AsyncHttpServer+addAction(String,String,HttpServerRequestCallback) com.koushikdutta.async.http.server.AsyncHttpServer+addAction(String,String,HttpServerRequestCallback) +() +onRequest(AsyncHttpServerRequest,AsyncHttpServerResponse)",com.koushikdutta.async.http.AsyncHttpGet+METHOD,2285,45,1,,"public void directory(Context context, String regex, final String assetPath) {
        final Context _context = context.getApplicationContext();
        addAction(AsyncHttpGet.METHOD, regex, new HttpServerRequestCallback() {
            @Override
            public void onRequest(AsyncHttpServerRequest request, final AsyncHttpServerResponse response) {
                String path = request.getMatcher().replaceAll("""");
                android.util.Pair<Integer, InputStream> pair = getAssetStream(_context, assetPath + path);
                if (pair == null || pair.second == null) {
                    response.code(404);
                    response.end();
                    return;
                }
                final InputStream is = pair.second;
                response.getHeaders().set(""Content-Length"", String.valueOf(pair.first));
                response.code(200);
                response.getHeaders().add(""Content-Type"", getContentType(assetPath + path));
                Util.pump(is, response, new CompletedCallback() {
                    @Override
                    public void onCompleted(Exception ex) {
                        response.end();
                        StreamUtility.closeQuietly(is);
                    }
                });
            }
        });
        addAction(AsyncHttpHead.METHOD, regex, new HttpServerRequestCallback() {
            @Override
            public void onRequest(AsyncHttpServerRequest request, final AsyncHttpServerResponse response) {
                String path = request.getMatcher().replaceAll("""");
                android.util.Pair<Integer, InputStream> pair = getAssetStream(_context, assetPath + path);
                if (pair == null || pair.second == null) {
                    response.code(404);
                    response.end();
                    return;
                }
                final InputStream is = pair.second;
                StreamUtility.closeQuietly(is);
                response.getHeaders().set(""Content-Length"", String.valueOf(pair.first));
                response.code(200);
                response.getHeaders().add(""Content-Type"", getContentType(assetPath + path));
                response.writeHead();
                response.end();
            }
        });
    }",True,True,The function of this method is to handle HTTP GET and HEAD requests for a given directory in an Android application. It retrieves the requested file from the assets folder and sends it as a response to the client.,True,"This code defines a method called ""directory"" that sets up HTTP server actions for handling GET and HEAD requests. It retrieves assets from the specified asset path and sends the appropriate response with the content type and length."
29,"directory(String,File)",directory regex directory ,Method,,,"com.koushikdutta.async.http.server.AsyncHttpServer+directory(String,File,boolean) com.koushikdutta.async.http.server.AsyncHttpServer+directory(String,File,boolean)",,109,3,1,,"public void directory(String regex, final File directory) {
        directory(regex, directory, false);
    }",True,True,"The function of this method is to call another method named ""directory"" with three parameters: a regular expression, a File object representing a directory, and a boolean value indicating whether to include subdirectories.",True,"The code defines a method named ""directory"" that takes a regular expression and a File object as parameters. It calls another version of the ""directory"" method with an additional boolean parameter set to false. The purpose of the method is to perform some operation on the files in the specified directory based on the given regular expression."
30,"directory(String,File,boolean)",directory regex directory list ,Method,"directory(String,File)",,,,2173,54,1,,"public void directory(String regex, final File directory, final boolean list) {
        assert directory.isDirectory();
        addAction(""GET"", regex, new HttpServerRequestCallback() {
            @Override
            public void onRequest(AsyncHttpServerRequest request, final AsyncHttpServerResponse response) {
                String path = request.getMatcher().replaceAll("""");
                File file = new File(directory, path);
                
                if (file.isDirectory() && list) {
                    ArrayList<File> dirs = new ArrayList<File>();
                    ArrayList<File> files = new ArrayList<File>();
                    for (File f: file.listFiles()) {
                        if (f.isDirectory())
                            dirs.add(f);
                        else
                            files.add(f);
                    }
                    
                    Comparator<File> c = new Comparator<File>() {
                        @Override
                        public int compare(File lhs, File rhs) {
                            return lhs.getName().compareTo(rhs.getName());
                        }
                    };
                    
                    Collections.sort(dirs, c);
                    Collections.sort(files, c);
                    
                    files.addAll(0, dirs);
                    
                    return;
                }
                if (!file.isFile()) {
                    response.code(404);
                    response.end();
                    return;
                }
                try {
                    FileInputStream is = new FileInputStream(file);
                    response.code(200);
                    Util.pump(is, response, new CompletedCallback() {
                        @Override
                        public void onCompleted(Exception ex) {
                            response.end();
                        }
                    });
                }
                catch (FileNotFoundException ex) {
                    response.code(404);
                    response.end();
                }
            }
        });
    }",True,True,"The function of this method is to handle HTTP requests for a directory. It checks if the requested file is a directory and if the ""list"" parameter is true, it lists the files and directories in the directory. If the requested file is not a directory or the ""list"" parameter is false, it returns the file content or a 404 error if the file is not found.",True,"This code defines a method called ""directory"" that handles HTTP requests for files and directories. It checks if the requested path is a directory and if the ""list"" flag is set, it returns a sorted list of files and directories. If the path is a file, it reads the file and sends it as a response."
31,mCodes,m codes ,Field,,,,,84,1,10,,"private static Hashtable<Integer, String> mCodes = new Hashtable<Integer, String>();",False,False,,False,
32,getResponseCodeDescription(int),get response code description code ,Method,,com.koushikdutta.async.http.server.AsyncHttpServerResponseImpl+initFirstWrite() com.koushikdutta.async.http.server.AsyncHttpServerResponseImpl+toString(),java.util.Hashtable+get(Object) java.util.Hashtable+get(Object),com.koushikdutta.async.http.server.AsyncHttpServer+mCodes,173,6,9,,"public static String getResponseCodeDescription(int code) {
        String d = mCodes.get(code);
        if (d == null)
            return ""Unknown"";
        return d;
    }",False,False,"This method returns the description of a given response code. If the code is not found in the map, it returns ""Unknown"".",False,"The given code is a method named ""getResponseCodeDescription"" that takes an integer parameter ""code"" and returns a string description based on the value of ""code"". It retrieves the description from a map named ""mCodes"" and if the description is not found, it returns ""Unknown""."
