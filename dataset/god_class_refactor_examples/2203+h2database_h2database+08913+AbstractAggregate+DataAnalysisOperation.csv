index,name,document,type,inner invocations,external invocations,calls,visits,length,lines,modifier,commit,full text,moved,removed,gpt text,gpt response,code summary
1,select,select ,Field,"AbstractAggregate(Select,boolean)",,,,30,1,20,,protected final Select select;,True,True,,False,
2,distinct,distinct ,Field,"AbstractAggregate(Select,boolean)",,,,33,1,20,,protected final boolean distinct;,False,False,,False,
3,filterCondition,filter condition ,Field,setFilterCondition(Expression),,,,37,1,4,,protected Expression filterCondition;,False,False,,False,
4,over,over ,Field,setOverCondition(Window),,,,22,1,4,,protected Window over;,True,True,,False,
5,overOrderBySort,over order by sort ,Field,,,,,36,1,4,,protected SortOrder overOrderBySort;,True,True,,False,
6,lastGroupRowId,last group row id ,Field,,,,,27,1,2,,private int lastGroupRowId;,True,True,,False,
7,"createOrder(Session,ArrayList<SelectOrderBy>,int)",create order session order by offset ,Method,optimize(Session),org.h2.expression.aggregate.Aggregate+optimize(Session),"java.util.ArrayList+size() java.util.ArrayList+size() java.util.ArrayList+get(int) java.util.ArrayList+get(int) org.h2.result.SortOrder+SortOrder(Database,int[],int[],ArrayList<SelectOrderBy>) org.h2.engine.Session+getDatabase() org.h2.engine.Session+getDatabase()",org.h2.command.dml.SelectOrderBy+sortType,467,11,12,,"protected static SortOrder createOrder(Session session, ArrayList<SelectOrderBy> orderBy, int offset) {
        int size = orderBy.size();
        int[] index = new int[size];
        int[] sortType = new int[size];
        for (int i = 0; i < size; i++) {
            SelectOrderBy o = orderBy.get(i);
            index[i] = i + offset;
            sortType[i] = o.sortType;
        }
        return new SortOrder(session.getDatabase(), index, sortType, null);
    }",True,True,"This method creates a SortOrder object based on the given session, orderBy list, and offset. It initializes arrays for index and sortType, populates them with values from the orderBy list, and returns a new SortOrder object.",True,"This code defines a protected static method called `createOrder` that takes a `Session` object, an `ArrayList` of `SelectOrderBy` objects, and an offset as parameters. It creates an array of indices and an array of sort types based on the `SelectOrderBy` objects, and then returns a new `SortOrder` object with these arrays as arguments."
8,"AbstractAggregate(Select,boolean)",abstract aggregate select distinct ,Method,,,,org.h2.expression.aggregate.AbstractAggregate+select org.h2.expression.aggregate.AbstractAggregate+select org.h2.expression.aggregate.AbstractAggregate+distinct org.h2.expression.aggregate.AbstractAggregate+distinct,122,4,0,,"AbstractAggregate(Select select, boolean distinct) {
        this.select = select;
        this.distinct = distinct;
    }",False,False,"The function of the method is to initialize the ""select"" and ""distinct"" variables with the values passed as parameters.",True,The code defines a constructor for an abstract class called AbstractAggregate. The constructor takes two parameters: a Select object and a boolean value indicating whether the select statement should return distinct values. The constructor initializes the select and distinct variables of the class with the provided values.
9,setFilterCondition(Expression),set filter condition filter condition sets the filter condition param filter condition filter condition ,Method,,org.h2.command.Parser+readFilterAndOver(AbstractAggregate),org.h2.expression.aggregate.AbstractAggregate+isAggregate() org.h2.expression.aggregate.AbstractAggregate+isAggregate() org.h2.message.DbException+getUnsupportedException(String) org.h2.message.DbException+getUnsupportedException(String),org.h2.expression.aggregate.AbstractAggregate+filterCondition org.h2.expression.aggregate.AbstractAggregate+filterCondition,370,13,1,"/** 
 * Sets the FILTER condition.
 * @param filterCondition FILTER condition
 */
","/**
     * Sets the FILTER condition.
     *
     * @param filterCondition
     *            FILTER condition
     */
    public void setFilterCondition(Expression filterCondition) {
        if (isAggregate()) {
            this.filterCondition = filterCondition;
        } else {
            throw DbException.getUnsupportedException(""Window function"");
        }
    }",False,False,"This method sets the FILTER condition for a window function. If the function is not an aggregate function, it throws an exception.",False,"This code defines a method called ""setFilterCondition"" that sets the filter condition for a window function. If the function is not an aggregate function, it throws an exception indicating that window functions are not supported."
10,setOverCondition(Window),set over condition over sets the over condition param over over condition ,Method,,org.h2.command.Parser+readFilterAndOver(AbstractAggregate),,org.h2.expression.aggregate.AbstractAggregate+over org.h2.expression.aggregate.AbstractAggregate+over,182,9,1,"/** 
 * Sets the OVER condition.
 * @param over OVER condition
 */
","/**
     * Sets the OVER condition.
     *
     * @param over
     *            OVER condition
     */
    public void setOverCondition(Window over) {
        this.over = over;
    }",True,True,This method sets the OVER condition for a window.,False,"This code defines a method called ""setOverCondition"" that takes a parameter of type ""Window"" and sets the value of the ""over"" instance variable to the provided value. The method is used to set the OVER condition for a specific window."
11,isAggregate(),is aggregate checks whether this expression is an aggregate function return true if this is an aggregate function including aggregates with over clause false if this is a window function ,Method,"setFilterCondition(Expression) optimize(Session) updateAggregate(Session,int) getWindowResult(Session,SelectGroups)",org.h2.command.Parser+readFilterAndOver(AbstractAggregate),,,269,7,1025,"/** 
 * Checks whether this expression is an aggregate function.
 * @return true if this is an aggregate function (including aggregates withOVER clause), false if this is a window function
 */
","/**
     * Checks whether this expression is an aggregate function.
     *
     * @return true if this is an aggregate function (including aggregates with
     *         OVER clause), false if this is a window function
     */
    public abstract boolean isAggregate();",False,True,"The method checks if the expression is an aggregate function or a window function, returning true for aggregate functions (including those with an OVER clause) and false for window functions.",False,"The given code snippet represents a method named ""isAggregate()"" which is used to determine whether the expression is an aggregate function or a window function. It returns true if the expression is an aggregate function (including aggregates with an OVER clause) and false if it is a window function."
12,getOverOrderBySort(),get over order by sort returns the sort order for over clause return the sort order for over clause ,Method,"getOrderedResultLoop(Session,HashMap<Integer,Value>,ArrayList<Value[]>,int)","org.h2.expression.aggregate.WindowFunction+getOrderedResultLoop(Session,HashMap<Integer,Value>,ArrayList<Value[]>,int) org.h2.expression.aggregate.WindowFunction+getNth(Session,HashMap<Integer,Value>,ArrayList<Value[]>,int) org.h2.expression.aggregate.WindowFunction+getNth(Session,HashMap<Integer,Value>,ArrayList<Value[]>,int) org.h2.expression.aggregate.WindowFunction+getNth(Session,HashMap<Integer,Value>,ArrayList<Value[]>,int)",,org.h2.expression.aggregate.AbstractAggregate+overOrderBySort,186,8,0,"/** 
 * Returns the sort order for OVER clause.
 * @return the sort order for OVER clause
 */
","/**
     * Returns the sort order for OVER clause.
     *
     * @return the sort order for OVER clause
     */
    SortOrder getOverOrderBySort() {
        return overOrderBySort;
    }",False,False,This method returns the sort order for the OVER clause.,False,"The code defines a method called ""getOverOrderBySort"" that returns the sort order for the OVER clause. It does not take any parameters and returns a value of type ""SortOrder"". The method is not accessible outside of the class it is defined in."
13,"mapColumns(ColumnResolver,int)",map columns resolver level ,Method,,,"org.h2.expression.Expression+mapColumns(ColumnResolver,int) org.h2.expression.Expression+mapColumns(ColumnResolver,int) org.h2.expression.aggregate.Window+mapColumns(ColumnResolver,int) org.h2.expression.aggregate.Window+mapColumns(ColumnResolver,int)",org.h2.expression.aggregate.AbstractAggregate+filterCondition org.h2.expression.aggregate.AbstractAggregate+filterCondition org.h2.expression.aggregate.AbstractAggregate+over org.h2.expression.aggregate.AbstractAggregate+over,270,9,1,,"@Override
    public void mapColumns(ColumnResolver resolver, int level) {
        if (filterCondition != null) {
            filterCondition.mapColumns(resolver, level);
        }
        if (over != null) {
            over.mapColumns(resolver, level);
        }
    }",False,False,This method maps the columns used in the filter condition and the over clause to their corresponding resolvers at a given level.,False,"This code is a method called ""mapColumns"" that overrides a method from a superclass. It takes a ColumnResolver object and an integer level as parameters. It checks if the filterCondition and over objects are not null, and if so, it calls their respective mapColumns methods with the resolver and level parameters."
14,optimize(Session),optimize session ,Method,,,"org.h2.expression.aggregate.Window+optimize(Session) org.h2.expression.aggregate.Window+optimize(Session) org.h2.expression.aggregate.Window+getOrderBy() org.h2.expression.aggregate.Window+getOrderBy() org.h2.expression.aggregate.AbstractAggregate+createOrder(Session,ArrayList<SelectOrderBy>,int) org.h2.expression.aggregate.AbstractAggregate+createOrder(Session,ArrayList<SelectOrderBy>,int) org.h2.expression.aggregate.AbstractAggregate+getNumExpressions() org.h2.expression.aggregate.AbstractAggregate+getNumExpressions() org.h2.expression.aggregate.AbstractAggregate+isAggregate() org.h2.expression.aggregate.AbstractAggregate+isAggregate() org.h2.result.SortOrder+SortOrder(Database,int[],int[],ArrayList<SelectOrderBy>) org.h2.engine.Session+getDatabase() org.h2.engine.Session+getDatabase() org.h2.expression.aggregate.AbstractAggregate+getNumExpressions() org.h2.expression.aggregate.AbstractAggregate+getNumExpressions()",org.h2.expression.aggregate.AbstractAggregate+over org.h2.expression.aggregate.AbstractAggregate+over org.h2.expression.aggregate.AbstractAggregate+over org.h2.expression.aggregate.AbstractAggregate+overOrderBySort org.h2.expression.aggregate.AbstractAggregate+overOrderBySort,522,13,1,,"@Override
    public Expression optimize(Session session) {
        if (over != null) {
            over.optimize(session);
            ArrayList<SelectOrderBy> orderBy = over.getOrderBy();
            if (orderBy != null) {
                overOrderBySort = createOrder(session, orderBy, getNumExpressions());
            } else if (!isAggregate()) {
                overOrderBySort = new SortOrder(session.getDatabase(), new int[getNumExpressions()], new int[0], null);
            }
        }
        return this;
    }",False,False,"This method optimizes the expression by checking if there is an ""over"" clause. If there is, it optimizes it and creates an order if there is an order by clause. If there is no order by clause and the expression is not an aggregate, it creates a new sort order. Finally, it returns the optimized expression.",False,"This code is an implementation of the `optimize` method in a Java class. It checks if the `over` variable is not null, and if so, it optimizes it by creating an order based on the `orderBy` list. If the `orderBy` list is null and the expression is not an aggregate, it creates a new `SortOrder` object. Finally, it returns the current instance of the class."
15,"setEvaluatable(TableFilter,boolean)",set evaluatable table filter b ,Method,,,"org.h2.expression.Expression+setEvaluatable(TableFilter,boolean) org.h2.expression.Expression+setEvaluatable(TableFilter,boolean) org.h2.expression.aggregate.Window+setEvaluatable(TableFilter,boolean) org.h2.expression.aggregate.Window+setEvaluatable(TableFilter,boolean)",org.h2.expression.aggregate.AbstractAggregate+filterCondition org.h2.expression.aggregate.AbstractAggregate+filterCondition org.h2.expression.aggregate.AbstractAggregate+over org.h2.expression.aggregate.AbstractAggregate+over,280,9,1,,"@Override
    public void setEvaluatable(TableFilter tableFilter, boolean b) {
        if (filterCondition != null) {
            filterCondition.setEvaluatable(tableFilter, b);
        }
        if (over != null) {
            over.setEvaluatable(tableFilter, b);
        }
    }",False,False,This method sets the evaluatable property of the filter condition and over condition in a table filter.,False,"This code is an implementation of the `setEvaluatable` method, which is used to set the evaluatable property of a `TableFilter` object. It checks if the `filterCondition` and `over` objects are not null, and if so, it calls their respective `setEvaluatable` methods with the provided boolean value."
16,"updateAggregate(Session,int)",update aggregate session stage ,Method,,,"org.h2.expression.aggregate.AbstractAggregate+updateSubAggregates(Session,int) org.h2.expression.aggregate.AbstractAggregate+updateSubAggregates(Session,int) org.h2.command.dml.Select+isWindowQuery() org.h2.command.dml.Select+isWindowQuery() org.h2.expression.aggregate.AbstractAggregate+updateSubAggregates(Session,int) org.h2.expression.aggregate.AbstractAggregate+updateSubAggregates(Session,int) org.h2.command.dml.Select+getGroupDataIfCurrent(boolean) org.h2.command.dml.Select+getGroupDataIfCurrent(boolean) org.h2.command.dml.SelectGroups+getCurrentGroupRowId() org.h2.command.dml.SelectGroups+getCurrentGroupRowId() org.h2.command.dml.Select+isGroupQuery() org.h2.command.dml.Select+isGroupQuery() org.h2.expression.aggregate.Window+updateAggregate(Session,int) org.h2.expression.aggregate.Window+updateAggregate(Session,int) org.h2.expression.Expression+getBooleanValue(Session) org.h2.expression.Expression+getBooleanValue(Session) org.h2.expression.aggregate.Window+getOrderBy() org.h2.expression.aggregate.Window+getOrderBy() org.h2.expression.aggregate.AbstractAggregate+isAggregate() org.h2.expression.aggregate.AbstractAggregate+isAggregate() org.h2.expression.aggregate.AbstractAggregate+updateOrderedAggregate(Session,SelectGroups,int,ArrayList<SelectOrderBy>) org.h2.expression.aggregate.AbstractAggregate+updateOrderedAggregate(Session,SelectGroups,int,ArrayList<SelectOrderBy>) org.h2.expression.aggregate.AbstractAggregate+updateAggregate(Session,Object) org.h2.expression.aggregate.AbstractAggregate+updateAggregate(Session,Object) org.h2.expression.aggregate.AbstractAggregate+getData(Session,SelectGroups,boolean,boolean) org.h2.expression.aggregate.AbstractAggregate+getData(Session,SelectGroups,boolean,boolean)",org.h2.expression.aggregate.Aggregate+STAGE_RESET org.h2.expression.aggregate.Aggregate+STAGE_RESET org.h2.expression.aggregate.AbstractAggregate+lastGroupRowId org.h2.expression.aggregate.Aggregate+STAGE_WINDOW org.h2.expression.aggregate.AbstractAggregate+over org.h2.expression.aggregate.AbstractAggregate+select org.h2.expression.aggregate.AbstractAggregate+select org.h2.expression.aggregate.AbstractAggregate+lastGroupRowId org.h2.expression.aggregate.AbstractAggregate+lastGroupRowId org.h2.expression.aggregate.AbstractAggregate+over org.h2.expression.aggregate.AbstractAggregate+select org.h2.expression.aggregate.AbstractAggregate+over org.h2.expression.aggregate.AbstractAggregate+filterCondition org.h2.expression.aggregate.AbstractAggregate+filterCondition org.h2.expression.aggregate.AbstractAggregate+over org.h2.expression.aggregate.AbstractAggregate+over,1686,50,1,,"@Override
    public void updateAggregate(Session session, int stage) {
        if (stage == Aggregate.STAGE_RESET) {
            updateSubAggregates(session, Aggregate.STAGE_RESET);
            lastGroupRowId = 0;
            return;
        }
        boolean window = stage == Aggregate.STAGE_WINDOW;
        if (window != (over != null)) {
            if (!window && select.isWindowQuery()) {
                updateSubAggregates(session, stage);
            }
            return;
        }
        // TODO aggregates: check nested MIN(MAX(ID)) and so on
        // if (on != null) {
        // on.updateAggregate();
        // }
        SelectGroups groupData = select.getGroupDataIfCurrent(window);
        if (groupData == null) {
            // this is a different level (the enclosing query)
            return;
        }

        int groupRowId = groupData.getCurrentGroupRowId();
        if (lastGroupRowId == groupRowId) {
            // already visited
            return;
        }
        lastGroupRowId = groupRowId;

        if (over != null) {
            if (!select.isGroupQuery()) {
                over.updateAggregate(session, stage);
            }
        }
        if (filterCondition != null) {
            if (!filterCondition.getBooleanValue(session)) {
                return;
            }
        }
        if (over != null) {
            ArrayList<SelectOrderBy> orderBy = over.getOrderBy();
            if (orderBy != null || !isAggregate()) {
                updateOrderedAggregate(session, groupData, groupRowId, orderBy);
                return;
            }
        }
        updateAggregate(session, getData(session, groupData, false, false));
    }",True,True,"This method updates the aggregate values for a given session and stage. It handles different stages of aggregation, checks for window queries, updates sub-aggregates, and handles group queries. It also checks for filter conditions and updates ordered aggregates if necessary.",True,"This code is a method called ""updateAggregate"" that is responsible for updating the aggregate values in a query. It handles different stages of the aggregation process, checks for nested aggregates, applies filter conditions, and updates the aggregates based on the group data and order by criteria."
17,"updateSubAggregates(Session,int)",update sub aggregates session stage ,Method,"updateAggregate(Session,int) updateAggregate(Session,int)",,"org.h2.expression.aggregate.AbstractAggregate+updateGroupAggregates(Session,int) org.h2.expression.aggregate.AbstractAggregate+updateGroupAggregates(Session,int) org.h2.expression.Expression+updateAggregate(Session,int) org.h2.expression.Expression+updateAggregate(Session,int) org.h2.expression.aggregate.Window+updateAggregate(Session,int) org.h2.expression.aggregate.Window+updateAggregate(Session,int)",org.h2.expression.aggregate.AbstractAggregate+filterCondition org.h2.expression.aggregate.AbstractAggregate+filterCondition org.h2.expression.aggregate.AbstractAggregate+over org.h2.expression.aggregate.AbstractAggregate+over,313,9,2,,"private void updateSubAggregates(Session session, int stage) {
        updateGroupAggregates(session, stage);
        if (filterCondition != null) {
            filterCondition.updateAggregate(session, stage);
        }
        if (over != null) {
            over.updateAggregate(session, stage);
        }
    }",False,False,The function of the method is to update sub-aggregates in a session for a given stage. It calls the updateGroupAggregates method and updates the filter condition and over aggregates if they are not null.,True,"The given code is a private method called ""updateSubAggregates"" that takes a session and a stage as parameters. It updates the group aggregates, and if there is a filter condition or an ""over"" condition, it updates their aggregates as well."
18,"updateAggregate(Session,Object)",update aggregate session aggregate data updates an aggregate value param session the session param aggregate data aggregate data ,Method,"updateAggregate(Session,int)",,,,250,9,1028,"/** 
 * Updates an aggregate value.
 * @param session the session
 * @param aggregateData aggregate data
 */
","/**
     * Updates an aggregate value.
     *
     * @param session
     *            the session
     * @param aggregateData
     *            aggregate data
     */
    protected abstract void updateAggregate(Session session, Object aggregateData);",False,False,This method serves to update an aggregate value using the provided session and aggregate data.,True,"The code contains an abstract method called ""updateAggregate"" that takes a session and an aggregate data as parameters. It is meant to update an aggregate value, but the specific implementation is left to the subclasses."
19,"updateGroupAggregates(Session,int)",update group aggregates session stage invoked when processing group stage of grouped window queries to update arguments of this aggregate param session the session param stage select stage ,Method,"updateSubAggregates(Session,int)",,,,315,10,1028,"/** 
 * Invoked when processing group stage of grouped window queries to update arguments of this aggregate.
 * @param session the session
 * @param stage select stage
 */
","/**
     * Invoked when processing group stage of grouped window queries to update
     * arguments of this aggregate.
     *
     * @param session
     *            the session
     * @param stage
     *            select stage
     */
    protected abstract void updateGroupAggregates(Session session, int stage);",False,True,This method is used to update the arguments of an aggregate during the processing of the group stage of grouped window queries. It takes in a session and a select stage as parameters.,True,The given code is an abstract method that is invoked during the processing of grouped window queries to update the arguments of an aggregate. It takes a session and a select stage as parameters and does not have an implementation in the current code.
20,getNumExpressions(),get num expressions returns the number of expressions excluding filter and over clauses return the number of expressions ,Method,"optimize(Session) updateOrderedAggregate(Session,SelectGroups,int,ArrayList<SelectOrderBy>) getOrderedResult(Session,SelectGroups,PartitionData,Object)",,,,184,6,1028,"/** 
 * Returns the number of expressions, excluding FILTER and OVER clauses.
 * @return the number of expressions
 */
","/**
     * Returns the number of expressions, excluding FILTER and OVER clauses.
     *
     * @return the number of expressions
     */
    protected abstract int getNumExpressions();",False,True,"This method serves to return the number of expressions, excluding FILTER and OVER clauses. It is an abstract method and returns an integer value.",True,"The code contains an abstract method called ""getNumExpressions"" which returns the number of expressions in a certain context. The method excludes FILTER and OVER clauses from the count. The method's purpose is to provide the number of expressions in a specific scenario."
21,"rememberExpressions(Session,Value[])",remember expressions session array stores current values of expressions into the specified array param session the session param array array to store values of expressions ,Method,"updateOrderedAggregate(Session,SelectGroups,int,ArrayList<SelectOrderBy>)",,,,296,9,1028,"/** 
 * Stores current values of expressions into the specified array.
 * @param session the session
 * @param array array to store values of expressions
 */
","/**
     * Stores current values of expressions into the specified array.
     *
     * @param session
     *            the session
     * @param array
     *            array to store values of expressions
     */
    protected abstract void rememberExpressions(Session session, Value[] array);",False,True,This method is used to store the current values of expressions into the specified array. It takes a session and an array as parameters and does not return anything.,True,"The code contains an abstract method called ""rememberExpressions"" that takes a session and an array as parameters. This method is responsible for storing the current values of expressions into the specified array."
22,"updateFromExpressions(Session,Object,Value[])",update from expressions session aggregate data array updates the provided aggregate data from the remembered expressions param session the session param aggregate data aggregate data param array values of expressions ,Method,"getOrderedResultLoop(Session,HashMap<Integer,Value>,ArrayList<Value[]>,int) getOrderedResultLoop(Session,HashMap<Integer,Value>,ArrayList<Value[]>,int) getOrderedResultLoop(Session,HashMap<Integer,Value>,ArrayList<Value[]>,int)",,,,372,11,1028,"/** 
 * Updates the provided aggregate data from the remembered expressions.
 * @param session the session
 * @param aggregateData aggregate data
 * @param array values of expressions
 */
","/**
     * Updates the provided aggregate data from the remembered expressions.
     *
     * @param session
     *            the session
     * @param aggregateData
     *            aggregate data
     * @param array
     *            values of expressions
     */
    protected abstract void updateFromExpressions(Session session, Object aggregateData, Value[] array);",False,True,"This method serves to update the provided aggregate data using the remembered expressions. It takes in the session, aggregate data, and an array of expression values as parameters.",True,"This code defines an abstract method called ""updateFromExpressions"" that takes in a session, aggregate data, and an array of values. The purpose of this method is to update the provided aggregate data using the values from the array, based on the specific implementation in the subclass."
23,"getData(Session,SelectGroups,boolean,boolean)",get data session group data if exists for order by ,Method,"updateAggregate(Session,int) getValue(Session) updateOrderedAggregate(Session,SelectGroups,int,ArrayList<SelectOrderBy>)",,"org.h2.expression.aggregate.Window+getCurrentKey(Session) org.h2.expression.aggregate.Window+getCurrentKey(Session) org.h2.command.dml.SelectGroups+getWindowExprData(Expression) org.h2.command.dml.SelectGroups+getWindowExprData(Expression) org.h2.command.dml.SelectGroups+setWindowExprData(Expression,Object) org.h2.command.dml.SelectGroups+setWindowExprData(Expression,Object) org.h2.util.ValueHashMap+get(Value) org.h2.util.ValueHashMap+get(Value) org.h2.expression.aggregate.AbstractAggregate+createAggregateData() org.h2.expression.aggregate.AbstractAggregate+createAggregateData() org.h2.util.ValueHashMap+put(Value,V) org.h2.util.ValueHashMap+put(Value,V) org.h2.expression.aggregate.PartitionData+PartitionData(Object) org.h2.expression.aggregate.PartitionData+getData() org.h2.expression.aggregate.PartitionData+getData() org.h2.command.dml.SelectGroups+getWindowExprData(Expression) org.h2.command.dml.SelectGroups+getWindowExprData(Expression) org.h2.expression.aggregate.AbstractAggregate+createAggregateData() org.h2.expression.aggregate.AbstractAggregate+createAggregateData() org.h2.command.dml.SelectGroups+setWindowExprData(Expression,Object) org.h2.command.dml.SelectGroups+setWindowExprData(Expression,Object) org.h2.expression.aggregate.PartitionData+PartitionData(Object) org.h2.expression.aggregate.PartitionData+getData() org.h2.expression.aggregate.PartitionData+getData() org.h2.command.dml.SelectGroups+getCurrentGroupExprData(Expression) org.h2.command.dml.SelectGroups+getCurrentGroupExprData(Expression) org.h2.expression.aggregate.AbstractAggregate+createAggregateData() org.h2.expression.aggregate.AbstractAggregate+createAggregateData() org.h2.command.dml.SelectGroups+setCurrentGroupExprData(Expression,Object) org.h2.command.dml.SelectGroups+setCurrentGroupExprData(Expression,Object)",org.h2.expression.aggregate.AbstractAggregate+over org.h2.expression.aggregate.AbstractAggregate+over,1991,48,4,,"protected Object getData(Session session, SelectGroups groupData, boolean ifExists, boolean forOrderBy) {
        Object data;
        if (over != null) {
            ValueArray key = over.getCurrentKey(session);
            if (key != null) {
                @SuppressWarnings(""unchecked"")
                ValueHashMap<Object> map = (ValueHashMap<Object>) groupData.getWindowExprData(this);
                if (map == null) {
                    if (ifExists) {
                        return null;
                    }
                    map = new ValueHashMap<>();
                    groupData.setWindowExprData(this, map);
                }
                PartitionData partition = (PartitionData) map.get(key);
                if (partition == null) {
                    if (ifExists) {
                        return null;
                    }
                    data = forOrderBy ? new ArrayList<>() : createAggregateData();
                    map.put(key, new PartitionData(data));
                } else {
                    data = partition.getData();
                }
            } else {
                PartitionData partition = (PartitionData) groupData.getWindowExprData(this);
                if (partition == null) {
                    if (ifExists) {
                        return null;
                    }
                    data = forOrderBy ? new ArrayList<>() : createAggregateData();
                    groupData.setWindowExprData(this, new PartitionData(data));
                } else {
                    data = partition.getData();
                }
            }
        } else {
            data = groupData.getCurrentGroupExprData(this);
            if (data == null) {
                if (ifExists) {
                    return null;
                }
                data = forOrderBy ? new ArrayList<>() : createAggregateData();
                groupData.setCurrentGroupExprData(this, data);
            }
        }
        return data;
    }",True,True,"This method retrieves data from a session, based on the given parameters. It checks if the data exists and returns it, or creates and returns new data if it doesn't exist. The returned data can be an ArrayList or an aggregate data object.",True,"This code is a method that retrieves data from a session based on different conditions. It checks if there is an ""over"" value, and if so, it retrieves data based on a key. If there is no ""over"" value, it retrieves data based on the current group. The method returns the retrieved data."
24,createAggregateData(),create aggregate data ,Method,"getData(Session,SelectGroups,boolean,boolean) getData(Session,SelectGroups,boolean,boolean) getData(Session,SelectGroups,boolean,boolean) getWindowResult(Session,SelectGroups) getWindowResult(Session,SelectGroups) getOrderedResultLoop(Session,HashMap<Integer,Value>,ArrayList<Value[]>,int) getOrderedResultLoop(Session,HashMap<Integer,Value>,ArrayList<Value[]>,int) getOrderedResultLoop(Session,HashMap<Integer,Value>,ArrayList<Value[]>,int)",,,,48,1,1028,,protected abstract Object createAggregateData();,False,True,"This method serves to create and return an object of type Object that represents aggregate data. It is protected and abstract, meaning it must be implemented by a subclass.",True,"The code contains a protected abstract method called ""createAggregateData()"" which returns an Object. The purpose of this method is not specified in the given code snippet."
25,isEverything(ExpressionVisitor),is everything visitor ,Method,,,org.h2.expression.ExpressionVisitor+getType() org.h2.expression.ExpressionVisitor+getType() org.h2.message.DbException+throwInternalError(String) org.h2.message.DbException+throwInternalError(String) org.h2.expression.ExpressionVisitor+getType() org.h2.expression.ExpressionVisitor+getType(),org.h2.expression.aggregate.AbstractAggregate+over org.h2.expression.ExpressionVisitor+QUERY_COMPARABLE org.h2.expression.ExpressionVisitor+OPTIMIZABLE_MIN_MAX_COUNT_ALL org.h2.expression.ExpressionVisitor+DETERMINISTIC org.h2.expression.ExpressionVisitor+INDEPENDENT org.h2.expression.ExpressionVisitor+EVALUATABLE org.h2.expression.ExpressionVisitor+READONLY org.h2.expression.ExpressionVisitor+NOT_FROM_RESOLVER org.h2.expression.ExpressionVisitor+GET_DEPENDENCIES org.h2.expression.ExpressionVisitor+SET_MAX_DATA_MODIFICATION_ID org.h2.expression.ExpressionVisitor+GET_COLUMNS1 org.h2.expression.ExpressionVisitor+GET_COLUMNS2,869,23,1,,"@Override
    public boolean isEverything(ExpressionVisitor visitor) {
        if (over == null) {
            return true;
        }
        switch (visitor.getType()) {
        case ExpressionVisitor.QUERY_COMPARABLE:
        case ExpressionVisitor.OPTIMIZABLE_MIN_MAX_COUNT_ALL:
        case ExpressionVisitor.DETERMINISTIC:
        case ExpressionVisitor.INDEPENDENT:
            return false;
        case ExpressionVisitor.EVALUATABLE:
        case ExpressionVisitor.READONLY:
        case ExpressionVisitor.NOT_FROM_RESOLVER:
        case ExpressionVisitor.GET_DEPENDENCIES:
        case ExpressionVisitor.SET_MAX_DATA_MODIFICATION_ID:
        case ExpressionVisitor.GET_COLUMNS1:
        case ExpressionVisitor.GET_COLUMNS2:
            return true;
        default:
            throw DbException.throwInternalError(""type="" + visitor.getType());
        }
    }",True,True,"The function of this method is to determine whether or not everything is true based on the type of ExpressionVisitor passed as a parameter. It returns true if the type matches any of the specified cases, and false otherwise. If the type does not match any of the specified cases, it throws an internal error.",False,"The code is implementing a method called ""isEverything"" which takes an ExpressionVisitor as a parameter. It checks the type of the visitor and returns a boolean value based on the type. If the type matches certain cases, it returns true, otherwise it throws an exception."
26,getValue(Session),get value session ,Method,,,"org.h2.command.dml.Select+getGroupDataIfCurrent(boolean) org.h2.command.dml.Select+getGroupDataIfCurrent(boolean) org.h2.message.DbException+get(int,String) org.h2.message.DbException+get(int,String) org.h2.expression.Expression+getSQL() org.h2.expression.Expression+getSQL() org.h2.expression.aggregate.AbstractAggregate+getAggregatedValue(Session,Object) org.h2.expression.aggregate.AbstractAggregate+getAggregatedValue(Session,Object) org.h2.expression.aggregate.AbstractAggregate+getData(Session,SelectGroups,boolean,boolean) org.h2.expression.aggregate.AbstractAggregate+getData(Session,SelectGroups,boolean,boolean) org.h2.expression.aggregate.AbstractAggregate+getWindowResult(Session,SelectGroups) org.h2.expression.aggregate.AbstractAggregate+getWindowResult(Session,SelectGroups)",org.h2.expression.aggregate.AbstractAggregate+select org.h2.expression.aggregate.AbstractAggregate+over org.h2.api.ErrorCode+INVALID_USE_OF_AGGREGATE_FUNCTION_1 org.h2.expression.aggregate.AbstractAggregate+over,427,9,1,,"@Override
    public Value getValue(Session session) {
        SelectGroups groupData = select.getGroupDataIfCurrent(over != null);
        if (groupData == null) {
            throw DbException.get(ErrorCode.INVALID_USE_OF_AGGREGATE_FUNCTION_1, getSQL());
        }
        return over == null ? getAggregatedValue(session, getData(session, groupData, true, false))
                : getWindowResult(session, groupData);
    }",True,True,"This method returns the value of an aggregate function for a given session. It checks if the group data is current, and throws an exception if it is not. It then either returns the aggregated value or the window result, depending on the presence of a window.",False,This code is an implementation of a method that returns a value based on the provided session. It checks if the group data is current and throws an exception if it is not. It then either retrieves the aggregated value or the window result based on the presence of a window function.
27,"getWindowResult(Session,SelectGroups)",get window result session group data ,Method,getValue(Session),,"org.h2.expression.aggregate.Window+getOrderBy() org.h2.expression.aggregate.Window+getOrderBy() org.h2.expression.aggregate.Window+getCurrentKey(Session) org.h2.expression.aggregate.Window+getCurrentKey(Session) org.h2.command.dml.SelectGroups+getWindowExprData(Expression) org.h2.command.dml.SelectGroups+getWindowExprData(Expression) org.h2.command.dml.SelectGroups+setWindowExprData(Expression,Object) org.h2.command.dml.SelectGroups+setWindowExprData(Expression,Object) org.h2.util.ValueHashMap+get(Value) org.h2.util.ValueHashMap+get(Value) org.h2.expression.aggregate.AbstractAggregate+createAggregateData() org.h2.expression.aggregate.AbstractAggregate+createAggregateData() org.h2.expression.aggregate.PartitionData+PartitionData(Object) org.h2.util.ValueHashMap+put(Value,V) org.h2.util.ValueHashMap+put(Value,V) org.h2.expression.aggregate.PartitionData+getData() org.h2.expression.aggregate.PartitionData+getData() org.h2.command.dml.SelectGroups+getWindowExprData(Expression) org.h2.command.dml.SelectGroups+getWindowExprData(Expression) org.h2.expression.aggregate.AbstractAggregate+createAggregateData() org.h2.expression.aggregate.AbstractAggregate+createAggregateData() org.h2.expression.aggregate.PartitionData+PartitionData(Object) org.h2.command.dml.SelectGroups+setWindowExprData(Expression,Object) org.h2.command.dml.SelectGroups+setWindowExprData(Expression,Object) org.h2.expression.aggregate.PartitionData+getData() org.h2.expression.aggregate.PartitionData+getData() org.h2.expression.aggregate.Window+getOrderBy() org.h2.expression.aggregate.Window+getOrderBy() org.h2.expression.aggregate.AbstractAggregate+isAggregate() org.h2.expression.aggregate.AbstractAggregate+isAggregate() org.h2.expression.aggregate.AbstractAggregate+getOrderedResult(Session,SelectGroups,PartitionData,Object) org.h2.expression.aggregate.AbstractAggregate+getOrderedResult(Session,SelectGroups,PartitionData,Object) org.h2.expression.aggregate.PartitionData+getResult() org.h2.expression.aggregate.PartitionData+getResult() org.h2.expression.aggregate.AbstractAggregate+getAggregatedValue(Session,Object) org.h2.expression.aggregate.AbstractAggregate+getAggregatedValue(Session,Object) org.h2.expression.aggregate.PartitionData+setResult(Value) org.h2.expression.aggregate.PartitionData+setResult(Value)",org.h2.expression.aggregate.AbstractAggregate+over org.h2.expression.aggregate.AbstractAggregate+over org.h2.expression.aggregate.AbstractAggregate+over,1658,40,2,,"private Value getWindowResult(Session session, SelectGroups groupData) {
        PartitionData partition;
        Object data;
        boolean forOrderBy = over.getOrderBy() != null;
        ValueArray key = over.getCurrentKey(session);
        if (key != null) {
            @SuppressWarnings(""unchecked"")
            ValueHashMap<Object> map = (ValueHashMap<Object>) groupData.getWindowExprData(this);
            if (map == null) {
                map = new ValueHashMap<>();
                groupData.setWindowExprData(this, map);
            }
            partition = (PartitionData) map.get(key);
            if (partition == null) {
                data = forOrderBy ? new ArrayList<>() : createAggregateData();
                partition = new PartitionData(data);
                map.put(key, partition);
            } else {
                data = partition.getData();
            }
        } else {
            partition = (PartitionData) groupData.getWindowExprData(this);
            if (partition == null) {
                data = forOrderBy ? new ArrayList<>() : createAggregateData();
                partition = new PartitionData(data);
                groupData.setWindowExprData(this, partition);
            } else {
                data = partition.getData();
            }
        }
        if (over.getOrderBy() != null || !isAggregate()) {
            return getOrderedResult(session, groupData, partition, data);
        }
        Value result = partition.getResult();
        if (result == null) {
            result = getAggregatedValue(session, data);
            partition.setResult(result);
        }
        return result;
    }",True,True,"The function of this method is to retrieve the result of a window function calculation for a specific session and group of data. It checks if the window function has been calculated before for the given session and group, and if not, it calculates and stores the result. Finally, it returns the result.",False,"This code is a private method that retrieves the result of a window function. It checks if a key exists in a map, and if not, creates a new entry with a partition data object. It then returns the ordered result or the aggregated value based on the presence of an order by clause or if the function is an aggregate."
28,"getAggregatedValue(Session,Object)",get aggregated value session aggregate data returns aggregated value param session the session param aggregate data the aggregate data return aggregated value ,Method,"getValue(Session) getWindowResult(Session,SelectGroups) getOrderedResultLoop(Session,HashMap<Integer,Value>,ArrayList<Value[]>,int) getOrderedResultLoop(Session,HashMap<Integer,Value>,ArrayList<Value[]>,int) getOrderedResultLoop(Session,HashMap<Integer,Value>,ArrayList<Value[]>,int)",,,,290,10,1028,"/** 
 * Returns aggregated value.
 * @param session the session
 * @param aggregateData the aggregate data
 * @return aggregated value.
 */
","/***
     * Returns aggregated value.
     *
     * @param session
     *            the session
     * @param aggregateData
     *            the aggregate data
     * @return aggregated value.
     */
    protected abstract Value getAggregatedValue(Session session, Object aggregateData);",False,True,"This method serves to return an aggregated value based on the provided session and aggregate data. It is an abstract method, so its implementation will vary depending on the specific class that extends it.",True,"This code defines an abstract method called ""getAggregatedValue"" that takes a session and an aggregate data object as parameters and returns a value. The purpose of this method is to calculate and return an aggregated value based on the provided session and aggregate data. The specific implementation of this method will be defined in the subclasses of the class containing this code."
29,"updateOrderedAggregate(Session,SelectGroups,int,ArrayList<SelectOrderBy>)",update ordered aggregate session group data group row id order by ,Method,"updateAggregate(Session,int)",,"org.h2.expression.aggregate.AbstractAggregate+getNumExpressions() org.h2.expression.aggregate.AbstractAggregate+getNumExpressions() java.util.ArrayList+size() java.util.ArrayList+size() org.h2.expression.aggregate.AbstractAggregate+rememberExpressions(Session,Value[]) org.h2.expression.aggregate.AbstractAggregate+rememberExpressions(Session,Value[]) java.util.ArrayList+get(int) java.util.ArrayList+get(int) org.h2.expression.Expression+getValue(Session) org.h2.expression.Expression+getValue(Session) org.h2.value.ValueInt+get(int) org.h2.value.ValueInt+get(int) org.h2.expression.aggregate.AbstractAggregate+getData(Session,SelectGroups,boolean,boolean) org.h2.expression.aggregate.AbstractAggregate+getData(Session,SelectGroups,boolean,boolean) java.util.ArrayList+add(E) java.util.ArrayList+add(E)",org.h2.command.dml.SelectOrderBy+expression,736,16,2,,"private void updateOrderedAggregate(Session session, SelectGroups groupData, int groupRowId,
            ArrayList<SelectOrderBy> orderBy) {
        int ne = getNumExpressions();
        int size = orderBy != null ? orderBy.size() : 0;
        Value[] array = new Value[ne + size + 1];
        rememberExpressions(session, array);
        for (int i = 0; i < size; i++) {
            @SuppressWarnings(""null"")
            SelectOrderBy o = orderBy.get(i);
            array[ne++] = o.expression.getValue(session);
        }
        array[ne] = ValueInt.get(groupRowId);
        @SuppressWarnings(""unchecked"")
        ArrayList<Value[]> data = (ArrayList<Value[]>) getData(session, groupData, false, true);
        data.add(array);
    }",True,True,"This method updates an ordered aggregate by adding a new row of values to the aggregate data. It takes a session, group data, group row ID, and an optional list of order by expressions as parameters. It creates an array to store the values, populates the array with expressions and order by values, and adds the array to the aggregate data.",False,"This code is a private method that updates an ordered aggregate by adding a new row of values to the existing data. It takes in a session, group data, a group row ID, and an array of order by expressions. It retrieves the values for the expressions, creates a new array with the values and the group row ID, and adds it to the existing data."
30,"getOrderedResult(Session,SelectGroups,PartitionData,Object)",get ordered result session group data partition data ,Method,"getWindowResult(Session,SelectGroups)",,"org.h2.expression.aggregate.PartitionData+getOrderedResult() org.h2.expression.aggregate.PartitionData+getOrderedResult() org.h2.expression.aggregate.AbstractAggregate+getNumExpressions() org.h2.expression.aggregate.AbstractAggregate+getNumExpressions() org.h2.expression.aggregate.Window+getOrderBy() org.h2.expression.aggregate.Window+getOrderBy() java.util.ArrayList+size() java.util.ArrayList+size() java.util.Collections+sort(List,Comparator) java.util.Collections+sort(List,Comparator) org.h2.expression.aggregate.AbstractAggregate+getOrderedResultLoop(Session,HashMap<Integer,Value>,ArrayList<Value[]>,int) org.h2.expression.aggregate.AbstractAggregate+getOrderedResultLoop(Session,HashMap<Integer,Value>,ArrayList<Value[]>,int) org.h2.expression.aggregate.PartitionData+setOrderedResult(HashMap<Integer,Value>) org.h2.expression.aggregate.PartitionData+setOrderedResult(HashMap<Integer,Value>) java.util.HashMap+get(Object) java.util.HashMap+get(Object) org.h2.command.dml.SelectGroups+getCurrentGroupRowId() org.h2.command.dml.SelectGroups+getCurrentGroupRowId()",org.h2.expression.aggregate.AbstractAggregate+over org.h2.expression.aggregate.AbstractAggregate+overOrderBySort,844,17,2,,"private Value getOrderedResult(Session session, SelectGroups groupData, PartitionData partition, Object data) {
        HashMap<Integer, Value> result = partition.getOrderedResult();
        if (result == null) {
            result = new HashMap<>();
            @SuppressWarnings(""unchecked"")
            ArrayList<Value[]> orderedData = (ArrayList<Value[]>) data;
            int rowIdColumn = getNumExpressions();
            ArrayList<SelectOrderBy> orderBy = over.getOrderBy();
            if (orderBy != null) {
                rowIdColumn += orderBy.size();
                Collections.sort(orderedData, overOrderBySort);
            }
            getOrderedResultLoop(session, result, orderedData, rowIdColumn);
            partition.setOrderedResult(result);
        }
        return result.get(groupData.getCurrentGroupRowId());
    }",False,True,"This method retrieves the ordered result for a specific group from a partition. If the ordered result is not already available, it creates it by sorting the data and storing it in a HashMap. Finally, it returns the value corresponding to the current group's row ID from the ordered result.",False,"This code is a private method that retrieves an ordered result from a partition. If the result is not already stored in the partition, it creates a new HashMap, sorts the data based on specified order, and stores the ordered result in the partition. Finally, it returns the value corresponding to the current group row ID from the ordered result."
31,"getOrderedResultLoop(Session,HashMap<Integer,Value>,ArrayList<Value[]>,int)",get ordered result loop session result ordered row id column param session the session param result the map to append result to param ordered ordered data param row id column the index of row id value ,Method,"getOrderedResult(Session,SelectGroups,PartitionData,Object)",,"org.h2.expression.aggregate.Window+getWindowFrame() org.h2.expression.aggregate.Window+getWindowFrame() org.h2.expression.aggregate.WindowFrame+isDefault() org.h2.expression.aggregate.WindowFrame+isDefault() org.h2.expression.aggregate.AbstractAggregate+createAggregateData() org.h2.expression.aggregate.AbstractAggregate+createAggregateData() org.h2.expression.aggregate.AbstractAggregate+updateFromExpressions(Session,Object,Value[]) org.h2.expression.aggregate.AbstractAggregate+updateFromExpressions(Session,Object,Value[]) java.util.HashMap+put(K,V) java.util.HashMap+put(K,V) org.h2.value.Value+getInt() org.h2.value.Value+getInt() org.h2.expression.aggregate.AbstractAggregate+getAggregatedValue(Session,Object) org.h2.expression.aggregate.AbstractAggregate+getAggregatedValue(Session,Object) org.h2.expression.aggregate.WindowFrame+isFullPartition() org.h2.expression.aggregate.WindowFrame+isFullPartition() org.h2.expression.aggregate.AbstractAggregate+createAggregateData() org.h2.expression.aggregate.AbstractAggregate+createAggregateData() org.h2.expression.aggregate.AbstractAggregate+updateFromExpressions(Session,Object,Value[]) org.h2.expression.aggregate.AbstractAggregate+updateFromExpressions(Session,Object,Value[]) org.h2.expression.aggregate.AbstractAggregate+getAggregatedValue(Session,Object) org.h2.expression.aggregate.AbstractAggregate+getAggregatedValue(Session,Object) java.util.HashMap+put(K,V) java.util.HashMap+put(K,V) org.h2.value.Value+getInt() org.h2.value.Value+getInt() java.util.ArrayList+size() java.util.ArrayList+size() org.h2.expression.aggregate.AbstractAggregate+createAggregateData() org.h2.expression.aggregate.AbstractAggregate+createAggregateData() org.h2.expression.aggregate.WindowFrame+iterator(Session,ArrayList<Value[]>,SortOrder,int,boolean) org.h2.expression.aggregate.WindowFrame+iterator(Session,ArrayList<Value[]>,SortOrder,int,boolean) org.h2.expression.aggregate.AbstractAggregate+getOverOrderBySort() org.h2.expression.aggregate.AbstractAggregate+getOverOrderBySort() java.util.Iterator+hasNext() java.util.Iterator+hasNext() org.h2.expression.aggregate.AbstractAggregate+updateFromExpressions(Session,Object,Value[]) org.h2.expression.aggregate.AbstractAggregate+updateFromExpressions(Session,Object,Value[]) java.util.Iterator+next() java.util.Iterator+next() java.util.HashMap+put(K,V) java.util.HashMap+put(K,V) org.h2.value.Value+getInt() java.util.ArrayList+get(int) java.util.ArrayList+get(int) org.h2.value.Value+getInt() org.h2.expression.aggregate.AbstractAggregate+getAggregatedValue(Session,Object) org.h2.expression.aggregate.AbstractAggregate+getAggregatedValue(Session,Object)",org.h2.expression.aggregate.AbstractAggregate+over,1756,40,4,"/** 
 * @param session the session
 * @param result the map to append result to
 * @param ordered ordered data
 * @param rowIdColumn the index of row id value
 */
","/**
     * @param session
     *            the session
     * @param result
     *            the map to append result to
     * @param ordered
     *            ordered data
     * @param rowIdColumn
     *            the index of row id value
     */
    protected void getOrderedResultLoop(Session session, HashMap<Integer, Value> result, ArrayList<Value[]> ordered,
            int rowIdColumn) {
        WindowFrame frame = over.getWindowFrame();
        if (frame == null || frame.isDefault()) {
            Object aggregateData = createAggregateData();
            for (Value[] row : ordered) {
                updateFromExpressions(session, aggregateData, row);
                result.put(row[rowIdColumn].getInt(), getAggregatedValue(session, aggregateData));
            }
        } else if (frame.isFullPartition()) {
            Object aggregateData = createAggregateData();
            for (Value[] row : ordered) {
                updateFromExpressions(session, aggregateData, row);
            }
            Value value = getAggregatedValue(session, aggregateData);
            for (Value[] row : ordered) {
                result.put(row[rowIdColumn].getInt(), value);
            }
        } else {
            int size = ordered.size();
            for (int i = 0; i < size; i++) {
                Object aggregateData = createAggregateData();
                for (Iterator<Value[]> iter = frame.iterator(session, ordered, getOverOrderBySort(), i, false); iter
                        .hasNext();) {
                    updateFromExpressions(session, aggregateData, iter.next());
                }
                result.put(ordered.get(i)[rowIdColumn].getInt(), getAggregatedValue(session, aggregateData));
            }
        }
    }",True,True,"This method is used to loop through ordered data and update a result map based on different window frame conditions. It creates aggregate data, updates it with expressions from each row, and puts the aggregated value into the result map with the corresponding row id.",True,"This code defines a method called ""getOrderedResultLoop"" that takes a session, a map, an ordered list, and an index as parameters. It iterates over the ordered list and updates the map with aggregated values based on the session and the data in each row. The method handles different window frame scenarios to determine how the aggregation is performed."
32,appendTailConditions(StringBuilder),append tail conditions builder ,Method,,org.h2.expression.aggregate.Aggregate+getSQLGroupConcat() org.h2.expression.aggregate.Aggregate+getSQLArrayAggregate() org.h2.expression.aggregate.Aggregate+getSQL() org.h2.expression.aggregate.Aggregate+getSQL() org.h2.expression.aggregate.JavaAggregate+getSQL() org.h2.expression.aggregate.WindowFunction+getSQL(),java.lang.StringBuilder+append(char) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) org.h2.expression.Expression+getSQL() org.h2.expression.Expression+getSQL() java.lang.StringBuilder+append(char) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(char) java.lang.StringBuilder+append(char) java.lang.StringBuilder+append(String) org.h2.expression.aggregate.Window+getSQL() org.h2.expression.aggregate.Window+getSQL(),org.h2.expression.aggregate.AbstractAggregate+filterCondition org.h2.expression.aggregate.AbstractAggregate+filterCondition org.h2.expression.aggregate.AbstractAggregate+over org.h2.expression.aggregate.AbstractAggregate+over,333,9,4,,"protected StringBuilder appendTailConditions(StringBuilder builder) {
        if (filterCondition != null) {
            builder.append("" FILTER (WHERE "").append(filterCondition.getSQL()).append(')');
        }
        if (over != null) {
            builder.append(' ').append(over.getSQL());
        }
        return builder;
    }",False,False,"This method appends tail conditions to a StringBuilder object. It adds a filter condition and an ""over"" condition if they are not null, and then returns the modified StringBuilder object.",True,"The `appendTailConditions` method appends tail conditions to a `StringBuilder` object. It checks if there is a filter condition and appends it to the builder if it exists. It also appends an ""over"" condition if it is present."
