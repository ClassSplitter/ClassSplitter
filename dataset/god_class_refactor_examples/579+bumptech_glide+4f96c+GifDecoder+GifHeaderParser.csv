index,name,document,type,inner invocations,external invocations,calls,visits,length,lines,modifier,commit,full text,moved,removed,gpt text,gpt response,code summary
1,TAG,tag ,Field,,,,,67,1,26,,private static final String TAG = GifDecoder.class.getSimpleName();,False,False,,False,
2,STATUS_OK,status ok file read status no errors ,Field,,,,,90,4,25,"/** 
 * File read status: No errors.
 */
","/**
     * File read status: No errors.
     */
    public static final int STATUS_OK = 0;",False,False,"/** 
 * File read status: No errors.
 */
",False,"/** 
 * File read status: No errors.
 */
"
3,STATUS_FORMAT_ERROR,status format error file read status error decoding file may be partially decoded ,Field,,,,,136,4,25,"/** 
 * File read status: Error decoding file (may be partially decoded)
 */
","/**
     * File read status: Error decoding file (may be partially decoded)
     */
    public static final int STATUS_FORMAT_ERROR = 1;",False,False,"/** 
 * File read status: Error decoding file (may be partially decoded)
 */
",False,"/** 
 * File read status: Error decoding file (may be partially decoded)
 */
"
4,STATUS_OPEN_ERROR,status open error file read status unable to open source ,Field,,,,,110,4,25,"/** 
 * File read status: Unable to open source.
 */
","/**
     * File read status: Unable to open source.
     */
    public static final int STATUS_OPEN_ERROR = 2;",False,False,"/** 
 * File read status: Unable to open source.
 */
",False,"/** 
 * File read status: Unable to open source.
 */
"
5,MAX_STACK_SIZE,max stack size max decoder pixel stack size ,Field,,,,,101,4,28,"/** 
 * max decoder pixel stack size
 */
","/**
     * max decoder pixel stack size
     */
    protected static final int MAX_STACK_SIZE = 4096;",False,False,"/** 
 * max decoder pixel stack size
 */
",False,"/** 
 * max decoder pixel stack size
 */
"
6,DISPOSAL_UNSPECIFIED,disposal unspecified gif disposal method meaning take no action ,Field,,,,,116,4,26,"/** 
 * GIF Disposal Method meaning take no action
 */
","/**
     * GIF Disposal Method meaning take no action
     */
    private static final int DISPOSAL_UNSPECIFIED = 0;",False,False,"/** 
 * GIF Disposal Method meaning take no action
 */
",False,"/** 
 * GIF Disposal Method meaning take no action
 */
"
7,DISPOSAL_NONE,disposal none gif disposal method meaning leave canvas from previous frame ,Field,,,,,127,4,26,"/** 
 * GIF Disposal Method meaning leave canvas from previous frame
 */
","/**
     * GIF Disposal Method meaning leave canvas from previous frame
     */
    private static final int DISPOSAL_NONE = 1;",False,False,"/** 
 * GIF Disposal Method meaning leave canvas from previous frame
 */
",False,"/** 
 * GIF Disposal Method meaning leave canvas from previous frame
 */
"
8,DISPOSAL_BACKGROUND,disposal background gif disposal method meaning clear canvas to background color ,Field,,,,,133,4,26,"/** 
 * GIF Disposal Method meaning clear canvas to background color
 */
","/**
     * GIF Disposal Method meaning clear canvas to background color
     */
    private static final int DISPOSAL_BACKGROUND = 2;",False,False,"/** 
 * GIF Disposal Method meaning clear canvas to background color
 */
",False,"/** 
 * GIF Disposal Method meaning clear canvas to background color
 */
"
9,DISPOSAL_PREVIOUS,disposal previous gif disposal method meaning clear canvas to frame before last ,Field,,,,,132,4,26,"/** 
 * GIF Disposal Method meaning clear canvas to frame before last
 */
","/**
     * GIF Disposal Method meaning clear canvas to frame before last
     */
    private static final int DISPOSAL_PREVIOUS = 3;",False,False,"/** 
 * GIF Disposal Method meaning clear canvas to frame before last
 */
",False,"/** 
 * GIF Disposal Method meaning clear canvas to frame before last
 */
"
10,status,status global status code of gif data parsing ,Field,,,,,83,4,4,"/** 
 * Global status code of GIF data parsing
 */
","/**
     * Global status code of GIF data parsing
     */
    protected int status;",True,True,"/** 
 * Global status code of GIF data parsing
 */
",False,"/** 
 * Global status code of GIF data parsing
 */
"
11,width,width ,Field,,,,,20,1,4,,protected int width;,True,True,,False,
12,height,height ,Field,,,,,21,1,4,,protected int height;,True,True,,False,
13,gctFlag,gct flag ,Field,,,,,26,1,4,,protected boolean gctFlag;,True,True,,False,
14,gctSize,gct size ,Field,,,,,22,1,4,,protected int gctSize;,True,True,,False,
15,loopCount,loop count ,Field,,,,,28,1,4,,protected int loopCount = 1;,True,True,,False,
16,gct,gct ,Field,,,,,20,1,4,,protected int[] gct;,True,True,,False,
17,act,act ,Field,,,,,20,1,4,,protected int[] act;,False,False,,False,
18,bgIndex,bg index ,Field,,,,,22,1,4,,protected int bgIndex;,True,True,,False,
19,bgColor,bg color ,Field,,,,,22,1,4,,protected int bgColor;,True,True,,False,
20,pixelAspect,pixel aspect ,Field,,,,,26,1,4,,protected int pixelAspect;,True,True,,False,
21,lctFlag,lct flag ,Field,,,,,26,1,4,,protected boolean lctFlag;,True,True,,False,
22,lctSize,lct size ,Field,,,,,22,1,4,,protected int lctSize;,True,True,,False,
23,isTransparent,is transparent ,Field,,,,,30,1,2,,private boolean isTransparent;,True,True,,False,
24,rawData,raw data ,Field,,,,,29,1,4,,protected ByteBuffer rawData;,False,False,,False,
25,block,block ,Field,,,,,39,1,4,,protected byte[] block = new byte[256];,False,False,,False,
26,blockSize,block size ,Field,,,,,28,1,4,,protected int blockSize = 0;,True,True,,False,
27,prefix,prefix ,Field,,,,,25,1,4,,protected short[] prefix;,False,False,,False,
28,suffix,suffix ,Field,,,,,24,1,4,,protected byte[] suffix;,False,False,,False,
29,pixelStack,pixel stack ,Field,,,,,28,1,4,,protected byte[] pixelStack;,False,False,,False,
30,mainPixels,main pixels ,Field,,,,,28,1,4,,protected byte[] mainPixels;,False,False,,False,
31,mainScratch,main scratch ,Field,,,,,28,1,4,,protected int[] mainScratch;,False,False,,False,
32,frames,frames ,Field,,,,,37,1,4,,protected ArrayList<GifFrame> frames;,False,False,,False,
33,currentFrame,current frame ,Field,,,,,32,1,4,,protected GifFrame currentFrame;,True,True,,False,
34,framePointer,frame pointer ,Field,,,,,27,1,4,,protected int framePointer;,False,False,,False,
35,frameCount,frame count ,Field,,,,,25,1,4,,protected int frameCount;,True,True,,False,
36,bitmapPool,bitmap pool ,Field,,,,,30,1,2,,private BitmapPool bitmapPool;,False,False,,False,
37,currentImage,current image ,Field,,,,,28,1,2,,private Bitmap currentImage;,False,False,,False,
38,data,data ,Field,,,,,20,1,2,,private byte[] data;,False,False,,False,
39,GifFrame,gif frame inner model class housing metadata for each frame ,MemberClass,,,,com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+ix com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+iy com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+iw com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+ih com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+interlace com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+transparency com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+dispose com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+transIndex com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+delay com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+bufferFrameStart com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+lct,608,19,10,"/** 
 * Inner model class housing metadata for each frame
 */
","/**
     * Inner model class housing metadata for each frame
     */
    private static class GifFrame {
        public int ix, iy, iw, ih;
        /* Control Flags */
        public boolean interlace;
        public boolean transparency;
        /* Disposal Method */
        public int dispose;
        /* Transparency Index */
        public int transIndex;
        /* Delay, in ms, to next frame */
        public int delay;
        /* Index in the raw buffer where we need to start reading to decode */
        public int bufferFrameStart;
        /* Local Color Table */
        public int[] lct;
    }",False,True,"/** 
 * Inner model class housing metadata for each frame
 */
",False,"/** 
 * Inner model class housing metadata for each frame
 */
"
40,GifDecoder(BitmapPool),gif decoder bitmap pool ,Method,,,,com.bumptech.glide.load.resource.gif.GifDecoder+bitmapPool com.bumptech.glide.load.resource.gif.GifDecoder+bitmapPool,86,3,1,,"public GifDecoder(BitmapPool bitmapPool) {
        this.bitmapPool = bitmapPool;
    }",False,False,"This method serves to assign the value of the ""bitmapPool"" parameter to the ""bitmapPool"" instance variable of the class.",True,
41,getWidth(),get width ,Method,,,,com.bumptech.glide.load.resource.gif.GifDecoder+width,51,3,1,,"public int getWidth() {
        return width;
    }",False,False,"The function of the method is to retrieve and return the value of the variable ""width"".",False,"The code contains a method named ""getWidth"" that returns an integer value representing the width. It is assumed that there is a variable named ""width"" which holds the width value."
42,getHeight(),get height ,Method,,,,com.bumptech.glide.load.resource.gif.GifDecoder+height,53,3,1,,"public int getHeight() {
        return height;
    }",False,False,"The function of the method is to retrieve and return the value of the variable ""height"".",False,"The code contains a method named ""getHeight"" which returns the value of the variable ""height"". It is assumed that ""height"" is an integer variable."
43,isTransparent(),is transparent ,Method,,,,com.bumptech.glide.load.resource.gif.GifDecoder+isTransparent,68,3,1,,"public boolean isTransparent() {
        return isTransparent;
    }",False,False,This method serves to check whether an object is transparent or not. It returns a boolean value indicating the transparency status of the object.,False,"The code contains a method named ""isTransparent"" which returns a boolean value indicating whether an object is transparent or not. The method simply returns the value of a boolean variable named ""isTransparent""."
44,getGifByteSize(),get gif byte size ,Method,,,,com.bumptech.glide.load.resource.gif.GifDecoder+data,63,3,1,,"public int getGifByteSize() {
        return data.length;
    }",False,False,"The function of the given method is to return the length of the data array, which represents the byte size of a GIF.",False,"The code defines a method named ""getGifByteSize"" that returns the length of a byte array called ""data"". This method is likely used to retrieve the size of a GIF image in bytes."
45,getData(),get data ,Method,,,,com.bumptech.glide.load.resource.gif.GifDecoder+data,52,3,1,,"public byte[] getData() {
        return data;
    }",False,False,"The function of the method is to retrieve and return a byte array called ""data"".",False,The code contains a method named `getData()` that returns a byte array called `data`. This method is responsible for retrieving the data stored in the `data` array and returning it to the caller.
46,getDecodedFrameByteSize(),get decoded frame byte size ,Method,,,,com.bumptech.glide.load.resource.gif.GifDecoder+frameCount com.bumptech.glide.load.resource.gif.GifDecoder+width com.bumptech.glide.load.resource.gif.GifDecoder+height com.bumptech.glide.load.resource.gif.GifDecoder+isTransparent,154,4,1,,"public int getDecodedFrameByteSize() {
        // 4 == ARGB_8888, 2 == RGB_565
        return frameCount * width * height * (isTransparent ? 4 : 2);
    }",False,False,"This method calculates the size in bytes of a decoded frame based on the frame count, width, height, and whether the frame is transparent or not. The size is determined by multiplying these values together.",False,"The method `getDecodedFrameByteSize()` calculates and returns the byte size of a decoded frame based on the frame count, width, height, and transparency. It multiplies the frame count by the product of width, height, and either 4 or 2 (depending on transparency) to determine the byte size."
47,advance(),advance move the animation frame counter forward ,Method,,,,com.bumptech.glide.load.resource.gif.GifDecoder+framePointer com.bumptech.glide.load.resource.gif.GifDecoder+framePointer com.bumptech.glide.load.resource.gif.GifDecoder+frameCount,149,6,1,"/** 
 * Move the animation frame counter forward
 */
","/**
     * Move the animation frame counter forward
     */
    public void advance() {
        framePointer = (framePointer + 1) % frameCount;
    }",False,False,"The function of the ""advance"" method is to increment the animation frame counter by 1 and wrap it back to 0 if it reaches the maximum frame count.",False,"The given code defines a method called ""advance"" that increments the animation frame counter by one. It uses the modulo operator to ensure that the counter wraps around to zero when it reaches the maximum frame count."
48,getDelay(int),get delay n gets display duration for specified frame param n int index of frame return delay in milliseconds ,Method,,,java.util.ArrayList+get(int) java.util.ArrayList+get(int),com.bumptech.glide.load.resource.gif.GifDecoder+frameCount com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+delay com.bumptech.glide.load.resource.gif.GifDecoder+frames com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+delay,320,13,1,"/** 
 * Gets display duration for specified frame.
 * @param n int index of frame
 * @return delay in milliseconds
 */
","/**
     * Gets display duration for specified frame.
     *
     * @param n int index of frame
     * @return delay in milliseconds
     */
    public int getDelay(int n) {
        int delay = -1;
        if ((n >= 0) && (n < frameCount)) {
            delay = frames.get(n).delay;
        }
        return delay;
    }",False,False,"This method returns the delay in milliseconds for a specified frame. It takes an integer index as input and checks if it is within the valid range. If it is, it retrieves the delay value for that frame and returns it.",False,"This code defines a method called ""getDelay"" that takes an integer parameter representing the index of a frame. It returns the delay in milliseconds for the specified frame, or -1 if the index is out of range."
49,getNextDelay(),get next delay gets display duration for the upcoming frame ,Method,,,com.bumptech.glide.load.resource.gif.GifDecoder+getDelay(int) com.bumptech.glide.load.resource.gif.GifDecoder+getDelay(int),com.bumptech.glide.load.resource.gif.GifDecoder+frameCount com.bumptech.glide.load.resource.gif.GifDecoder+framePointer com.bumptech.glide.load.resource.gif.GifDecoder+framePointer,225,10,1,"/** 
 * Gets display duration for the upcoming frame
 */
","/**
     * Gets display duration for the upcoming frame
     */
    public int getNextDelay() {
        if (frameCount <= 0 || framePointer < 0) {
            return -1;
        }

        return getDelay(framePointer);
    }",False,False,"The function ""getNextDelay"" returns the display duration for the upcoming frame. It checks if the frame count or frame pointer is invalid, and returns -1 in that case. Otherwise, it calls the ""getDelay"" function with the frame pointer as an argument and returns the result.",False,"The `getNextDelay()` method returns the display duration for the upcoming frame. It checks if the frame count and frame pointer are valid, and if so, it calls the `getDelay()` method to retrieve the delay for the current frame. If the frame count or frame pointer is invalid, it returns -1."
50,getFrameCount(),get frame count gets the number of frames read from file return frame count ,Method,,,,com.bumptech.glide.load.resource.gif.GifDecoder+frameCount,160,8,1,"/** 
 * Gets the number of frames read from file.
 * @return frame count
 */
","/**
     * Gets the number of frames read from file.
     *
     * @return frame count
     */
    public int getFrameCount() {
        return frameCount;
    }",False,False,This method returns the number of frames read from a file.,False,"This code defines a method called ""getFrameCount"" that returns the number of frames read from a file. The method has no parameters and returns an integer value representing the frame count."
51,getCurrentFrameIndex(),get current frame index gets the current index of the animation frame or 1 if animation hasn t not yet started return frame index ,Method,,,,com.bumptech.glide.load.resource.gif.GifDecoder+framePointer,216,8,1,"/** 
 * Gets the current index of the animation frame, or -1 if animation hasn't not yet started
 * @return frame index
 */
","/**
     * Gets the current index of the animation frame, or -1 if animation hasn't not yet started
     *
     * @return frame index
     */
    public int getCurrentFrameIndex() {
        return framePointer;
    }",False,False,"This method returns the current index of the animation frame. If the animation has not yet started, it returns -1.",False,"This code defines a method called getCurrentFrameIndex() that returns the current index of the animation frame. If the animation has not yet started, it returns -1. The method provides a way to retrieve the current frame index for the animation."
52,getLoopCount(),get loop count gets the netscape iteration count if any a count of 0 means repeat indefinitiely return iteration count if one was specified else 1 ,Method,,,,com.bumptech.glide.load.resource.gif.GifDecoder+loopCount,236,8,1,"/** 
 * Gets the ""Netscape"" iteration count, if any. A count of 0 means repeat indefinitiely.
 * @return iteration count if one was specified, else 1.
 */
","/**
     * Gets the ""Netscape"" iteration count, if any. A count of 0 means repeat indefinitiely.
     *
     * @return iteration count if one was specified, else 1.
     */
    public int getLoopCount() {
        return loopCount;
    }",False,False,"This method returns the ""Netscape"" iteration count, which indicates how many times an animation should repeat. If no count is specified, it returns 1.",False,"This code defines a method called ""getLoopCount"" that returns the iteration count for a ""Netscape"" operation. If a count was specified, it is returned; otherwise, the default value of 1 is returned."
53,getNextFrame(),get next frame get the next frame in the animation sequence return bitmap representation of frame ,Method,,,"java.util.ArrayList+get(int) java.util.ArrayList+get(int) com.bumptech.glide.load.resource.gif.GifDecoder+setPixels(int) com.bumptech.glide.load.resource.gif.GifDecoder+setPixels(int) com.bumptech.glide.load.resource.bitmap.BitmapResource+BitmapResource(Bitmap,BitmapPool)",com.bumptech.glide.load.resource.gif.GifDecoder+frameCount com.bumptech.glide.load.resource.gif.GifDecoder+framePointer com.bumptech.glide.load.resource.gif.GifDecoder+frames com.bumptech.glide.load.resource.gif.GifDecoder+framePointer com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+lct com.bumptech.glide.load.resource.gif.GifDecoder+act com.bumptech.glide.load.resource.gif.GifDecoder+gct com.bumptech.glide.load.resource.gif.GifDecoder+act com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+lct com.bumptech.glide.load.resource.gif.GifDecoder+bgIndex com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+transIndex com.bumptech.glide.load.resource.gif.GifDecoder+bgColor com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+transparency com.bumptech.glide.load.resource.gif.GifDecoder+act com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+transIndex com.bumptech.glide.load.resource.gif.GifDecoder+act com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+transIndex com.bumptech.glide.load.resource.gif.GifDecoder+act com.bumptech.glide.load.resource.gif.GifDecoder+TAG com.bumptech.glide.load.resource.gif.GifDecoder+status com.bumptech.glide.load.resource.gif.GifDecoder+STATUS_FORMAT_ERROR com.bumptech.glide.load.resource.gif.GifDecoder+framePointer com.bumptech.glide.load.resource.gif.GifDecoder+currentImage com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+transparency com.bumptech.glide.load.resource.gif.GifDecoder+act com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+transIndex com.bumptech.glide.load.resource.gif.GifDecoder+bitmapPool,1295,45,1,"/** 
 * Get the next frame in the animation sequence.
 * @return Bitmap representation of frame
 */
","/**
     * Get the next frame in the animation sequence.
     *
     * @return Bitmap representation of frame
     */
    public Resource<Bitmap> getNextFrame() {
        if (frameCount <= 0 || framePointer < 0 ) {
            return null;
        }

        long startTime = SystemClock.currentThreadTimeMillis();

        GifFrame frame = frames.get(framePointer);

        //Set the appropriate color table
        if (frame.lct == null) {
            act = gct;
        } else {
            act = frame.lct;
            if (bgIndex == frame.transIndex) {
                bgColor = 0;
            }
        }

        int save = 0;
        if (frame.transparency) {
            save = act[frame.transIndex];
            act[frame.transIndex] = 0; // set transparent color if specified
        }
        if (act == null) {
            Log.w(TAG, ""No Valid Color Table"");
            status = STATUS_FORMAT_ERROR; // no color table defined
            return null;
        }

        Bitmap result = setPixels(framePointer); // transfer pixel data to image
        currentImage = result;

        // Reset the transparent pixel in the color table
        if (frame.transparency) {
            act[frame.transIndex] = save;
        }

        return new BitmapResource(result, bitmapPool);
    }",False,False,This method serves to get the next frame in an animation sequence. It returns a Bitmap representation of the frame.,False,"This code is a method that retrieves the next frame in an animation sequence. It sets the appropriate color table, transfers pixel data to an image, and returns a Bitmap representation of the frame."
54,"read(InputStream,int)",read is content length reads gif image from stream param is containing gif file return read status code 0 no errors ,Method,,,"java.io.ByteArrayOutputStream+ByteArrayOutputStream(int) java.io.InputStream+read(byte[],int,int) java.io.InputStream+read(byte[],int,int) java.io.ByteArrayOutputStream+write(byte[],int,int) java.io.ByteArrayOutputStream+write(byte[],int,int) java.io.OutputStream+flush() java.io.OutputStream+flush() com.bumptech.glide.load.resource.gif.GifDecoder+read(byte[]) com.bumptech.glide.load.resource.gif.GifDecoder+read(byte[]) java.io.ByteArrayOutputStream+toByteArray() java.io.ByteArrayOutputStream+toByteArray() java.io.InputStream+close() java.io.InputStream+close()",com.bumptech.glide.load.resource.gif.GifDecoder+TAG com.bumptech.glide.load.resource.gif.GifDecoder+status com.bumptech.glide.load.resource.gif.GifDecoder+STATUS_OPEN_ERROR com.bumptech.glide.load.resource.gif.GifDecoder+TAG com.bumptech.glide.load.resource.gif.GifDecoder+status,1046,34,1,"/** 
 * Reads GIF image from stream
 * @param is containing GIF file.
 * @return read status code (0 = no errors)
 */
","/**
     * Reads GIF image from stream
     *
     * @param is containing GIF file.
     * @return read status code (0 = no errors)
     */
    public int read(InputStream is, int contentLength) {
        if (is != null) {
            try {
                int capacity = (contentLength > 0) ? (contentLength + 4096) : 16384;
                ByteArrayOutputStream buffer = new ByteArrayOutputStream(capacity);
                int nRead;
                byte[] data = new byte[16384];
                while ((nRead = is.read(data, 0, data.length)) != -1) {
                    buffer.write(data, 0, nRead);
                }
                buffer.flush();

                read(buffer.toByteArray());
            } catch (IOException e) {
                Log.w(TAG, ""Error reading data from stream"", e);
            }
        } else {
            status = STATUS_OPEN_ERROR;
        }

        try {
            is.close();
        } catch (Exception e) {
            Log.w(TAG, ""Error closing stream"", e);
        }

        return status;
    }",False,False,"This method reads a GIF image from an input stream, stores it in a buffer, and then calls another method to process the image. It returns a status code indicating whether the read operation was successful or not.",True,"This code reads a GIF image from an input stream, storing the data in a buffer. It then calls another method to process the data and returns a status code indicating the success of the read operation."
55,read(byte[]),read data reads gif image from byte array param data containing gif file return read status code 0 no errors ,Method,,,com.bumptech.glide.load.resource.gif.GifDecoder+init() com.bumptech.glide.load.resource.gif.GifDecoder+init() java.nio.ByteBuffer+wrap(byte[]) java.nio.ByteBuffer+wrap(byte[]) java.nio.ByteBuffer+rewind() java.nio.ByteBuffer+rewind() java.nio.ByteBuffer+order(ByteOrder) java.nio.ByteBuffer+order(ByteOrder) com.bumptech.glide.load.resource.gif.GifDecoder+readHeader() com.bumptech.glide.load.resource.gif.GifDecoder+readHeader() com.bumptech.glide.load.resource.gif.GifDecoder+err() com.bumptech.glide.load.resource.gif.GifDecoder+err() com.bumptech.glide.load.resource.gif.GifDecoder+readContents() com.bumptech.glide.load.resource.gif.GifDecoder+readContents(),com.bumptech.glide.load.resource.gif.GifDecoder+data com.bumptech.glide.load.resource.gif.GifDecoder+data com.bumptech.glide.load.resource.gif.GifDecoder+rawData com.bumptech.glide.load.resource.gif.GifDecoder+rawData com.bumptech.glide.load.resource.gif.GifDecoder+rawData java.nio.ByteOrder+LITTLE_ENDIAN com.bumptech.glide.load.resource.gif.GifDecoder+frameCount com.bumptech.glide.load.resource.gif.GifDecoder+status com.bumptech.glide.load.resource.gif.GifDecoder+STATUS_FORMAT_ERROR com.bumptech.glide.load.resource.gif.GifDecoder+status com.bumptech.glide.load.resource.gif.GifDecoder+STATUS_OPEN_ERROR com.bumptech.glide.load.resource.gif.GifDecoder+status,724,28,1,"/** 
 * Reads GIF image from byte array
 * @param data containing GIF file.
 * @return read status code (0 = no errors)
 */
","/**
     * Reads GIF image from byte array
     *
     * @param data containing GIF file.
     * @return read status code (0 = no errors)
     */
    public int read(byte[] data) {
        this.data = data;
        init();
        if (data != null) {
            //Initialize the raw data buffer
            rawData = ByteBuffer.wrap(data);
            rawData.rewind();
            rawData.order(ByteOrder.LITTLE_ENDIAN);

            readHeader();
            if (!err()) {
                readContents();
                if (frameCount < 0) {
                    status = STATUS_FORMAT_ERROR;
                }
            }
        } else {
            status = STATUS_OPEN_ERROR;
        }

        return status;
    }",False,False,This method reads a GIF image from a byte array and returns a status code indicating if there were any errors during the reading process.,True,"This code reads a GIF image from a byte array. It initializes the raw data buffer, reads the header and contents of the GIF, and returns a status code indicating any errors encountered during the process."
56,setPixels(int),set pixels frame index creates new frame image from current data and previous frames as specified by their disposition codes ,Method,,,"java.util.ArrayList+get(int) java.util.ArrayList+get(int) java.util.ArrayList+get(int) java.util.ArrayList+get(int) java.lang.System+currentTimeMillis() java.lang.System+currentTimeMillis() java.lang.System+currentTimeMillis() java.lang.System+currentTimeMillis() com.bumptech.glide.load.resource.gif.GifDecoder+decodeBitmapData(GifFrame,byte[]) com.bumptech.glide.load.resource.gif.GifDecoder+decodeBitmapData(GifFrame,byte[]) java.lang.System+currentTimeMillis() java.lang.System+currentTimeMillis() java.lang.System+currentTimeMillis() java.lang.System+currentTimeMillis() com.bumptech.glide.load.resource.gif.GifDecoder+getNextBitmap() com.bumptech.glide.load.resource.gif.GifDecoder+getNextBitmap()",com.bumptech.glide.load.resource.gif.GifDecoder+frames com.bumptech.glide.load.resource.gif.GifDecoder+frames com.bumptech.glide.load.resource.gif.GifDecoder+mainScratch com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+dispose com.bumptech.glide.load.resource.gif.GifDecoder+DISPOSAL_UNSPECIFIED com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+dispose com.bumptech.glide.load.resource.gif.GifDecoder+DISPOSAL_NONE com.bumptech.glide.load.resource.gif.GifDecoder+currentImage com.bumptech.glide.load.resource.gif.GifDecoder+currentImage com.bumptech.glide.load.resource.gif.GifDecoder+width com.bumptech.glide.load.resource.gif.GifDecoder+width com.bumptech.glide.load.resource.gif.GifDecoder+height com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+dispose com.bumptech.glide.load.resource.gif.GifDecoder+DISPOSAL_BACKGROUND com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+transparency com.bumptech.glide.load.resource.gif.GifDecoder+bgColor com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+ih com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+iy com.bumptech.glide.load.resource.gif.GifDecoder+width com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+ix com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+iw com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+transparency com.bumptech.glide.load.resource.gif.GifDecoder+bgColor com.bumptech.glide.load.resource.gif.GifDecoder+mainPixels com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+ih com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+interlace com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+ih com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+iy com.bumptech.glide.load.resource.gif.GifDecoder+height com.bumptech.glide.load.resource.gif.GifDecoder+width com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+ix com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+iw com.bumptech.glide.load.resource.gif.GifDecoder+width com.bumptech.glide.load.resource.gif.GifDecoder+width com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+iw com.bumptech.glide.load.resource.gif.GifDecoder+mainPixels com.bumptech.glide.load.resource.gif.GifDecoder+act com.bumptech.glide.load.resource.gif.GifDecoder+width com.bumptech.glide.load.resource.gif.GifDecoder+width com.bumptech.glide.load.resource.gif.GifDecoder+height,4008,105,4,"/** 
 * Creates new frame image from current data (and previous frames as specified by their disposition codes).
 */
","/**
     * Creates new frame image from current data (and previous frames as specified by their disposition codes).
     */
    protected Bitmap setPixels(int frameIndex) {
        GifFrame currentFrame = frames.get(frameIndex);
        GifFrame previousFrame = null;
        int previousIndex = frameIndex - 1;
        if (previousIndex >= 0) {
            previousFrame = frames.get(previousIndex);
        }

        // final location of blended pixels
        final int[] dest = mainScratch;

        // fill in starting image contents based on last image's dispose code
        long disposeStartTime = System.currentTimeMillis();
        if (previousFrame != null && previousFrame.dispose > DISPOSAL_UNSPECIFIED) {
            if (previousFrame.dispose == DISPOSAL_NONE && currentImage != null) {
                // Start with the current image
                currentImage.getPixels(dest, 0, width, 0, 0, width, height);
            }
            if (previousFrame.dispose == DISPOSAL_BACKGROUND) {
                // Start with a canvas filled with the background color
                int c = 0;
                if (!currentFrame.transparency) {
                    c = bgColor;
                }
                for (int i = 0; i < previousFrame.ih; i++) {
                    int n1 = (previousFrame.iy + i) * width + previousFrame.ix;
                    int n2 = n1 + previousFrame.iw;
                    for (int k = n1; k < n2; k++) {
                        dest[k] = c;
                    }
                }
            }
        } else {
            int c = 0;
            if (!currentFrame.transparency) {
                c = bgColor;
            }
            for (int i = 0; i < dest.length; i++) {
                dest[i] = c;
            }
        }

        //Decode pixels for this frame  into the global pixels[] scratch
        long start = System.currentTimeMillis();
        decodeBitmapData(currentFrame, mainPixels); // decode pixel data

        // copy each source line to the appropriate place in the destination
        long startTime = System.currentTimeMillis();
        int pass = 1;
        int inc = 8;
        int iline = 0;
        for (int i = 0; i < currentFrame.ih; i++) {
            int line = i;
            if (currentFrame.interlace) {
                if (iline >= currentFrame.ih) {
                    pass++;
                    switch (pass) {
                        case 2:
                            iline = 4;
                            break;
                        case 3:
                            iline = 2;
                            inc = 4;
                            break;
                        case 4:
                            iline = 1;
                            inc = 2;
                            break;
                        default:
                            break;
                    }
                }
                line = iline;
                iline += inc;
            }
            line += currentFrame.iy;
            if (line < height) {
                int k = line * width;
                int dx = k + currentFrame.ix; // start of line in dest
                int dlim = dx + currentFrame.iw; // end of dest line
                if ((k + width) < dlim) {
                    dlim = k + width; // past dest edge
                }
                int sx = i * currentFrame.iw; // start of line in source
                while (dx < dlim) {
                    // map color and insert in destination
                    int index = ((int) mainPixels[sx++]) & 0xff;
                    int c = act[index];
                    if (c != 0) {
                        dest[dx] = c;
                    }
                    dx++;
                }
            }
        }

        //Set pixels for current image
        long startSetPixelBitmap = System.currentTimeMillis();
        Bitmap result = getNextBitmap();
        result.setPixels(dest, 0, width, 0, 0, width, height);
        return result;
    }",False,False,"This method creates a new frame image by blending the current frame with previous frames, based on their disposition codes. It fills in the starting image contents and decodes the pixel data for the current frame. It then copies each source line to the appropriate place in the destination image. Finally, it sets the pixels for the current image and returns it.",False,"This method creates a new frame image by blending the current frame with previous frames based on their disposition codes. It fills in the starting image contents based on the last image's dispose code, decodes the pixel data for the current frame, and copies each source line to the appropriate place in the destination. Finally, it sets the pixels for the current image and returns the resulting bitmap."
57,"decodeBitmapData(GifFrame,byte[])",decode bitmap data frame dst pixels decodes lzw image data into pixel array adapted from john cristy s bitmap magick ,Method,,,java.nio.ByteBuffer+position(int) java.nio.ByteBuffer+position(int) com.bumptech.glide.load.resource.gif.GifDecoder+read() com.bumptech.glide.load.resource.gif.GifDecoder+read() java.lang.System+currentTimeMillis() java.lang.System+currentTimeMillis() java.lang.System+currentTimeMillis() java.lang.System+currentTimeMillis() com.bumptech.glide.load.resource.gif.GifDecoder+readBlock() com.bumptech.glide.load.resource.gif.GifDecoder+readBlock() java.lang.System+currentTimeMillis() java.lang.System+currentTimeMillis(),com.bumptech.glide.load.resource.gif.GifDecoder+rawData com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+bufferFrameStart com.bumptech.glide.load.resource.gif.GifDecoder+width com.bumptech.glide.load.resource.gif.GifDecoder+height com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+iw com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+ih com.bumptech.glide.load.resource.gif.GifDecoder+prefix com.bumptech.glide.load.resource.gif.GifDecoder+prefix com.bumptech.glide.load.resource.gif.GifDecoder+MAX_STACK_SIZE com.bumptech.glide.load.resource.gif.GifDecoder+suffix com.bumptech.glide.load.resource.gif.GifDecoder+suffix com.bumptech.glide.load.resource.gif.GifDecoder+MAX_STACK_SIZE com.bumptech.glide.load.resource.gif.GifDecoder+pixelStack com.bumptech.glide.load.resource.gif.GifDecoder+pixelStack com.bumptech.glide.load.resource.gif.GifDecoder+MAX_STACK_SIZE com.bumptech.glide.load.resource.gif.GifDecoder+prefix com.bumptech.glide.load.resource.gif.GifDecoder+suffix com.bumptech.glide.load.resource.gif.GifDecoder+block com.bumptech.glide.load.resource.gif.GifDecoder+pixelStack com.bumptech.glide.load.resource.gif.GifDecoder+suffix com.bumptech.glide.load.resource.gif.GifDecoder+pixelStack com.bumptech.glide.load.resource.gif.GifDecoder+pixelStack com.bumptech.glide.load.resource.gif.GifDecoder+suffix com.bumptech.glide.load.resource.gif.GifDecoder+prefix com.bumptech.glide.load.resource.gif.GifDecoder+suffix com.bumptech.glide.load.resource.gif.GifDecoder+MAX_STACK_SIZE com.bumptech.glide.load.resource.gif.GifDecoder+pixelStack com.bumptech.glide.load.resource.gif.GifDecoder+prefix com.bumptech.glide.load.resource.gif.GifDecoder+suffix com.bumptech.glide.load.resource.gif.GifDecoder+MAX_STACK_SIZE com.bumptech.glide.load.resource.gif.GifDecoder+pixelStack,4418,120,4,"/** 
 * Decodes LZW image data into pixel array. Adapted from John Cristy's BitmapMagick.
 */
","/**
     * Decodes LZW image data into pixel array. Adapted from John Cristy's BitmapMagick.
     */
    protected void decodeBitmapData(GifFrame frame, byte[] dstPixels) {
        if (frame != null) {
            //Jump to the frame start position
            rawData.position(frame.bufferFrameStart);
        }

        int nullCode = -1;
        int npix = (frame == null) ? width * height : frame.iw * frame.ih;
        int available, clear, code_mask, code_size, end_of_information, in_code, old_code, bits, code, count, i, datum, data_size, first, top, bi, pi;

        if (dstPixels == null || dstPixels.length < npix) {
            dstPixels = new byte[npix]; // allocate new pixel array
        }
        if (prefix == null) {
            prefix = new short[MAX_STACK_SIZE];
        }
        if (suffix == null) {
            suffix = new byte[MAX_STACK_SIZE];
        }
        if (pixelStack == null) {
            pixelStack = new byte[MAX_STACK_SIZE + 1];
        }

        // Initialize GIF data stream decoder.
        data_size = read();
        clear = 1 << data_size;
        end_of_information = clear + 1;
        available = clear + 2;
        old_code = nullCode;
        code_size = data_size + 1;
        code_mask = (1 << code_size) - 1;
        long start = System.currentTimeMillis();
        for (code = 0; code < clear; code++) {
            prefix[code] = 0; // XXX ArrayIndexOutOfBoundsException
            suffix[code] = (byte) code;
        }

        start = System.currentTimeMillis();
        // Decode GIF pixel stream.
        datum = bits = count = first = top = pi = bi = 0;
        int iterations = 0;
        for (i = 0; i < npix; ) {
            iterations++;
            if (top == 0) {
                if (bits < code_size) {
                    // Load bytes until there are enough bits for a code.
                    if (count == 0) {
                        // Read a new data block.
                        count = readBlock();
                        if (count <= 0) {
                            break;
                        }
                        bi = 0;
                    }
                    datum += (((int) block[bi]) & 0xff) << bits;
                    bits += 8;
                    bi++;
                    count--;
                    continue;
                }
                // Get the next code.
                code = datum & code_mask;
                datum >>= code_size;
                bits -= code_size;
                // Interpret the code
                if ((code > available) || (code == end_of_information)) {
                    break;
                }
                if (code == clear) {
                    // Reset decoder.
                    code_size = data_size + 1;
                    code_mask = (1 << code_size) - 1;
                    available = clear + 2;
                    old_code = nullCode;
                    continue;
                }
                if (old_code == nullCode) {
                    pixelStack[top++] = suffix[code];
                    old_code = code;
                    first = code;
                    continue;
                }
                in_code = code;
                if (code == available) {
                    pixelStack[top++] = (byte) first;
                    code = old_code;
                }
                while (code > clear) {
                    pixelStack[top++] = suffix[code];
                    code = prefix[code];
                }
                first = ((int) suffix[code]) & 0xff;
                // Add a new string to the string table,
                if (available >= MAX_STACK_SIZE) {
                    break;
                }
                pixelStack[top++] = (byte) first;
                prefix[available] = (short) old_code;
                suffix[available] = (byte) first;
                available++;
                if (((available & code_mask) == 0) && (available < MAX_STACK_SIZE)) {
                    code_size++;
                    code_mask += available;
                }
                old_code = in_code;
            }
            // Pop a pixel off the pixel stack.
            top--;
            dstPixels[pi++] = pixelStack[top];
            i++;
        }
        start = System.currentTimeMillis();

        for (i = pi; i < npix; i++) {
            dstPixels[i] = 0; // clear missing pixels
        }
    }",False,False,"The function decodes LZW image data into a pixel array. It initializes the decoder, reads the data block, interprets the codes, and adds new strings to the string table. It then pops pixels off the pixel stack and stores them in the destination pixel array. Finally, it clears any missing pixels in the array.",False,"The `decodeBitmapData` method decodes LZW image data into a pixel array. It reads the GIF data stream, interprets the codes, and adds pixels to the pixel array. If the pixel array is not large enough, it allocates a new one."
58,err(),err returns true if an error was encountered during reading decoding ,Method,,,,com.bumptech.glide.load.resource.gif.GifDecoder+status com.bumptech.glide.load.resource.gif.GifDecoder+STATUS_OK,155,6,4,"/** 
 * Returns true if an error was encountered during reading/decoding
 */
","/**
     * Returns true if an error was encountered during reading/decoding
     */
    protected boolean err() {
        return status != STATUS_OK;
    }",True,True,"The function ""err()"" checks if an error occurred during reading or decoding by comparing the status variable to STATUS_OK and returns true if an error was encountered.",False,"The code defines a protected method named ""err()"" that returns a boolean value. It checks if an error was encountered during reading or decoding by evaluating the ""status"" variable, and returns true if an error occurred, otherwise false."
59,init(),init initializes or re initializes reader ,Method,,,java.util.ArrayList+ArrayList(),com.bumptech.glide.load.resource.gif.GifDecoder+status com.bumptech.glide.load.resource.gif.GifDecoder+STATUS_OK com.bumptech.glide.load.resource.gif.GifDecoder+frameCount com.bumptech.glide.load.resource.gif.GifDecoder+framePointer com.bumptech.glide.load.resource.gif.GifDecoder+frames com.bumptech.glide.load.resource.gif.GifDecoder+gct,232,10,4,"/** 
 * Initializes or re-initializes reader
 */
","/**
     * Initializes or re-initializes reader
     */
    protected void init() {
        status = STATUS_OK;
        frameCount = 0;
        framePointer = -1;
        frames = new ArrayList<GifFrame>();
        gct = null;
    }",False,True,"This method initializes or resets the reader by setting the status, frame count, frame pointer, frames, and gct variables to their initial values.",False,"The `init()` method is used to initialize or re-initialize a reader. It sets the status to ""OK"", resets the frame count and pointer, creates a new ArrayList for storing GifFrames, and sets the global color table (gct) to null."
60,read(),read reads a single byte from the input stream ,Method,,,java.nio.ByteBuffer+get() java.nio.ByteBuffer+get(),com.bumptech.glide.load.resource.gif.GifDecoder+rawData com.bumptech.glide.load.resource.gif.GifDecoder+status com.bumptech.glide.load.resource.gif.GifDecoder+STATUS_FORMAT_ERROR,287,12,4,"/** 
 * Reads a single byte from the input stream.
 */
","/**
     * Reads a single byte from the input stream.
     */
    protected int read() {
        int curByte = 0;
        try {
            curByte = (rawData.get() & 0xFF);
        } catch (Exception e) {
            status = STATUS_FORMAT_ERROR;
        }
        return curByte;
    }",False,False,"This method reads a single byte from an input stream and returns it as an integer. If an exception occurs, it sets the status to indicate a format error.",True,"The given code defines a protected method called ""read"" that reads a single byte from an input stream. It retrieves the byte value from the ""rawData"" object and returns it as an integer. If any exception occurs during the process, the ""status"" variable is set to indicate a format error."
61,readBlock(),read block reads next variable length block from input return number of bytes stored in buffer ,Method,,,"com.bumptech.glide.load.resource.gif.GifDecoder+read() com.bumptech.glide.load.resource.gif.GifDecoder+read() java.nio.ByteBuffer+get(byte[],int,int) java.nio.ByteBuffer+get(byte[],int,int)",com.bumptech.glide.load.resource.gif.GifDecoder+blockSize com.bumptech.glide.load.resource.gif.GifDecoder+blockSize com.bumptech.glide.load.resource.gif.GifDecoder+blockSize com.bumptech.glide.load.resource.gif.GifDecoder+blockSize com.bumptech.glide.load.resource.gif.GifDecoder+rawData com.bumptech.glide.load.resource.gif.GifDecoder+block com.bumptech.glide.load.resource.gif.GifDecoder+TAG com.bumptech.glide.load.resource.gif.GifDecoder+status com.bumptech.glide.load.resource.gif.GifDecoder+STATUS_FORMAT_ERROR,641,24,4,"/** 
 * Reads next variable length block from input.
 * @return number of bytes stored in ""buffer""
 */
","/**
     * Reads next variable length block from input.
     *
     * @return number of bytes stored in ""buffer""
     */
    protected int readBlock() {
        blockSize = read();
        int n = 0;
        if (blockSize > 0) {
            try {
                int count;
                while (n < blockSize) {
                    count = blockSize - n;
                    rawData.get(block, n, count);

                    n += count;
                }
            } catch (Exception e) {
                Log.w(TAG, ""Error Reading Block"", e);
                status = STATUS_FORMAT_ERROR;
            }
        }
        return n;
    }",False,False,"The function of the method is to read the next variable length block from the input and return the number of bytes stored in the ""buffer"".",False,"The `readBlock()` method reads a variable length block from an input source. It returns the number of bytes stored in the buffer. If an error occurs during the reading process, it logs a warning and sets the status to indicate a format error."
62,readColorTable(int),read color table ncolors reads color table as 256 rgb integer values param ncolors int number of colors to read return int array containing 256 colors packed argb with full alpha ,Method,,,java.nio.ByteBuffer+get(byte[]) java.nio.ByteBuffer+get(byte[]),com.bumptech.glide.load.resource.gif.GifDecoder+rawData com.bumptech.glide.load.resource.gif.GifDecoder+TAG com.bumptech.glide.load.resource.gif.GifDecoder+status com.bumptech.glide.load.resource.gif.GifDecoder+STATUS_FORMAT_ERROR,945,30,4,"/** 
 * Reads color table as 256 RGB integer values
 * @param ncolors int number of colors to read
 * @return int array containing 256 colors (packed ARGB with full alpha)
 */
","/**
     * Reads color table as 256 RGB integer values
     *
     * @param ncolors int number of colors to read
     * @return int array containing 256 colors (packed ARGB with full alpha)
     */
    protected int[] readColorTable(int ncolors) {
        int nbytes = 3 * ncolors;
        int[] tab = null;
        byte[] c = new byte[nbytes];

        try {
            rawData.get(c);

            tab = new int[256]; // max size to avoid bounds checks
            int i = 0;
            int j = 0;
            while (i < ncolors) {
                int r = ((int) c[j++]) & 0xff;
                int g = ((int) c[j++]) & 0xff;
                int b = ((int) c[j++]) & 0xff;
                tab[i++] = 0xff000000 | (r << 16) | (g << 8) | b;
            }
        } catch (BufferUnderflowException e) {
            Log.w(TAG, ""Format Error Reading Color Table"", e);
            status = STATUS_FORMAT_ERROR;
        }

        return tab;
    }",True,True,This method reads a color table as 256 RGB integer values and returns an int array containing the colors.,False,"This code is a protected method that reads a color table consisting of 256 RGB integer values. It takes the number of colors to read as a parameter and returns an int array containing the colors. If there is a format error while reading the color table, it logs a warning and sets the status to indicate the error."
63,readContents(),read contents main file parser reads gif content blocks ,Method,,,com.bumptech.glide.load.resource.gif.GifDecoder+err() com.bumptech.glide.load.resource.gif.GifDecoder+err() com.bumptech.glide.load.resource.gif.GifDecoder+read() com.bumptech.glide.load.resource.gif.GifDecoder+read() com.bumptech.glide.load.resource.gif.GifDecoder+readBitmap() com.bumptech.glide.load.resource.gif.GifDecoder+readBitmap() com.bumptech.glide.load.resource.gif.GifDecoder+read() com.bumptech.glide.load.resource.gif.GifDecoder+read() com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+GifFrame() com.bumptech.glide.load.resource.gif.GifDecoder+readGraphicControlExt() com.bumptech.glide.load.resource.gif.GifDecoder+readGraphicControlExt() com.bumptech.glide.load.resource.gif.GifDecoder+readBlock() com.bumptech.glide.load.resource.gif.GifDecoder+readBlock() java.lang.String+equals(Object) java.lang.String+equals(Object) com.bumptech.glide.load.resource.gif.GifDecoder+readNetscapeExt() com.bumptech.glide.load.resource.gif.GifDecoder+readNetscapeExt() com.bumptech.glide.load.resource.gif.GifDecoder+skip() com.bumptech.glide.load.resource.gif.GifDecoder+skip() com.bumptech.glide.load.resource.gif.GifDecoder+skip() com.bumptech.glide.load.resource.gif.GifDecoder+skip() com.bumptech.glide.load.resource.gif.GifDecoder+skip() com.bumptech.glide.load.resource.gif.GifDecoder+skip() com.bumptech.glide.load.resource.gif.GifDecoder+skip() com.bumptech.glide.load.resource.gif.GifDecoder+skip(),com.bumptech.glide.load.resource.gif.GifDecoder+currentFrame com.bumptech.glide.load.resource.gif.GifDecoder+block com.bumptech.glide.load.resource.gif.GifDecoder+status com.bumptech.glide.load.resource.gif.GifDecoder+STATUS_FORMAT_ERROR,1988,51,4,"/** 
 * Main file parser. Reads GIF content blocks.
 */
","/**
     * Main file parser. Reads GIF content blocks.
     */
    protected void readContents() {
        // read GIF file content blocks
        boolean done = false;
        while (!(done || err())) {
            int code = read();
            switch (code) {
                case 0x2C: // image separator
                    readBitmap();
                    break;
                case 0x21: // extension
                    code = read();
                    switch (code) {
                        case 0xf9: // graphics control extension
                            //Start a new frame
                            currentFrame = new GifFrame();
                            readGraphicControlExt();
                            break;
                        case 0xff: // application extension
                            readBlock();
                            String app = """";
                            for (int i = 0; i < 11; i++) {
                                app += (char) block[i];
                            }
                            if (app.equals(""NETSCAPE2.0"")) {
                                readNetscapeExt();
                            } else {
                                skip(); // don't care
                            }
                            break;
                        case 0xfe:// comment extension
                            skip();
                            break;
                        case 0x01:// plain text extension
                            skip();
                            break;
                        default: // uninteresting extension
                            skip();
                    }
                    break;
                case 0x3b: // terminator
                    done = true;
                    break;
                case 0x00: // bad byte, but keep going and see what happens break;
                default:
                    status = STATUS_FORMAT_ERROR;
            }
        }
    }",True,True,"The function of the method ""readContents"" is to parse the content blocks of a GIF file. It reads the blocks one by one and performs different actions based on the code of each block, such as reading a bitmap, reading a graphic control extension, reading a Netscape extension, skipping uninteresting extensions, or marking the end of the file.",True,"The `readContents()` method is responsible for parsing the content blocks of a GIF file. It reads the blocks one by one and performs different actions based on the code of each block, such as reading a bitmap, handling graphics control extensions, or skipping uninteresting extensions."
64,readHeader(),read header reads gif file header information ,Method,,,com.bumptech.glide.load.resource.gif.GifDecoder+read() com.bumptech.glide.load.resource.gif.GifDecoder+read() java.lang.String+startsWith(String) java.lang.String+startsWith(String) com.bumptech.glide.load.resource.gif.GifDecoder+readLSD() com.bumptech.glide.load.resource.gif.GifDecoder+readLSD() com.bumptech.glide.load.resource.gif.GifDecoder+err() com.bumptech.glide.load.resource.gif.GifDecoder+err() com.bumptech.glide.load.resource.gif.GifDecoder+readColorTable(int) com.bumptech.glide.load.resource.gif.GifDecoder+readColorTable(int),com.bumptech.glide.load.resource.gif.GifDecoder+status com.bumptech.glide.load.resource.gif.GifDecoder+STATUS_FORMAT_ERROR com.bumptech.glide.load.resource.gif.GifDecoder+gctFlag com.bumptech.glide.load.resource.gif.GifDecoder+gct com.bumptech.glide.load.resource.gif.GifDecoder+gctSize com.bumptech.glide.load.resource.gif.GifDecoder+bgColor com.bumptech.glide.load.resource.gif.GifDecoder+gct com.bumptech.glide.load.resource.gif.GifDecoder+bgIndex,448,18,4,"/** 
 * Reads GIF file header information.
 */
","/**
     * Reads GIF file header information.
     */
    protected void readHeader() {
        String id = """";
        for (int i = 0; i < 6; i++) {
            id += (char) read();
        }
        if (!id.startsWith(""GIF"")) {
            status = STATUS_FORMAT_ERROR;
            return;
        }
        readLSD();
        if (gctFlag && !err()) {
            gct = readColorTable(gctSize);
            bgColor = gct[bgIndex];
        }
    }",True,True,"The function of the method is to read the header information of a GIF file. It reads the first 6 characters of the file, checks if it starts with ""GIF"", and then proceeds to read the logical screen descriptor and the global color table if present.",True,"The `readHeader()` method reads the header information of a GIF file. It checks if the file starts with ""GIF"" and sets the status to `STATUS_FORMAT_ERROR` if it doesn't. It also reads the logical screen descriptor and the global color table if present."
65,readGraphicControlExt(),read graphic control ext reads graphics control extension values ,Method,,,com.bumptech.glide.load.resource.gif.GifDecoder+read() com.bumptech.glide.load.resource.gif.GifDecoder+read() com.bumptech.glide.load.resource.gif.GifDecoder+read() com.bumptech.glide.load.resource.gif.GifDecoder+read() com.bumptech.glide.load.resource.gif.GifDecoder+readShort() com.bumptech.glide.load.resource.gif.GifDecoder+readShort() com.bumptech.glide.load.resource.gif.GifDecoder+read() com.bumptech.glide.load.resource.gif.GifDecoder+read() com.bumptech.glide.load.resource.gif.GifDecoder+read() com.bumptech.glide.load.resource.gif.GifDecoder+read(),com.bumptech.glide.load.resource.gif.GifDecoder+currentFrame com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+dispose com.bumptech.glide.load.resource.gif.GifDecoder+currentFrame com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+dispose com.bumptech.glide.load.resource.gif.GifDecoder+currentFrame com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+dispose com.bumptech.glide.load.resource.gif.GifDecoder+currentFrame com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+transparency com.bumptech.glide.load.resource.gif.GifDecoder+isTransparent com.bumptech.glide.load.resource.gif.GifDecoder+currentFrame com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+transparency com.bumptech.glide.load.resource.gif.GifDecoder+currentFrame com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+delay com.bumptech.glide.load.resource.gif.GifDecoder+currentFrame com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+transIndex,674,16,4,"/** 
 * Reads Graphics Control Extension values
 */
","/**
     * Reads Graphics Control Extension values
     */
    protected void readGraphicControlExt() {
        read(); // block size
        int packed = read(); // packed fields
        currentFrame.dispose = (packed & 0x1c) >> 2; // disposal method
        if (currentFrame.dispose == 0) {
            currentFrame.dispose = 1; // elect to keep old image if discretionary
        }
        currentFrame.transparency = (packed & 1) != 0;
        isTransparent |= currentFrame.transparency;
        currentFrame.delay = readShort() * 10; // delay in milliseconds
        currentFrame.transIndex = read(); // transparent color index
        read(); // block terminator
    }",True,True,"The function reads and sets various properties of a Graphics Control Extension, including the disposal method, transparency, delay, and transparent color index, for a current frame.",True,"The `readGraphicControlExt` method reads the values of the Graphics Control Extension in a GIF file. It extracts information such as the disposal method, transparency, delay, and transparent color index for the current frame. It also updates the `currentFrame` object with these values."
66,readBitmap(),read bitmap reads next frame image ,Method,,,"com.bumptech.glide.load.resource.gif.GifDecoder+readShort() com.bumptech.glide.load.resource.gif.GifDecoder+readShort() com.bumptech.glide.load.resource.gif.GifDecoder+readShort() com.bumptech.glide.load.resource.gif.GifDecoder+readShort() com.bumptech.glide.load.resource.gif.GifDecoder+readShort() com.bumptech.glide.load.resource.gif.GifDecoder+readShort() com.bumptech.glide.load.resource.gif.GifDecoder+readShort() com.bumptech.glide.load.resource.gif.GifDecoder+readShort() com.bumptech.glide.load.resource.gif.GifDecoder+read() com.bumptech.glide.load.resource.gif.GifDecoder+read() java.lang.Math+pow(double,double) java.lang.Math+pow(double,double) com.bumptech.glide.load.resource.gif.GifDecoder+readColorTable(int) com.bumptech.glide.load.resource.gif.GifDecoder+readColorTable(int) java.nio.Buffer+position() java.nio.Buffer+position() com.bumptech.glide.load.resource.gif.GifDecoder+decodeBitmapData(GifFrame,byte[]) com.bumptech.glide.load.resource.gif.GifDecoder+decodeBitmapData(GifFrame,byte[]) com.bumptech.glide.load.resource.gif.GifDecoder+skip() com.bumptech.glide.load.resource.gif.GifDecoder+skip() com.bumptech.glide.load.resource.gif.GifDecoder+err() com.bumptech.glide.load.resource.gif.GifDecoder+err() java.util.ArrayList+add(E) java.util.ArrayList+add(E)",com.bumptech.glide.load.resource.gif.GifDecoder+currentFrame com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+ix com.bumptech.glide.load.resource.gif.GifDecoder+currentFrame com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+iy com.bumptech.glide.load.resource.gif.GifDecoder+currentFrame com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+iw com.bumptech.glide.load.resource.gif.GifDecoder+currentFrame com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+ih com.bumptech.glide.load.resource.gif.GifDecoder+lctFlag com.bumptech.glide.load.resource.gif.GifDecoder+lctSize com.bumptech.glide.load.resource.gif.GifDecoder+currentFrame com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+interlace com.bumptech.glide.load.resource.gif.GifDecoder+lctFlag com.bumptech.glide.load.resource.gif.GifDecoder+currentFrame com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+lct com.bumptech.glide.load.resource.gif.GifDecoder+lctSize com.bumptech.glide.load.resource.gif.GifDecoder+currentFrame com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+lct com.bumptech.glide.load.resource.gif.GifDecoder+currentFrame com.bumptech.glide.load.resource.gif.GifDecoder.GifFrame+bufferFrameStart com.bumptech.glide.load.resource.gif.GifDecoder+rawData com.bumptech.glide.load.resource.gif.GifDecoder+mainPixels com.bumptech.glide.load.resource.gif.GifDecoder+frameCount com.bumptech.glide.load.resource.gif.GifDecoder+frames com.bumptech.glide.load.resource.gif.GifDecoder+currentFrame,1135,33,4,"/** 
 * Reads next frame image
 */
","/**
     * Reads next frame image
     */
    protected void readBitmap() {
        currentFrame.ix = readShort(); // (sub)image position & size
        currentFrame.iy = readShort();
        currentFrame.iw = readShort();
        currentFrame.ih = readShort();

        int packed = read();
        lctFlag = (packed & 0x80) != 0; // 1 - local color table flag interlace
        lctSize = (int) Math.pow(2, (packed & 0x07) + 1);
        // 3 - sort flag
        // 4-5 - reserved lctSize = 2 << (packed & 7); // 6-8 - local color
        // table size
        currentFrame.interlace = (packed & 0x40) != 0;
        if (lctFlag) {
            currentFrame.lct = readColorTable(lctSize); // read table
        } else {
            currentFrame.lct = null; //No local color table
        }

        currentFrame.bufferFrameStart = rawData.position(); //Save this as the decoding position pointer

        decodeBitmapData(null, mainPixels); // false decode pixel data to advance buffer
        skip();
        if (err()) {
            return;
        }

        frameCount++;
        frames.add(currentFrame); // add image to frame
    }",True,True,"This method reads the next frame image by reading the position, size, and other properties of the image. It also reads the color table if it exists. Finally, it decodes the pixel data and adds the image to the frame.",True,The `readBitmap()` method reads the next frame image by extracting information about its position and size. It also determines if there is a local color table and if the image is interlaced. The method then decodes the pixel data and adds the image to the frame.
67,readLSD(),read lsd reads logical screen descriptor ,Method,,,com.bumptech.glide.load.resource.gif.GifDecoder+readShort() com.bumptech.glide.load.resource.gif.GifDecoder+readShort() com.bumptech.glide.load.resource.gif.GifDecoder+readShort() com.bumptech.glide.load.resource.gif.GifDecoder+readShort() com.bumptech.glide.load.resource.gif.GifDecoder+read() com.bumptech.glide.load.resource.gif.GifDecoder+read() com.bumptech.glide.load.resource.gif.GifDecoder+read() com.bumptech.glide.load.resource.gif.GifDecoder+read() com.bumptech.glide.load.resource.gif.GifDecoder+read() com.bumptech.glide.load.resource.gif.GifDecoder+read(),com.bumptech.glide.load.resource.gif.GifDecoder+width com.bumptech.glide.load.resource.gif.GifDecoder+height com.bumptech.glide.load.resource.gif.GifDecoder+gctFlag com.bumptech.glide.load.resource.gif.GifDecoder+gctSize com.bumptech.glide.load.resource.gif.GifDecoder+bgIndex com.bumptech.glide.load.resource.gif.GifDecoder+pixelAspect com.bumptech.glide.load.resource.gif.GifDecoder+mainPixels com.bumptech.glide.load.resource.gif.GifDecoder+width com.bumptech.glide.load.resource.gif.GifDecoder+height com.bumptech.glide.load.resource.gif.GifDecoder+mainScratch com.bumptech.glide.load.resource.gif.GifDecoder+width com.bumptech.glide.load.resource.gif.GifDecoder+height,676,20,4,"/** 
 * Reads Logical Screen Descriptor
 */
","/**
     * Reads Logical Screen Descriptor
     */
    protected void readLSD() {
        // logical screen size
        width = readShort();
        height = readShort();
        // packed fields
        int packed = read();
        gctFlag = (packed & 0x80) != 0; // 1 : global color table flag
        // 2-4 : color resolution
        // 5 : gct sort flag
        gctSize = 2 << (packed & 7); // 6-8 : gct size
        bgIndex = read(); // background color index
        pixelAspect = read(); // pixel aspect ratio

        //Now that we know the size, init scratch arrays
        mainPixels = new byte[width * height];
        mainScratch = new int[width * height];
    }",False,True,"The function reads the logical screen descriptor, which includes the screen size, color information, background color index, and pixel aspect ratio. It also initializes scratch arrays based on the screen size.",True,"The `readLSD` method reads the logical screen descriptor, which includes information about the screen size, color table, background color, and pixel aspect ratio. It also initializes arrays for storing pixel data based on the screen size."
68,getNextBitmap(),get next bitmap ,Method,,,"com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool+get(int,int,Config) com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool+get(int,int,Config)",com.bumptech.glide.load.resource.gif.GifDecoder+isTransparent com.bumptech.glide.load.resource.gif.GifDecoder+bitmapPool com.bumptech.glide.load.resource.gif.GifDecoder+width com.bumptech.glide.load.resource.gif.GifDecoder+height com.bumptech.glide.load.resource.gif.GifDecoder+width com.bumptech.glide.load.resource.gif.GifDecoder+height,343,8,2,,"private Bitmap getNextBitmap() {
        Bitmap.Config targetConfig = isTransparent ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
        Bitmap result = bitmapPool.get(width, height, targetConfig);
        if (result == null) {
            result = Bitmap.createBitmap(width, height, targetConfig);
        }
        return result;
    }",False,False,"This method returns the next available Bitmap object from a bitmap pool. If no Bitmap is available, it creates a new one with the specified width, height, and configuration.",False,"This code defines a private method called ""getNextBitmap"" that returns a Bitmap object. It first determines the target configuration for the Bitmap based on a boolean variable ""isTransparent"". It then tries to obtain a Bitmap from a bitmap pool, and if it is not available, it creates a new Bitmap with the specified width, height, and target configuration. The method ultimately returns the obtained or created Bitmap."
69,readNetscapeExt(),read netscape ext reads netscape extenstion to obtain iteration count ,Method,,,com.bumptech.glide.load.resource.gif.GifDecoder+readBlock() com.bumptech.glide.load.resource.gif.GifDecoder+readBlock() com.bumptech.glide.load.resource.gif.GifDecoder+err() com.bumptech.glide.load.resource.gif.GifDecoder+err(),com.bumptech.glide.load.resource.gif.GifDecoder+block com.bumptech.glide.load.resource.gif.GifDecoder+block com.bumptech.glide.load.resource.gif.GifDecoder+block com.bumptech.glide.load.resource.gif.GifDecoder+loopCount com.bumptech.glide.load.resource.gif.GifDecoder+blockSize,429,14,4,"/** 
 * Reads Netscape extenstion to obtain iteration count
 */
","/**
     * Reads Netscape extenstion to obtain iteration count
     */
    protected void readNetscapeExt() {
        do {
            readBlock();
            if (block[0] == 1) {
                // loop count sub-block
                int b1 = ((int) block[1]) & 0xff;
                int b2 = ((int) block[2]) & 0xff;
                loopCount = (b2 << 8) | b1;
            }
        } while ((blockSize > 0) && !err());
    }",True,True,"The function reads the Netscape extension to obtain the iteration count. It reads blocks, checks if the first element of the block is 1, and if so, calculates the loop count based on the second and third elements of the block. It continues reading blocks until the block size is greater than 0 and there are no errors.",True,"The method ""readNetscapeExt"" reads a Netscape extension to obtain the iteration count. It loops through blocks, checks if the first byte of the block is equal to 1, and if so, extracts the loop count from the next two bytes of the block. The loop continues until the block size is greater than 0 and there are no errors."
70,readShort(),read short reads next 16 bit value lsb first ,Method,,,java.nio.ByteBuffer+getShort() java.nio.ByteBuffer+getShort(),com.bumptech.glide.load.resource.gif.GifDecoder+rawData,155,7,4,"/** 
 * Reads next 16-bit value, LSB first
 */
","/**
     * Reads next 16-bit value, LSB first
     */
    protected int readShort() {
        // read 16-bit value
        return rawData.getShort();
    }",False,True,This method reads the next 16-bit value from the rawData and returns it.,True,"The given code is a protected method named ""readShort()"" that reads the next 16-bit value from a data source. It returns the value in LSB (Least Significant Bit) first format."
71,skip(),skip skips variable length blocks up to and including next zero length block ,Method,,,com.bumptech.glide.load.resource.gif.GifDecoder+readBlock() com.bumptech.glide.load.resource.gif.GifDecoder+readBlock() com.bumptech.glide.load.resource.gif.GifDecoder+err() com.bumptech.glide.load.resource.gif.GifDecoder+err(),com.bumptech.glide.load.resource.gif.GifDecoder+blockSize,208,8,4,"/** 
 * Skips variable length blocks up to and including next zero length block.
 */
","/**
     * Skips variable length blocks up to and including next zero length block.
     */
    protected void skip() {
        do {
            readBlock();
        } while ((blockSize > 0) && !err());
    }",True,True,"The function of the ""skip"" method is to read variable length blocks until it reaches a zero length block, while also checking for any errors.",True,The `skip()` method is used to skip over variable length blocks until it reaches a zero length block. It repeatedly calls the `readBlock()` method until the block size is greater than 0 and there are no errors.
