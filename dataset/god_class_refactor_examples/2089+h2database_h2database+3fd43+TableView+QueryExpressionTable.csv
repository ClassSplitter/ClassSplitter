index,name,document,type,inner invocations,external invocations,calls,visits,length,lines,modifier,commit,full text,moved,removed,gpt text,gpt response,code summary
1,ROW_COUNT_APPROXIMATION,row count approximation ,Field,,,,,56,1,26,,private static final long ROW_COUNT_APPROXIMATION = 100;,True,True,,False,
2,querySQL,query sql ,Field,"replace(String,Column[],SessionLocal,boolean,boolean,boolean) init(String,ArrayList<Parameter>,Column[],SessionLocal,boolean,boolean,boolean) initColumnsAndTables(SessionLocal,boolean)",,,,24,1,2,,private String querySQL;,False,False,,False,
3,tables,tables ,Field,,,,,32,1,2,,private ArrayList<Table> tables;,True,True,,False,
4,columnTemplates,column templates ,Field,"replace(String,Column[],SessionLocal,boolean,boolean,boolean) init(String,ArrayList<Parameter>,Column[],SessionLocal,boolean,boolean,boolean)",,,,33,1,2,,private Column[] columnTemplates;,False,False,,False,
5,viewQuery,view query ,Field,,,,,24,1,2,,private Query viewQuery;,True,True,,False,
6,index,index ,Field,,,,,24,1,2,,private ViewIndex index;,False,True,,False,
7,allowRecursive,allow recursive ,Field,"replace(String,Column[],SessionLocal,boolean,boolean,boolean) init(String,ArrayList<Parameter>,Column[],SessionLocal,boolean,boolean,boolean)",,,,31,1,2,,private boolean allowRecursive;,False,False,,False,
8,createException,create exception ,Field,,,,,36,1,2,,private DbException createException;,False,False,,False,
9,lastModificationCheck,last modification check ,Field,,,,,35,1,2,,private long lastModificationCheck;,True,True,,False,
10,maxDataModificationId,max data modification id ,Field,,,,,35,1,2,,private long maxDataModificationId;,True,True,,False,
11,owner,owner ,Field,setOwner(User),,,,19,1,2,,private User owner;,False,True,,False,
12,topQuery,top query ,Field,setTopQuery(Query),,,,23,1,2,,private Query topQuery;,False,True,,False,
13,recursiveResult,recursive result ,Field,setRecursiveResult(ResultInterface),,,,40,1,2,,private ResultInterface recursiveResult;,False,False,,False,
14,isRecursiveQueryDetected,is recursive query detected ,Field,"init(String,ArrayList<Parameter>,Column[],SessionLocal,boolean,boolean,boolean) initColumnsAndTables(SessionLocal,boolean)",,,,41,1,2,,private boolean isRecursiveQueryDetected;,False,False,,False,
15,isTableExpression,is table expression ,Field,"init(String,ArrayList<Parameter>,Column[],SessionLocal,boolean,boolean,boolean)",,,,34,1,2,,private boolean isTableExpression;,False,False,,False,
16,isSubquery,is subquery ,Field,"TableView(Schema,int,String,String,ArrayList<Parameter>,Column[],SessionLocal,boolean,boolean,boolean,boolean,boolean)",,,,27,1,2,,private boolean isSubquery;,False,True,,False,
17,"TableView(Schema,int,String,String,ArrayList<Parameter>,Column[],SessionLocal,boolean,boolean,boolean,boolean,boolean)",table view schema id name query sql params column templates session allow recursive literals checked is table expression is temporary is subquery ,Method,,,"org.h2.engine.DbObject+setTemporary(boolean) org.h2.engine.DbObject+setTemporary(boolean) org.h2.table.TableView+init(String,ArrayList<Parameter>,Column[],SessionLocal,boolean,boolean,boolean) org.h2.table.TableView+init(String,ArrayList<Parameter>,Column[],SessionLocal,boolean,boolean,boolean)",org.h2.table.TableView+isSubquery org.h2.table.TableView+isSubquery,536,9,1,,"public TableView(Schema schema, int id, String name, String querySQL,
            ArrayList<Parameter> params, Column[] columnTemplates, SessionLocal session,
            boolean allowRecursive, boolean literalsChecked, boolean isTableExpression, boolean isTemporary,
            boolean isSubquery) {
        super(schema, id, name, false, true);
        setTemporary(isTemporary);
        this.isSubquery = isSubquery;
        init(querySQL, params, columnTemplates, session, allowRecursive, literalsChecked, isTableExpression);
    }",False,False,The function of this method is to initialize a TableView object with the given parameters and set its properties accordingly.,False,"This code defines a constructor for a TableView object, which initializes its properties based on the provided parameters. The constructor sets the temporary flag, initializes the query, parameters, column templates, session, and other properties, and sets the isSubquery flag."
18,"replace(String,Column[],SessionLocal,boolean,boolean,boolean)",replace query sql new column templates session recursive force literals checked try to replace the sql statement of the view and re compile this and all dependent views param query sql the sql statement param new column templates the columns param session the session param recursive whether this is a recursive view param force if errors should be ignored param literals checked if literals have been checked ,Method,,org.h2.command.ddl.CreateView+update(Schema),"org.h2.table.TableView+init(String,ArrayList<Parameter>,Column[],SessionLocal,boolean,boolean,boolean) org.h2.table.TableView+init(String,ArrayList<Parameter>,Column[],SessionLocal,boolean,boolean,boolean) org.h2.table.TableView+recompile(SessionLocal,boolean,boolean) org.h2.table.TableView+recompile(SessionLocal,boolean,boolean) org.h2.table.TableView+init(String,ArrayList<Parameter>,Column[],SessionLocal,boolean,boolean,boolean) org.h2.table.TableView+init(String,ArrayList<Parameter>,Column[],SessionLocal,boolean,boolean,boolean) org.h2.table.TableView+recompile(SessionLocal,boolean,boolean) org.h2.table.TableView+recompile(SessionLocal,boolean,boolean)",org.h2.table.TableView+querySQL org.h2.table.TableView+querySQL org.h2.table.TableView+columnTemplates org.h2.table.TableView+columnTemplates org.h2.table.TableView+allowRecursive org.h2.table.TableView+allowRecursive org.h2.table.TableView+isTableExpression org.h2.table.TableView+isTableExpression,1135,25,1,"/** 
 * Try to replace the SQL statement of the view and re-compile this and all dependent views.
 * @param querySQL the SQL statement
 * @param newColumnTemplates the columns
 * @param session the session
 * @param recursive whether this is a recursive view
 * @param force if errors should be ignored
 * @param literalsChecked if literals have been checked
 */
","/**
     * Try to replace the SQL statement of the view and re-compile this and all
     * dependent views.
     *
     * @param querySQL the SQL statement
     * @param newColumnTemplates the columns
     * @param session the session
     * @param recursive whether this is a recursive view
     * @param force if errors should be ignored
     * @param literalsChecked if literals have been checked
     */
    public void replace(String querySQL,  Column[] newColumnTemplates, SessionLocal session,
            boolean recursive, boolean force, boolean literalsChecked) {
        String oldQuerySQL = this.querySQL;
        Column[] oldColumnTemplates = this.columnTemplates;
        boolean oldRecursive = this.allowRecursive;
        init(querySQL, null, newColumnTemplates, session, recursive, literalsChecked, isTableExpression);
        DbException e = recompile(session, force, true);
        if (e != null) {
            init(oldQuerySQL, null, oldColumnTemplates, session, oldRecursive,
                    literalsChecked, isTableExpression);
            recompile(session, true, false);
            throw e;
        }
    }",False,False,"This method serves to replace the SQL statement of a view, re-compile the view and all dependent views, and handle any errors that occur during the process.",False,"This code defines a method called ""replace"" that is used to replace the SQL statement of a view and re-compile it along with its dependent views. The method takes in parameters such as the new SQL statement, column templates, session information, and flags for recursion and error handling. If an error occurs during recompilation, the method reverts back to the original SQL statement and column templates and throws the exception."
19,"init(String,ArrayList<Parameter>,Column[],SessionLocal,boolean,boolean,boolean)",init query sql params column templates session allow recursive literals checked is table expression ,Method,"TableView(Schema,int,String,String,ArrayList<Parameter>,Column[],SessionLocal,boolean,boolean,boolean,boolean,boolean) replace(String,Column[],SessionLocal,boolean,boolean,boolean) replace(String,Column[],SessionLocal,boolean,boolean,boolean)",,"org.h2.index.ViewIndex+ViewIndex(TableView,String,ArrayList<Parameter>,boolean) org.h2.table.TableView+initColumnsAndTables(SessionLocal,boolean) org.h2.table.TableView+initColumnsAndTables(SessionLocal,boolean)",org.h2.table.TableView+querySQL org.h2.table.TableView+querySQL org.h2.table.TableView+columnTemplates org.h2.table.TableView+columnTemplates org.h2.table.TableView+allowRecursive org.h2.table.TableView+allowRecursive org.h2.table.TableView+isRecursiveQueryDetected org.h2.table.TableView+isRecursiveQueryDetected org.h2.table.TableView+isTableExpression org.h2.table.TableView+isTableExpression org.h2.table.TableView+index,586,11,34,,"private synchronized void init(String querySQL, ArrayList<Parameter> params,
            Column[] columnTemplates, SessionLocal session, boolean allowRecursive, boolean literalsChecked,
            boolean isTableExpression) {
        this.querySQL = querySQL;
        this.columnTemplates = columnTemplates;
        this.allowRecursive = allowRecursive;
        this.isRecursiveQueryDetected = false;
        this.isTableExpression = isTableExpression;
        index = new ViewIndex(this, querySQL, params, allowRecursive);
        initColumnsAndTables(session, literalsChecked);
    }",False,False,"This method initializes the query and its parameters, column templates, session, and flags. It also creates a new ViewIndex object and initializes columns and tables.",False,"This method initializes the state of an object by setting various properties and creating a ViewIndex object. It also calls another method to initialize columns and tables based on the provided session and literalsChecked flag. The method is synchronized, indicating that it can only be accessed by one thread at a time."
20,"compileViewQuery(SessionLocal,String,boolean)",compile view query session sql literals checked ,Method,"recompile(SessionLocal,boolean,boolean) initColumnsAndTables(SessionLocal,boolean)",,"org.h2.engine.SessionLocal+setParsingCreateView(boolean) org.h2.engine.SessionLocal+setParsingCreateView(boolean) org.h2.engine.SessionLocal+prepare(String,boolean,boolean) org.h2.engine.SessionLocal+prepare(String,boolean,boolean) org.h2.engine.SessionLocal+setParsingCreateView(boolean) org.h2.engine.SessionLocal+setParsingCreateView(boolean) org.h2.message.DbException+getSyntaxError(String,int) org.h2.message.DbException+getSyntaxError(String,int) org.h2.command.query.Query+setNeverLazy(boolean) org.h2.command.query.Query+setNeverLazy(boolean)",org.h2.table.TableView+isTableExpression org.h2.table.TableView+allowRecursive,629,18,2,,"private Query compileViewQuery(SessionLocal session, String sql, boolean literalsChecked) {
        Prepared p;
        session.setParsingCreateView(true);
        try {
            p = session.prepare(sql, false, literalsChecked);
        } finally {
            session.setParsingCreateView(false);
        }
        if (!(p instanceof Query)) {
            throw DbException.getSyntaxError(sql, 0);
        }
        Query q = (Query) p;
        // only potentially recursive cte queries need to be non-lazy
        if (isTableExpression && allowRecursive) {
            q.setNeverLazy(true);
        }
        return q;
    }",False,False,"The function of this method is to compile a view query by preparing the SQL statement, setting parsing flags, and returning the compiled query. It also checks if the query is a potentially recursive CTE query and sets the lazy evaluation flag accordingly.",True,"This code compiles a view query by preparing the SQL statement and checking if it is a valid query. If the query is potentially recursive and a table expression, it is set to be non-lazy. The compiled query is then returned."
21,"recompile(SessionLocal,boolean,boolean)",recompile session force clear index cache re compile the view query and all views that depend on this object param session the session param force if exceptions should be ignored param clear index cache if we need to clear view index cache return the exception if re compiling this or any dependent view failed only when force is disabled ,Method,"replace(String,Column[],SessionLocal,boolean,boolean,boolean) replace(String,Column[],SessionLocal,boolean,boolean,boolean) recompile(SessionLocal,boolean,boolean)",org.h2.command.ddl.AlterView+update() org.h2.engine.Database+recompileInvalidViews(),"org.h2.table.TableView+compileViewQuery(SessionLocal,String,boolean) org.h2.table.TableView+compileViewQuery(SessionLocal,String,boolean) org.h2.table.Table+getDependentViews() org.h2.table.Table+getDependentViews() org.h2.table.TableView+initColumnsAndTables(SessionLocal,boolean) org.h2.table.TableView+initColumnsAndTables(SessionLocal,boolean) org.h2.table.TableView+recompile(SessionLocal,boolean,boolean) org.h2.table.TableView+recompile(SessionLocal,boolean,boolean) org.h2.table.TableView+clearIndexCaches(Database) org.h2.table.TableView+clearIndexCaches(Database)",org.h2.table.TableView+querySQL org.h2.engine.DbObject+database org.h2.table.TableView+createException,1134,31,33,"/** 
 * Re-compile the view query and all views that depend on this object.
 * @param session the session
 * @param force if exceptions should be ignored
 * @param clearIndexCache if we need to clear view index cache
 * @return the exception if re-compiling this or any dependent view failed(only when force is disabled)
 */
","/**
     * Re-compile the view query and all views that depend on this object.
     *
     * @param session the session
     * @param force if exceptions should be ignored
     * @param clearIndexCache if we need to clear view index cache
     * @return the exception if re-compiling this or any dependent view failed
     *         (only when force is disabled)
     */
    public synchronized DbException recompile(SessionLocal session, boolean force,
            boolean clearIndexCache) {
        try {
            compileViewQuery(session, querySQL, false);
        } catch (DbException e) {
            if (!force) {
                return e;
            }
        }
        ArrayList<TableView> dependentViews = new ArrayList<>(getDependentViews());
        initColumnsAndTables(session, false);
        for (TableView v : dependentViews) {
            DbException e = v.recompile(session, force, false);
            if (e != null && !force) {
                return e;
            }
        }
        if (clearIndexCache) {
            clearIndexCaches(database);
        }
        return force ? null : createException;
    }",False,False,"This method serves to re-compile the view query and all views that depend on this object. It takes in a session, a boolean value to determine if exceptions should be ignored, and a boolean value to determine if the view index cache should be cleared. It returns an exception if re-compiling this or any dependent view fails (only when force is disabled), otherwise it returns null.",True,"This code is a method that re-compiles a view query and all views that depend on it. It takes in a session, a boolean flag to ignore exceptions, and a flag to clear the view index cache. It returns an exception if re-compiling fails and the force flag is disabled, otherwise it returns null."
22,"initColumnsAndTables(SessionLocal,boolean)",init columns and tables session literals checked ,Method,"init(String,ArrayList<Parameter>,Column[],SessionLocal,boolean,boolean,boolean) recompile(SessionLocal,boolean,boolean)",,"org.h2.table.TableView+removeCurrentViewFromOtherTables() org.h2.table.TableView+removeCurrentViewFromOtherTables() org.h2.table.Table+setTableExpression(boolean) org.h2.table.Table+setTableExpression(boolean) org.h2.table.TableView+compileViewQuery(SessionLocal,String,boolean) org.h2.table.TableView+compileViewQuery(SessionLocal,String,boolean) org.h2.command.Prepared+getPlanSQL(int) org.h2.command.Prepared+getPlanSQL(int) org.h2.command.query.Query+getTables() org.h2.command.query.Query+getTables() org.h2.command.query.Query+getExpressions() org.h2.command.query.Query+getExpressions() org.h2.command.query.Query+getColumnCount() org.h2.command.query.Query+getColumnCount() java.util.ArrayList+get(int) java.util.ArrayList+get(int) org.h2.table.Column+getName() org.h2.table.Column+getName() org.h2.table.Column+getType() org.h2.table.Column+getType() org.h2.expression.Expression+getAlias(SessionLocal,int) org.h2.expression.Expression+getAlias(SessionLocal,int) org.h2.expression.Expression+getColumnNameForView(SessionLocal,int) org.h2.expression.Expression+getColumnNameForView(SessionLocal,int) org.h2.value.TypeInfo+getValueType() org.h2.value.TypeInfo+getValueType() org.h2.expression.Expression+getType() org.h2.expression.Expression+getType() java.util.ArrayList+add(E) java.util.ArrayList+add(E) org.h2.table.Column+Column(String,TypeInfo,Table,int) java.util.ArrayList+toArray(T[]) java.util.ArrayList+toArray(T[]) org.h2.message.DbException+getErrorCode() org.h2.message.DbException+getErrorCode() org.h2.message.DbException+addSQL(String) org.h2.message.DbException+addSQL(String) org.h2.table.TableView+getCreateSQL() org.h2.table.TableView+getCreateSQL() org.h2.table.TableView+isRecursiveQueryExceptionDetected(DbException) org.h2.table.TableView+isRecursiveQueryExceptionDetected(DbException) org.h2.util.Utils+newSmallArrayList() org.h2.util.Utils+newSmallArrayList() org.h2.table.Column+getClone() org.h2.table.Column+getClone() org.h2.index.ViewIndex+setRecursive(boolean) org.h2.index.ViewIndex+setRecursive(boolean) org.h2.table.Table+setColumns(Column[]) org.h2.table.Table+setColumns(Column[]) org.h2.engine.DbObject+getId() org.h2.engine.DbObject+getId() org.h2.table.TableView+addDependentViewToTables() org.h2.table.TableView+addDependentViewToTables()",org.h2.table.TableView+isTableExpression org.h2.table.TableView+querySQL org.h2.table.TableView+querySQL org.h2.table.TableView+querySQL org.h2.util.HasSQL+DEFAULT_SQL_FLAGS org.h2.table.TableView+tables org.h2.value.TypeInfo+TYPE_UNKNOWN org.h2.table.TableView+columnTemplates org.h2.table.TableView+columnTemplates org.h2.table.TableView+columnTemplates org.h2.table.TableView+columnTemplates org.h2.table.TableView+isSubquery org.h2.value.Value+UNKNOWN org.h2.table.TableView+createException org.h2.table.TableView+viewQuery org.h2.api.ErrorCode+COLUMN_ALIAS_IS_NOT_SPECIFIED_1 org.h2.table.TableView+createException org.h2.table.TableView+createException org.h2.table.TableView+isRecursiveQueryDetected org.h2.table.TableView+isRecursiveQueryDetected org.h2.table.TableView+tables org.h2.table.TableView+allowRecursive org.h2.table.TableView+columnTemplates org.h2.table.TableView+columnTemplates org.h2.table.TableView+columnTemplates org.h2.table.TableView+columnTemplates org.h2.table.TableView+index org.h2.table.TableView+createException,2735,60,2,,"private void initColumnsAndTables(SessionLocal session, boolean literalsChecked) {
        Column[] cols;
        removeCurrentViewFromOtherTables();
        setTableExpression(isTableExpression);
        try {
            Query compiledQuery = compileViewQuery(session, querySQL, literalsChecked);
            this.querySQL = compiledQuery.getPlanSQL(DEFAULT_SQL_FLAGS);
            tables = new ArrayList<>(compiledQuery.getTables());
            ArrayList<Expression> expressions = compiledQuery.getExpressions();
            final int count = compiledQuery.getColumnCount();
            ArrayList<Column> list = new ArrayList<>(count);
            for (int i = 0; i < count; i++) {
                Expression expr = expressions.get(i);
                String name = null;
                TypeInfo type = TypeInfo.TYPE_UNKNOWN;
                if (columnTemplates != null && columnTemplates.length > i) {
                    name = columnTemplates[i].getName();
                    type = columnTemplates[i].getType();
                }
                if (name == null) {
                    name = isSubquery ? expr.getAlias(session, i) : expr.getColumnNameForView(session, i);
                }
                if (type.getValueType() == Value.UNKNOWN) {
                    type = expr.getType();
                }
                list.add(new Column(name, type, this, i));
            }
            cols = list.toArray(new Column[0]);
            createException = null;
            viewQuery = compiledQuery;
        } catch (DbException e) {
            if (e.getErrorCode() == ErrorCode.COLUMN_ALIAS_IS_NOT_SPECIFIED_1) {
                throw e;
            }
            e.addSQL(getCreateSQL());
            createException = e;
            // If it can't be compiled, then it's a 'zero column table'
            // this avoids problems when creating the view when opening the
            // database.
            // If it can not be compiled - it could also be a recursive common
            // table expression query.
            if (isRecursiveQueryExceptionDetected(createException)) {
                this.isRecursiveQueryDetected = true;
            }
            tables = Utils.newSmallArrayList();
            cols = new Column[0];
            if (allowRecursive && columnTemplates != null) {
                cols = new Column[columnTemplates.length];
                for (int i = 0; i < columnTemplates.length; i++) {
                    cols[i] = columnTemplates[i].getClone();
                }
                index.setRecursive(true);
                createException = null;
            }
        }
        setColumns(cols);
        if (getId() != 0) {
            addDependentViewToTables();
        }
    }",False,False,"The function of this method is to initialize the columns and tables for a view. It compiles the view query, retrieves the columns and their types, and sets them for the view. It also handles exceptions and sets the view as recursive if necessary. Finally, it adds the view as a dependent to the tables.",True,"The `initColumnsAndTables` method initializes the columns and tables for a view. It compiles the view query, retrieves the columns and their types, and creates the necessary exceptions and dependencies."
23,isView(),is view ,Method,,,,,66,4,1,,"@Override
    public boolean isView() {
        return true;
    }",True,True,"This method serves to determine whether an object is a view or not. It returns a boolean value of true if the object is a view, and false otherwise.",False,"The code snippet defines a method named ""isView"" that returns a boolean value of true. It is likely part of a class or interface implementation and indicates that the object associated with this method is a view."
24,isInvalid(),is invalid check if this view is currently invalid return true if it is ,Method,,"org.h2.engine.Database+recompileInvalidViews() org.h2.engine.Database+recompileInvalidViews() org.h2.table.InformationSchemaTable+views(SessionLocal,ArrayList<Row>,String,Table,String) org.h2.table.TableFilter+getPlanSQL(StringBuilder,boolean,int)",,org.h2.table.TableView+createException,174,8,1,"/** 
 * Check if this view is currently invalid.
 * @return true if it is
 */
","/**
     * Check if this view is currently invalid.
     *
     * @return true if it is
     */
    public boolean isInvalid() {
        return createException != null;
    }",False,False,"The function of this method is to check if the view is currently invalid by returning true if there is a createException, and false otherwise.",False,The method `isInvalid()` checks if the current view is invalid by returning true if there is an exception (`createException`) associated with it. This method provides a simple way to determine the validity of the view.
25,"getBestPlanItem(SessionLocal,int[],TableFilter[],int,SortOrder,AllColumnsForPlan)",get best plan item session masks filters filter sort order all columns set ,Method,"getScanIndex(SessionLocal) getScanIndex(SessionLocal,int[],TableFilter[],int,SortOrder,AllColumnsForPlan)",,"org.h2.table.TableView.CacheKey+CacheKey(int[],TableView) org.h2.engine.SessionLocal+getViewIndexCache(boolean) org.h2.engine.SessionLocal+getViewIndexCache(boolean) java.util.Map+get(Object) java.util.Map+get(Object) org.h2.index.ViewIndex+isExpired() org.h2.index.ViewIndex+isExpired() org.h2.index.ViewIndex+ViewIndex(TableView,ViewIndex,SessionLocal,int[],TableFilter[],int,SortOrder) java.util.Map+put(K,V) java.util.Map+put(K,V) org.h2.table.PlanItem+PlanItem() org.h2.index.ViewIndex+getCost(SessionLocal,int[],TableFilter[],int,SortOrder,AllColumnsForPlan) org.h2.index.ViewIndex+getCost(SessionLocal,int[],TableFilter[],int,SortOrder,AllColumnsForPlan) org.h2.table.PlanItem+setIndex(Index) org.h2.table.PlanItem+setIndex(Index)",org.h2.table.TableView+topQuery org.h2.table.TableView+index org.h2.table.PlanItem+cost,757,16,1,,"@Override
    public PlanItem getBestPlanItem(SessionLocal session, int[] masks,
            TableFilter[] filters, int filter, SortOrder sortOrder,
            AllColumnsForPlan allColumnsSet) {
        final CacheKey cacheKey = new CacheKey(masks, this);
        Map<Object, ViewIndex> indexCache = session.getViewIndexCache(topQuery != null);
        ViewIndex i = indexCache.get(cacheKey);
        if (i == null || i.isExpired()) {
            i = new ViewIndex(this, index, session, masks, filters, filter, sortOrder);
            indexCache.put(cacheKey, i);
        }
        PlanItem item = new PlanItem();
        item.cost = i.getCost(session, masks, filters, filter, sortOrder, allColumnsSet);
        item.setIndex(i);
        return item;
    }",True,True,"This method retrieves the best plan item for executing a query. It checks if the plan item is already cached, and if not, creates a new one and adds it to the cache. It then calculates the cost of the plan item and returns it.",True,"This code is an implementation of a method that retrieves the best plan item based on certain parameters. It checks if the plan item is already cached and not expired, otherwise it creates a new one and adds it to the cache. The method then calculates the cost of the plan item and returns it."
26,isQueryComparable(),is query comparable ,Method,,,org.h2.table.Table+isQueryComparable() org.h2.table.Table+isQueryComparable() org.h2.table.Table+isQueryComparable() org.h2.command.query.Query+isEverything(ExpressionVisitor) org.h2.command.query.Query+isEverything(ExpressionVisitor),org.h2.table.TableView+tables org.h2.table.TableView+topQuery org.h2.table.TableView+topQuery org.h2.expression.ExpressionVisitor+QUERY_COMPARABLE_VISITOR,438,16,1,,"@Override
    public boolean isQueryComparable() {
        if (!super.isQueryComparable()) {
            return false;
        }
        for (Table t : tables) {
            if (!t.isQueryComparable()) {
                return false;
            }
        }
        if (topQuery != null &&
                !topQuery.isEverything(ExpressionVisitor.QUERY_COMPARABLE_VISITOR)) {
            return false;
        }
        return true;
    }",True,True,"This method checks if the current query is comparable. It first checks if the super class query is comparable, then checks if all tables in the query are comparable. Finally, it checks if the top query is comparable. If any of these conditions are not met, it returns false. Otherwise, it returns true.",False,"The code defines a method named `isQueryComparable()` that checks if a query is comparable. It first checks if the superclass's `isQueryComparable()` method returns false, and if so, returns false. Then, it iterates over a list of tables and checks if each table is query comparable. Finally, it checks if a top query is query comparable and returns true if all conditions are met."
27,getTopQuery(),get top query ,Method,,"org.h2.index.ViewIndex+ViewIndex(TableView,ViewIndex,SessionLocal,int[],TableFilter[],int,SortOrder)",,org.h2.table.TableView+topQuery,59,3,1,,"public Query getTopQuery() {
        return topQuery;
    }",False,False,"The function of the method is to return the value of the variable ""topQuery"".",False,"The code contains a method named ""getTopQuery"" which returns a Query object. This method is used to retrieve the top query from a data source or collection."
28,getDropSQL(),get drop sql ,Method,,,"java.lang.StringBuilder+toString() java.lang.StringBuilder+append(String) org.h2.table.TableView+getSQL(StringBuilder,int) org.h2.table.TableView+getSQL(StringBuilder,int) java.lang.StringBuilder+StringBuilder(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+toString()",org.h2.util.HasSQL+DEFAULT_SQL_FLAGS,163,4,1,,"@Override
    public String getDropSQL() {
        return getSQL(new StringBuilder(""DROP VIEW IF EXISTS ""), DEFAULT_SQL_FLAGS).append("" CASCADE"").toString();
    }",False,False,"The method serves to generate and return a SQL statement for dropping a view if it exists, with the option to cascade the drop operation.",True,"The code is implementing a method called `getDropSQL()` that returns a SQL statement for dropping a view. The method appends ""DROP VIEW IF EXISTS"" to a StringBuilder object, adds some default SQL flags, and appends ""CASCADE"" to the SQL statement before returning it as a String."
29,"getCreateSQLForCopy(Table,String)",get create sql for copy table quoted name ,Method,,,"org.h2.table.TableView+getCreateSQL(boolean,boolean,String) org.h2.table.TableView+getCreateSQL(boolean,boolean,String)",,141,4,1,,"@Override
    public String getCreateSQLForCopy(Table table, String quotedName) {
        return getCreateSQL(false, true, quotedName);
    }",False,False,"The method ""getCreateSQLForCopy"" returns the create SQL statement for copying a table, by calling the ""getCreateSQL"" method with specific parameters.",True,The method `getCreateSQLForCopy` is an overridden method that returns the SQL statement for creating a copy of a table. It calls the `getCreateSQL` method with specific parameters to generate the SQL statement.
30,getCreateSQL(),get create sql ,Method,"initColumnsAndTables(SessionLocal,boolean)",,"org.h2.table.TableView+getCreateSQL(boolean,boolean) org.h2.table.TableView+getCreateSQL(boolean,boolean)",,92,4,1,,"@Override
    public String getCreateSQL() {
        return getCreateSQL(false, true);
    }",False,False,"The method ""getCreateSQL"" returns a string that represents the SQL statement for creating a database table, using the parameters ""false"" and ""true"" as arguments.",True,"The method `getCreateSQL()` is overridden to return the SQL statement for creating a database object. It calls another method `getCreateSQL(boolean, boolean)` with `false` and `true` as arguments to generate the SQL statement."
31,"getCreateSQL(boolean,boolean)",get create sql or replace force generate create sql statement for the view param or replace if true then include the or replace clause param force if true then include the force clause return the sql statement ,Method,getCreateSQL(),"org.h2.command.ddl.AlterTableAlterColumn+copyData(Table,ArrayList<Sequence>,boolean)","org.h2.table.TableView+getCreateSQL(boolean,boolean,String) org.h2.table.TableView+getCreateSQL(boolean,boolean,String) org.h2.schema.SchemaObject+getSQL(int) org.h2.schema.SchemaObject+getSQL(int)",org.h2.util.HasSQL+DEFAULT_SQL_FLAGS,378,10,1,"/** 
 * Generate ""CREATE"" SQL statement for the view.
 * @param orReplace if true, then include the OR REPLACE clause
 * @param force if true, then include the FORCE clause
 * @return the SQL statement
 */
","/**
     * Generate ""CREATE"" SQL statement for the view.
     *
     * @param orReplace if true, then include the OR REPLACE clause
     * @param force if true, then include the FORCE clause
     * @return the SQL statement
     */
    public String getCreateSQL(boolean orReplace, boolean force) {
        return getCreateSQL(orReplace, force, getSQL(DEFAULT_SQL_FLAGS));
    }",False,False,"The method generates a ""CREATE"" SQL statement for a view. It takes two boolean parameters, orReplace and force, and returns the SQL statement.",True,"This code defines a method called ""getCreateSQL"" that generates a ""CREATE"" SQL statement for a view. The method takes in two boolean parameters, ""orReplace"" and ""force"", and returns the SQL statement. It also calls another method, ""getSQL"", to retrieve the default SQL flags."
32,"getCreateSQL(boolean,boolean,String)",get create sql or replace force quoted name ,Method,"getCreateSQLForCopy(Table,String) getCreateSQL(boolean,boolean)",,"java.lang.StringBuilder+StringBuilder(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) org.h2.util.StringUtils+quoteStringSQL(StringBuilder,String) org.h2.util.StringUtils+quoteStringSQL(StringBuilder,String) java.lang.StringBuilder+append(char) java.lang.StringBuilder+append(char) org.h2.table.Column+writeColumns(StringBuilder,Column[],int) org.h2.table.Column+writeColumns(StringBuilder,Column[],int) java.lang.StringBuilder+append(char) java.lang.StringBuilder+append(char) java.lang.StringBuilder+append(char) java.lang.StringBuilder+append(char) org.h2.table.Column+writeColumns(StringBuilder,Column[],int) org.h2.table.Column+writeColumns(StringBuilder,Column[],int) java.lang.StringBuilder+append(char) java.lang.StringBuilder+append(char) java.lang.StringBuilder+toString() java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+toString()",org.h2.table.TableView+isTableExpression org.h2.engine.DbObject+comment org.h2.engine.DbObject+comment org.h2.table.Table+columns org.h2.table.Table+columns org.h2.table.Table+columns org.h2.util.HasSQL+DEFAULT_SQL_FLAGS org.h2.table.TableView+columnTemplates org.h2.table.TableView+columnTemplates org.h2.util.HasSQL+DEFAULT_SQL_FLAGS org.h2.table.TableView+querySQL,1055,28,2,,"private String getCreateSQL(boolean orReplace, boolean force, String quotedName) {
        StringBuilder builder = new StringBuilder(""CREATE "");
        if (orReplace) {
            builder.append(""OR REPLACE "");
        }
        if (force) {
            builder.append(""FORCE "");
        }
        builder.append(""VIEW "");
        if (isTableExpression) {
            builder.append(""TABLE_EXPRESSION "");
        }
        builder.append(quotedName);
        if (comment != null) {
            builder.append("" COMMENT "");
            StringUtils.quoteStringSQL(builder, comment);
        }
        if (columns != null && columns.length > 0) {
            builder.append('(');
            Column.writeColumns(builder, columns, DEFAULT_SQL_FLAGS);
            builder.append(')');
        } else if (columnTemplates != null) {
            builder.append('(');
            Column.writeColumns(builder, columnTemplates, DEFAULT_SQL_FLAGS);
            builder.append(')');
        }
        return builder.append("" AS\n"").append(querySQL).toString();
    }",False,False,"The function of this method is to generate a SQL statement for creating a view. The method takes in parameters for whether to use ""OR REPLACE"" and ""FORCE"" keywords, the name of the view, and optional comment, columns, and query SQL. It returns the complete SQL statement as a string.",True,"This code defines a private method called `getCreateSQL` that returns a string. It takes in three boolean parameters (`orReplace`, `force`, and `quotedName`) and constructs a SQL CREATE VIEW statement based on these parameters and other variables within the method. The resulting SQL statement is returned as a string."
33,close(SessionLocal),close session ,Method,,,,,86,4,1,,"@Override
    public void close(SessionLocal session) {
        // nothing to do
    }",True,True,"This method serves as an override for the ""close"" function in the parent class. It takes a ""SessionLocal"" parameter and does nothing.",False,"The given code snippet is an implementation of the `close` method, which takes a `SessionLocal` object as a parameter. The method does not perform any actions and simply contains a comment stating that there is nothing to do."
34,"addIndex(SessionLocal,String,int,IndexColumn[],int,IndexType,boolean,String)",add index session index name index id cols unique column count index type create index comment ,Method,,,org.h2.message.DbException+getUnsupportedException(String) org.h2.message.DbException+getUnsupportedException(String),,268,5,1,,"@Override
    public Index addIndex(SessionLocal session, String indexName, int indexId, IndexColumn[] cols,
            int uniqueColumnCount, IndexType indexType, boolean create, String indexComment) {
        throw DbException.getUnsupportedException(""VIEW"");
    }",True,True,"This method is used to add an index to a database table. It throws an exception with the message ""VIEW"" to indicate that adding an index to a view is not supported.",False,"The code contains an overridden method called ""addIndex"" that throws an unsupported exception for the ""VIEW"" feature. It takes various parameters such as session, index name, index ID, columns, unique column count, index type, create flag, and index comment."
35,isInsertable(),is insertable ,Method,,,,,73,4,1,,"@Override
    public boolean isInsertable() {
        return false;
    }",True,True,"The function of the method isInsertable() is to determine whether an object can be inserted or not. It returns a boolean value of false, indicating that the object is not insertable.",False,"The code snippet defines a method named ""isInsertable"" that returns a boolean value. The method always returns false, indicating that the object associated with this method cannot be inserted into a data structure or collection."
36,"removeRow(SessionLocal,Row)",remove row session row ,Method,,,org.h2.message.DbException+getUnsupportedException(String) org.h2.message.DbException+getUnsupportedException(String),,133,4,1,,"@Override
    public void removeRow(SessionLocal session, Row row) {
        throw DbException.getUnsupportedException(""VIEW"");
    }",True,True,This method is used to remove a row from a database table. It throws an exception with a message indicating that the operation is not supported for views.,True,"The given code snippet is a method named ""removeRow"" that overrides a superclass method. It takes a session and a row as parameters and throws an exception with a message indicating that the operation is not supported for views."
37,"addRow(SessionLocal,Row)",add row session row ,Method,,,org.h2.message.DbException+getUnsupportedException(String) org.h2.message.DbException+getUnsupportedException(String),,130,4,1,,"@Override
    public void addRow(SessionLocal session, Row row) {
        throw DbException.getUnsupportedException(""VIEW"");
    }",False,True,"This method is used to add a row to a session, but it throws an exception indicating that the operation is not supported for views.",True,"The given code snippet is an overridden method named ""addRow"" that takes a session and a row as parameters. It throws an unsupported exception with the message ""VIEW"" when called, indicating that the operation is not supported for views."
38,checkSupportAlter(),check support alter ,Method,,,org.h2.message.DbException+getUnsupportedException(String) org.h2.message.DbException+getUnsupportedException(String),,112,4,1,,"@Override
    public void checkSupportAlter() {
        throw DbException.getUnsupportedException(""VIEW"");
    }",True,True,"This method is used to check if altering a view is supported. If it is not supported, it throws an exception with the message ""VIEW"".",True,"The given code snippet is a method named ""checkSupportAlter"" that is overridden from a superclass. It throws an exception with a message indicating that altering a view is not supported."
39,truncate(SessionLocal),truncate session ,Method,,,org.h2.message.DbException+getUnsupportedException(String) org.h2.message.DbException+getUnsupportedException(String),,123,4,1,,"@Override
    public long truncate(SessionLocal session) {
        throw DbException.getUnsupportedException(""VIEW"");
    }",True,True,"This method is used to truncate a session in a database. It throws an exception with the message ""VIEW"" to indicate that truncating a session is not supported.",True,The code snippet is an overridden method that belongs to a class. It throws an exception with a message indicating that the operation is not supported for views.
40,getRowCount(SessionLocal),get row count session ,Method,,,org.h2.message.DbException+getInternalError(String) org.h2.message.DbException+getInternalError(String) org.h2.engine.DbObject+toString() org.h2.engine.DbObject+toString(),,123,4,1,,"@Override
    public long getRowCount(SessionLocal session) {
        throw DbException.getInternalError(toString());
    }",True,True,This method is used to get the row count of a session. It throws an internal error with a message that represents the object as a string.,True,"The code snippet is an implementation of the `getRowCount` method, which is expected to return the number of rows in a database table. However, in this particular implementation, it throws an internal error with a message indicating the object's string representation."
41,canGetRowCount(SessionLocal),can get row count session ,Method,,,,,160,5,1,,"@Override
    public boolean canGetRowCount(SessionLocal session) {
        // TODO view: could get the row count, but not that easy
        return false;
    }",True,True,This method is used to determine if it is possible to retrieve the row count for a given session. It always returns false.,True,"The method `canGetRowCount` is overridden to determine if the row count can be obtained for a given session. However, the implementation is not provided and it always returns false."
42,canDrop(),can drop ,Method,,,,,67,4,1,,"@Override
    public boolean canDrop() {
        return true;
    }",False,False,"The function of the method is to determine whether an object can be dropped. It returns a boolean value of true if the object can be dropped, and false otherwise.",False,"The code snippet defines a method named ""canDrop()"" that returns a boolean value of true. It is likely used to determine whether an object can be dropped or not in a certain context."
43,getTableType(),get table type ,Method,,,,,84,4,1,,"@Override
    public TableType getTableType() {
        return TableType.VIEW;
    }",False,False,"This method returns the TableType of a table, which is set to VIEW.",False,The code snippet defines a method named `getTableType()` that returns the `TableType` enum value `VIEW`. This method is likely part of a class or interface implementation and is annotated with `@Override` to indicate that it overrides a method from a superclass or interface.
44,removeChildrenAndResources(SessionLocal),remove children and resources session ,Method,"createTableViewMaybeRecursive(Schema,int,String,String,ArrayList<Parameter>,Column[],SessionLocal,boolean,boolean,boolean,Database)",,"org.h2.table.TableView+removeCurrentViewFromOtherTables() org.h2.table.TableView+removeCurrentViewFromOtherTables() org.h2.table.Table+removeChildrenAndResources(SessionLocal) org.h2.engine.Database+removeMeta(SessionLocal,int) org.h2.engine.Database+removeMeta(SessionLocal,int) org.h2.engine.DbObject+getId() org.h2.engine.DbObject+getId() org.h2.table.TableView+clearIndexCaches(Database) org.h2.table.TableView+clearIndexCaches(Database) org.h2.engine.DbObject+invalidate() org.h2.engine.DbObject+invalidate()",org.h2.engine.DbObject+database org.h2.table.TableView+querySQL org.h2.table.TableView+index org.h2.engine.DbObject+database,329,10,1,,"@Override
    public void removeChildrenAndResources(SessionLocal session) {
        removeCurrentViewFromOtherTables();
        super.removeChildrenAndResources(session);
        database.removeMeta(session, getId());
        querySQL = null;
        index = null;
        clearIndexCaches(database);
        invalidate();
    }",False,False,"This method removes children and resources associated with a session, removes the current view from other tables, removes metadata from the database, clears index caches, and invalidates the session.",False,"This code is a method called ""removeChildrenAndResources"" that overrides a superclass method. It removes the current view from other tables, removes metadata associated with the session, clears some variables and caches, and invalidates the view."
45,clearIndexCaches(Database),clear index caches database clear the cached indexes for all sessions param database the database ,Method,"recompile(SessionLocal,boolean,boolean) removeChildrenAndResources(SessionLocal)",org.h2.engine.Database+recompileInvalidViews(),org.h2.engine.Database+getSessions(boolean) org.h2.engine.Database+getSessions(boolean) org.h2.engine.SessionLocal+clearViewIndexCache() org.h2.engine.SessionLocal+clearViewIndexCache(),,278,10,9,"/** 
 * Clear the cached indexes for all sessions.
 * @param database the database
 */
","/**
     * Clear the cached indexes for all sessions.
     *
     * @param database the database
     */
    public static void clearIndexCaches(Database database) {
        for (SessionLocal s : database.getSessions(true)) {
            s.clearViewIndexCache();
        }
    }",False,False,This method clears the cached indexes for all sessions in a given database by iterating through each session and calling the clearViewIndexCache() method.,False,This code defines a method called `clearIndexCaches` that takes a `Database` object as a parameter. It iterates over all sessions in the database and calls the `clearViewIndexCache` method on each session to clear the cached indexes.
46,"getSQL(StringBuilder,int)",get sql builder sql flags ,Method,getDropSQL(),,"org.h2.engine.DbObject+isTemporary() org.h2.engine.DbObject+isTemporary() java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(char) org.h2.util.StringUtils+indent(StringBuilder,String,int,boolean) org.h2.util.StringUtils+indent(StringBuilder,String,int,boolean) java.lang.StringBuilder+append(char) org.h2.schema.SchemaObject+getSQL(StringBuilder,int)",org.h2.table.TableView+querySQL org.h2.table.TableView+querySQL,307,8,1,,"@Override
    public StringBuilder getSQL(StringBuilder builder, int sqlFlags) {
        if (isTemporary() && querySQL != null) {
            builder.append(""(\n"");
            return StringUtils.indent(builder, querySQL, 4, true).append(')');
        }
        return super.getSQL(builder, sqlFlags);
    }",False,False,"This method returns a StringBuilder object that contains SQL code. If the object is temporary and the querySQL is not null, it appends the querySQL to the builder with indentation. Otherwise, it calls the superclass's getSQL method.",False,"This code overrides the `getSQL` method and adds functionality for generating SQL queries. If the object is temporary and has a query SQL, it appends the query SQL to the builder with indentation. Otherwise, it calls the superclass's `getSQL` method."
47,getQuery(),get query ,Method,,"org.h2.command.ddl.AlterTableAlterColumn+checkViewsAreValid(DbObject) org.h2.table.InformationSchemaTable+views(SessionLocal,ArrayList<Row>,String,Table,String)",,org.h2.table.TableView+querySQL,57,3,1,,"public String getQuery() {
        return querySQL;
    }",False,False,"The function of the given method is to return the value of the variable ""querySQL"" as a string.",False,"The code contains a method named ""getQuery"" which returns a string value. This method retrieves and returns the value of a variable named ""querySQL""."
48,getScanIndex(SessionLocal),get scan index session ,Method,,,"org.h2.table.PlanItem+getIndex() org.h2.table.TableView+getBestPlanItem(SessionLocal,int[],TableFilter[],int,SortOrder,AllColumnsForPlan) org.h2.table.TableView+getBestPlanItem(SessionLocal,int[],TableFilter[],int,SortOrder,AllColumnsForPlan) org.h2.table.PlanItem+getIndex()",,149,4,1,,"@Override
    public Index getScanIndex(SessionLocal session) {
        return getBestPlanItem(session, null, null, -1, null, null).getIndex();
    }",True,True,This method returns the scan index of the best plan item for a given session.,True,"The given code is an overridden method that returns the index of the best plan item obtained by calling the ""getBestPlanItem"" method with specific parameters. It takes a session as input and returns the index of the best plan item."
49,"getScanIndex(SessionLocal,int[],TableFilter[],int,SortOrder,AllColumnsForPlan)",get scan index session masks filters filter sort order all columns set ,Method,,,"java.lang.Throwable+getMessage() java.lang.Throwable+getMessage() org.h2.message.DbException+get(int,String) org.h2.message.DbException+get(int,String) org.h2.util.HasSQL+getTraceSQL() org.h2.util.HasSQL+getTraceSQL() org.h2.table.TableView+getBestPlanItem(SessionLocal,int[],TableFilter[],int,SortOrder,AllColumnsForPlan) org.h2.table.TableView+getBestPlanItem(SessionLocal,int[],TableFilter[],int,SortOrder,AllColumnsForPlan) org.h2.table.PlanItem+getIndex() org.h2.table.PlanItem+getIndex()",org.h2.table.TableView+createException org.h2.table.TableView+createException org.h2.api.ErrorCode+VIEW_IS_INVALID_2 org.h2.table.TableView+createException,532,11,1,,"@Override
    public Index getScanIndex(SessionLocal session, int[] masks,
            TableFilter[] filters, int filter, SortOrder sortOrder,
            AllColumnsForPlan allColumnsSet) {
        if (createException != null) {
            String msg = createException.getMessage();
            throw DbException.get(ErrorCode.VIEW_IS_INVALID_2, createException, getTraceSQL(), msg);
        }
        PlanItem item = getBestPlanItem(session, masks, filters, filter, sortOrder, allColumnsSet);
        return item.getIndex();
    }",False,False,"This method returns the index for scanning based on the given session, masks, filters, filter, sortOrder, and allColumnsSet. If there is a createException, it throws a DbException with an error code and message. Otherwise, it retrieves the best plan item and returns its index.",True,"This code is an implementation of a method that returns the index used for scanning a table. It first checks if there is an exception during the creation of the index, and if so, throws a database exception. Otherwise, it retrieves the best plan item for scanning the table and returns its index."
50,canReference(),can reference ,Method,,,,,73,4,1,,"@Override
    public boolean canReference() {
        return false;
    }",True,True,The function of the method is to determine whether a reference can be made. It returns a boolean value of false.,False,"The code snippet defines a method named `canReference()` that returns a boolean value. The method is overridden from a superclass or interface and always returns `false`, indicating that referencing is not allowed."
51,getIndexes(),get indexes ,Method,,,,,79,4,1,,"@Override
    public ArrayList<Index> getIndexes() {
        return null;
    }",True,True,"This method is an overridden implementation of the ""getIndexes"" function. It returns an ArrayList of Index objects, but in this case, it always returns null.",False,"The code contains a method named ""getIndexes"" that returns an ArrayList of objects of type ""Index"". However, in this implementation, the method always returns null."
52,getMaxDataModificationId(),get max data modification id ,Method,,,org.h2.engine.Database+getModificationDataId() org.h2.engine.Database+getModificationDataId() org.h2.command.query.Query+getMaxDataModificationId() org.h2.command.query.Query+getMaxDataModificationId(),org.h2.table.TableView+createException java.lang.Long+MAX_VALUE org.h2.table.TableView+viewQuery java.lang.Long+MAX_VALUE org.h2.engine.DbObject+database org.h2.table.TableView+lastModificationCheck org.h2.table.TableView+maxDataModificationId org.h2.table.TableView+maxDataModificationId org.h2.table.TableView+viewQuery org.h2.table.TableView+lastModificationCheck org.h2.table.TableView+maxDataModificationId,701,18,1,,"@Override
    public long getMaxDataModificationId() {
        if (createException != null) {
            return Long.MAX_VALUE;
        }
        if (viewQuery == null) {
            return Long.MAX_VALUE;
        }
        // if nothing was modified in the database since the last check, and the
        // last is known, then we don't need to check again
        // this speeds up nested views
        long dbMod = database.getModificationDataId();
        if (dbMod > lastModificationCheck && maxDataModificationId <= dbMod) {
            maxDataModificationId = viewQuery.getMaxDataModificationId();
            lastModificationCheck = dbMod;
        }
        return maxDataModificationId;
    }",False,False,"This method returns the maximum data modification ID. If there is a create exception or no view query, it returns the maximum value. Otherwise, it checks if the database has been modified since the last check. If not, it returns the current maximum data modification ID.",False,"This code defines a method called `getMaxDataModificationId()` that returns the maximum data modification ID. It checks if there is an exception or if the view query is null, and if not, it compares the database modification ID with the last modification check and updates the maximum data modification ID accordingly. Finally, it returns the maximum data modification ID."
53,removeCurrentViewFromOtherTables(),remove current view from other tables ,Method,"initColumnsAndTables(SessionLocal,boolean) removeChildrenAndResources(SessionLocal)",,org.h2.table.Table+removeDependentView(TableView) org.h2.table.Table+removeDependentView(TableView) java.util.ArrayList+clear() java.util.ArrayList+clear(),org.h2.table.TableView+tables org.h2.table.TableView+tables org.h2.table.TableView+tables,219,8,2,,"private void removeCurrentViewFromOtherTables() {
        if (tables != null) {
            for (Table t : tables) {
                t.removeDependentView(this);
            }
            tables.clear();
        }
    }",False,False,This method removes the current view from other tables by iterating through the list of tables and calling the removeDependentView method on each table. It then clears the list of tables.,True,"The `removeCurrentViewFromOtherTables` method removes the current view from a list of tables. It iterates through each table in the list and calls the `removeDependentView` method on each table, passing the current view as a parameter. Finally, it clears the list of tables."
54,addDependentViewToTables(),add dependent view to tables ,Method,"initColumnsAndTables(SessionLocal,boolean)",,org.h2.table.Table+addDependentView(TableView) org.h2.table.Table+addDependentView(TableView),org.h2.table.TableView+tables,128,5,2,,"private void addDependentViewToTables() {
        for (Table t : tables) {
            t.addDependentView(this);
        }
    }",False,False,"This method adds the current view as a dependent view to each table in the ""tables"" collection.",True,"The code defines a private method called ""addDependentViewToTables"" that iterates over a collection of tables and calls the ""addDependentView"" method on each table, passing in the current object as an argument. This method is responsible for adding the current object as a dependent view to each table in the collection."
55,setOwner(User),set owner owner ,Method,"createTempView(SessionLocal,User,String,Column[],Query,Query)",,,org.h2.table.TableView+owner org.h2.table.TableView+owner,69,3,2,,"private void setOwner(User owner) {
        this.owner = owner;
    }",False,True,This method sets the owner of an object.,False,"The code defines a private method called ""setOwner"" that takes a User object as a parameter and assigns it to the ""owner"" variable of the class. This method is not accessible outside the class and is used to set the owner of an object."
56,getOwner(),get owner ,Method,,"org.h2.engine.User+hasTableRight(Table,int)",,org.h2.table.TableView+owner,52,3,1,,"public User getOwner() {
        return owner;
    }",False,True,This method returns the owner of an object.,False,"The code contains a method named ""getOwner"" which returns an object of type ""User"". This method is used to retrieve the owner of something, possibly an entity or an object."
57,"createTempView(SessionLocal,User,String,Column[],Query,Query)",create temp view session owner name column templates query top query create a temporary view out of the given query param session the session param owner the owner of the query param name the view name param column templates column templates or code null param query the prepared query param top query the top level query return the view table ,Method,,"org.h2.command.query.Query+toTable(String,Column[],ArrayList<Parameter>,boolean,Query)","org.h2.engine.Database+getMainSchema() org.h2.engine.SessionLocal+getDatabase() org.h2.engine.SessionLocal+getDatabase() org.h2.engine.Database+getMainSchema() org.h2.command.Prepared+getPlanSQL(int) org.h2.command.Prepared+getPlanSQL(int) org.h2.table.TableView+TableView(Schema,int,String,String,ArrayList<Parameter>,Column[],SessionLocal,boolean,boolean,boolean,boolean,boolean) org.h2.command.Prepared+getParameters() org.h2.command.Prepared+getParameters() org.h2.table.TableView+setTopQuery(Query) org.h2.table.TableView+setTopQuery(Query) org.h2.table.TableView+setOwner(User) org.h2.table.TableView+setOwner(User) org.h2.engine.DbObject+setTemporary(boolean) org.h2.engine.DbObject+setTemporary(boolean)",org.h2.util.HasSQL+DEFAULT_SQL_FLAGS org.h2.table.TableView+createException org.h2.table.TableView+createException,1116,27,9,"/** 
 * Create a temporary view out of the given query.
 * @param session the session
 * @param owner the owner of the query
 * @param name the view name
 * @param columnTemplates column templates, or {@code null}
 * @param query the prepared query
 * @param topQuery the top level query
 * @return the view table
 */
","/**
     * Create a temporary view out of the given query.
     *
     * @param session the session
     * @param owner the owner of the query
     * @param name the view name
     * @param columnTemplates column templates, or {@code null}
     * @param query the prepared query
     * @param topQuery the top level query
     * @return the view table
     */
    public static TableView createTempView(SessionLocal session, User owner,
            String name, Column[] columnTemplates, Query query, Query topQuery) {
        Schema mainSchema = session.getDatabase().getMainSchema();
        String querySQL = query.getPlanSQL(DEFAULT_SQL_FLAGS);
        TableView v = new TableView(mainSchema, 0, name,
                querySQL, query.getParameters(), columnTemplates, session,
                false, true /* literals have already been checked when parsing original query */,
                false, true, true);
        if (v.createException != null) {
            throw v.createException;
        }
        v.setTopQuery(topQuery);
        v.setOwner(owner);
        v.setTemporary(true);
        return v;
    }",False,True,"This method creates a temporary view using the given query, session, owner, name, column templates, and top level query. It returns the created view table.",False,"This code defines a method called `createTempView` that creates a temporary view table based on a given query. The method takes in various parameters such as the session, owner, name, column templates, and the query itself. It creates the view table using the provided information and returns it."
58,setTopQuery(Query),set top query top query ,Method,"createTempView(SessionLocal,User,String,Column[],Query,Query)",,,org.h2.table.TableView+topQuery org.h2.table.TableView+topQuery,82,3,2,,"private void setTopQuery(Query topQuery) {
        this.topQuery = topQuery;
    }",False,True,This method sets the value of the topQuery variable to the provided Query object.,False,"The code defines a private method called ""setTopQuery"" that takes a parameter of type ""Query"". This method assigns the value of the parameter to the instance variable ""topQuery"" of the current object."
59,getRowCountApproximation(SessionLocal),get row count approximation session ,Method,,,,org.h2.table.TableView+ROW_COUNT_APPROXIMATION,120,4,1,,"@Override
    public long getRowCountApproximation(SessionLocal session) {
        return ROW_COUNT_APPROXIMATION;
    }",True,True,This method returns the approximate row count of a session.,True,"The given code snippet is a method named `getRowCountApproximation` that overrides a method from a superclass or interface. It takes a `SessionLocal` object as a parameter and returns a constant value `ROW_COUNT_APPROXIMATION`, which is of type `long`. This method is used to estimate the approximate number of rows in a data set."
60,getParameterOffset(ArrayList<Parameter>),get parameter offset additional parameters get the index of the first parameter param additional parameters additional parameters return the index of the first parameter ,Method,,"org.h2.index.ViewIndex+setupQueryParameters(SessionLocal,SearchRow,SearchRow,SearchRow) org.h2.index.ViewIndex+getQuery(SessionLocal,int[])","org.h2.table.TableView+getMaxParameterIndex(ArrayList<Parameter>) org.h2.table.TableView+getMaxParameterIndex(ArrayList<Parameter>) org.h2.command.Prepared+getParameters() org.h2.command.Prepared+getParameters() java.lang.Math+max(int,int) java.lang.Math+max(int,int) org.h2.table.TableView+getMaxParameterIndex(ArrayList<Parameter>) org.h2.table.TableView+getMaxParameterIndex(ArrayList<Parameter>)",org.h2.table.TableView+topQuery org.h2.table.TableView+topQuery,510,13,1,"/** 
 * Get the index of the first parameter.
 * @param additionalParameters additional parameters
 * @return the index of the first parameter
 */
","/**
     * Get the index of the first parameter.
     *
     * @param additionalParameters additional parameters
     * @return the index of the first parameter
     */
    public int getParameterOffset(ArrayList<Parameter> additionalParameters) {
        int result = topQuery == null ? -1 : getMaxParameterIndex(topQuery.getParameters());
        if (additionalParameters != null) {
            result = Math.max(result, getMaxParameterIndex(additionalParameters));
        }
        return result + 1;
    }",True,True,"This method returns the index of the first parameter. It checks if there is a top query and gets the maximum parameter index from it. If there are additional parameters, it gets the maximum parameter index from them as well. The final result is the maximum index + 1.",False,"This code defines a method called `getParameterOffset` that takes an `ArrayList` of `Parameter` objects as a parameter. It calculates the index of the first parameter by finding the maximum parameter index from the `topQuery` and `additionalParameters` lists, and then returns the result incremented by 1."
61,getMaxParameterIndex(ArrayList<Parameter>),get max parameter index parameters ,Method,getParameterOffset(ArrayList<Parameter>) getParameterOffset(ArrayList<Parameter>),,"java.lang.Math+max(int,int) java.lang.Math+max(int,int) org.h2.expression.Parameter+getIndex() org.h2.expression.Parameter+getIndex()",,279,9,10,,"private static int getMaxParameterIndex(ArrayList<Parameter> parameters) {
        int result = -1;
        for (Parameter p : parameters) {
            if (p != null) {
                result = Math.max(result, p.getIndex());
            }
        }
        return result;
    }",False,False,This method returns the index of the parameter with the highest index value in the given ArrayList of Parameter objects.,False,"The code defines a private static method named ""getMaxParameterIndex"" that takes an ArrayList of Parameter objects as input. It iterates through the list and returns the maximum index value of the non-null Parameter objects."
62,isRecursive(),is recursive ,Method,,"org.h2.command.query.Select+getPlanSQL(int) org.h2.table.TableFilter+getPlanSQL(StringBuilder,boolean,int)",,org.h2.table.TableView+allowRecursive,67,3,1,,"public boolean isRecursive() {
        return allowRecursive;
    }",False,False,The function of the method isRecursive is to return a boolean value indicating whether recursion is allowed or not.,False,"The code contains a method named ""isRecursive"" which returns a boolean value. It checks whether recursion is allowed or not by returning the value of the variable ""allowRecursive""."
63,isDeterministic(),is deterministic ,Method,,,org.h2.command.query.Query+isEverything(ExpressionVisitor) org.h2.command.query.Query+isEverything(ExpressionVisitor),org.h2.table.TableView+allowRecursive org.h2.table.TableView+viewQuery org.h2.table.TableView+viewQuery org.h2.expression.ExpressionVisitor+DETERMINISTIC_VISITOR,221,7,1,,"@Override
    public boolean isDeterministic() {
        if (allowRecursive || viewQuery == null) {
            return false;
        }
        return viewQuery.isEverything(ExpressionVisitor.DETERMINISTIC_VISITOR);
    }",False,False,"This method checks if the query is deterministic by returning false if either allowRecursive is true or viewQuery is null. Otherwise, it checks if viewQuery is everything using a specific visitor.",False,"The code is implementing a method called ""isDeterministic()"" which returns a boolean value. It checks if a certain condition is met and returns false if it is, otherwise it calls a method on a viewQuery object and returns its result."
64,setRecursiveResult(ResultInterface),set recursive result value ,Method,,"org.h2.index.ViewIndex+findRecursive(SearchRow,SearchRow) org.h2.index.ViewIndex+findRecursive(SearchRow,SearchRow) org.h2.index.ViewIndex+findRecursive(SearchRow,SearchRow)",org.h2.result.ResultInterface+close() org.h2.result.ResultInterface+close(),org.h2.table.TableView+recursiveResult org.h2.table.TableView+recursiveResult org.h2.table.TableView+recursiveResult org.h2.table.TableView+recursiveResult,185,6,1,,"public void setRecursiveResult(ResultInterface value) {
        if (recursiveResult != null) {
            recursiveResult.close();
        }
        this.recursiveResult = value;
    }",False,False,"This method sets the value of the recursiveResult variable. If the variable is not null, it closes the previous value before assigning the new value.",False,"The code defines a method called ""setRecursiveResult"" that takes a parameter of type ""ResultInterface"". It checks if the current ""recursiveResult"" is not null and closes it if it is. Then, it assigns the input value to the ""recursiveResult"" variable."
65,getRecursiveResult(),get recursive result ,Method,,"org.h2.index.ViewIndex+findRecursive(SearchRow,SearchRow)",,org.h2.table.TableView+recursiveResult,83,3,1,,"public ResultInterface getRecursiveResult() {
        return recursiveResult;
    }",False,False,This method returns the value of the recursiveResult variable.,False,"The code contains a method named ""getRecursiveResult"" which returns an object of type ""ResultInterface"". This method is used to retrieve the value of the ""recursiveResult"" variable."
66,addDependencies(HashSet<DbObject>),add dependencies dependencies ,Method,,,org.h2.table.Table+addDependencies(HashSet<DbObject>) org.h2.table.Table+getTableType() org.h2.table.Table+getTableType() org.h2.table.Table+addDependencies(HashSet<DbObject>) org.h2.table.Table+addDependencies(HashSet<DbObject>),org.h2.table.TableView+tables org.h2.table.TableView+tables,346,11,1,,"@Override
    public void addDependencies(HashSet<DbObject> dependencies) {
        super.addDependencies(dependencies);
        if (tables != null) {
            for (Table t : tables) {
                if (TableType.VIEW != t.getTableType()) {
                    t.addDependencies(dependencies);
                }
            }
        }
    }",True,True,"This method adds dependencies to a set of database objects. It first calls the superclass method to add dependencies. Then, it iterates over a list of tables and adds their dependencies to the set, excluding tables of type VIEW.",True,"This code is an overridden method that adds dependencies to a HashSet of DbObjects. It first calls the superclass's addDependencies method, then iterates through a list of tables and adds their dependencies to the HashSet, excluding tables of type VIEW."
67,CacheKey,cache key the key of the index cache for views ,MemberClass,,,"org.h2.table.TableView.CacheKey+CacheKey(int[],TableView) org.h2.table.TableView.CacheKey+hashCode() java.util.Arrays+hashCode(int[]) java.util.Arrays+hashCode(int[]) java.lang.Object+hashCode() java.lang.Object+hashCode() org.h2.table.TableView.CacheKey+equals(Object) java.lang.Object+getClass() java.lang.Object+getClass() java.lang.Object+getClass() java.lang.Object+getClass() java.util.Arrays+equals(int[],int[]) java.util.Arrays+equals(int[],int[])",org.h2.table.TableView.CacheKey+masks org.h2.table.TableView.CacheKey+view org.h2.table.TableView.CacheKey+masks org.h2.table.TableView.CacheKey+view org.h2.table.TableView.CacheKey+masks org.h2.table.TableView.CacheKey+view org.h2.table.TableView.CacheKey+view org.h2.table.TableView.CacheKey+view org.h2.table.TableView.CacheKey+masks org.h2.table.TableView.CacheKey+masks,1061,40,26,"/** 
 * The key of the index cache for views.
 */
","/**
     * The key of the index cache for views.
     */
    private static final class CacheKey {

        private final int[] masks;
        private final TableView view;

        CacheKey(int[] masks, TableView view) {
            this.masks = masks;
            this.view = view;
        }

        @Override
        public int hashCode() {
            final int prime = 31;
            int result = 1;
            result = prime * result + Arrays.hashCode(masks);
            result = prime * result + view.hashCode();
            return result;
        }

        @Override
        public boolean equals(Object obj) {
            if (this == obj) {
                return true;
            }
            if (obj == null) {
                return false;
            }
            if (getClass() != obj.getClass()) {
                return false;
            }
            CacheKey other = (CacheKey) obj;
            if (view != other.view) {
                return false;
            }
            return Arrays.equals(masks, other.masks);
        }
    }",False,False,"/** 
 * The key of the index cache for views.
 */
",False,"/** 
 * The key of the index cache for views.
 */
"
68,isRecursiveQueryDetected(),is recursive query detected was query recursion detected during compiling return true if yes ,Method,"createTableViewMaybeRecursive(Schema,int,String,String,ArrayList<Parameter>,Column[],SessionLocal,boolean,boolean,boolean,Database)",,,org.h2.table.TableView+isRecursiveQueryDetected,194,8,1,"/** 
 * Was query recursion detected during compiling.
 * @return true if yes
 */
","/**
     * Was query recursion detected during compiling.
     *
     * @return true if yes
     */
    public boolean isRecursiveQueryDetected() {
        return isRecursiveQueryDetected;
    }",False,False,This method serves to check if query recursion was detected during compiling and returns a boolean value indicating whether it was detected or not.,False,"The code contains a method named ""isRecursiveQueryDetected"" which returns a boolean value indicating whether query recursion was detected during compiling. The method does not take any parameters and simply returns the value of a boolean variable named ""isRecursiveQueryDetected""."
69,isRecursiveQueryExceptionDetected(DbException),is recursive query exception detected exception does exception indicate query recursion ,Method,"initColumnsAndTables(SessionLocal,boolean)",,org.h2.message.DbException+getErrorCode() org.h2.message.DbException+getErrorCode() java.lang.String+contains(CharSequence) java.lang.Throwable+getMessage() java.lang.Throwable+getMessage() java.lang.String+contains(CharSequence) org.h2.engine.DbObject+getName() org.h2.engine.DbObject+getName(),org.h2.api.ErrorCode+TABLE_OR_VIEW_NOT_FOUND_1 org.h2.api.ErrorCode+TABLE_OR_VIEW_NOT_FOUND_DATABASE_EMPTY_1 org.h2.api.ErrorCode+TABLE_OR_VIEW_NOT_FOUND_WITH_CANDIDATES_2,617,16,2,"/** 
 * Does exception indicate query recursion?
 */
","/**
     * Does exception indicate query recursion?
     */
    private boolean isRecursiveQueryExceptionDetected(DbException exception) {
        if (exception == null) {
            return false;
        }
        int errorCode = exception.getErrorCode();
        if (errorCode != ErrorCode.TABLE_OR_VIEW_NOT_FOUND_1 &&
                errorCode != ErrorCode.TABLE_OR_VIEW_NOT_FOUND_DATABASE_EMPTY_1 &&
                errorCode != ErrorCode.TABLE_OR_VIEW_NOT_FOUND_WITH_CANDIDATES_2
        ) {
            return false;
        }
        return exception.getMessage().contains(""\"""" + this.getName() + ""\"""");
    }",False,False,"This method checks if the given exception indicates a query recursion by checking the error code and the message of the exception. It returns true if the exception indicates query recursion, otherwise false.",False,"The method `isRecursiveQueryExceptionDetected` checks if a given `DbException` indicates a query recursion by examining its error code and message. It returns `true` if the error code corresponds to a table or view not found exception and the exception message contains the name of the current object. Otherwise, it returns `false`."
70,getTables(),get tables ,Method,,org.h2.command.ddl.DropView+update(),,org.h2.table.TableView+tables,61,3,1,,"public List<Table> getTables() {
        return tables;
    }",False,False,This method returns a list of tables.,False,"The code defines a method named ""getTables"" that returns a list of objects of type ""Table"". This method retrieves and returns the list of tables."
71,"createTableViewMaybeRecursive(Schema,int,String,String,ArrayList<Parameter>,Column[],SessionLocal,boolean,boolean,boolean,Database)",create table view maybe recursive schema id name query sql parameters column templates session literals checked is table expression is temporary db create a view param schema the schema param id the view id param name the view name param query sql the query param parameters the parameters param column templates the columns param session the session param literals checked whether literals in the query are checked param is table expression if this is a table expression param is temporary whether the view is persisted param db the database return the view ,Method,,org.h2.command.ddl.CreateView+update(Schema),"org.h2.table.TableView+createShadowTableForRecursiveTableExpression(boolean,SessionLocal,String,Schema,List<Column>,Database) org.h2.table.TableView+createShadowTableForRecursiveTableExpression(boolean,SessionLocal,String,Schema,List<Column>,Database) java.util.Arrays+asList(T[]) java.util.Arrays+asList(T[]) java.util.ArrayList+add(E) java.util.ArrayList+add(E) org.h2.table.Column+getName() org.h2.table.Column+getName() org.h2.engine.SessionLocal+prepare(String,boolean,boolean) org.h2.engine.SessionLocal+prepare(String,boolean,boolean) org.h2.command.Prepared+setSession(SessionLocal) org.h2.command.Prepared+setSession(SessionLocal) org.h2.table.TableView+createQueryColumnTemplateList(String[],Query,String[]) org.h2.table.TableView+createQueryColumnTemplateList(String[],Query,String[]) java.util.ArrayList+toArray(T[]) java.util.ArrayList+toArray(T[]) org.h2.table.TableView+destroyShadowTableForRecursiveExpression(boolean,SessionLocal,Table) org.h2.table.TableView+destroyShadowTableForRecursiveExpression(boolean,SessionLocal,Table) org.h2.table.TableView+TableView(Schema,int,String,String,ArrayList<Parameter>,Column[],SessionLocal,boolean,boolean,boolean,boolean,boolean) java.util.List+toArray(T[]) java.util.List+toArray(T[]) org.h2.table.TableView+isRecursiveQueryDetected() org.h2.table.TableView+isRecursiveQueryDetected() org.h2.engine.Database+addSchemaObject(SessionLocal,SchemaObject) org.h2.engine.Database+addSchemaObject(SessionLocal,SchemaObject) org.h2.table.Table+lock(SessionLocal,int) org.h2.table.Table+lock(SessionLocal,int) org.h2.engine.Database+removeSchemaObject(SessionLocal,SchemaObject) org.h2.engine.SessionLocal+getDatabase() org.h2.engine.SessionLocal+getDatabase() org.h2.engine.Database+removeSchemaObject(SessionLocal,SchemaObject) org.h2.table.TableView+removeChildrenAndResources(SessionLocal) org.h2.table.TableView+removeChildrenAndResources(SessionLocal) org.h2.engine.SessionLocal+removeLocalTempTable(Table) org.h2.engine.SessionLocal+removeLocalTempTable(Table) org.h2.table.TableView+TableView(Schema,int,String,String,ArrayList<Parameter>,Column[],SessionLocal,boolean,boolean,boolean,boolean,boolean)",org.h2.table.Table+EXCLUSIVE_LOCK,3041,70,9,"/** 
 * Create a view.
 * @param schema the schema
 * @param id the view id
 * @param name the view name
 * @param querySQL the query
 * @param parameters the parameters
 * @param columnTemplates the columns
 * @param session the session
 * @param literalsChecked whether literals in the query are checked
 * @param isTableExpression if this is a table expression
 * @param isTemporary whether the view is persisted
 * @param db the database
 * @return the view
 */
","/**
     * Create a view.
     *
     * @param schema the schema
     * @param id the view id
     * @param name the view name
     * @param querySQL the query
     * @param parameters the parameters
     * @param columnTemplates the columns
     * @param session the session
     * @param literalsChecked whether literals in the query are checked
     * @param isTableExpression if this is a table expression
     * @param isTemporary whether the view is persisted
     * @param db the database
     * @return the view
     */
    public static TableView createTableViewMaybeRecursive(Schema schema, int id, String name, String querySQL,
            ArrayList<Parameter> parameters, Column[] columnTemplates, SessionLocal session,
            boolean literalsChecked, boolean isTableExpression, boolean isTemporary, Database db) {


        Table recursiveTable = createShadowTableForRecursiveTableExpression(isTemporary, session, name,
                schema, Arrays.asList(columnTemplates), db);

        List<Column> columnTemplateList;
        String[] querySQLOutput = new String[1];
        ArrayList<String> columnNames = new ArrayList<>();
        for (Column columnTemplate: columnTemplates) {
            columnNames.add(columnTemplate.getName());
        }

        try {
            Prepared withQuery = session.prepare(querySQL, false, false);
            if (!isTemporary) {
                withQuery.setSession(session);
            }
            columnTemplateList = TableView.createQueryColumnTemplateList(columnNames.toArray(new String[1]),
                    (Query) withQuery, querySQLOutput);

        } finally {
            destroyShadowTableForRecursiveExpression(isTemporary, session, recursiveTable);
        }

        // build with recursion turned on
        TableView view = new TableView(schema, id, name, querySQL,
                parameters, columnTemplateList.toArray(columnTemplates), session,
                true/* try recursive */, literalsChecked, isTableExpression, isTemporary, false);

        // is recursion really detected ? if not - recreate it without recursion flag
        // and no recursive index
        if (!view.isRecursiveQueryDetected()) {
            if (!isTemporary) {
                db.addSchemaObject(session, view);
                view.lock(session, Table.EXCLUSIVE_LOCK);
                session.getDatabase().removeSchemaObject(session, view);

                // during database startup - this method does not normally get called - and it
                // needs to be to correctly un-register the table which the table expression
                // uses...
                view.removeChildrenAndResources(session);
            } else {
                session.removeLocalTempTable(view);
            }
            view = new TableView(schema, id, name, querySQL, parameters,
                    columnTemplates, session,
                    false/* detected not recursive */, literalsChecked, isTableExpression, isTemporary, false);
        }

        return view;
    }",False,False,"This method creates a view in a database. It takes various parameters such as the schema, view id, view name, query, parameters, columns, session, and other flags. It creates a shadow table for recursive table expressions, prepares the query, and creates the view with recursion turned on. If recursion is not detected, it recreates the view without recursion. Finally, it returns the created view.",False,"This code defines a method called `createTableViewMaybeRecursive` that creates a view in a database. It takes various parameters such as the schema, view id, name, query, parameters, columns, session, and database. The method creates the view and handles recursion if detected, and returns the created view."
72,"createQueryColumnTemplateList(String[],Query,String[])",create query column template list cols the query query sql output creates a list of column templates from a query usually from with query but could be any query param cols an optional list of column names can be specified by wit hclause overriding usual select names param the query the query object we want the column list for param query sql output array of length 1 to receive extra output fieldin addition to return value containing the sql query of the query object return a list of column object returned by with query ,Method,"createTableViewMaybeRecursive(Schema,int,String,String,ArrayList<Parameter>,Column[],SessionLocal,boolean,boolean,boolean,Database)",org.h2.command.Parser+readDerivedTableWithCorrelation(),"org.h2.command.query.Query+prepare() org.h2.command.query.Query+prepare() org.h2.util.StringUtils+cache(String) org.h2.util.StringUtils+cache(String) org.h2.command.Prepared+getPlanSQL(int) org.h2.command.Prepared+getPlanSQL(int) org.h2.command.Prepared+getSession() org.h2.command.Prepared+getSession() org.h2.command.query.Query+getExpressions() org.h2.command.query.Query+getExpressions() java.util.ArrayList+size() java.util.ArrayList+size() java.util.ArrayList+get(int) java.util.ArrayList+get(int) org.h2.expression.Expression+getColumnNameForView(SessionLocal,int) org.h2.expression.Expression+getColumnNameForView(SessionLocal,int) java.util.List+add(E) java.util.List+add(E) org.h2.table.Column+Column(String,TypeInfo) org.h2.expression.Expression+getType() org.h2.expression.Expression+getType()",org.h2.util.HasSQL+ADD_PLAN_INFORMATION,1685,32,9,"/** 
 * Creates a list of column templates from a query (usually from WITH query, but could be any query)
 * @param cols - an optional list of column names (can be specified by WITHclause overriding usual select names)
 * @param theQuery - the query object we want the column list for
 * @param querySQLOutput - array of length 1 to receive extra 'output' fieldin addition to return value - containing the SQL query of the Query object
 * @return a list of column object returned by withQuery
 */
","/**
     * Creates a list of column templates from a query (usually from WITH query,
     * but could be any query)
     *
     * @param cols - an optional list of column names (can be specified by WITH
     *            clause overriding usual select names)
     * @param theQuery - the query object we want the column list for
     * @param querySQLOutput - array of length 1 to receive extra 'output' field
     *            in addition to return value - containing the SQL query of the
     *            Query object
     * @return a list of column object returned by withQuery
     */
    public static List<Column> createQueryColumnTemplateList(String[] cols,
            Query theQuery, String[] querySQLOutput) {
        List<Column> columnTemplateList = new ArrayList<>();
        theQuery.prepare();
        // String array of length 1 is to receive extra 'output' field in addition to
        // return value
        querySQLOutput[0] = StringUtils.cache(theQuery.getPlanSQL(ADD_PLAN_INFORMATION));
        SessionLocal session = theQuery.getSession();
        ArrayList<Expression> withExpressions = theQuery.getExpressions();
        for (int i = 0; i < withExpressions.size(); ++i) {
            Expression columnExp = withExpressions.get(i);
            // use the passed in column name if supplied, otherwise use alias
            // (if found) otherwise use column name derived from column
            // expression
            String columnName = cols != null && cols.length > i ? cols[i] : columnExp.getColumnNameForView(session, i);
            columnTemplateList.add(new Column(columnName, columnExp.getType()));

        }
        return columnTemplateList;
    }",True,True,"This method creates a list of column templates from a query. It takes in optional column names, the query object, and an array to receive the SQL query. It returns a list of column objects.",False,"This code defines a method called `createQueryColumnTemplateList` that takes in an optional list of column names, a query object, and an array to store the SQL query. It creates a list of column objects based on the query's expressions, using the provided column names or aliases if available, and returns the list."
73,"createShadowTableForRecursiveTableExpression(boolean,SessionLocal,String,Schema,List<Column>,Database)",create shadow table for recursive table expression is temporary target session cte view name schema columns db create a table for a recursive query param is temporary whether the table is persisted param target session the session param cte view name the name param schema the schema param columns the columns param db the database return the table ,Method,"createTableViewMaybeRecursive(Schema,int,String,String,ArrayList<Parameter>,Column[],SessionLocal,boolean,boolean,boolean,Database)",,"org.h2.command.ddl.CreateTableData+CreateTableData() org.h2.engine.Database+allocateObjectId() org.h2.engine.Database+allocateObjectId() org.h2.schema.Schema+createTable(CreateTableData) org.h2.schema.Schema+createTable(CreateTableData) org.h2.engine.Database+unlockMeta(SessionLocal) org.h2.engine.Database+unlockMeta(SessionLocal) org.h2.engine.Database+addSchemaObject(SessionLocal,SchemaObject) org.h2.engine.Database+addSchemaObject(SessionLocal,SchemaObject) org.h2.engine.SessionLocal+addLocalTempTable(Table) org.h2.engine.SessionLocal+addLocalTempTable(Table)",org.h2.command.ddl.CreateTableData+id org.h2.command.ddl.CreateTableData+columns org.h2.command.ddl.CreateTableData+tableName org.h2.command.ddl.CreateTableData+temporary org.h2.command.ddl.CreateTableData+persistData org.h2.command.ddl.CreateTableData+persistIndexes org.h2.command.ddl.CreateTableData+session,1531,38,9,"/** 
 * Create a table for a recursive query.
 * @param isTemporary whether the table is persisted
 * @param targetSession the session
 * @param cteViewName the name
 * @param schema the schema
 * @param columns the columns
 * @param db the database
 * @return the table
 */
","/**
     * Create a table for a recursive query.
     *
     * @param isTemporary whether the table is persisted
     * @param targetSession the session
     * @param cteViewName the name
     * @param schema the schema
     * @param columns the columns
     * @param db the database
     * @return the table
     */
    public static Table createShadowTableForRecursiveTableExpression(boolean isTemporary, SessionLocal targetSession,
            String cteViewName, Schema schema, List<Column> columns, Database db) {

        // create table data object
        CreateTableData recursiveTableData = new CreateTableData();
        recursiveTableData.id = db.allocateObjectId();
        recursiveTableData.columns = new ArrayList<>(columns);
        recursiveTableData.tableName = cteViewName;
        recursiveTableData.temporary = isTemporary;
        recursiveTableData.persistData = true;
        recursiveTableData.persistIndexes = !isTemporary;
        recursiveTableData.session = targetSession;

        // this gets a meta table lock that is not released
        Table recursiveTable = schema.createTable(recursiveTableData);

        if (!isTemporary) {
            // this unlock is to prevent lock leak from schema.createTable()
            db.unlockMeta(targetSession);
            synchronized (targetSession) {
                db.addSchemaObject(targetSession, recursiveTable);
            }
        } else {
            targetSession.addLocalTempTable(recursiveTable);
        }
        return recursiveTable;
    }",False,False,"This method creates a table for a recursive query. It takes in parameters such as whether the table is temporary or persisted, the session, name, schema, columns, and database. It creates a table data object, sets its properties, and creates the table in the schema. If the table is not temporary, it adds the table to the database and releases the lock. If the table is temporary, it adds the table to the session's local temporary tables. Finally, it returns the created table.",False,"This code defines a method called `createShadowTableForRecursiveTableExpression` that creates a table for a recursive query. It takes in parameters such as whether the table is temporary or not, the session, table name, schema, columns, and database. It creates the table, adds it to the schema or session, and returns the created table."
74,"destroyShadowTableForRecursiveExpression(boolean,SessionLocal,Table)",destroy shadow table for recursive expression is temporary target session recursive table remove a table for a recursive query param is temporary whether the table is persisted param target session the session param recursive table the table ,Method,"createTableViewMaybeRecursive(Schema,int,String,String,ArrayList<Parameter>,Column[],SessionLocal,boolean,boolean,boolean,Database)",,"org.h2.table.Table+lock(SessionLocal,int) org.h2.table.Table+lock(SessionLocal,int) org.h2.engine.Database+removeSchemaObject(SessionLocal,SchemaObject) org.h2.engine.SessionLocal+getDatabase() org.h2.engine.SessionLocal+getDatabase() org.h2.engine.Database+removeSchemaObject(SessionLocal,SchemaObject) org.h2.engine.SessionLocal+removeLocalTempTable(Table) org.h2.engine.SessionLocal+removeLocalTempTable(Table) org.h2.engine.Database+unlockMeta(SessionLocal) org.h2.engine.SessionLocal+getDatabase() org.h2.engine.SessionLocal+getDatabase() org.h2.engine.Database+unlockMeta(SessionLocal)",org.h2.table.Table+EXCLUSIVE_LOCK,875,22,9,"/** 
 * Remove a table for a recursive query.
 * @param isTemporary whether the table is persisted
 * @param targetSession the session
 * @param recursiveTable the table
 */
","/**
     * Remove a table for a recursive query.
     *
     * @param isTemporary whether the table is persisted
     * @param targetSession the session
     * @param recursiveTable the table
     */
    public static void destroyShadowTableForRecursiveExpression(boolean isTemporary, SessionLocal targetSession,
            Table recursiveTable) {
        if (recursiveTable != null) {
            if (!isTemporary) {
                recursiveTable.lock(targetSession, Table.EXCLUSIVE_LOCK);
                targetSession.getDatabase().removeSchemaObject(targetSession, recursiveTable);

            } else {
                targetSession.removeLocalTempTable(recursiveTable);
            }

            // both removeSchemaObject and removeLocalTempTable hold meta locks - release them here
            targetSession.getDatabase().unlockMeta(targetSession);
        }
    }",False,False,"This method serves to remove a table used for a recursive query. It takes in parameters to determine if the table is temporary or not, the session, and the table itself. If the table is not temporary, it locks the table, removes it from the session's database, and releases the meta locks. If the table is temporary, it simply removes it from the session's local temporary tables and releases the meta locks.",False,"This code defines a method called `destroyShadowTableForRecursiveExpression` that removes a table used in a recursive query. It takes parameters indicating whether the table is temporary, the session, and the table itself. The method locks the table, removes it from the session's database, or removes it from the session's local temporary tables, depending on its persistence. Finally, it releases the meta locks held during the process."
