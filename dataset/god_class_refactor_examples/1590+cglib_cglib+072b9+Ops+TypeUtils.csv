index,name,document,type,inner invocations,external invocations,calls,visits,length,lines,modifier,commit,full text,moved,removed,gpt text,gpt response,code summary
1,SWITCH_STYLE_TRIE,switch style trie ,Field,,,,,46,1,25,,public static final int SWITCH_STYLE_TRIE = 0;,False,False,,False,
2,SWITCH_STYLE_HASH,switch style hash ,Field,,,,,46,1,25,,public static final int SWITCH_STYLE_HASH = 1;,False,False,,False,
3,FIND_CLASS,find class ,Field,,,,,99,2,26,,"private static final Signature FIND_CLASS =
      Signature.parse(""Class CGLIB$findClass(String)"");",False,False,,False,
4,Ops(),ops ,Method,,,,,21,2,2,,"private Ops() {
    }",False,False,"The function of the private Ops() method is not clear without further context. It could be used for initialization, utility operations, or as a placeholder for future implementation.",True,"The code snippet defines a private constructor for a class named ""Ops"". This constructor is empty and does not take any parameters. It is likely used to prevent the instantiation of the ""Ops"" class from outside the class itself."
5,load_class_this(Emitter),load class this e ,Method,,"net.sf.cglib.MethodInterceptor+generateStatic(Emitter,Context)","net.sf.cglib.core.Ops+load_class_helper(Emitter,Type) net.sf.cglib.core.Ops+load_class_helper(Emitter,Type) net.sf.cglib.core.Emitter+getClassType() net.sf.cglib.core.Emitter+getClassType()",,101,3,9,,"public static void load_class_this(Emitter e) {
        load_class_helper(e, e.getClassType());
    }",False,True,The function of the given method is to load a class using the provided Emitter object and its class type.,True,"The code defines a static method called ""load_class_this"" that takes an ""Emitter"" object as a parameter. It calls another method called ""load_class_helper"" with the ""Emitter"" object and its class type as arguments. The purpose of this code is to load the class of the ""Emitter"" object."
6,"load_class(Emitter,Type)",load class e type ,Method,"load_method(Emitter,Method) push_object(Emitter,Object)",,"net.sf.cglib.core.Emitter+isPrimitive(Type) net.sf.cglib.core.Emitter+isPrimitive(Type) java.lang.IllegalArgumentException+IllegalArgumentException(String) net.sf.cglib.core.Emitter+getstatic(Type,String,Type) net.sf.cglib.core.Emitter+getstatic(Type,String,Type) net.sf.cglib.core.Ops+getBoxedType(Type) net.sf.cglib.core.Ops+getBoxedType(Type) net.sf.cglib.core.Ops+load_class_helper(Emitter,Type) net.sf.cglib.core.Ops+load_class_helper(Emitter,Type)",org.objectweb.asm.Type+VOID_TYPE net.sf.cglib.core.Types+CLASS,366,10,9,,"public static void load_class(Emitter e, Type type) {
        if (Emitter.isPrimitive(type)) {
            if (type == Type.VOID_TYPE) {
                throw new IllegalArgumentException(""cannot load void type"");
            }
            e.getstatic(getBoxedType(type), ""TYPE"", Types.CLASS);
        } else {
            load_class_helper(e, type);
        }
    }",False,True,"The function of this method is to load a class based on the given emitter and type. If the type is a primitive type, it checks if it is void and throws an exception if it is. Otherwise, it calls the helper method to load the class.",True,"The given code is a method named ""load_class"" that takes an Emitter object and a Type object as parameters. It checks if the Type is a primitive type, and if so, it throws an exception for void type. Otherwise, it calls the ""load_class_helper"" method to load the class."
7,"load_method(Emitter,Method)",load method e method ,Method,,"net.sf.cglib.InvocationHandler+generateStatic(Emitter,Context) net.sf.cglib.MethodInterceptor+generateStatic(Emitter,Context)","net.sf.cglib.core.Ops+load_class(Emitter,Type) net.sf.cglib.core.Ops+load_class(Emitter,Type) org.objectweb.asm.Type+getType(Class) org.objectweb.asm.Type+getType(Class) java.lang.reflect.Method+getDeclaringClass() java.lang.reflect.Method+getDeclaringClass() net.sf.cglib.core.Emitter+push(String) net.sf.cglib.core.Emitter+push(String) java.lang.reflect.Method+getName() java.lang.reflect.Method+getName() net.sf.cglib.core.Ops+push_object(Emitter,Object) net.sf.cglib.core.Ops+push_object(Emitter,Object) java.lang.reflect.Method+getParameterTypes() java.lang.reflect.Method+getParameterTypes() net.sf.cglib.core.Emitter+invoke_virtual(Type,Signature) net.sf.cglib.core.Emitter+invoke_virtual(Type,Signature)",net.sf.cglib.core.Types+CLASS net.sf.cglib.core.Signatures+GET_DECLARED_METHOD,286,6,9,,"public static void load_method(Emitter e, Method method) {
        load_class(e, Type.getType(method.getDeclaringClass()));
        e.push(method.getName());
        push_object(e, method.getParameterTypes());
        e.invoke_virtual(Types.CLASS, Signatures.GET_DECLARED_METHOD);
    }",False,True,"The function of the given method is to load a method by invoking the ""load_class"" method with the declaring class, pushing the method name, pushing the parameter types, and then invoking the virtual method ""GET_DECLARED_METHOD"" on the class.",True,"The given code is a method named ""load_method"" that takes an Emitter object and a Method object as parameters. It loads the class of the method's declaring class, pushes the method's name onto the stack, pushes the method's parameter types as objects onto the stack, and then invokes the virtual method ""GET_DECLARED_METHOD"" on the Class object."
8,"load_class_helper(Emitter,Type)",load class helper e type ,Method,"load_class_this(Emitter) load_class(Emitter,Type)",,"net.sf.cglib.core.Emitter+register(Object,FinalizeCallback) net.sf.cglib.core.Emitter+register(Object,FinalizeCallback) +() +process()",net.sf.cglib.core.Ops+FIND_CLASS,322,9,10,,"private static void load_class_helper(final Emitter e, Type type) {
        e.register(FIND_CLASS, new Emitter.FinalizeCallback() {
            public void process() {
                generateFindClass(e);
            }
        });
        e.push(emulateClassGetName(type));
        e.invoke_static_this(FIND_CLASS);
    }",False,True,"This method is used to load a class by registering a callback function, generating a findClass method, pushing the class name onto the stack, and invoking the findClass method.",True,"The code defines a private static method called ""load_class_helper"" that takes an Emitter object and a Type object as parameters. Within the method, a FinalizeCallback is registered with the Emitter object, which generates a ""findClass"" method. The ""findClass"" method is then invoked with the ""emulateClassGetName"" value of the given Type object."
9,emulateClassGetName(Type),emulate class get name type ,Method,,,"net.sf.cglib.core.Emitter+isPrimitive(Type) net.sf.cglib.core.Emitter+isPrimitive(Type) net.sf.cglib.core.Emitter+isArray(Type) net.sf.cglib.core.Emitter+isArray(Type) java.lang.String+replace(char,char) org.objectweb.asm.Type+getDescriptor() org.objectweb.asm.Type+getDescriptor() java.lang.String+replace(char,char) org.objectweb.asm.Type+getClassName() org.objectweb.asm.Type+getClassName()",,252,7,10,,"private static String emulateClassGetName(Type type) {
        if (Emitter.isPrimitive(type) || Emitter.isArray(type)) {
            return type.getDescriptor().replace('/', '.');
        } else {
            return type.getClassName();
        }
    }",True,True,"The function emulates the behavior of the getClass().getName() method for a given Type object. It returns the fully qualified class name if the type is not a primitive or an array, otherwise it returns the descriptor of the type.",False,"The given code is a private static method named ""emulateClassGetName"" that takes a ""Type"" parameter and returns a string. It checks if the type is a primitive or an array, and if so, it returns the descriptor of the type with '/' replaced by '.'. Otherwise, it returns the class name of the type."
10,generateFindClass(Emitter),generate find class e ,Method,,,"net.sf.cglib.core.Emitter+begin_method(int,Signature,Type[]) net.sf.cglib.core.Emitter+begin_method(int,Signature,Type[]) net.sf.cglib.core.Emitter+begin_block() net.sf.cglib.core.Emitter+begin_block() net.sf.cglib.core.Emitter+load_arg(int) net.sf.cglib.core.Emitter+load_arg(int) net.sf.cglib.core.Emitter+invoke_static(Type,Signature) net.sf.cglib.core.Emitter+invoke_static(Type,Signature) net.sf.cglib.core.Emitter+return_value() net.sf.cglib.core.Emitter+return_value() net.sf.cglib.core.Emitter+end_block() net.sf.cglib.core.Emitter+end_block() net.sf.cglib.core.Emitter+catch_exception(Block,Type) net.sf.cglib.core.Emitter+catch_exception(Block,Type) net.sf.cglib.core.Emitter+invoke_virtual(Type,Signature) net.sf.cglib.core.Emitter+invoke_virtual(Type,Signature) net.sf.cglib.core.Emitter+new_instance(Type) net.sf.cglib.core.Emitter+new_instance(Type) net.sf.cglib.core.Emitter+dup_x1() net.sf.cglib.core.Emitter+dup_x1() net.sf.cglib.core.Emitter+swap() net.sf.cglib.core.Emitter+swap() net.sf.cglib.core.Emitter+invoke_constructor(Type,Signature) net.sf.cglib.core.Emitter+invoke_constructor(Type,Signature) net.sf.cglib.core.Emitter+athrow() net.sf.cglib.core.Emitter+athrow()",net.sf.cglib.core.Constants+PRIVATE_FINAL_STATIC net.sf.cglib.core.Ops+FIND_CLASS net.sf.cglib.core.Types+CLASS net.sf.cglib.core.Signatures+FOR_NAME net.sf.cglib.core.Types+CLASS_NOT_FOUND_EXCEPTION net.sf.cglib.core.Types+THROWABLE net.sf.cglib.core.Signatures+GET_MESSAGE net.sf.cglib.core.Types+NO_CLASS_DEF_FOUND_ERROR net.sf.cglib.core.Types+NO_CLASS_DEF_FOUND_ERROR net.sf.cglib.core.Signatures+CSTRUCT_STRING,986,24,10,,"private static void generateFindClass(Emitter e) {
        /* generates:
           static private Class findClass(String name) throws Exception {
               try {
                   return Class.forName(name);
               } catch (java.lang.ClassNotFoundException cne) {
                   throw new java.lang.NoClassDefFoundError(cne.getMessage());
               }
           }
         */
        e.begin_method(Constants.PRIVATE_FINAL_STATIC, FIND_CLASS, null);
        Block block = e.begin_block();
        e.load_arg(0);
        e.invoke_static(Types.CLASS, Signatures.FOR_NAME);
        e.return_value();
        e.end_block();
        e.catch_exception(block, Types.CLASS_NOT_FOUND_EXCEPTION);
        e.invoke_virtual(Types.THROWABLE, Signatures.GET_MESSAGE);
        e.new_instance(Types.NO_CLASS_DEF_FOUND_ERROR);
        e.dup_x1();
        e.swap();
        e.invoke_constructor(Types.NO_CLASS_DEF_FOUND_ERROR, Signatures.CSTRUCT_STRING);
        e.athrow();
    }",False,True,"The function generates a static private method called findClass that takes a String parameter and returns a Class object. It uses the Class.forName method to find the class with the given name, and throws a NoClassDefFoundError if the class is not found.",True,"The code generates a static private method called `findClass` that takes a `String` parameter and returns a `Class` object. It uses the `Class.forName` method to find the class with the given name, and if the class is not found, it throws a `NoClassDefFoundError` with the corresponding error message."
11,create_arg_array(Emitter),create arg array e allocates and fills an object array with the arguments to the current method primitive values are inserted as their boxed object equivalents ,Method,,"net.sf.cglib.InvocationHandler+generate(Emitter,Context) net.sf.cglib.MethodInterceptor+generateAroundMethod(Emitter,Context,Method)","net.sf.cglib.core.Emitter+getArgumentTypes() net.sf.cglib.core.Emitter+getArgumentTypes() net.sf.cglib.core.Emitter+push(int) net.sf.cglib.core.Emitter+push(int) net.sf.cglib.core.Emitter+newarray() net.sf.cglib.core.Emitter+newarray() net.sf.cglib.core.Emitter+dup() net.sf.cglib.core.Emitter+dup() net.sf.cglib.core.Emitter+push(int) net.sf.cglib.core.Emitter+push(int) net.sf.cglib.core.Emitter+load_arg(int) net.sf.cglib.core.Emitter+load_arg(int) net.sf.cglib.core.Ops+box(Emitter,Type) net.sf.cglib.core.Ops+box(Emitter,Type) net.sf.cglib.core.Emitter+aastore() net.sf.cglib.core.Emitter+aastore()",,654,20,9,"/** 
 * Allocates and fills an Object[] array with the arguments to the current method. Primitive values are inserted as their boxed (Object) equivalents.
 */
","/**
     * Allocates and fills an Object[] array with the arguments to the
     * current method. Primitive values are inserted as their boxed
     * (Object) equivalents.
     */
    public static void create_arg_array(Emitter e) {
        /* generates:
           Object[] args = new Object[]{ arg1, new Integer(arg2) };
         */
        Type[] argumentTypes = e.getArgumentTypes();
        e.push(argumentTypes.length);
        e.newarray();
        for (int i = 0; i < argumentTypes.length; i++) {
            e.dup();
            e.push(i);
            e.load_arg(i);
            box(e, argumentTypes[i]);
            e.aastore();
        }
    }",False,False,The function of this method is to allocate and fill an Object[] array with the arguments to the current method. Primitive values are converted to their boxed (Object) equivalents before being inserted into the array.,True,"This code defines a method called ""create_arg_array"" that takes an Emitter object as a parameter. It creates and fills an Object[] array with the arguments passed to the current method, converting primitive values to their boxed (Object) equivalents."
12,"push(Emitter,Object[])",push e array ,Method,"push_object(Emitter,Object)","net.sf.cglib.beans.BeanMap+generateKeySet(Map,Map)","net.sf.cglib.core.Emitter+push(int) net.sf.cglib.core.Emitter+push(int) net.sf.cglib.core.Emitter+newarray(Type) net.sf.cglib.core.Emitter+newarray(Type) org.objectweb.asm.Type+getType(Class) org.objectweb.asm.Type+getType(Class) java.lang.Class+getComponentType() java.lang.Object+getClass() java.lang.Object+getClass() java.lang.Class+getComponentType() net.sf.cglib.core.Emitter+dup() net.sf.cglib.core.Emitter+dup() net.sf.cglib.core.Emitter+push(int) net.sf.cglib.core.Emitter+push(int) net.sf.cglib.core.Ops+push_object(Emitter,Object) net.sf.cglib.core.Ops+push_object(Emitter,Object) net.sf.cglib.core.Emitter+aastore() net.sf.cglib.core.Emitter+aastore()",,325,10,9,,"public static void push(Emitter e, Object[] array) {
        e.push(array.length);
        e.newarray(Type.getType(array.getClass().getComponentType()));
        for (int i = 0; i < array.length; i++) {
            e.dup();
            e.push(i);
            push_object(e, array[i]);
            e.aastore();
        }
    }",True,True,"The function of this method is to push the length of an array onto an Emitter, create a new array of the same type, and then push each element of the original array onto the new array.",True,"The code defines a method named ""push"" that takes an Emitter object and an array as parameters. It pushes the length of the array onto the Emitter stack, creates a new array of the same type as the input array, and then iterates over the input array, pushing each element onto the stack and storing it in the new array."
13,"push_object(Emitter,Object)",push object e obj ,Method,"load_method(Emitter,Method) push(Emitter,Object[]) push_unboxed(Emitter,Object)",,"net.sf.cglib.core.Emitter+aconst_null() net.sf.cglib.core.Emitter+aconst_null() java.lang.Object+getClass() java.lang.Object+getClass() java.lang.Class+isArray() java.lang.Class+isArray() net.sf.cglib.core.Ops+push(Emitter,Object[]) net.sf.cglib.core.Ops+push(Emitter,Object[]) net.sf.cglib.core.Emitter+push(String) net.sf.cglib.core.Emitter+push(String) net.sf.cglib.core.Ops+load_class(Emitter,Type) net.sf.cglib.core.Ops+load_class(Emitter,Type) org.objectweb.asm.Type+getType(Class) org.objectweb.asm.Type+getType(Class) net.sf.cglib.core.Emitter+new_instance(Type) net.sf.cglib.core.Emitter+new_instance(Type) net.sf.cglib.core.Emitter+dup() net.sf.cglib.core.Emitter+dup() net.sf.cglib.core.Emitter+push(String) net.sf.cglib.core.Emitter+push(String) java.lang.Object+toString() java.lang.Object+toString() net.sf.cglib.core.Emitter+invoke_constructor(Type) net.sf.cglib.core.Emitter+invoke_constructor(Type) net.sf.cglib.core.Emitter+new_instance(Type) net.sf.cglib.core.Emitter+new_instance(Type) net.sf.cglib.core.Emitter+dup() net.sf.cglib.core.Emitter+dup() net.sf.cglib.core.Emitter+push(String) net.sf.cglib.core.Emitter+push(String) java.lang.Object+toString() java.lang.Object+toString() net.sf.cglib.core.Emitter+invoke_constructor(Type) net.sf.cglib.core.Emitter+invoke_constructor(Type) net.sf.cglib.core.Ops+push_unboxed(Emitter,Object) net.sf.cglib.core.Ops+push_unboxed(Emitter,Object) java.lang.IllegalArgumentException+IllegalArgumentException(String) java.lang.Object+getClass() java.lang.Object+getClass()",net.sf.cglib.core.Types+BIG_INTEGER net.sf.cglib.core.Types+BIG_INTEGER net.sf.cglib.core.Types+BIG_DECIMAL net.sf.cglib.core.Types+BIG_DECIMAL,1106,28,9,,"public static void push_object(Emitter e, Object obj) {
        if (obj == null) {
            e.aconst_null();
        } else {
            Class type = obj.getClass();
            if (type.isArray()) {
                push(e, (Object[])obj);
            } else if (obj instanceof String) {
                e.push((String)obj);
            } else if (obj instanceof Class) {
                load_class(e, Type.getType((Class)obj));
            } else if (obj instanceof BigInteger) {
                e.new_instance(Types.BIG_INTEGER);
                e.dup();
                e.push(obj.toString());
                e.invoke_constructor(Types.BIG_INTEGER);
            } else if (obj instanceof BigDecimal) {
                e.new_instance(Types.BIG_DECIMAL);
                e.dup();
                e.push(obj.toString());
                e.invoke_constructor(Types.BIG_DECIMAL);
            } else if (obj instanceof Number) {
                push_unboxed(e, obj);
            } else {
                throw new IllegalArgumentException(""unknown type: "" + obj.getClass());
            }
        }
    }",True,True,"The function of this method is to push an object onto an emitter. It checks the type of the object and performs different actions based on the type, such as pushing a null value, pushing an array, pushing a string, loading a class, creating a new instance of BigInteger or BigDecimal, pushing a number, or throwing an exception for an unknown type.",True,"The code defines a method called `push_object` that takes an `Emitter` object and an `Object` as parameters. It checks the type of the object and performs different actions based on the type, such as pushing null, strings, arrays, classes, big integers, big decimals, numbers, or throwing an exception for unknown types."
14,"push_unboxed(Emitter,Object)",push unboxed e obj if the object is a number boolean or character pushes the equivalent primitive value onto the stack otherwise calls push object obj ,Method,"push_object(Emitter,Object)",,"net.sf.cglib.core.Emitter+push(int) net.sf.cglib.core.Emitter+push(int) java.lang.Boolean+booleanValue() java.lang.Boolean+booleanValue() net.sf.cglib.core.Emitter+push(int) net.sf.cglib.core.Emitter+push(int) java.lang.Character+charValue() java.lang.Character+charValue() net.sf.cglib.core.Emitter+push(long) net.sf.cglib.core.Emitter+push(long) java.lang.Long+longValue() java.lang.Long+longValue() net.sf.cglib.core.Emitter+push(double) net.sf.cglib.core.Emitter+push(double) java.lang.Double+doubleValue() java.lang.Double+doubleValue() net.sf.cglib.core.Emitter+push(float) net.sf.cglib.core.Emitter+push(float) java.lang.Float+floatValue() java.lang.Float+floatValue() net.sf.cglib.core.Emitter+push(int) net.sf.cglib.core.Emitter+push(int) java.lang.Number+intValue() java.lang.Number+intValue() net.sf.cglib.core.Ops+push_object(Emitter,Object) net.sf.cglib.core.Ops+push_object(Emitter,Object)",,948,24,9,"/** 
 * If the object is a Number, Boolean, or Character, pushes the equivalent primitive value onto the stack. Otherwise, calls push_object(obj).
 */
","/**
     * If the object is a Number, Boolean, or Character, pushes the equivalent primitive
     * value onto the stack. Otherwise, calls push_object(obj).
     */
    public static void push_unboxed(Emitter e, Object obj)
    {
        if (obj instanceof Boolean) {
            e.push(((Boolean)obj).booleanValue() ? 1 : 0);
        } else if (obj instanceof Character) {
            e.push((short)((Character)obj).charValue());
        } else if (obj instanceof Long) {
            e.push(((Long)obj).longValue());
        } else if (obj instanceof Double) {
            e.push(((Double)obj).doubleValue());
        } else if (obj instanceof Float) {
            e.push(((Float)obj).floatValue());
        } else if ((obj instanceof Integer) ||
                   (obj instanceof Short) ||
                   (obj instanceof Byte)) {
            e.push(((Number)obj).intValue());
        } else {
            push_object(e, obj);
        }
    }",False,True,"The function `push_unboxed` takes an `Emitter` object and an `Object` as parameters. If the `Object` is a `Number`, `Boolean`, or `Character`, it pushes the equivalent primitive value onto the stack using the `Emitter` object. Otherwise, it calls the `push_object` method.",True,"This code defines a method called ""push_unboxed"" that takes an Emitter object and an Object as parameters. It checks the type of the object and pushes the equivalent primitive value onto the stack if it is a Number, Boolean, or Character. Otherwise, it calls another method called ""push_object"" to handle the object."
15,"zero_or_null(Emitter,Type)",zero or null e type pushes a zero onto the stack if the argument is a primitive class or a null otherwise ,Method,"unbox_or_zero(Emitter,Type)",net.sf.cglib.reflect.MulticastDelegate+Generator.generateClass(ClassVisitor),net.sf.cglib.core.Emitter+isPrimitive(Type) net.sf.cglib.core.Emitter+isPrimitive(Type) org.objectweb.asm.Type+getSort() org.objectweb.asm.Type+getSort() net.sf.cglib.core.Emitter+push(double) net.sf.cglib.core.Emitter+push(double) net.sf.cglib.core.Emitter+push(long) net.sf.cglib.core.Emitter+push(long) net.sf.cglib.core.Emitter+push(float) net.sf.cglib.core.Emitter+push(float) net.sf.cglib.core.Emitter+aconst_null() net.sf.cglib.core.Emitter+aconst_null() net.sf.cglib.core.Emitter+push(int) net.sf.cglib.core.Emitter+push(int) net.sf.cglib.core.Emitter+aconst_null() net.sf.cglib.core.Emitter+aconst_null(),org.objectweb.asm.Type+DOUBLE org.objectweb.asm.Type+LONG org.objectweb.asm.Type+FLOAT org.objectweb.asm.Type+VOID,670,24,9,"/** 
 * Pushes a zero onto the stack if the argument is a primitive class, or a null otherwise.
 */
","/**
     * Pushes a zero onto the stack if the argument is a primitive class, or a null otherwise.
     */
    public static void zero_or_null(Emitter e, Type type) {
        if (Emitter.isPrimitive(type)) {
            switch (type.getSort()) {
            case Type.DOUBLE:
                e.push(0d);
                break;
            case Type.LONG:
                e.push(0L);
                break;
            case Type.FLOAT:
                e.push(0f);
                break;
            case Type.VOID:
                e.aconst_null();
            default:
                e.push(0);
            }
        } else {
            e.aconst_null();
        }
    }",False,False,"The function pushes a zero onto the stack if the argument is a primitive class, or a null otherwise.",True,"This code defines a method called ""zero_or_null"" that takes an Emitter object and a Type object as arguments. It checks if the Type is a primitive class and pushes a zero value onto the stack based on the type, or pushes a null value if the Type is not a primitive class."
16,"unbox_or_zero(Emitter,Type)",unbox or zero e type unboxes the object on the top of the stack if the object is null the unboxed primitive value becomes zero ,Method,,"net.sf.cglib.MethodInterceptor+generateAroundMethod(Emitter,Context,Method)","net.sf.cglib.core.Emitter+isPrimitive(Type) net.sf.cglib.core.Emitter+isPrimitive(Type) net.sf.cglib.core.Emitter+make_label() net.sf.cglib.core.Emitter+make_label() net.sf.cglib.core.Emitter+make_label() net.sf.cglib.core.Emitter+make_label() net.sf.cglib.core.Emitter+dup() net.sf.cglib.core.Emitter+dup() net.sf.cglib.core.Emitter+ifnonnull(Label) net.sf.cglib.core.Emitter+ifnonnull(Label) net.sf.cglib.core.Emitter+pop() net.sf.cglib.core.Emitter+pop() net.sf.cglib.core.Ops+zero_or_null(Emitter,Type) net.sf.cglib.core.Ops+zero_or_null(Emitter,Type) net.sf.cglib.core.Emitter+goTo(Label) net.sf.cglib.core.Emitter+goTo(Label) net.sf.cglib.core.Emitter+mark(Label) net.sf.cglib.core.Emitter+mark(Label) net.sf.cglib.core.Ops+unbox(Emitter,Type) net.sf.cglib.core.Ops+unbox(Emitter,Type) net.sf.cglib.core.Emitter+mark(Label) net.sf.cglib.core.Emitter+mark(Label) net.sf.cglib.core.Emitter+checkcast(Type) net.sf.cglib.core.Emitter+checkcast(Type)",org.objectweb.asm.Type+VOID_TYPE,698,22,9,"/** 
 * Unboxes the object on the top of the stack. If the object is null, the unboxed primitive value becomes zero.
 */
","/**
     * Unboxes the object on the top of the stack. If the object is null, the
     * unboxed primitive value becomes zero.
     */
    public static void unbox_or_zero(Emitter e, Type type) {
        if (Emitter.isPrimitive(type)) {
            if (type != Type.VOID_TYPE) {
                Label nonNull = e.make_label();
                Label end = e.make_label();
                e.dup();
                e.ifnonnull(nonNull);
                e.pop();
                zero_or_null(e, type);
                e.goTo(end);
                e.mark(nonNull);
                unbox(e, type);
                e.mark(end);
            }
        } else {
            e.checkcast(type);
        }
    }",False,False,"The function unboxes an object on the top of the stack. If the object is null, the unboxed primitive value becomes zero.",True,"The `unbox_or_zero` method takes an `Emitter` object and a `Type` object as parameters. It checks if the `Type` is a primitive type, and if so, it unboxes the object on the top of the stack. If the object is null, the unboxed primitive value becomes zero. If the `Type` is not a primitive type, it performs a checkcast operation."
17,getBoxedType(Type),get boxed type type ,Method,"load_class(Emitter,Type) box(Emitter,Type)",,org.objectweb.asm.Type+getSort() org.objectweb.asm.Type+getSort(),org.objectweb.asm.Type+CHAR net.sf.cglib.core.Types+CHARACTER org.objectweb.asm.Type+BOOLEAN net.sf.cglib.core.Types+BOOLEAN org.objectweb.asm.Type+DOUBLE net.sf.cglib.core.Types+DOUBLE org.objectweb.asm.Type+FLOAT net.sf.cglib.core.Types+FLOAT org.objectweb.asm.Type+LONG net.sf.cglib.core.Types+LONG org.objectweb.asm.Type+INT net.sf.cglib.core.Types+INTEGER org.objectweb.asm.Type+SHORT net.sf.cglib.core.Types+SHORT org.objectweb.asm.Type+BYTE net.sf.cglib.core.Types+BYTE,598,22,10,,"private static Type getBoxedType(Type type) {
        switch (type.getSort()) {
        case Type.CHAR:
            return Types.CHARACTER;
        case Type.BOOLEAN:
            return Types.BOOLEAN;
        case Type.DOUBLE:
            return Types.DOUBLE;
        case Type.FLOAT:
            return Types.FLOAT;
        case Type.LONG:
            return Types.LONG;
        case Type.INT:
            return Types.INTEGER;
        case Type.SHORT:
            return Types.SHORT;
        case Type.BYTE:
            return Types.BYTE;
        default:
            return type;
        }
    }",True,True,"This method takes a Type object as input and returns the corresponding boxed type. If the input type is a primitive type, it returns the corresponding wrapper class type. If the input type is not a primitive type, it returns the same type.",False,"The given code is a method named ""getBoxedType"" that takes a Type object as input and returns the corresponding boxed type. It uses a switch statement to determine the type of the input and returns the appropriate boxed type from the Types class. If the input type is not one of the primitive types, it simply returns the input type itself."
18,"box(Emitter,Type)",box e type if the argument is a primitive class replaces the primitive value on the top of the stack with the wrapped object equivalent for example char character if the class is void a null is pushed onto the stack instead param type the class indicating the current type of the top stack value ,Method,create_arg_array(Emitter),"net.sf.cglib.beans.BeanMap+processCase(Object,Label) net.sf.cglib.beans.BeanMap+processCase(Object,Label) net.sf.cglib.beans.BulkBean+generateGet(Class,Method[]) net.sf.cglib.reflect.FastClass+processCase(int,Label)","net.sf.cglib.core.Emitter+isPrimitive(Type) net.sf.cglib.core.Emitter+isPrimitive(Type) net.sf.cglib.core.Emitter+aconst_null() net.sf.cglib.core.Emitter+aconst_null() net.sf.cglib.core.Ops+getBoxedType(Type) net.sf.cglib.core.Ops+getBoxedType(Type) net.sf.cglib.core.Emitter+new_instance(Type) net.sf.cglib.core.Emitter+new_instance(Type) org.objectweb.asm.Type+getSize() org.objectweb.asm.Type+getSize() net.sf.cglib.core.Emitter+dup_x2() net.sf.cglib.core.Emitter+dup_x2() net.sf.cglib.core.Emitter+dup_x2() net.sf.cglib.core.Emitter+dup_x2() net.sf.cglib.core.Emitter+pop() net.sf.cglib.core.Emitter+pop() net.sf.cglib.core.Emitter+dup_x1() net.sf.cglib.core.Emitter+dup_x1() net.sf.cglib.core.Emitter+swap() net.sf.cglib.core.Emitter+swap() net.sf.cglib.core.Emitter+invoke_constructor(Type,Type[]) net.sf.cglib.core.Emitter+invoke_constructor(Type,Type[])",org.objectweb.asm.Type+VOID_TYPE,1095,28,9,"/** 
 * If the argument is a primitive class, replaces the primitive value on the top of the stack with the wrapped (Object) equivalent. For example, char -> Character. If the class is Void, a null is pushed onto the stack instead.
 * @param type the class indicating the current type of the top stack value
 */
","/**
      * If the argument is a primitive class, replaces the primitive value
      * on the top of the stack with the wrapped (Object) equivalent. For
      * example, char -> Character.
      * If the class is Void, a null is pushed onto the stack instead.
      * @param type the class indicating the current type of the top stack value
      */
     public static void box(Emitter e, Type type) {
         if (Emitter.isPrimitive(type)) {
             if (type == Type.VOID_TYPE) {
                 e.aconst_null();
             } else {
                 Type boxed = getBoxedType(type);
                 e.new_instance(boxed);
                 if (type.getSize() == 2) {
                     // Pp -> Ppo -> oPpo -> ooPpo -> ooPp -> o
                     e.dup_x2();
                     e.dup_x2();
                     e.pop();
                 } else {
                     // p -> po -> opo -> oop -> o
                     e.dup_x1();
                     e.swap();
                 }
                 e.invoke_constructor(boxed, new Type[]{ type });
             }
         }
     }",False,False,"The function of this method is to convert a primitive value on the top of the stack into its wrapped (Object) equivalent. If the class is Void, it pushes a null onto the stack instead.",True,"The `box` method takes an `Emitter` object and a `Type` object as parameters. If the `Type` object represents a primitive class, the method replaces the primitive value on the top of the stack with its wrapped (Object) equivalent. If the `Type` object represents the `Void` class, a null value is pushed onto the stack instead."
19,"unbox(Emitter,Type)",unbox e type if the argument is a primitive class replaces the object on the top of the stack with the unwrapped primitive equivalent for example character char param type the class indicating the desired type of the top stack value return true if the value was unboxed ,Method,"unbox_or_zero(Emitter,Type)","net.sf.cglib.beans.BeanMap+processCase(Object,Label) net.sf.cglib.beans.BulkBean+generateSet(Class,Method[]) net.sf.cglib.Enhancer+processCase(Object,Label) net.sf.cglib.InvocationHandler+generate(Emitter,Context) net.sf.cglib.reflect.FastClass+processCase(int,Label)","org.objectweb.asm.Type+getSort() org.objectweb.asm.Type+getSort() net.sf.cglib.core.Emitter+checkcast(Type) net.sf.cglib.core.Emitter+checkcast(Type) net.sf.cglib.core.Emitter+checkcast(Type) net.sf.cglib.core.Emitter+checkcast(Type) net.sf.cglib.core.Emitter+invoke_virtual(Type,Signature) net.sf.cglib.core.Emitter+invoke_virtual(Type,Signature)",net.sf.cglib.core.Types+NUMBER org.objectweb.asm.Type+VOID org.objectweb.asm.Type+CHAR net.sf.cglib.core.Types+CHARACTER net.sf.cglib.core.Signatures+CHAR_VALUE org.objectweb.asm.Type+BOOLEAN net.sf.cglib.core.Types+BOOLEAN net.sf.cglib.core.Signatures+BOOLEAN_VALUE org.objectweb.asm.Type+DOUBLE net.sf.cglib.core.Signatures+DOUBLE_VALUE org.objectweb.asm.Type+FLOAT net.sf.cglib.core.Signatures+FLOAT_VALUE org.objectweb.asm.Type+LONG net.sf.cglib.core.Signatures+LONG_VALUE org.objectweb.asm.Type+INT org.objectweb.asm.Type+SHORT org.objectweb.asm.Type+BYTE net.sf.cglib.core.Signatures+INT_VALUE,1282,43,9,"/** 
 * If the argument is a primitive class, replaces the object on the top of the stack with the unwrapped (primitive) equivalent. For example, Character -> char.
 * @param type the class indicating the desired type of the top stack value
 * @return true if the value was unboxed
 */
","/**
     * If the argument is a primitive class, replaces the object
     * on the top of the stack with the unwrapped (primitive)
     * equivalent. For example, Character -> char.
     * @param type the class indicating the desired type of the top stack value
     * @return true if the value was unboxed
     */
    public static void unbox(Emitter e, Type type) {
        Type t = Types.NUMBER;
        Signature sig = null;
        switch (type.getSort()) {
        case Type.VOID:
            return;
        case Type.CHAR:
            t = Types.CHARACTER;
            sig = Signatures.CHAR_VALUE;
            break;
        case Type.BOOLEAN:
            t = Types.BOOLEAN;
            sig = Signatures.BOOLEAN_VALUE;
            break;
        case Type.DOUBLE:
            sig = Signatures.DOUBLE_VALUE;
            break;
        case Type.FLOAT:
            sig = Signatures.FLOAT_VALUE;
            break;
        case Type.LONG:
            sig = Signatures.LONG_VALUE;
            break;
        case Type.INT:
        case Type.SHORT:
        case Type.BYTE:
            sig = Signatures.INT_VALUE;
        }

        if (sig == null) {
            e.checkcast(type);
        } else {
            e.checkcast(t);
            e.invoke_virtual(t, sig);
        }
    }",False,False,The function of this method is to unbox the top value on the stack if it is a primitive class. It determines the desired type of the top stack value and replaces the object with its unwrapped (primitive) equivalent.,True,"This code defines a method called ""unbox"" that takes an Emitter object and a Type object as parameters. It checks the type of the given Type object and performs the appropriate unboxing operation on the top value of the stack in the Emitter object, replacing it with the unwrapped (primitive) equivalent if applicable."
20,"process_array(Emitter,Type,ProcessArrayCallback)",process array e type callback process an array on the stack assumes the top item on the stack is an array of the specified type for each element in the array puts the element on the stack and triggers the callback param type the type of the array type is array must be true param callback the callback triggered for each element ,Method,,net.sf.cglib.core.KeyFactory+hash_array(Type) net.sf.cglib.reflect.MulticastDelegate+Generator.generateClass(ClassVisitor),"net.sf.cglib.core.Emitter+getComponentType(Type) net.sf.cglib.core.Emitter+getComponentType(Type) net.sf.cglib.core.Emitter+make_local() net.sf.cglib.core.Emitter+make_local() net.sf.cglib.core.Emitter+make_local(Type) net.sf.cglib.core.Emitter+make_local(Type) net.sf.cglib.core.Emitter+make_label() net.sf.cglib.core.Emitter+make_label() net.sf.cglib.core.Emitter+make_label() net.sf.cglib.core.Emitter+make_label() net.sf.cglib.core.Emitter+store_local(Local) net.sf.cglib.core.Emitter+store_local(Local) net.sf.cglib.core.Emitter+push(int) net.sf.cglib.core.Emitter+push(int) net.sf.cglib.core.Emitter+store_local(Local) net.sf.cglib.core.Emitter+store_local(Local) net.sf.cglib.core.Emitter+goTo(Label) net.sf.cglib.core.Emitter+goTo(Label) net.sf.cglib.core.Emitter+mark(Label) net.sf.cglib.core.Emitter+mark(Label) net.sf.cglib.core.Emitter+load_local(Local) net.sf.cglib.core.Emitter+load_local(Local) net.sf.cglib.core.Emitter+load_local(Local) net.sf.cglib.core.Emitter+load_local(Local) net.sf.cglib.core.Emitter+array_load(Type) net.sf.cglib.core.Emitter+array_load(Type) net.sf.cglib.core.ProcessArrayCallback+processElement(Type) net.sf.cglib.core.ProcessArrayCallback+processElement(Type) net.sf.cglib.core.Emitter+iinc(Local,int) net.sf.cglib.core.Emitter+iinc(Local,int) net.sf.cglib.core.Emitter+mark(Label) net.sf.cglib.core.Emitter+mark(Label) net.sf.cglib.core.Emitter+load_local(Local) net.sf.cglib.core.Emitter+load_local(Local) net.sf.cglib.core.Emitter+load_local(Local) net.sf.cglib.core.Emitter+load_local(Local) net.sf.cglib.core.Emitter+arraylength() net.sf.cglib.core.Emitter+arraylength() net.sf.cglib.core.Emitter+if_icmplt(Label) net.sf.cglib.core.Emitter+if_icmplt(Label)",org.objectweb.asm.Type+INT_TYPE,1155,31,9,"/** 
 * Process an array on the stack. Assumes the top item on the stack is an array of the specified type. For each element in the array, puts the element on the stack and triggers the callback.
 * @param type the type of the array (type.isArray() must be true)
 * @param callback the callback triggered for each element
 */
","/**
     * Process an array on the stack. Assumes the top item on the stack
     * is an array of the specified type. For each element in the array,
     * puts the element on the stack and triggers the callback.
     * @param type the type of the array (type.isArray() must be true)
     * @param callback the callback triggered for each element
     */
    public static void process_array(Emitter e, Type type, ProcessArrayCallback callback) {
        Type componentType = Emitter.getComponentType(type);
        Local array = e.make_local();
        Local loopvar = e.make_local(Type.INT_TYPE);
        Label loopbody = e.make_label();
        Label checkloop = e.make_label();
        e.store_local(array);
        e.push(0);
        e.store_local(loopvar);
        e.goTo(checkloop);
        
        e.mark(loopbody);
        e.load_local(array);
        e.load_local(loopvar);
        e.array_load(componentType);
        callback.processElement(componentType);
        e.iinc(loopvar, 1);
        
        e.mark(checkloop);
        e.load_local(loopvar);
        e.load_local(array);
        e.arraylength();
        e.if_icmplt(loopbody);
    }",False,False,"The function processes an array on the stack. It assumes the top item on the stack is an array of a specified type. For each element in the array, it puts the element on the stack and triggers a callback.",True,"The given code is a method called `process_array` that takes an `Emitter` object, a `Type` object, and a `ProcessArrayCallback` object as parameters. It assumes that the top item on the stack is an array of the specified type and for each element in the array, it puts the element on the stack and triggers the callback."
21,"process_arrays(Emitter,Type,ProcessArrayCallback)",process arrays e type callback process two arrays on the stack in parallel assumes the top two items on the stack are arrays of the specified class the arrays must be the same length for each pair of elements in the arrays puts the pair on the stack and triggers the callback param type the type of the arrays type is array must be true param callback the callback triggered for each pair of elements ,Method,"not_equals_helper(Emitter,Type,Label,ProcessArrayCallback)",,"net.sf.cglib.core.Emitter+getComponentType(Type) net.sf.cglib.core.Emitter+getComponentType(Type) net.sf.cglib.core.Emitter+make_local() net.sf.cglib.core.Emitter+make_local() net.sf.cglib.core.Emitter+make_local() net.sf.cglib.core.Emitter+make_local() net.sf.cglib.core.Emitter+make_local(Type) net.sf.cglib.core.Emitter+make_local(Type) net.sf.cglib.core.Emitter+make_label() net.sf.cglib.core.Emitter+make_label() net.sf.cglib.core.Emitter+make_label() net.sf.cglib.core.Emitter+make_label() net.sf.cglib.core.Emitter+store_local(Local) net.sf.cglib.core.Emitter+store_local(Local) net.sf.cglib.core.Emitter+store_local(Local) net.sf.cglib.core.Emitter+store_local(Local) net.sf.cglib.core.Emitter+push(int) net.sf.cglib.core.Emitter+push(int) net.sf.cglib.core.Emitter+store_local(Local) net.sf.cglib.core.Emitter+store_local(Local) net.sf.cglib.core.Emitter+goTo(Label) net.sf.cglib.core.Emitter+goTo(Label) net.sf.cglib.core.Emitter+mark(Label) net.sf.cglib.core.Emitter+mark(Label) net.sf.cglib.core.Emitter+load_local(Local) net.sf.cglib.core.Emitter+load_local(Local) net.sf.cglib.core.Emitter+load_local(Local) net.sf.cglib.core.Emitter+load_local(Local) net.sf.cglib.core.Emitter+array_load(Type) net.sf.cglib.core.Emitter+array_load(Type) net.sf.cglib.core.Emitter+load_local(Local) net.sf.cglib.core.Emitter+load_local(Local) net.sf.cglib.core.Emitter+load_local(Local) net.sf.cglib.core.Emitter+load_local(Local) net.sf.cglib.core.Emitter+array_load(Type) net.sf.cglib.core.Emitter+array_load(Type) net.sf.cglib.core.ProcessArrayCallback+processElement(Type) net.sf.cglib.core.ProcessArrayCallback+processElement(Type) net.sf.cglib.core.Emitter+iinc(Local,int) net.sf.cglib.core.Emitter+iinc(Local,int) net.sf.cglib.core.Emitter+mark(Label) net.sf.cglib.core.Emitter+mark(Label) net.sf.cglib.core.Emitter+load_local(Local) net.sf.cglib.core.Emitter+load_local(Local) net.sf.cglib.core.Emitter+load_local(Local) net.sf.cglib.core.Emitter+load_local(Local) net.sf.cglib.core.Emitter+arraylength() net.sf.cglib.core.Emitter+arraylength() net.sf.cglib.core.Emitter+if_icmplt(Label) net.sf.cglib.core.Emitter+if_icmplt(Label)",org.objectweb.asm.Type+INT_TYPE,1400,36,9,"/** 
 * Process two arrays on the stack in parallel. Assumes the top two items on the stack are arrays of the specified class. The arrays must be the same length. For each pair of elements in the arrays, puts the pair on the stack and triggers the callback.
 * @param type the type of the arrays (type.isArray() must be true)
 * @param callback the callback triggered for each pair of elements
 */
","/**
     * Process two arrays on the stack in parallel. Assumes the top two items on the stack
     * are arrays of the specified class. The arrays must be the same length. For each pair
     * of elements in the arrays, puts the pair on the stack and triggers the callback.
     * @param type the type of the arrays (type.isArray() must be true)
     * @param callback the callback triggered for each pair of elements
     */
    public static void process_arrays(Emitter e, Type type, ProcessArrayCallback callback) {
        Type componentType = Emitter.getComponentType(type);
        Local array1 = e.make_local();
        Local array2 = e.make_local();
        Local loopvar = e.make_local(Type.INT_TYPE);
        Label loopbody = e.make_label();
        Label checkloop = e.make_label();
        e.store_local(array1);
        e.store_local(array2);
        e.push(0);
        e.store_local(loopvar);
        e.goTo(checkloop);
        
        e.mark(loopbody);
        e.load_local(array1);
        e.load_local(loopvar);
        e.array_load(componentType);
        e.load_local(array2);
        e.load_local(loopvar);
        e.array_load(componentType);
        callback.processElement(componentType);
        e.iinc(loopvar, 1);
        
        e.mark(checkloop);
        e.load_local(loopvar);
        e.load_local(array1);
        e.arraylength();
        e.if_icmplt(loopbody);
    }",False,False,"The function processes two arrays in parallel. It assumes that the top two items on the stack are arrays of the specified class. For each pair of elements in the arrays, it puts the pair on the stack and triggers the callback.",True,"This code defines a method called ""process_arrays"" that takes an emitter, a type, and a callback as parameters. It processes two arrays in parallel by iterating over their elements and triggering the callback for each pair of elements. The arrays must be of the same length and the callback is responsible for processing the elements."
22,"not_equals(Emitter,Type,Label)",not equals e type not equals branches to the specified label if the top two items on the stack are not equal the items must both be of the specified class equality is determined by comparing primitive values directly and by invoking the equals method for objects arrays are recursively processed in the same manner ,Method,,net.sf.cglib.core.KeyFactory+generateEquals(Class[]),+processElement(Type) +() +processElement(Type),,640,14,9,"/** 
 * Branches to the specified label if the top two items on the stack are not equal. The items must both be of the specified class. Equality is determined by comparing primitive values directly and by invoking the <code>equals</code> method for Objects. Arrays are recursively processed in the same manner.
 */
","/**
     * Branches to the specified label if the top two items on the stack
     * are not equal. The items must both be of the specified
     * class. Equality is determined by comparing primitive values
     * directly and by invoking the <code>equals</code> method for
     * Objects. Arrays are recursively processed in the same manner.
     */
    public static void not_equals(final Emitter e, Type type, final Label notEquals) {
        (new ProcessArrayCallback() {
            public void processElement(Type type) {
                not_equals_helper(e, type, notEquals, this);
            }
        }).processElement(type);
    }",False,False,"The function of this method is to branch to a specified label if the top two items on the stack are not equal. The items must both be of the specified class, and equality is determined by comparing primitive values directly or invoking the equals method for Objects. Arrays are recursively processed in the same manner.",True,"This code defines a method called ""not_equals"" that branches to a specified label if the top two items on the stack are not equal. The method compares the items based on their primitive values or by invoking the ""equals"" method for Objects, including recursively processing arrays."
23,"not_equals_helper(Emitter,Type,Label,ProcessArrayCallback)",not equals helper e type not equals callback ,Method,,,"net.sf.cglib.core.Emitter+isPrimitive(Type) net.sf.cglib.core.Emitter+isPrimitive(Type) net.sf.cglib.core.Emitter+if_cmpne(Type,Label) net.sf.cglib.core.Emitter+if_cmpne(Type,Label) net.sf.cglib.core.Emitter+make_label() net.sf.cglib.core.Emitter+make_label() net.sf.cglib.core.Ops+nullcmp(Emitter,Label,Label) net.sf.cglib.core.Ops+nullcmp(Emitter,Label,Label) net.sf.cglib.core.Emitter+isArray(Type) net.sf.cglib.core.Emitter+isArray(Type) net.sf.cglib.core.Emitter+make_label() net.sf.cglib.core.Emitter+make_label() net.sf.cglib.core.Emitter+dup2() net.sf.cglib.core.Emitter+dup2() net.sf.cglib.core.Emitter+arraylength() net.sf.cglib.core.Emitter+arraylength() net.sf.cglib.core.Emitter+swap() net.sf.cglib.core.Emitter+swap() net.sf.cglib.core.Emitter+arraylength() net.sf.cglib.core.Emitter+arraylength() net.sf.cglib.core.Emitter+if_icmpeq(Label) net.sf.cglib.core.Emitter+if_icmpeq(Label) net.sf.cglib.core.Emitter+pop2() net.sf.cglib.core.Emitter+pop2() net.sf.cglib.core.Emitter+goTo(Label) net.sf.cglib.core.Emitter+goTo(Label) net.sf.cglib.core.Emitter+mark(Label) net.sf.cglib.core.Emitter+mark(Label) net.sf.cglib.core.Ops+process_arrays(Emitter,Type,ProcessArrayCallback) net.sf.cglib.core.Ops+process_arrays(Emitter,Type,ProcessArrayCallback) net.sf.cglib.core.Emitter+invoke_virtual(Type,Signature) net.sf.cglib.core.Emitter+invoke_virtual(Type,Signature) net.sf.cglib.core.Emitter+ifeq(Label) net.sf.cglib.core.Emitter+ifeq(Label) net.sf.cglib.core.Emitter+mark(Label) net.sf.cglib.core.Emitter+mark(Label)",net.sf.cglib.core.Types+OBJECT net.sf.cglib.core.Signatures+EQUALS,874,24,10,,"private static void not_equals_helper(Emitter e, Type type, Label notEquals, ProcessArrayCallback callback) {
        if (Emitter.isPrimitive(type)) {
            e.if_cmpne(type, notEquals);
        } else {
            Label end = e.make_label();
            nullcmp(e, notEquals, end);
            if (Emitter.isArray(type)) {
                Label checkContents = e.make_label();
                e.dup2();
                e.arraylength();
                e.swap();
                e.arraylength();
                e.if_icmpeq(checkContents);
                e.pop2();
                e.goTo(notEquals);
                e.mark(checkContents);
                process_arrays(e, type, callback);
            } else {
                e.invoke_virtual(Types.OBJECT, Signatures.EQUALS);
                e.ifeq(notEquals);
            }
            e.mark(end);
        }
    }",False,False,"The function of the given method is to compare two objects or arrays for inequality. It takes an Emitter, a Type, a Label, and a ProcessArrayCallback as parameters, and performs the necessary comparisons and operations based on the type of the objects or arrays.",False,"The code defines a private static method called `not_equals_helper` that takes an `Emitter` object, a `Type` object, a `Label` object, and a `ProcessArrayCallback` object as parameters. The method checks if the given `Type` object is a primitive type and performs a comparison using the `Emitter` object. If the `Type` object is not a primitive type, it checks for null values, arrays, and invokes the `equals` method on non-array objects before performing the comparison."
24,"nullcmp(Emitter,Label,Label)",nullcmp e one null both null if both objects on the top of the stack are non null does nothing if one is null or both are null both are popped off and execution branches to the respective label param one null label to branch to if only one of the objects is null param both null label to branch to if both of the objects are null ,Method,"not_equals_helper(Emitter,Type,Label,ProcessArrayCallback)",,net.sf.cglib.core.Emitter+dup2() net.sf.cglib.core.Emitter+dup2() net.sf.cglib.core.Emitter+make_label() net.sf.cglib.core.Emitter+make_label() net.sf.cglib.core.Emitter+make_label() net.sf.cglib.core.Emitter+make_label() net.sf.cglib.core.Emitter+make_label() net.sf.cglib.core.Emitter+make_label() net.sf.cglib.core.Emitter+ifnonnull(Label) net.sf.cglib.core.Emitter+ifnonnull(Label) net.sf.cglib.core.Emitter+ifnonnull(Label) net.sf.cglib.core.Emitter+ifnonnull(Label) net.sf.cglib.core.Emitter+pop2() net.sf.cglib.core.Emitter+pop2() net.sf.cglib.core.Emitter+goTo(Label) net.sf.cglib.core.Emitter+goTo(Label) net.sf.cglib.core.Emitter+mark(Label) net.sf.cglib.core.Emitter+mark(Label) net.sf.cglib.core.Emitter+ifnull(Label) net.sf.cglib.core.Emitter+ifnull(Label) net.sf.cglib.core.Emitter+goTo(Label) net.sf.cglib.core.Emitter+goTo(Label) net.sf.cglib.core.Emitter+mark(Label) net.sf.cglib.core.Emitter+mark(Label) net.sf.cglib.core.Emitter+pop2() net.sf.cglib.core.Emitter+pop2() net.sf.cglib.core.Emitter+goTo(Label) net.sf.cglib.core.Emitter+goTo(Label) net.sf.cglib.core.Emitter+mark(Label) net.sf.cglib.core.Emitter+mark(Label),,885,27,10,"/** 
 * If both objects on the top of the stack are non-null, does nothing. If one is null, or both are null, both are popped off and execution branches to the respective label.
 * @param oneNull label to branch to if only one of the objects is null
 * @param bothNull label to branch to if both of the objects are null
 */
","/**
     * If both objects on the top of the stack are non-null, does nothing.
     * If one is null, or both are null, both are popped off and execution
     * branches to the respective label.
     * @param oneNull label to branch to if only one of the objects is null
     * @param bothNull label to branch to if both of the objects are null
     */
    private static void nullcmp(Emitter e, Label oneNull, Label bothNull) {
        e.dup2();
        Label nonNull = e.make_label();
        Label oneNullHelper = e.make_label();
        Label end = e.make_label();
        e.ifnonnull(nonNull);
        e.ifnonnull(oneNullHelper);
        e.pop2();
        e.goTo(bothNull);
        
        e.mark(nonNull);
        e.ifnull(oneNullHelper);
        e.goTo(end);
        
        e.mark(oneNullHelper);
        e.pop2();
        e.goTo(oneNull);
        
        e.mark(end);
    }",False,False,"The function compares the top two objects on the stack. If both are non-null, it does nothing. If one or both are null, it pops them off the stack and branches to the respective label.",True,"The `nullcmp` method takes in an `Emitter` object, a label for when only one object is null, and a label for when both objects are null. It checks if both objects on the top of the stack are non-null, and if not, it branches to the respective label based on the nullness of the objects."
25,"string_switch(Emitter,String[],int,ObjectSwitchCallback)",string switch e strings switch style callback ,Method,,"net.sf.cglib.beans.BeanMap+generateGet(Class,int,Map) net.sf.cglib.beans.BeanMap+generatePut(Class,int,Map) net.sf.cglib.core.TestStringSwitch+Generator.generateClass(ClassVisitor)","net.sf.cglib.core.Ops+string_switch_trie(Emitter,String[],ObjectSwitchCallback) net.sf.cglib.core.Ops+string_switch_trie(Emitter,String[],ObjectSwitchCallback) net.sf.cglib.core.Ops+string_switch_hash(Emitter,String[],ObjectSwitchCallback) net.sf.cglib.core.Ops+string_switch_hash(Emitter,String[],ObjectSwitchCallback) java.lang.IllegalArgumentException+IllegalArgumentException(String)",net.sf.cglib.core.Ops+SWITCH_STYLE_TRIE net.sf.cglib.core.Ops+SWITCH_STYLE_HASH,493,13,9,,"public static void string_switch(Emitter e, String[] strings, int switchStyle, ObjectSwitchCallback callback)
    throws Exception {
        switch (switchStyle) {
        case SWITCH_STYLE_TRIE:
            string_switch_trie(e, strings, callback);
            break;
        case SWITCH_STYLE_HASH:
            string_switch_hash(e, strings, callback);
            break;
        default:
            throw new IllegalArgumentException(""unknown switch style "" + switchStyle);
        }
    }",False,False,The function of this method is to switch between different styles of string switching based on the value of the switchStyle parameter. It calls the appropriate method based on the switchStyle value and throws an exception if the switchStyle value is unknown.,True,"The code defines a method called ""string_switch"" that takes an Emitter object, an array of strings, an integer switchStyle, and an ObjectSwitchCallback object as parameters. It uses a switch statement to determine the switchStyle and calls different methods based on the value of switchStyle. If the switchStyle is not recognized, it throws an IllegalArgumentException."
26,"string_switch_trie(Emitter,String[],ObjectSwitchCallback)",string switch trie e strings callback ,Method,"string_switch(Emitter,String[],int,ObjectSwitchCallback)",,"net.sf.cglib.core.Emitter+make_label() net.sf.cglib.core.Emitter+make_label() net.sf.cglib.core.Emitter+make_label() net.sf.cglib.core.Emitter+make_label() net.sf.cglib.core.CollectionUtils+bucket(Collection,Transformer) net.sf.cglib.core.CollectionUtils+bucket(Collection,Transformer) java.util.Arrays+asList(T[]) java.util.Arrays+asList(T[]) +() +transform(Object)",,1159,26,10,,"private static void string_switch_trie(final Emitter e,
                                           String[] strings,
                                           final ObjectSwitchCallback callback) throws Exception {
        final Label def = e.make_label();
        final Label end = e.make_label();
        final Map buckets = CollectionUtils.bucket(Arrays.asList(strings), new Transformer() {
            public Object transform(Object value) {
                return new Integer(((String)value).length());
            }
        });
        e.dup();
        e.invoke_virtual(Types.STRING, Signatures.STRING_LENGTH);
        e.process_switch(getSwitchKeys(buckets), new ProcessSwitchCallback() {
                public void processCase(int key, Label ignore_end) throws Exception {
                    List bucket = (List)buckets.get(new Integer(key));
                    stringSwitchHelper(e, bucket, callback, def, end, 0);
                }
                public void processDefault() {
                    e.goTo(def);
                }
            });
        e.mark(def);
        e.pop();
        callback.processDefault();
        e.mark(end);
    }",False,False,"The function of this method is to perform a switch statement on a given set of strings based on their length. It uses a trie data structure to efficiently group the strings by length and then processes each group using a helper method. If no match is found, it invokes a default callback function.",True,"This code is a method called `string_switch_trie` that takes an `Emitter` object, an array of strings, and an `ObjectSwitchCallback` object as parameters. It creates a trie data structure to efficiently switch between different string lengths and invokes a helper method to process each case. If no case matches, it invokes the default callback function."
27,"stringSwitchHelper(Emitter,List,ObjectSwitchCallback,Label,Label,int)",string switch helper e strings callback def end index ,Method,,,"java.lang.String+length() java.util.List+get(int) java.util.List+get(int) java.lang.String+length() net.sf.cglib.core.CollectionUtils+bucket(Collection,Transformer) net.sf.cglib.core.CollectionUtils+bucket(Collection,Transformer) +() +transform(Object)",,1436,30,10,,"private static void stringSwitchHelper(final Emitter e,
                                           List strings,
                                           final ObjectSwitchCallback callback,
                                           final Label def,
                                           final Label end,
                                           final int index) throws Exception {
        final int len = ((String)strings.get(0)).length();
        final Map buckets = CollectionUtils.bucket(strings, new Transformer() {
            public Object transform(Object value) {
                return new Integer(((String)value).charAt(index));
            }
        });
        e.dup();
        e.push(index);
        e.invoke_virtual(Types.STRING, Signatures.STRING_CHAR_AT);
        e.process_switch(getSwitchKeys(buckets), new ProcessSwitchCallback() {
                public void processCase(int key, Label ignore_end) throws Exception {
                    List bucket = (List)buckets.get(new Integer(key));
                    if (index + 1 == len) {
                        e.pop();
                        callback.processCase(bucket.get(0), end);
                    } else {
                        stringSwitchHelper(e, bucket, callback, def, end, index + 1);
                    }
                }
                public void processDefault() {
                    e.goTo(def);
                }
            });
    }",False,False,The function of this method is to switch between different cases based on the characters at a specific index in a list of strings. It uses a callback function to process each case and a default label to handle cases that do not match any of the switch keys.,True,"The code defines a private static method called `stringSwitchHelper` that takes in an `Emitter` object, a list of strings, a callback function, labels for default and end cases, and an index. It uses the `bucket` method from `CollectionUtils` to group the strings based on the character at the given index, and then processes the switch cases using the provided callback function."
28,getSwitchKeys(Map),get switch keys buckets ,Method,,,java.util.Map+size() java.util.Map+size() java.util.Set+iterator() java.util.Map+keySet() java.util.Map+keySet() java.util.Set+iterator() java.util.Iterator+hasNext() java.util.Iterator+hasNext() java.lang.Integer+intValue() java.util.Iterator+next() java.util.Iterator+next() java.lang.Integer+intValue() java.util.Arrays+sort(int[]) java.util.Arrays+sort(int[]),,316,9,10,,"private static int[] getSwitchKeys(Map buckets) {
        int[] keys = new int[buckets.size()];
        int index = 0;
        for (Iterator it = buckets.keySet().iterator(); it.hasNext();) {
            keys[index++] = ((Integer)it.next()).intValue();
        }
        Arrays.sort(keys);
        return keys;
    }",False,False,"This method takes a Map as input and returns an array of integers. It extracts the keys from the Map, converts them to integers, sorts them, and returns the sorted array.",False,"This code defines a private static method called ""getSwitchKeys"" that takes a Map as input. It creates an array of integers with the same size as the Map, iterates over the keys of the Map, converts them to integers, sorts the array, and finally returns the sorted array of keys."
29,"string_switch_hash(Emitter,String[],ObjectSwitchCallback)",string switch hash e strings callback ,Method,"string_switch(Emitter,String[],int,ObjectSwitchCallback)",,"net.sf.cglib.core.CollectionUtils+bucket(Collection,Transformer) net.sf.cglib.core.CollectionUtils+bucket(Collection,Transformer) java.util.Arrays+asList(T[]) java.util.Arrays+asList(T[]) +() +transform(Object)",,1782,43,10,,"private static void string_switch_hash(final Emitter e,
                                           final String[] strings,
                                           final ObjectSwitchCallback callback) throws Exception {
        final Map buckets = CollectionUtils.bucket(Arrays.asList(strings), new Transformer() {
            public Object transform(Object value) {
                return new Integer(value.hashCode());
            }
        });
        final Label def = e.make_label();
        final Label end = e.make_label();
        e.dup();
        e.invoke_virtual(Types.OBJECT, Signatures.HASH_CODE);
        e.process_switch(getSwitchKeys(buckets), new ProcessSwitchCallback() {
            public void processCase(int key, Label ignore_end) throws Exception {
                List bucket = (List)buckets.get(new Integer(key));
                Label next = null;
                for (Iterator it = bucket.iterator(); it.hasNext();) {
                    String string = (String)it.next();
                    if (next != null) {
                        e.mark(next);
                    }
                    if (it.hasNext()) {
                        e.dup();
                    }
                    e.push(string);
                    e.invoke_virtual(Types.OBJECT, Signatures.EQUALS);
                    if (it.hasNext()) {
                        e.ifeq(next = e.make_label());
                        e.pop();
                    } else {
                        e.ifeq(def);
                    }
                    callback.processCase(string, end);
                }
            }
            public void processDefault() {
                e.pop();
            }
        });
        e.mark(def);
        callback.processDefault();
        e.mark(end);
    }",False,False,"The function of this method is to perform a switch statement on a list of strings. It uses a hash function to group the strings into buckets, and then iterates through each bucket to compare the strings and execute the appropriate callback function.",True,"This code defines a method called `string_switch_hash` that takes an `Emitter` object, an array of strings, and a callback function as parameters. It uses a hash map to group the strings based on their hash codes, and then uses a switch statement to process each group of strings, invoking the callback function for each string in the group."
30,ParameterTyper,parameter typer ,MemberClass,,,net.sf.cglib.core.Ops.ParameterTyper+getParameterTypes(Object),,90,3,2,,"private interface ParameterTyper {
        Class[] getParameterTypes(Object member);
    }",False,True,,False,
31,"method_switch(Emitter,Method[],ObjectSwitchCallback)",method switch e methods callback ,Method,,,"net.sf.cglib.core.Ops+member_switch_helper(Emitter,List,ObjectSwitchCallback,boolean,ParameterTyper) net.sf.cglib.core.Ops+member_switch_helper(Emitter,List,ObjectSwitchCallback,boolean,ParameterTyper) java.util.Arrays+asList(T[]) java.util.Arrays+asList(T[]) +() +getParameterTypes(Object)",,435,9,9,,"public static void method_switch(Emitter e,
                                     Method[] methods,
                                     ObjectSwitchCallback callback) throws Exception {
        member_switch_helper(e, Arrays.asList(methods), callback, true, new ParameterTyper() {
            public Class[] getParameterTypes(Object member) {
                return ((Method)member).getParameterTypes();
            }
        });
    }",True,True,"This method serves to switch between different methods based on the provided emitter, array of methods, and callback. It also throws an exception.",True,"The given code is a method named ""method_switch"" that takes an Emitter object, an array of Method objects, and an ObjectSwitchCallback object as parameters. It calls a helper method named ""member_switch_helper"" with the provided parameters and additional arguments, including an anonymous implementation of the ParameterTyper interface."
32,"constructor_switch(Emitter,Constructor[],ObjectSwitchCallback)",constructor switch e cstructs callback ,Method,,net.sf.cglib.reflect.TestMemberSwitch+Generator.generateClass(ClassVisitor),"net.sf.cglib.core.Ops+member_switch_helper(Emitter,List,ObjectSwitchCallback,boolean,ParameterTyper) net.sf.cglib.core.Ops+member_switch_helper(Emitter,List,ObjectSwitchCallback,boolean,ParameterTyper) java.util.Arrays+asList(T[]) java.util.Arrays+asList(T[]) +() +getParameterTypes(Object)",,463,9,9,,"public static void constructor_switch(Emitter e,
                                          Constructor[] cstructs,
                                          ObjectSwitchCallback callback) throws Exception {
        member_switch_helper(e, Arrays.asList(cstructs), callback, false, new ParameterTyper() {
            public Class[] getParameterTypes(Object member) {
                return ((Constructor)member).getParameterTypes();
            }
        });
    }",True,True,"This method serves as a constructor switch, which takes an emitter, an array of constructors, and a callback function as parameters. It then calls a helper method with additional parameters to perform the switch operation.",True,"The given code is a method named ""constructor_switch"" that takes an Emitter object, an array of Constructor objects, and an ObjectSwitchCallback object as parameters. It calls a helper method named ""member_switch_helper"" with the provided parameters, along with additional arguments, and passes a ParameterTyper object as an anonymous inner class. The method throws an Exception."
33,"member_switch_helper(Emitter,List,ObjectSwitchCallback,boolean,ParameterTyper)",member switch helper e members callback use name typer ,Method,"method_switch(Emitter,Method[],ObjectSwitchCallback) constructor_switch(Emitter,Constructor[],ObjectSwitchCallback)",,java.util.HashMap+HashMap() +() +getParameterTypes(Object),,1818,41,10,,"private static void member_switch_helper(final Emitter e,
                                             List members,
                                             final ObjectSwitchCallback callback,
                                             boolean useName,
                                             final ParameterTyper typer) throws Exception {
        final Map cache = new HashMap();
        final ParameterTyper cached = new ParameterTyper() {
            public Class[] getParameterTypes(Object member) {
                Class[] types = (Class[])cache.get(member);
                if (types == null) {
                    cache.put(member, types = typer.getParameterTypes(member));
                }
                return types;
            }
        };
        final Label def = e.make_label();
        final Label end = e.make_label();
        if (useName) {
            e.swap();
            final Map buckets = CollectionUtils.bucket(members, new Transformer() {
                public Object transform(Object value) {
                    return ((Member)value).getName();
                }
            });
            String[] names = (String[])buckets.keySet().toArray(new String[buckets.size()]);
            string_switch_hash(e, names, new ObjectSwitchCallback() {
                public void processCase(Object key, Label dontUseEnd) throws Exception {
                    member_helper_size(e, (List)buckets.get(key), callback, cached, def, end);
                }
                public void processDefault() throws Exception {
                    e.goTo(def);
                }
            });
        } else {
            member_helper_size(e, members, callback, cached, def, end);
        }
        e.mark(def);
        e.pop();
        callback.processDefault();
        e.mark(end);
    }",True,True,"The function of this method is to switch between different members based on certain conditions, and invoke a callback function for each case. It also caches the parameter types of the members for efficiency.",True,"The code defines a private static method called `member_switch_helper` that takes an `Emitter` object, a list of members, a callback function, a boolean flag, and a `ParameterTyper` object as parameters. It performs a switch operation based on the value of the `useName` flag and calls the `callback` function accordingly. The method also handles default cases and exception handling."
34,"member_helper_size(Emitter,List,ObjectSwitchCallback,ParameterTyper,Label,Label)",member helper size e members callback typer def end ,Method,,,"net.sf.cglib.core.CollectionUtils+bucket(Collection,Transformer) net.sf.cglib.core.CollectionUtils+bucket(Collection,Transformer) +() +transform(Object)",,1212,24,10,,"private static void member_helper_size(final Emitter e,
                                           List members,
                                           final ObjectSwitchCallback callback,
                                           final ParameterTyper typer,
                                           final Label def,
                                           final Label end) throws Exception {
        final Map buckets = CollectionUtils.bucket(members, new Transformer() {
            public Object transform(Object value) {
                return new Integer(typer.getParameterTypes(value).length);
            }
        });
        e.dup();
        e.arraylength();
        e.process_switch(getSwitchKeys(buckets), new ProcessSwitchCallback() {
            public void processCase(int key, Label dontUseEnd) throws Exception {
                List bucket = (List)buckets.get(new Integer(key));
                Class[] types = typer.getParameterTypes(bucket.get(0));
                member_helper_type(e, bucket, callback, typer, def, end, new BitSet(types.length));
            }
            public void processDefault() throws Exception {
                e.goTo(def);
            }
        });
    }",True,True,"The function of this method is to process a list of members and group them into buckets based on the number of parameters they have. It then performs a switch statement on the buckets and calls another method for each case, passing the appropriate bucket of members. If there is no matching case, it goes to a default label.",False,"The code defines a private static method called `member_helper_size` that takes in several parameters. It uses the `CollectionUtils.bucket` method to group the `members` list based on the length of their parameter types. It then processes the switch cases based on the grouped buckets and calls the `member_helper_type` method for each case, passing in the appropriate parameters."
35,"member_helper_type(Emitter,List,ObjectSwitchCallback,ParameterTyper,Label,Label,BitSet)",member helper type e members callback typer def end checked ,Method,,,"java.util.List+size() java.util.List+size() java.util.List+get(int) java.util.List+get(int) net.sf.cglib.core.Ops.ParameterTyper+getParameterTypes(Object) net.sf.cglib.core.Ops.ParameterTyper+getParameterTypes(Object) java.util.BitSet+get(int) java.util.BitSet+get(int) net.sf.cglib.core.Emitter+dup() net.sf.cglib.core.Emitter+dup() net.sf.cglib.core.Emitter+aaload(int) net.sf.cglib.core.Emitter+aaload(int) net.sf.cglib.core.Emitter+invoke_virtual(Type,Signature) net.sf.cglib.core.Emitter+invoke_virtual(Type,Signature) net.sf.cglib.core.Emitter+push(String) net.sf.cglib.core.Emitter+push(String) java.lang.Class+getName() java.lang.Class+getName() net.sf.cglib.core.Emitter+invoke_virtual(Type,Signature) net.sf.cglib.core.Emitter+invoke_virtual(Type,Signature) net.sf.cglib.core.Emitter+ifeq(Label) net.sf.cglib.core.Emitter+ifeq(Label) net.sf.cglib.core.Emitter+pop() net.sf.cglib.core.Emitter+pop() net.sf.cglib.core.ObjectSwitchCallback+processCase(Object,Label) net.sf.cglib.core.ObjectSwitchCallback+processCase(Object,Label) net.sf.cglib.core.Ops.ParameterTyper+getParameterTypes(Object) net.sf.cglib.core.Ops.ParameterTyper+getParameterTypes(Object) java.util.List+get(int) java.util.List+get(int) net.sf.cglib.core.CollectionUtils+bucket(Collection,Transformer) net.sf.cglib.core.CollectionUtils+bucket(Collection,Transformer) +() +transform(Object)",net.sf.cglib.core.Types+CLASS net.sf.cglib.core.Signatures+GET_NAME net.sf.cglib.core.Types+OBJECT net.sf.cglib.core.Signatures+EQUALS,2951,64,10,,"private static void member_helper_type(final Emitter e,
                                           List members,
                                           final ObjectSwitchCallback callback,
                                           final ParameterTyper typer,
                                           final Label def,
                                           final Label end,
                                           final BitSet checked) throws Exception {
        if (members.size() == 1) {
            // need to check classes that have not already been checked via switches
            Member member = (Member)members.get(0);
            Class[] types = typer.getParameterTypes(member);
            for (int i = 0; i < types.length; i++) {
                if (checked == null || !checked.get(i)) {
                    e.dup();
                    e.aaload(i);
                    e.invoke_virtual(Types.CLASS, Signatures.GET_NAME);
                    e.push(types[i].getName());
                    e.invoke_virtual(Types.OBJECT, Signatures.EQUALS);
                    e.ifeq(def);
                }
            }
            e.pop();
            callback.processCase(member, end);
        } else {
            // choose the index that has the best chance of uniquely identifying member
            Class[] example = typer.getParameterTypes(members.get(0));
            Map buckets = null;
            int index = -1;
            for (int i = 0; i < example.length; i++) {
                final int j = i;
                Map test = CollectionUtils.bucket(members, new Transformer() {
                    public Object transform(Object value) {
                        return typer.getParameterTypes(value)[j].getName();
                    }
                });
                if (buckets == null || test.size() > buckets.size()) {
                    buckets = test;
                    index = i;
                }
            }
            if (buckets == null) {
                // TODO: switch by returnType
                // must have two methods with same name, types, and different return types
                e.goTo(def);
            } else {
                checked.set(index);

                e.dup();
                e.aaload(index);
                e.invoke_virtual(Types.CLASS, Signatures.GET_NAME);

                final Map fbuckets = buckets;
                String[] names = (String[])buckets.keySet().toArray(new String[buckets.size()]);
                string_switch_hash(e, names, new ObjectSwitchCallback() {
                    public void processCase(Object key, Label dontUseEnd) throws Exception {
                        member_helper_type(e, (List)fbuckets.get(key), callback, typer, def, end, checked);
                    }
                    public void processDefault() throws Exception {
                        e.goTo(def);
                    }
                });
            }
        }
    }",True,True,The function of this method is to help determine the type of a member by checking its parameter types. It uses a switch statement to handle different cases based on the parameter types of the member.,False,The code is a recursive method that helps in selecting a specific member from a list of members based on their parameter types. It uses a combination of checks and switches to determine the appropriate member and invokes a callback function with the selected member.
36,"begin_class(Emitter,int,String,Class,Class[],String)",begin class e access class name superclass interfaces source file ,Method,,"net.sf.cglib.beans.BeanMap+BeanMapEmitter(ClassVisitor,String,Class,int) net.sf.cglib.beans.BulkBean+BulkBeanEmitter(ClassVisitor,String,Class,String[],String[],Class[]) net.sf.cglib.core.KeyFactory+KeyFactoryEmitter(ClassVisitor,String,Class) net.sf.cglib.Enhancer+EnhancerEmitter(ClassVisitor,String,Class,Class[],CallbackFilter) net.sf.cglib.Mixin+MixinEmitter(ClassVisitor,String,Class[],int[]) net.sf.cglib.reflect.ConstructorDelegate+Generator.generateClass(ClassVisitor) net.sf.cglib.reflect.FastClass+FastClassEmitter(ClassVisitor,String,Class) net.sf.cglib.reflect.MethodDelegate+Generator.generateClass(ClassVisitor) net.sf.cglib.reflect.MulticastDelegate+Generator.generateClass(ClassVisitor) net.sf.cglib.util.ParallelSorter+ParallelSorterEmitter(ClassVisitor,String,Object[]) net.sf.cglib.core.TestStringSwitch+Generator.generateClass(ClassVisitor) net.sf.cglib.core.TestSwitch+Generator.generateClass(ClassVisitor) net.sf.cglib.reflect.TestMemberSwitch+Generator.generateClass(ClassVisitor)","net.sf.cglib.core.Emitter+begin_class(int,Type,Type,Type[],String) net.sf.cglib.core.Emitter+begin_class(int,Type,Type,Type[],String) net.sf.cglib.core.Ops+getType(String) net.sf.cglib.core.Ops+getType(String) org.objectweb.asm.Type+getType(Class) org.objectweb.asm.Type+getType(Class) net.sf.cglib.core.Signature+getTypes(Class[]) net.sf.cglib.core.Signature+getTypes(Class[])",,550,12,9,,"public static void begin_class(Emitter e,
                                   int access,
                                   String className,
                                   Class superclass,
                                   Class[] interfaces,
                                   String sourceFile) {
        e.begin_class(access,
                      getType(className),
                      (superclass != null) ? Type.getType(superclass) : null,
                      Signature.getTypes(interfaces),
                      sourceFile);
    }",False,True,"This method begins a class by calling the ""begin_class"" method of an ""Emitter"" object, passing in the access level, class name, superclass, interfaces, and source file.",True,"This code defines a method called ""begin_class"" that takes in various parameters such as an Emitter object, access level, class name, superclass, interfaces, and source file. It then calls the ""begin_class"" method of the Emitter object with the appropriate arguments to begin the definition of a class."
37,"begin_constructor(Emitter,Constructor)",begin constructor e constructor ,Method,,net.sf.cglib.Enhancer+generateConstructors(List),"net.sf.cglib.core.Emitter+begin_constructor(int,Type[],Type[]) net.sf.cglib.core.Emitter+begin_constructor(int,Type[],Type[]) net.sf.cglib.core.Signature+getTypes(Class[]) net.sf.cglib.core.Signature+getTypes(Class[]) java.lang.reflect.Constructor+getParameterTypes() java.lang.reflect.Constructor+getParameterTypes() net.sf.cglib.core.Signature+getTypes(Class[]) net.sf.cglib.core.Signature+getTypes(Class[]) java.lang.reflect.Constructor+getExceptionTypes() java.lang.reflect.Constructor+getExceptionTypes()",org.objectweb.asm.Constants+ACC_PUBLIC,324,5,9,,"public static void begin_constructor(Emitter e, Constructor constructor) {
        e.begin_constructor(Constants.ACC_PUBLIC, // constructor.getModifiers(),
                            Signature.getTypes(constructor.getParameterTypes()),
                            Signature.getTypes(constructor.getExceptionTypes()));
    }",True,True,"This method serves to begin the construction of a constructor by taking an Emitter object and a Constructor object as parameters. It sets the access modifier, parameter types, and exception types for the constructor.",True,"This code defines a static method called ""begin_constructor"" that takes an Emitter object and a Constructor object as parameters. It calls the ""begin_constructor"" method of the Emitter object with the access modifier, parameter types, and exception types of the given Constructor object."
38,"begin_method(Emitter,int,String,Class,Class[],Class[])",begin method e access name return type parameter types exception types ,Method,,"net.sf.cglib.MethodInterceptor+generateAccessMethod(Emitter,Context,Method)","net.sf.cglib.core.Emitter+begin_method(int,String,Type,Type[],Type[]) net.sf.cglib.core.Emitter+begin_method(int,String,Type,Type[],Type[]) org.objectweb.asm.Type+getType(Class) org.objectweb.asm.Type+getType(Class) net.sf.cglib.core.Signature+getTypes(Class[]) net.sf.cglib.core.Signature+getTypes(Class[]) net.sf.cglib.core.Signature+getTypes(Class[]) net.sf.cglib.core.Signature+getTypes(Class[])",,549,12,9,,"public static void begin_method(Emitter e,
                                    int access,
                                    String name,
                                    Class returnType,
                                    Class[] parameterTypes,
                                    Class[] exceptionTypes) {
        e.begin_method(access,
                       name,
                       Type.getType(returnType),
                       Signature.getTypes(parameterTypes),
                       Signature.getTypes(exceptionTypes));
    }",True,True,"The function of this method is to begin a method by passing the necessary parameters such as the emitter, access level, name, return type, parameter types, and exception types.",True,"This code defines a method called ""begin_method"" that takes an Emitter object, access level, name, return type, parameter types, and exception types as arguments. It then calls the ""begin_method"" method of the Emitter object with the provided arguments."
39,"begin_method(Emitter,Method)",begin method e method ,Method,,"net.sf.cglib.Enhancer+generateFactory(List) net.sf.cglib.Mixin+MixinEmitter(ClassVisitor,String,Class[],int[]) net.sf.cglib.reflect.ConstructorDelegate+Generator.generateClass(ClassVisitor) net.sf.cglib.reflect.MethodDelegate+Generator.generateClass(ClassVisitor) net.sf.cglib.reflect.MulticastDelegate+Generator.generateClass(ClassVisitor) net.sf.cglib.core.TestStringSwitch+Generator.generateClass(ClassVisitor) net.sf.cglib.core.TestSwitch+Generator.generateClass(ClassVisitor) net.sf.cglib.reflect.TestMemberSwitch+Generator.generateClass(ClassVisitor)","net.sf.cglib.core.Ops+begin_method(Emitter,Method,int) net.sf.cglib.core.Ops+begin_method(Emitter,Method,int) net.sf.cglib.core.Ops+getDefaultModifiers(int) net.sf.cglib.core.Ops+getDefaultModifiers(int) java.lang.reflect.Method+getModifiers() java.lang.reflect.Method+getModifiers()",,142,3,9,,"public static void begin_method(Emitter e, Method method) {
        begin_method(e, method, getDefaultModifiers(method.getModifiers()));
    }",True,True,"The function of this method is to begin a method by calling another method with the provided emitter, method, and default modifiers.",True,"The code defines a static method called ""begin_method"" that takes an ""Emitter"" object and a ""Method"" object as parameters. It calls another version of the ""begin_method"" method with an additional parameter, which is the default modifiers of the given method."
40,"begin_method(Emitter,Method,int)",begin method e method modifiers ,Method,"begin_method(Emitter,Method)","net.sf.cglib.Dispatcher+generate(Emitter,Context) net.sf.cglib.InvocationHandler+generate(Emitter,Context) net.sf.cglib.LazyLoader+generate(Emitter,Context) net.sf.cglib.MethodInterceptor+generateAroundMethod(Emitter,Context,Method)","net.sf.cglib.core.Emitter+begin_method(int,Signature,Type[]) net.sf.cglib.core.Emitter+begin_method(int,Signature,Type[]) net.sf.cglib.core.Signature+Signature(Method) net.sf.cglib.core.Signature+getTypes(Class[]) net.sf.cglib.core.Signature+getTypes(Class[]) java.lang.reflect.Method+getExceptionTypes() java.lang.reflect.Method+getExceptionTypes()",,232,5,9,,"public static void begin_method(Emitter e, Method method, int modifiers) {
        e.begin_method(modifiers,
                       new Signature(method),
                       Signature.getTypes(method.getExceptionTypes()));
    }",True,True,"This method serves to begin a method by calling the ""begin_method"" method of the given Emitter object, passing the given modifiers, method signature, and exception types.",True,"This code defines a static method called ""begin_method"" that takes an Emitter object, a Method object, and an integer as parameters. It calls the ""begin_method"" method of the Emitter object with the provided modifiers, signature, and exception types of the given Method object."
41,"getfield(Emitter,Field)",getfield e field ,Method,,,"java.lang.reflect.Modifier+isStatic(int) java.lang.reflect.Modifier+isStatic(int) java.lang.reflect.Field+getModifiers() java.lang.reflect.Field+getModifiers() net.sf.cglib.core.Ops+fieldHelper(Emitter,int,Field) net.sf.cglib.core.Ops+fieldHelper(Emitter,int,Field)",org.objectweb.asm.Constants+GETSTATIC org.objectweb.asm.Constants+GETFIELD,202,4,9,,"public static void getfield(Emitter e,Field field) {
        int opcode = Modifier.isStatic(field.getModifiers()) ? Constants.GETSTATIC : Constants.GETFIELD;
        fieldHelper(e, opcode, field);
    }",True,True,"The function of the given method is to retrieve the value of a field from an object or a class. It determines the appropriate opcode based on whether the field is static or not, and then calls the fieldHelper method to perform the retrieval.",True,"The code defines a method named ""getfield"" that takes an Emitter object and a Field object as parameters. It determines the opcode based on whether the field is static or not, and then calls a helper method named ""fieldHelper"" with the determined opcode and the field object."
42,"putfield(Emitter,Field)",putfield e field ,Method,,,"java.lang.reflect.Modifier+isStatic(int) java.lang.reflect.Modifier+isStatic(int) java.lang.reflect.Field+getModifiers() java.lang.reflect.Field+getModifiers() net.sf.cglib.core.Ops+fieldHelper(Emitter,int,Field) net.sf.cglib.core.Ops+fieldHelper(Emitter,int,Field)",org.objectweb.asm.Constants+PUTSTATIC org.objectweb.asm.Constants+PUTFIELD,203,4,9,,"public static void putfield(Emitter e, Field field) {
        int opcode = Modifier.isStatic(field.getModifiers()) ? Constants.PUTSTATIC : Constants.PUTFIELD;
        fieldHelper(e, opcode, field);
    }",True,True,"The function of the method is to determine the opcode based on the modifiers of the field, and then call the fieldHelper method with the determined opcode and the given field.",True,"The code defines a method called ""putfield"" that takes an Emitter object and a Field object as parameters. It determines the opcode based on whether the field is static or not, and then calls a helper method called ""fieldHelper"" with the opcode and field as arguments."
43,"fieldHelper(Emitter,int,Field)",field helper e opcode field ,Method,"getfield(Emitter,Field) putfield(Emitter,Field)",,"net.sf.cglib.core.Emitter+emit_field(int,Type,String,Type) net.sf.cglib.core.Emitter+emit_field(int,Type,String,Type) org.objectweb.asm.Type+getType(Class) org.objectweb.asm.Type+getType(Class) java.lang.reflect.Field+getDeclaringClass() java.lang.reflect.Field+getDeclaringClass() java.lang.reflect.Field+getName() java.lang.reflect.Field+getName() org.objectweb.asm.Type+getType(Class) org.objectweb.asm.Type+getType(Class) java.lang.reflect.Field+getType() java.lang.reflect.Field+getType()",,319,7,10,,"private static void fieldHelper(Emitter e, int opcode, Field field) {
        // TODO: remove need for direct access to emit_field?
        e.emit_field(opcode,
                     Type.getType(field.getDeclaringClass()),
                     field.getName(),
                     Type.getType(field.getType()));
    }",True,True,"The function of the method is to assist in emitting a field instruction using the provided emitter, opcode, and field information.",False,"The code is a helper method that emits a field instruction using the given emitter, opcode, and field information. It is used to generate bytecode instructions for accessing a field in a class. The TODO comment suggests that there might be a better way to handle the direct access to the emit_field method."
44,"invoke(Emitter,Method)",invoke e method ,Method,,"net.sf.cglib.beans.BeanMap+processCase(Object,Label) net.sf.cglib.beans.BeanMap+processCase(Object,Label) net.sf.cglib.beans.BeanMap+processCase(Object,Label) net.sf.cglib.beans.BulkBean+generateGet(Class,Method[]) net.sf.cglib.beans.BulkBean+generateSet(Class,Method[]) net.sf.cglib.Dispatcher+generate(Emitter,Context) net.sf.cglib.Enhancer+generateSetCallbacks() net.sf.cglib.Enhancer+generateSetThreadCallbacks() net.sf.cglib.Enhancer+generateSetThreadCallbacks() net.sf.cglib.Enhancer+generateCurrentCallback(int) net.sf.cglib.LazyLoader+generate(Emitter,Context) net.sf.cglib.MethodInterceptor+generateAroundMethod(Emitter,Context,Method) net.sf.cglib.MethodInterceptor+generateStatic(Emitter,Context) net.sf.cglib.MethodInterceptor+generateStatic(Emitter,Context) net.sf.cglib.Mixin+MixinEmitter(ClassVisitor,String,Class[],int[]) net.sf.cglib.reflect.FastClass+processCase(int,Label) net.sf.cglib.reflect.MethodDelegate+Generator.generateClass(ClassVisitor) net.sf.cglib.reflect.MulticastDelegate+Generator.processElement(Type)","java.lang.Class+isInterface() java.lang.reflect.Method+getDeclaringClass() java.lang.reflect.Method+getDeclaringClass() java.lang.Class+isInterface() java.lang.reflect.Modifier+isStatic(int) java.lang.reflect.Modifier+isStatic(int) java.lang.reflect.Method+getModifiers() java.lang.reflect.Method+getModifiers() net.sf.cglib.core.Emitter+emit_invoke(int,Type,String,Type,Type[]) net.sf.cglib.core.Emitter+emit_invoke(int,Type,String,Type,Type[]) org.objectweb.asm.Type+getType(Class) org.objectweb.asm.Type+getType(Class) java.lang.reflect.Method+getDeclaringClass() java.lang.reflect.Method+getDeclaringClass() java.lang.reflect.Method+getName() java.lang.reflect.Method+getName() org.objectweb.asm.Type+getType(Class) org.objectweb.asm.Type+getType(Class) java.lang.reflect.Method+getReturnType() java.lang.reflect.Method+getReturnType() net.sf.cglib.core.Signature+getTypes(Class[]) net.sf.cglib.core.Signature+getTypes(Class[]) java.lang.reflect.Method+getParameterTypes() java.lang.reflect.Method+getParameterTypes()",org.objectweb.asm.Constants+INVOKEINTERFACE org.objectweb.asm.Constants+INVOKESTATIC org.objectweb.asm.Constants+INVOKEVIRTUAL,692,16,9,,"public static void invoke(Emitter e, Method method) {
        int opcode;
        if (method.getDeclaringClass().isInterface()) {
            opcode = Constants.INVOKEINTERFACE;
        } else if (Modifier.isStatic(method.getModifiers())) {
            opcode = Constants.INVOKESTATIC;
        } else {
            opcode = Constants.INVOKEVIRTUAL;
        }
        // TODO: remove need for direct access to emit_invoke?
        e.emit_invoke(opcode,
                      Type.getType(method.getDeclaringClass()),
                      method.getName(),
                      Type.getType(method.getReturnType()),
                      Signature.getTypes(method.getParameterTypes()));
    }",True,True,"This method determines the appropriate opcode for invoking a method based on its declaring class and modifiers, and then emits the opcode along with other necessary information to invoke the method using an Emitter object.",True,"This code defines a method called ""invoke"" that takes an Emitter object and a Method object as parameters. It determines the appropriate opcode based on the method's declaring class and modifiers, and then emits the corresponding invoke instruction using the Emitter object."
45,"invoke(Emitter,Constructor)",invoke e constructor ,Method,,"net.sf.cglib.reflect.ConstructorDelegate+Generator.generateClass(ClassVisitor) net.sf.cglib.reflect.FastClass+processCase(int,Label)","net.sf.cglib.core.Emitter+invoke_constructor(Type,Type[]) net.sf.cglib.core.Emitter+invoke_constructor(Type,Type[]) org.objectweb.asm.Type+getType(Class) org.objectweb.asm.Type+getType(Class) java.lang.reflect.Constructor+getDeclaringClass() java.lang.reflect.Constructor+getDeclaringClass() net.sf.cglib.core.Signature+getTypes(Class[]) net.sf.cglib.core.Signature+getTypes(Class[]) java.lang.reflect.Constructor+getParameterTypes() java.lang.reflect.Constructor+getParameterTypes()",,228,4,9,,"public static void invoke(Emitter e, Constructor constructor) {
        e.invoke_constructor(Type.getType(constructor.getDeclaringClass()),
                             Signature.getTypes(constructor.getParameterTypes()));
    }",True,True,This method invokes a constructor on an emitter object by passing the constructor's declaring class and parameter types.,True,"The given code is a method named ""invoke"" that takes an ""Emitter"" object and a ""Constructor"" object as parameters. It invokes the constructor specified by the ""Constructor"" object using the ""Emitter"" object, passing the appropriate type and signature information."
46,"super_invoke(Emitter,Method)",super invoke e method ,Method,,"net.sf.cglib.MethodInterceptor+generateAccessMethod(Emitter,Context,Method) net.sf.cglib.MethodInterceptor+generateAroundMethod(Emitter,Context,Method)","net.sf.cglib.core.Emitter+emit_invoke(int,Type,String,Type,Type[]) net.sf.cglib.core.Emitter+emit_invoke(int,Type,String,Type,Type[]) net.sf.cglib.core.Emitter+getSuperType() net.sf.cglib.core.Emitter+getSuperType() java.lang.reflect.Method+getName() java.lang.reflect.Method+getName() org.objectweb.asm.Type+getType(Class) org.objectweb.asm.Type+getType(Class) java.lang.reflect.Method+getReturnType() java.lang.reflect.Method+getReturnType() net.sf.cglib.core.Signature+getTypes(Class[]) net.sf.cglib.core.Signature+getTypes(Class[]) java.lang.reflect.Method+getParameterTypes() java.lang.reflect.Method+getParameterTypes()",org.objectweb.asm.Constants+INVOKESPECIAL,386,8,9,,"public static void super_invoke(Emitter e, Method method) {
        // TODO: remove need for direct access to emit_invoke?
        e.emit_invoke(Constants.INVOKESPECIAL,
                      e.getSuperType(),
                      method.getName(),
                      Type.getType(method.getReturnType()),
                      Signature.getTypes(method.getParameterTypes()));
    }",True,True,"This method is used to emit an invokespecial instruction in bytecode. It takes an Emitter object and a Method object as parameters, and uses them to generate the necessary bytecode instructions for invoking a method on the superclass.",True,"The given code defines a static method named ""super_invoke"" that takes an ""Emitter"" object and a ""Method"" object as parameters. It emits an ""INVOKESPECIAL"" instruction using the provided emitter, super type, method name, return type, and parameter types. The purpose of this method is to invoke a superclass method from a subclass."
47,"super_invoke(Emitter,Constructor)",super invoke e constructor ,Method,,net.sf.cglib.Enhancer+generateConstructors(List),net.sf.cglib.core.Emitter+super_invoke_constructor(Type[]) net.sf.cglib.core.Emitter+super_invoke_constructor(Type[]) net.sf.cglib.core.Signature+getTypes(Class[]) net.sf.cglib.core.Signature+getTypes(Class[]) java.lang.reflect.Constructor+getParameterTypes() java.lang.reflect.Constructor+getParameterTypes(),,164,3,9,,"public static void super_invoke(Emitter e, Constructor constructor) {
        e.super_invoke_constructor(Signature.getTypes(constructor.getParameterTypes()));
    }",False,True,The function of the method is to invoke the constructor of a class using the provided Emitter object and Constructor object.,True,"The given code is a method named ""super_invoke"" that takes an ""Emitter"" object and a ""Constructor"" object as parameters. It invokes the constructor of the ""Emitter"" object using the parameter types of the given ""Constructor"" object."
48,getDefaultModifiers(int),get default modifiers modifiers ,Method,"begin_method(Emitter,Method)",,,org.objectweb.asm.Constants+ACC_FINAL org.objectweb.asm.Constants+ACC_ABSTRACT org.objectweb.asm.Constants+ACC_NATIVE org.objectweb.asm.Constants+ACC_SYNCHRONIZED,247,7,9,,"public static int getDefaultModifiers(int modifiers) {
        return Constants.ACC_FINAL
            | (modifiers
               & ~Constants.ACC_ABSTRACT
               & ~Constants.ACC_NATIVE
               & ~Constants.ACC_SYNCHRONIZED);
    }",True,True,"The function of this method is to return the default modifiers for a given set of modifiers, excluding the abstract, native, and synchronized modifiers.",True,"This code is a method named ""getDefaultModifiers"" that takes an integer parameter ""modifiers"". It returns the value of ""modifiers"" after removing the flags for abstract, native, and synchronized, and adding the flag for final."
49,getType(String),get type fqcn ,Method,"begin_class(Emitter,int,String,Class,Class[],String)",,"org.objectweb.asm.Type+getType(String) org.objectweb.asm.Type+getType(String) java.lang.String+replace(char,char) java.lang.String+replace(char,char)",,113,3,10,,"private static Type getType(String fqcn) {
        return Type.getType(""L"" + fqcn.replace('.', '/') + "";"");
    }",False,True,The function of the given method is to convert a fully qualified class name (fqcn) into a Type object by replacing the dots with slashes and adding the necessary prefix and suffix.,True,"The given code is a private static method named ""getType"" that takes a fully qualified class name (fqcn) as input and returns a Type object. It converts the fqcn into a format compatible with the Type class by replacing the dots with slashes and adding a prefix and suffix."
