index,name,document,type,inner invocations,external invocations,calls,visits,length,lines,modifier,commit,full text,moved,removed,gpt text,gpt response,code summary
1,ruleFactory,rule factory ,Field,"ObjectRule(RuleFactory,ParcelableHelper)",,,,38,1,18,,private final RuleFactory ruleFactory;,False,False,,False,
2,parcelableHelper,parcelable helper ,Field,"ObjectRule(RuleFactory,ParcelableHelper)",,,,48,1,18,,private final ParcelableHelper parcelableHelper;,False,False,,False,
3,"ObjectRule(RuleFactory,ParcelableHelper)",object rule rule factory parcelable helper ,Method,,,,org.jsonschema2pojo.rules.ObjectRule+ruleFactory org.jsonschema2pojo.rules.ObjectRule+ruleFactory org.jsonschema2pojo.rules.ObjectRule+parcelableHelper org.jsonschema2pojo.rules.ObjectRule+parcelableHelper,178,4,4,,"protected ObjectRule(RuleFactory ruleFactory, ParcelableHelper parcelableHelper) {
        this.ruleFactory = ruleFactory;
        this.parcelableHelper = parcelableHelper;
    }",False,False,The function of the method is to initialize the ObjectRule class with the provided RuleFactory and ParcelableHelper objects.,True,"The code defines a protected constructor for the ObjectRule class, which takes two parameters: a RuleFactory object and a ParcelableHelper object. The constructor assigns these parameters to the corresponding instance variables of the ObjectRule class."
4,"apply(String,JsonNode,JsonNode,JPackage,Schema)",apply node name node parent package schema applies this schema rule to take the required code generation steps when this rule is applied for schemas of type object the properties of the schema are used to generate a new java class and determine its characteristics see other implementers of link rule for details ,Method,,org.jsonschema2pojo.rules.TypeRuleTest+applyGeneratesCustomObject(),"org.jsonschema2pojo.rules.ObjectRule+getSuperType(String,JsonNode,JPackage,Schema) org.jsonschema2pojo.rules.ObjectRule+getSuperType(String,JsonNode,JPackage,Schema) org.jsonschema2pojo.rules.ObjectRule+isFinal(JType) org.jsonschema2pojo.rules.ObjectRule+isFinal(JType) org.jsonschema2pojo.rules.ObjectRule+createClass(String,JsonNode,JPackage) org.jsonschema2pojo.rules.ObjectRule+createClass(String,JsonNode,JPackage) org.jsonschema2pojo.exception.ClassAlreadyExistsException+getExistingClass() org.jsonschema2pojo.exception.ClassAlreadyExistsException+getExistingClass() org.jsonschema2pojo.Schema+setJavaTypeIfEmpty(JType) org.jsonschema2pojo.Schema+setJavaTypeIfEmpty(JType) org.jsonschema2pojo.rules.ObjectRule+addJsonTypeInfoAnnotation(JDefinedClass,JsonNode) org.jsonschema2pojo.rules.ObjectRule+addJsonTypeInfoAnnotation(JDefinedClass,JsonNode) org.jsonschema2pojo.rules.RuleFactory+getTitleRule() org.jsonschema2pojo.rules.RuleFactory+getTitleRule() org.jsonschema2pojo.rules.RuleFactory+getDescriptionRule() org.jsonschema2pojo.rules.RuleFactory+getDescriptionRule() org.jsonschema2pojo.GenerationConfig+isGenerateBuilders() org.jsonschema2pojo.rules.RuleFactory+getGenerationConfig() org.jsonschema2pojo.rules.RuleFactory+getGenerationConfig() org.jsonschema2pojo.GenerationConfig+isGenerateBuilders() org.jsonschema2pojo.GenerationConfig+isUseInnerClassBuilders() org.jsonschema2pojo.rules.RuleFactory+getGenerationConfig() org.jsonschema2pojo.rules.RuleFactory+getGenerationConfig() org.jsonschema2pojo.GenerationConfig+isUseInnerClassBuilders() org.jsonschema2pojo.rules.RuleFactory+getBuilderRule() org.jsonschema2pojo.rules.RuleFactory+getBuilderRule() org.jsonschema2pojo.rules.RuleFactory+getPropertiesRule() org.jsonschema2pojo.rules.RuleFactory+getPropertiesRule() org.jsonschema2pojo.rules.ObjectRule+addInterfaces(JDefinedClass,JsonNode) org.jsonschema2pojo.rules.ObjectRule+addInterfaces(JDefinedClass,JsonNode) org.jsonschema2pojo.rules.RuleFactory+getAdditionalPropertiesRule() org.jsonschema2pojo.rules.RuleFactory+getAdditionalPropertiesRule() org.jsonschema2pojo.rules.RuleFactory+getDynamicPropertiesRule() org.jsonschema2pojo.rules.RuleFactory+getDynamicPropertiesRule() org.jsonschema2pojo.rules.RuleFactory+getRequiredArrayRule() org.jsonschema2pojo.rules.RuleFactory+getRequiredArrayRule() org.jsonschema2pojo.GenerationConfig+isIncludeToString() org.jsonschema2pojo.rules.RuleFactory+getGenerationConfig() org.jsonschema2pojo.rules.RuleFactory+getGenerationConfig() org.jsonschema2pojo.GenerationConfig+isIncludeToString() org.jsonschema2pojo.rules.ObjectRule+addToString(JDefinedClass) org.jsonschema2pojo.rules.ObjectRule+addToString(JDefinedClass) org.jsonschema2pojo.GenerationConfig+isIncludeHashcodeAndEquals() org.jsonschema2pojo.rules.RuleFactory+getGenerationConfig() org.jsonschema2pojo.rules.RuleFactory+getGenerationConfig() org.jsonschema2pojo.GenerationConfig+isIncludeHashcodeAndEquals() org.jsonschema2pojo.rules.ObjectRule+addHashCode(JDefinedClass,JsonNode) org.jsonschema2pojo.rules.ObjectRule+addHashCode(JDefinedClass,JsonNode) org.jsonschema2pojo.rules.ObjectRule+addEquals(JDefinedClass,JsonNode) org.jsonschema2pojo.rules.ObjectRule+addEquals(JDefinedClass,JsonNode) org.jsonschema2pojo.GenerationConfig+isParcelable() org.jsonschema2pojo.rules.RuleFactory+getGenerationConfig() org.jsonschema2pojo.rules.RuleFactory+getGenerationConfig() org.jsonschema2pojo.GenerationConfig+isParcelable() org.jsonschema2pojo.rules.ObjectRule+addParcelSupport(JDefinedClass) org.jsonschema2pojo.rules.ObjectRule+addParcelSupport(JDefinedClass) org.jsonschema2pojo.GenerationConfig+isIncludeConstructors() org.jsonschema2pojo.rules.RuleFactory+getGenerationConfig() org.jsonschema2pojo.rules.RuleFactory+getGenerationConfig() org.jsonschema2pojo.GenerationConfig+isIncludeConstructors() org.jsonschema2pojo.rules.ObjectRule+addConstructors(JDefinedClass,JsonNode,Schema,boolean) org.jsonschema2pojo.rules.ObjectRule+addConstructors(JDefinedClass,JsonNode,Schema,boolean) org.jsonschema2pojo.GenerationConfig+isConstructorsRequiredPropertiesOnly() org.jsonschema2pojo.rules.RuleFactory+getGenerationConfig() org.jsonschema2pojo.rules.RuleFactory+getGenerationConfig() org.jsonschema2pojo.GenerationConfig+isConstructorsRequiredPropertiesOnly() org.jsonschema2pojo.GenerationConfig+isSerializable() org.jsonschema2pojo.rules.RuleFactory+getGenerationConfig() org.jsonschema2pojo.rules.RuleFactory+getGenerationConfig() org.jsonschema2pojo.GenerationConfig+isSerializable() org.jsonschema2pojo.util.SerializableHelper+addSerializableSupport(JDefinedClass) org.jsonschema2pojo.util.SerializableHelper+addSerializableSupport(JDefinedClass)",org.jsonschema2pojo.rules.ObjectRule+ruleFactory org.jsonschema2pojo.rules.ObjectRule+ruleFactory org.jsonschema2pojo.rules.ObjectRule+ruleFactory org.jsonschema2pojo.rules.ObjectRule+ruleFactory org.jsonschema2pojo.rules.ObjectRule+ruleFactory org.jsonschema2pojo.rules.ObjectRule+ruleFactory org.jsonschema2pojo.rules.ObjectRule+ruleFactory org.jsonschema2pojo.rules.ObjectRule+ruleFactory org.jsonschema2pojo.rules.ObjectRule+ruleFactory org.jsonschema2pojo.rules.ObjectRule+ruleFactory org.jsonschema2pojo.rules.ObjectRule+ruleFactory org.jsonschema2pojo.rules.ObjectRule+ruleFactory org.jsonschema2pojo.rules.ObjectRule+ruleFactory org.jsonschema2pojo.rules.ObjectRule+ruleFactory org.jsonschema2pojo.rules.ObjectRule+ruleFactory,3009,82,1,"/** 
 * Applies this schema rule to take the required code generation steps. <p> When this rule is applied for schemas of type object, the properties of the schema are used to generate a new Java class and determine its characteristics. See other implementers of  {@link Rule} for details.
 */
","/**
     * Applies this schema rule to take the required code generation steps.
     * <p>
     * When this rule is applied for schemas of type object, the properties of
     * the schema are used to generate a new Java class and determine its
     * characteristics. See other implementers of {@link Rule} for details.
     */
    @Override
    public JType apply(String nodeName, JsonNode node, JsonNode parent, JPackage _package, Schema schema) {

        JType superType = getSuperType(nodeName, node, _package, schema);

        if (superType.isPrimitive() || isFinal(superType)) {
            return superType;
        }

        JDefinedClass jclass;
        try {
            jclass = createClass(nodeName, node, _package);
        } catch (ClassAlreadyExistsException e) {
            return e.getExistingClass();
        }

        jclass._extends((JClass) superType);

        schema.setJavaTypeIfEmpty(jclass);

        if (node.has(""deserializationClassProperty"")) {
            addJsonTypeInfoAnnotation(jclass, node);
        }

        if (node.has(""title"")) {
            ruleFactory.getTitleRule().apply(nodeName, node.get(""title""), node, jclass, schema);
        }

        if (node.has(""description"")) {
            ruleFactory.getDescriptionRule().apply(nodeName, node.get(""description""), node, jclass, schema);
        }

        // Creates the class definition for the builder
        if(ruleFactory.getGenerationConfig().isGenerateBuilders() && ruleFactory.getGenerationConfig().isUseInnerClassBuilders()){
            ruleFactory.getBuilderRule().apply(nodeName, node, parent, jclass, schema);
        }

        ruleFactory.getPropertiesRule().apply(nodeName, node.get(""properties""), node, jclass, schema);

        if (node.has(""javaInterfaces"")) {
            addInterfaces(jclass, node.get(""javaInterfaces""));
        }

        ruleFactory.getAdditionalPropertiesRule().apply(nodeName, node.get(""additionalProperties""), node, jclass, schema);

        ruleFactory.getDynamicPropertiesRule().apply(nodeName, node.get(""properties""), node, jclass, schema);

        if (node.has(""required"")) {
            ruleFactory.getRequiredArrayRule().apply(nodeName, node.get(""required""), node, jclass, schema);
        }

        if (ruleFactory.getGenerationConfig().isIncludeToString()) {
            addToString(jclass);
        }

        if (ruleFactory.getGenerationConfig().isIncludeHashcodeAndEquals()) {
            addHashCode(jclass, node);
            addEquals(jclass, node);
        }

        if (ruleFactory.getGenerationConfig().isParcelable()) {
            addParcelSupport(jclass);
        }

        if (ruleFactory.getGenerationConfig().isIncludeConstructors()) {
            addConstructors(jclass, node, schema, ruleFactory.getGenerationConfig().isConstructorsRequiredPropertiesOnly());
        }

        if (ruleFactory.getGenerationConfig().isSerializable()) {
            SerializableHelper.addSerializableSupport(jclass);
        }

        return jclass;

    }",False,False,"This method applies a schema rule to generate code for a Java class based on a JSON schema. It also performs various code generation steps such as adding annotations, implementing interfaces, and generating constructors.",True,"This code represents the implementation of a schema rule in Java. It applies various code generation steps based on the properties of the schema, such as creating a new Java class, adding annotations, generating builder classes, defining properties, implementing interfaces, adding toString, hashCode, equals methods, supporting Parcelable, constructors, and serialization."
5,addParcelSupport(JDefinedClass),add parcel support jclass ,Method,"apply(String,JsonNode,JsonNode,JPackage,Schema)",,org.jsonschema2pojo.util.ParcelableHelper+addWriteToParcel(JDefinedClass) org.jsonschema2pojo.util.ParcelableHelper+addWriteToParcel(JDefinedClass) org.jsonschema2pojo.util.ParcelableHelper+addDescribeContents(JDefinedClass) org.jsonschema2pojo.util.ParcelableHelper+addDescribeContents(JDefinedClass) org.jsonschema2pojo.util.ParcelableHelper+addCreator(JDefinedClass) org.jsonschema2pojo.util.ParcelableHelper+addCreator(JDefinedClass) org.jsonschema2pojo.util.ParcelableHelper+addConstructorFromParcel(JDefinedClass) org.jsonschema2pojo.util.ParcelableHelper+addConstructorFromParcel(JDefinedClass) org.jsonschema2pojo.GenerationConfig+isIncludeConstructors() org.jsonschema2pojo.rules.RuleFactory+getGenerationConfig() org.jsonschema2pojo.rules.RuleFactory+getGenerationConfig() org.jsonschema2pojo.GenerationConfig+isIncludeConstructors(),org.jsonschema2pojo.rules.ObjectRule+parcelableHelper org.jsonschema2pojo.rules.ObjectRule+parcelableHelper org.jsonschema2pojo.rules.ObjectRule+parcelableHelper org.jsonschema2pojo.rules.ObjectRule+parcelableHelper org.jsonschema2pojo.rules.ObjectRule+ruleFactory,591,13,2,,"private void addParcelSupport(JDefinedClass jclass) {
        jclass._implements(jclass.owner().directClass(""android.os.Parcelable""));

        parcelableHelper.addWriteToParcel(jclass);
        parcelableHelper.addDescribeContents(jclass);
        parcelableHelper.addCreator(jclass);
        parcelableHelper.addConstructorFromParcel(jclass);
        // #742 : includeConstructors will include the default constructor
        if (!ruleFactory.getGenerationConfig().isIncludeConstructors()) {
            // Add empty constructor
            jclass.constructor(JMod.PUBLIC);
        }
    }",False,False,"The function adds support for the Parcelable interface to the given class. It adds methods for writing to a parcel, describing contents, creating an instance, and constructing from a parcel. It also adds an empty constructor if necessary.",False,"The code adds support for the Parcelable interface to a given class. It calls various methods from a parcelableHelper object to add necessary functionality such as writing to a parcel, describing contents, adding a creator, and adding a constructor from a parcel. If the generation configuration does not include constructors, an empty public constructor is added."
6,"getConstructorProperties(JsonNode,boolean)",get constructor properties node only required retrieve the list of properties to go in the constructor from node this is all properties listed in node properties if only required and only required properties if only required param node return ,Method,"getSuperTypeConstructorPropertiesRecursive(JsonNode,Schema,boolean) addConstructors(JDefinedClass,JsonNode,Schema,boolean)",,"java.util.Set+add(E) java.util.Set+add(E) org.jsonschema2pojo.rules.RuleFactory+getNameHelper() org.jsonschema2pojo.rules.RuleFactory+getNameHelper() java.util.HashSet+add(E) java.util.HashSet+add(E) org.jsonschema2pojo.util.NameHelper+getPropertyName(String,JsonNode) org.jsonschema2pojo.util.NameHelper+getPropertyName(String,JsonNode) java.util.Set+contains(Object) java.util.Set+contains(Object) java.util.HashSet+add(E) java.util.HashSet+add(E) org.jsonschema2pojo.util.NameHelper+getPropertyName(String,JsonNode) org.jsonschema2pojo.util.NameHelper+getPropertyName(String,JsonNode) java.util.HashSet+add(E) java.util.HashSet+add(E) org.jsonschema2pojo.util.NameHelper+getPropertyName(String,JsonNode) org.jsonschema2pojo.util.NameHelper+getPropertyName(String,JsonNode)",org.jsonschema2pojo.rules.ObjectRule+ruleFactory,2033,50,2,"/** 
 * Retrieve the list of properties to go in the constructor from node. This is all properties listed in node[""properties""] if ! onlyRequired, and only required properties if onlyRequired.
 * @param node
 * @return
 */
","/**
     * Retrieve the list of properties to go in the constructor from node. This
     * is all properties listed in node[""properties""] if ! onlyRequired, and
     * only required properties if onlyRequired.
     *
     * @param node
     * @return
     */
    private LinkedHashSet<String> getConstructorProperties(JsonNode node, boolean onlyRequired) {

        if (!node.has(""properties"")) {
            return new LinkedHashSet<>();
        }

        LinkedHashSet<String> rtn = new LinkedHashSet<>();
        Set<String> draft4RequiredProperties = new HashSet<>();

        // setup the set of required properties for draft4 style ""required""
        if (onlyRequired && node.has(""required"")) {
            JsonNode requiredArray =  node.get(""required"");
            if (requiredArray.isArray()) {
                for (JsonNode requiredEntry: requiredArray) {
                    if (requiredEntry.isTextual()) {
                        draft4RequiredProperties.add(requiredEntry.asText());
                    }
                }
            }
        }

        NameHelper nameHelper = ruleFactory.getNameHelper();
        for (Iterator<Map.Entry<String, JsonNode>> properties = node.get(""properties"").fields(); properties.hasNext();) {
            Map.Entry<String, JsonNode> property = properties.next();

            JsonNode propertyObj = property.getValue();
            if (onlyRequired) {
                // draft3 style
                if (propertyObj.has(""required"") && propertyObj.get(""required"").asBoolean()) {
                    rtn.add(nameHelper.getPropertyName(property.getKey(), property.getValue()));
                }

                // draft4 style
                if (draft4RequiredProperties.contains(property.getKey())) {
                    rtn.add(nameHelper.getPropertyName(property.getKey(), property.getValue()));
                }
            } else {
                rtn.add(nameHelper.getPropertyName(property.getKey(), property.getValue()));
            }
        }
        return rtn;
    }",False,True,"The function of this method is to retrieve a list of properties from a given node. The properties can either be all properties listed in node[""properties""] if onlyRequired is false, or only the required properties if onlyRequired is true. The method returns a LinkedHashSet<String> containing the retrieved properties.",False,"This code defines a private method called ""getConstructorProperties"" that takes a JSON node and a boolean flag as parameters. It retrieves a list of properties from the JSON node based on the flag value, either including all properties or only the required ones. The method returns a LinkedHashSet containing the names of the properties."
7,"getSuperTypeConstructorPropertiesRecursive(JsonNode,Schema,boolean)",get super type constructor properties recursive node schema only required recursive walks the schema tree and assembles a list of all properties of this schema s super schemas ,Method,"getSuperTypeConstructorPropertiesRecursive(JsonNode,Schema,boolean) addConstructors(JDefinedClass,JsonNode,Schema,boolean)",,"org.jsonschema2pojo.rules.ObjectRule+getSuperSchema(JsonNode,Schema,boolean) org.jsonschema2pojo.rules.ObjectRule+getSuperSchema(JsonNode,Schema,boolean) org.jsonschema2pojo.Schema+getContent() org.jsonschema2pojo.Schema+getContent() org.jsonschema2pojo.rules.ObjectRule+getConstructorProperties(JsonNode,boolean) org.jsonschema2pojo.rules.ObjectRule+getConstructorProperties(JsonNode,boolean) java.util.AbstractCollection+addAll(Collection) java.util.AbstractCollection+addAll(Collection) org.jsonschema2pojo.rules.ObjectRule+getSuperTypeConstructorPropertiesRecursive(JsonNode,Schema,boolean) org.jsonschema2pojo.rules.ObjectRule+getSuperTypeConstructorPropertiesRecursive(JsonNode,Schema,boolean)",,712,17,2,"/** 
 * Recursive, walks the schema tree and assembles a list of all properties of this schema's super schemas
 */
","/**
     * Recursive, walks the schema tree and assembles a list of all properties of this schema's super schemas
     */
    private LinkedHashSet<String> getSuperTypeConstructorPropertiesRecursive(JsonNode node, Schema schema, boolean onlyRequired) {
        Schema superTypeSchema = getSuperSchema(node, schema, true);

        if (superTypeSchema == null) {
            return new LinkedHashSet<>();
        }

        JsonNode superSchemaNode = superTypeSchema.getContent();

        LinkedHashSet<String> rtn = getConstructorProperties(superSchemaNode, onlyRequired);
        rtn.addAll(getSuperTypeConstructorPropertiesRecursive(superSchemaNode, superTypeSchema, onlyRequired));

        return rtn;
    }",False,False,The function of this method is to recursively traverse a schema tree and collect a list of all properties from the super schemas of the given schema. It returns a LinkedHashSet of these properties.,False,"The `getSuperTypeConstructorPropertiesRecursive` method is a recursive function that traverses a schema tree and collects a list of all properties from the super schemas of a given schema. It takes a `JsonNode` object, a `Schema` object, and a boolean flag indicating whether only required properties should be included. It returns a `LinkedHashSet` containing the collected properties."
8,"createClass(String,JsonNode,JPackage)",create class node name node package creates a new java class that will be generated param node name the node name which may be used to dictate the new class name param node the node representing the schema that caused the need for a new class this node may include a java type property which if present will override the fully qualified name of the newly generated class param package the package which may contain a new class after this method call return a reference to a newly created class throws class already exists exception if the given arguments cause an attempt to create a class that already exists either on the classpath or in the current map of classes to be generated ,Method,"apply(String,JsonNode,JsonNode,JPackage,Schema)",,"org.jsonschema2pojo.exception.ClassAlreadyExistsException+ClassAlreadyExistsException(JType) org.jsonschema2pojo.exception.ClassAlreadyExistsException+ClassAlreadyExistsException(JType) org.jsonschema2pojo.rules.ObjectRule+usesPolymorphicDeserialization(JsonNode) org.jsonschema2pojo.rules.ObjectRule+usesPolymorphicDeserialization(JsonNode) org.jsonschema2pojo.exception.GenerationException+GenerationException(String) java.lang.String+contains(CharSequence) java.lang.String+contains(CharSequence) org.jsonschema2pojo.exception.GenerationException+GenerationException(String) java.lang.String+lastIndexOf(String) java.lang.String+lastIndexOf(String) java.lang.String+length() java.lang.String+length() java.lang.String+substring(int,int) java.lang.String+substring(int,int) org.jsonschema2pojo.GenerationConfig+getClassNamePrefix() org.jsonschema2pojo.rules.RuleFactory+getGenerationConfig() org.jsonschema2pojo.rules.RuleFactory+getGenerationConfig() org.jsonschema2pojo.GenerationConfig+getClassNamePrefix() java.lang.String+substring(int) java.lang.String+substring(int) org.jsonschema2pojo.GenerationConfig+getClassNameSuffix() org.jsonschema2pojo.rules.RuleFactory+getGenerationConfig() org.jsonschema2pojo.rules.RuleFactory+getGenerationConfig() org.jsonschema2pojo.GenerationConfig+getClassNameSuffix() org.jsonschema2pojo.util.NameHelper+getClassName(String,JsonNode,JPackage) org.jsonschema2pojo.rules.RuleFactory+getNameHelper() org.jsonschema2pojo.rules.RuleFactory+getNameHelper() org.jsonschema2pojo.util.NameHelper+getClassName(String,JsonNode,JPackage) org.jsonschema2pojo.util.NameHelper+getClassName(String,JsonNode,JPackage) org.jsonschema2pojo.rules.RuleFactory+getNameHelper() org.jsonschema2pojo.rules.RuleFactory+getNameHelper() org.jsonschema2pojo.util.NameHelper+getClassName(String,JsonNode,JPackage) org.jsonschema2pojo.exception.ClassAlreadyExistsException+ClassAlreadyExistsException(JType) org.jsonschema2pojo.Annotator+propertyInclusion(JDefinedClass,JsonNode) org.jsonschema2pojo.rules.RuleFactory+getAnnotator() org.jsonschema2pojo.rules.RuleFactory+getAnnotator() org.jsonschema2pojo.Annotator+propertyInclusion(JDefinedClass,JsonNode)",org.jsonschema2pojo.rules.ObjectRule+ruleFactory org.jsonschema2pojo.rules.ObjectRule+ruleFactory org.jsonschema2pojo.rules.ObjectRule+ruleFactory org.jsonschema2pojo.rules.ObjectRule+ruleFactory org.jsonschema2pojo.rules.ObjectRule+ruleFactory,3480,73,2,"/** 
 * Creates a new Java class that will be generated.
 * @param nodeName the node name which may be used to dictate the new class name
 * @param node the node representing the schema that caused the need for a new class. This node may include a 'javaType' property which if present will override the fully qualified name of the newly generated class.
 * @param _package the package which may contain a new class after this method call
 * @return a reference to a newly created class
 * @throws ClassAlreadyExistsException if the given arguments cause an attempt to create a class that already exists, either on the classpath or in the current map of classes to be generated.
 */
","/**
     * Creates a new Java class that will be generated.
     *
     * @param nodeName
     *            the node name which may be used to dictate the new class name
     * @param node
     *            the node representing the schema that caused the need for a
     *            new class. This node may include a 'javaType' property which
     *            if present will override the fully qualified name of the newly
     *            generated class.
     * @param _package
     *            the package which may contain a new class after this method
     *            call
     * @return a reference to a newly created class
     * @throws ClassAlreadyExistsException
     *             if the given arguments cause an attempt to create a class
     *             that already exists, either on the classpath or in the
     *             current map of classes to be generated.
     */
    private JDefinedClass createClass(String nodeName, JsonNode node, JPackage _package) throws ClassAlreadyExistsException {

        JDefinedClass newType;

        try {
            if (node.has(""existingJavaType"")) {
                String fqn = substringBefore(node.get(""existingJavaType"").asText(), ""<"");

                if (isPrimitive(fqn, _package.owner())) {
                    throw new ClassAlreadyExistsException(primitiveType(fqn, _package.owner()));
                }

                JClass existingClass = resolveType(_package, fqn + (node.get(""existingJavaType"").asText().contains(""<"") ? ""<"" + substringAfter(node.get(""existingJavaType"").asText(), ""<"") : """"));
                throw new ClassAlreadyExistsException(existingClass);
            }

            boolean usePolymorphicDeserialization = usesPolymorphicDeserialization(node);
            if (node.has(""javaType"")) {
                String fqn = node.path(""javaType"").asText();

                if (isPrimitive(fqn, _package.owner())) {
                    throw new GenerationException(""javaType cannot refer to a primitive type ("" + fqn + ""), did you mean to use existingJavaType?"");
                }

                if (fqn.contains(""<"")) {
                    throw new GenerationException(""javaType does not support generic args ("" + fqn + ""), did you mean to use existingJavaType?"");
                }

                int index = fqn.lastIndexOf(""."") + 1;
                if (index >= 0 && index < fqn.length()) {
                    fqn = fqn.substring(0, index) + ruleFactory.getGenerationConfig().getClassNamePrefix() + fqn.substring(index) + ruleFactory.getGenerationConfig().getClassNameSuffix();
                }

                if (usePolymorphicDeserialization) {
                    newType = _package.owner()._class(JMod.PUBLIC, fqn, ClassType.CLASS);
                } else {
                    newType = _package.owner()._class(fqn);
                }
            } else {
                if (usePolymorphicDeserialization) {
                    newType = _package._class(JMod.PUBLIC, ruleFactory.getNameHelper().getClassName(nodeName, node, _package), ClassType.CLASS);
                } else {
                    newType = _package._class(ruleFactory.getNameHelper().getClassName(nodeName, node, _package));
                }
            }
        } catch (JClassAlreadyExistsException e) {
            throw new ClassAlreadyExistsException(e.getExistingClass());
        }

        ruleFactory.getAnnotator().propertyInclusion(newType, node);

        return newType;

    }",False,False,"This method creates a new Java class based on the given parameters. It takes in a node name, a node representing the schema, and a package. It returns a reference to the newly created class. It may throw an exception if the class already exists.",True,"This code defines a private method called `createClass` that creates a new Java class based on the given parameters. It handles various scenarios such as existing Java types, polymorphic deserialization, and generates the class name based on the node name and package. It also includes exception handling for class already exists scenarios."
9,isFinal(JType),is final super type ,Method,"apply(String,JsonNode,JsonNode,JPackage,Schema)",,java.lang.Class+forName(String) java.lang.Class+forName(String) java.lang.reflect.Modifier+isFinal(int) java.lang.reflect.Modifier+isFinal(int) java.lang.Class+getModifiers() java.lang.Class+getModifiers(),,276,8,2,,"private boolean isFinal(JType superType) {
        try {
            Class<?> javaClass = Class.forName(superType.fullName());
            return Modifier.isFinal(javaClass.getModifiers());
        } catch (ClassNotFoundException e) {
            return false;
        }
    }",True,True,"This method checks if the given JType is a final class by attempting to load its corresponding Java class and checking if it has the final modifier. It returns true if the class is final, false otherwise.",False,"The given code is a private method named ""isFinal"" that takes a JType object as a parameter. It attempts to load the corresponding Java class using the full name of the JType object and checks if the class is declared as final using the Modifier class. If the class is found and is final, it returns true; otherwise, it returns false."
10,"getSuperType(String,JsonNode,JPackage,Schema)",get super type node name node j package schema ,Method,"apply(String,JsonNode,JsonNode,JPackage,Schema)",,"java.lang.IllegalStateException+IllegalStateException(String) org.jsonschema2pojo.rules.ObjectRule+getSuperSchema(JsonNode,Schema,boolean) org.jsonschema2pojo.rules.ObjectRule+getSuperSchema(JsonNode,Schema,boolean) org.jsonschema2pojo.rules.RuleFactory+getSchemaRule() org.jsonschema2pojo.rules.RuleFactory+getSchemaRule()",org.jsonschema2pojo.rules.ObjectRule+ruleFactory,761,15,2,,"private JType getSuperType(String nodeName, JsonNode node, JPackage jPackage, Schema schema) {
        if (node.has(""extends"") && node.has(""extendsJavaClass"")) {
            throw new IllegalStateException(""'extends' and 'extendsJavaClass' defined simultaneously"");
        }

        JType superType = jPackage.owner().ref(Object.class);
        Schema superTypeSchema = getSuperSchema(node, schema, false);
        if (superTypeSchema != null) {
            superType = ruleFactory.getSchemaRule().apply(nodeName + ""Parent"", node.get(""extends""), node, jPackage, superTypeSchema);
        } else if (node.has(""extendsJavaClass"")) {
            superType = resolveType(jPackage, node.get(""extendsJavaClass"").asText());
        }

        return superType;
    }",False,True,"The function of this method is to determine the super type of a given node in a JSON schema. It checks if the node has an ""extends"" property and an ""extendsJavaClass"" property, and throws an exception if both are defined. It then determines the super type based on the presence of a super schema or an ""extendsJavaClass"" property. Finally, it returns the determined super type.",True,"This code defines a private method called ""getSuperType"" that takes in a nodeName, a JsonNode, a JPackage, and a Schema as parameters. It checks if the JsonNode has properties ""extends"" and ""extendsJavaClass"" and throws an exception if both are defined. It then determines the superType based on the presence of a superTypeSchema or an ""extendsJavaClass"" property, and returns the superType."
11,"getSuperSchema(JsonNode,Schema,boolean)",get super schema node schema follow refs ,Method,"getSuperTypeConstructorPropertiesRecursive(JsonNode,Schema,boolean) getSuperType(String,JsonNode,JPackage,Schema)",,"java.net.URI+getFragment() org.jsonschema2pojo.Schema+getId() org.jsonschema2pojo.Schema+getId() java.net.URI+getFragment() java.net.URI+getFragment() org.jsonschema2pojo.Schema+getId() org.jsonschema2pojo.Schema+getId() java.net.URI+getFragment() org.jsonschema2pojo.SchemaStore+create(Schema,String,String) org.jsonschema2pojo.rules.RuleFactory+getSchemaStore() org.jsonschema2pojo.rules.RuleFactory+getSchemaStore() org.jsonschema2pojo.SchemaStore+create(Schema,String,String) org.jsonschema2pojo.GenerationConfig+getRefFragmentPathDelimiters() org.jsonschema2pojo.rules.RuleFactory+getGenerationConfig() org.jsonschema2pojo.rules.RuleFactory+getGenerationConfig() org.jsonschema2pojo.GenerationConfig+getRefFragmentPathDelimiters() org.jsonschema2pojo.rules.ObjectRule+resolveSchemaRefsRecursive(Schema) org.jsonschema2pojo.rules.ObjectRule+resolveSchemaRefsRecursive(Schema)",org.jsonschema2pojo.rules.ObjectRule+ruleFactory org.jsonschema2pojo.rules.ObjectRule+ruleFactory,676,19,2,,"private Schema getSuperSchema(JsonNode node, Schema schema, boolean followRefs) {
        if (node.has(""extends"")) {
            String path;
            if (schema.getId().getFragment() == null) {
                path = ""#extends"";
            } else {
                path = ""#"" + schema.getId().getFragment() + ""/extends"";
            }

            Schema superSchema = ruleFactory.getSchemaStore().create(schema, path, ruleFactory.getGenerationConfig().getRefFragmentPathDelimiters());

            if (followRefs) {
                superSchema = resolveSchemaRefsRecursive(superSchema);
            }

            return superSchema;
        }
        return null;
    }",True,True,"The function of this method is to retrieve the super schema of a given schema, based on the ""extends"" property in a JSON node. If the ""followRefs"" parameter is true, it also resolves any schema references recursively.",False,"This code defines a private method called `getSuperSchema` that takes in a `JsonNode`, a `Schema`, and a boolean flag. It checks if the `JsonNode` has a property called ""extends"" and if so, it creates a new `Schema` object based on the existing `Schema` and a path. If the `followRefs` flag is true, it resolves any schema references recursively and returns the resulting `Schema`, otherwise it returns null."
12,resolveSchemaRefsRecursive(Schema),resolve schema refs recursive schema ,Method,"getSuperSchema(JsonNode,Schema,boolean) resolveSchemaRefsRecursive(Schema)",,"org.jsonschema2pojo.Schema+getContent() org.jsonschema2pojo.Schema+getContent() org.jsonschema2pojo.SchemaStore+create(Schema,String,String) org.jsonschema2pojo.rules.RuleFactory+getSchemaStore() org.jsonschema2pojo.rules.RuleFactory+getSchemaStore() org.jsonschema2pojo.SchemaStore+create(Schema,String,String) org.jsonschema2pojo.GenerationConfig+getRefFragmentPathDelimiters() org.jsonschema2pojo.rules.RuleFactory+getGenerationConfig() org.jsonschema2pojo.rules.RuleFactory+getGenerationConfig() org.jsonschema2pojo.GenerationConfig+getRefFragmentPathDelimiters() org.jsonschema2pojo.rules.ObjectRule+resolveSchemaRefsRecursive(Schema) org.jsonschema2pojo.rules.ObjectRule+resolveSchemaRefsRecursive(Schema)",org.jsonschema2pojo.rules.ObjectRule+ruleFactory org.jsonschema2pojo.rules.ObjectRule+ruleFactory,406,8,2,,"private Schema resolveSchemaRefsRecursive(Schema schema) {
        JsonNode schemaNode = schema.getContent();
        if (schemaNode.has(""$ref"")) {
            schema = ruleFactory.getSchemaStore().create(schema, schemaNode.get(""$ref"").asText(), ruleFactory.getGenerationConfig().getRefFragmentPathDelimiters());
            return resolveSchemaRefsRecursive(schema);
        }
        return schema;
    }",True,True,"The function of the method is to recursively resolve schema references in a given schema object. It checks if the schema contains a reference, creates a new schema object with the resolved reference, and continues resolving until no more references are found. The final resolved schema is returned.",False,"The `resolveSchemaRefsRecursive` method takes a `Schema` object as input and recursively resolves any schema references present in it. It checks if the schema contains a `$ref` property, and if so, creates a new schema using the referenced path and continues the process until no more references are found. The method returns the resolved schema."
13,"addJsonTypeInfoAnnotation(JDefinedClass,JsonNode)",add json type info annotation jclass node ,Method,"apply(String,JsonNode,JsonNode,JPackage,Schema)",,org.jsonschema2pojo.GenerationConfig+getAnnotationStyle() org.jsonschema2pojo.rules.RuleFactory+getGenerationConfig() org.jsonschema2pojo.rules.RuleFactory+getGenerationConfig() org.jsonschema2pojo.GenerationConfig+getAnnotationStyle(),org.jsonschema2pojo.rules.ObjectRule+ruleFactory,548,9,2,,"private void addJsonTypeInfoAnnotation(JDefinedClass jclass, JsonNode node) {
        if (ruleFactory.getGenerationConfig().getAnnotationStyle() == AnnotationStyle.JACKSON2) {
            String annotationName = node.get(""deserializationClassProperty"").asText();
            JAnnotationUse jsonTypeInfo = jclass.annotate(JsonTypeInfo.class);
            jsonTypeInfo.param(""use"", JsonTypeInfo.Id.CLASS);
            jsonTypeInfo.param(""include"", JsonTypeInfo.As.PROPERTY);
            jsonTypeInfo.param(""property"", annotationName);
        }
    }",False,False,This method adds a Jackson JSON type information annotation to a given class if the annotation style is set to JACKSON2. The annotation includes information about the deserialization class property.,True,"This code adds a Jackson2 annotation, JsonTypeInfo, to a given class if the annotation style is set to JACKSON2. The annotation includes parameters for specifying the use of class identification, inclusion of type information as a property, and the name of the property to be used."
14,addToString(JDefinedClass),add to string jclass ,Method,"apply(String,JsonNode,JsonNode,JPackage,Schema)",,java.util.Arrays+asList(T[]) java.util.Arrays+asList(T[]) org.jsonschema2pojo.GenerationConfig+getToStringExcludes() org.jsonschema2pojo.rules.RuleFactory+getGenerationConfig() org.jsonschema2pojo.rules.RuleFactory+getGenerationConfig() org.jsonschema2pojo.GenerationConfig+getToStringExcludes() java.lang.Class+getName() java.lang.Class+getName() java.util.Set+contains(Object) java.util.Set+contains(Object) java.lang.UnsupportedOperationException+UnsupportedOperationException(String),org.jsonschema2pojo.rules.ObjectRule+ruleFactory,5417,108,2,,"private void addToString(JDefinedClass jclass) {
        Map<String, JFieldVar> fields = jclass.fields();
        JMethod toString = jclass.method(JMod.PUBLIC, String.class, ""toString"");
        Set<String> excludes = new HashSet<>(Arrays.asList(ruleFactory.getGenerationConfig().getToStringExcludes()));

        JBlock body = toString.body();

        // The following toString implementation roughly matches the commons ToStringBuilder for
        // backward compatibility
        JClass stringBuilderClass = jclass.owner().ref(StringBuilder.class);
        JVar sb = body.decl(stringBuilderClass, ""sb"", JExpr._new(stringBuilderClass));

        // Write the header, e.g.: example.domain.MyClass@85e382a7[
        body.add(sb
                .invoke(""append"").arg(jclass.dotclass().invoke(""getName""))
                .invoke(""append"").arg(JExpr.lit('@'))
                .invoke(""append"").arg(
                        jclass.owner().ref(Integer.class).staticInvoke(""toHexString"").arg(
                                jclass.owner().ref(System.class).staticInvoke(""identityHashCode"").arg(JExpr._this())))
                .invoke(""append"").arg(JExpr.lit('[')));

        // If this has a parent class, include its toString()
        if (!jclass._extends().fullName().equals(Object.class.getName())) {
            JVar baseLength = body.decl(jclass.owner().INT, ""baseLength"", sb.invoke(""length""));
            JVar superString = body.decl(jclass.owner().ref(String.class), ""superString"", JExpr._super().invoke(""toString""));

            JBlock superToStringBlock = body._if(superString.ne(JExpr._null()))._then();

            // If super.toString() is in the Clazz@2ee6529d[field=10] format, extract the fields
            // from the wrapper
            JVar contentStart = superToStringBlock.decl(jclass.owner().INT, ""contentStart"",
                    superString.invoke(""indexOf"").arg(JExpr.lit('[')));
            JVar contentEnd = superToStringBlock.decl(jclass.owner().INT, ""contentEnd"",
                    superString.invoke(""lastIndexOf"").arg(JExpr.lit(']')));

            JConditional superToStringInnerConditional = superToStringBlock._if(
                    contentStart.gte(JExpr.lit(0)).cand(contentEnd.gt(contentStart)));

            superToStringInnerConditional._then().add(
                    sb.invoke(""append"")
                            .arg(superString)
                            .arg(contentStart.plus(JExpr.lit(1)))
                            .arg(contentEnd));

            // Otherwise, just append super.toString()
            superToStringInnerConditional._else().add(sb.invoke(""append"").arg(superString));

            // Append a comma if needed
            body._if(sb.invoke(""length"").gt(baseLength))
                    ._then().add(sb.invoke(""append"").arg(JExpr.lit(',')));
        }

        // For each included instance field, add to the StringBuilder in the field=value format
        for (JFieldVar fieldVar : fields.values()) {
            if (excludes.contains(fieldVar.name()) || (fieldVar.mods().getValue() & JMod.STATIC) == JMod.STATIC) {
                continue;
            }

            body.add(sb.invoke(""append"").arg(fieldVar.name()));
            body.add(sb.invoke(""append"").arg(JExpr.lit('=')));

            if (fieldVar.type().isPrimitive()) {
                body.add(sb.invoke(""append"").arg(JExpr.refthis(fieldVar.name())));
            } else if (fieldVar.type().isArray()) {
                // Only primitive arrays are supported
                if (!fieldVar.type().elementType().isPrimitive()) {
                    throw new UnsupportedOperationException(""Only primitive arrays are supported"");
                }

                // Leverage Arrays.toString()
                body.add(sb.invoke(""append"")
                        .arg(JOp.cond(
                                JExpr.refthis(fieldVar.name()).eq(JExpr._null()),
                                JExpr.lit(""<null>""),
                                jclass.owner().ref(Arrays.class).staticInvoke(""toString"")
                                        .arg(JExpr.refthis(fieldVar.name()))
                                        .invoke(""replace"").arg(JExpr.lit('[')).arg(JExpr.lit('{'))
                                        .invoke(""replace"").arg(JExpr.lit(']')).arg(JExpr.lit('}'))
                                        .invoke(""replace"").arg(JExpr.lit("", "")).arg(JExpr.lit("","")))));
            } else {
                body.add(sb.invoke(""append"")
                        .arg(JOp.cond(
                                JExpr.refthis(fieldVar.name()).eq(JExpr._null()),
                                JExpr.lit(""<null>""),
                                JExpr.refthis(fieldVar.name()))));
            }

            body.add(sb.invoke(""append"").arg(JExpr.lit(',')));
        }

        // Add the trailer
        JConditional trailerConditional = body._if(
                sb.invoke(""charAt"").arg(sb.invoke(""length"").minus(JExpr.lit(1)))
                        .eq(JExpr.lit(',')));

        trailerConditional._then().add(
                sb.invoke(""setCharAt"")
                        .arg(sb.invoke(""length"").minus(JExpr.lit(1)))
                        .arg(JExpr.lit(']')));

        trailerConditional._else().add(
                sb.invoke(""append"").arg(JExpr.lit(']')));


        body._return(sb.invoke(""toString""));

        toString.annotate(Override.class);
    }",False,False,"The function of the method is to generate a string representation of a given class object. It creates a StringBuilder object, appends the class name and identity hash code, includes the parent class's toString() if it exists, and appends the instance fields and their values. The resulting string is returned.",True,"The code defines a private method called ""addToString"" that adds a ""toString"" method to a given class. The ""toString"" method generates a string representation of the class instance by appending the class name, identity hash code, parent class's ""toString"" result, and the values of all non-static fields in the class. The generated string follows the format of the commons ToStringBuilder for backward compatibility."
15,"addHashCode(JDefinedClass,JsonNode)",add hash code jclass node ,Method,"apply(String,JsonNode,JsonNode,JPackage,Schema)",,"org.jsonschema2pojo.rules.ObjectRule+removeFieldsExcludedFromEqualsAndHashCode(Map<String,JFieldVar>,JsonNode) org.jsonschema2pojo.rules.ObjectRule+removeFieldsExcludedFromEqualsAndHashCode(Map<String,JFieldVar>,JsonNode) java.lang.String+equals(Object) java.lang.String+equals(Object) java.lang.String+equals(Object) java.lang.String+equals(Object) java.lang.String+equals(Object) java.lang.String+equals(Object) java.lang.String+equals(Object) java.lang.String+equals(Object) java.lang.String+equals(Object) java.lang.String+equals(Object) java.lang.UnsupportedOperationException+UnsupportedOperationException(String) java.lang.Class+getName() java.lang.Class+getName()",,2743,54,2,,"private void addHashCode(JDefinedClass jclass, JsonNode node) {
        Map<String, JFieldVar> fields = removeFieldsExcludedFromEqualsAndHashCode(jclass.fields(), node);

        JMethod hashCode = jclass.method(JMod.PUBLIC, int.class, ""hashCode"");
        JBlock body = hashCode.body();
        JVar result = body.decl(jclass.owner().INT, ""result"", JExpr.lit(1));

        // Incorporate each non-excluded field in the hashCode calculation
        for (JFieldVar fieldVar : fields.values()) {
            if ((fieldVar.mods().getValue() & JMod.STATIC) == JMod.STATIC) {
                continue;
            }

            JFieldRef fieldRef = JExpr.refthis(fieldVar.name());

            JExpression fieldHash;
            if (fieldVar.type().isPrimitive()) {
                if (""long"".equals(fieldVar.type().name())) {
                    fieldHash = JExpr.cast(jclass.owner().INT, fieldRef.xor(fieldRef.shrz(JExpr.lit(32))));
                } else if (""boolean"".equals(fieldVar.type().name())) {
                    fieldHash = JOp.cond(fieldRef, JExpr.lit(1), JExpr.lit(0));
                } else if (""int"".equals(fieldVar.type().name())) {
                    fieldHash = fieldRef;
                } else if (""double"".equals(fieldVar.type().name())) {
                    JClass doubleClass = jclass.owner().ref(Double.class);
                    JExpression longField = doubleClass.staticInvoke(""doubleToLongBits"").arg(fieldRef);
                    fieldHash = JExpr.cast(jclass.owner().INT,
                            longField.xor(longField.shrz(JExpr.lit(32))));
                } else if (""float"".equals(fieldVar.type().name())) {
                    fieldHash = jclass.owner().ref(Float.class).staticInvoke(""floatToIntBits"").arg(fieldRef);
                } else {
                    fieldHash = JExpr.cast(jclass.owner().INT, fieldRef);
                }
            } else if (fieldVar.type().isArray()) {
                if (!fieldVar.type().elementType().isPrimitive()) {
                    throw new UnsupportedOperationException(""Only primitive arrays are supported"");
                }

                fieldHash = jclass.owner().ref(Arrays.class).staticInvoke(""hashCode"").arg(fieldRef);
            } else {
                fieldHash = JOp.cond(fieldRef.eq(JExpr._null()), JExpr.lit(0), fieldRef.invoke(""hashCode""));
            }

            body.assign(result, result.mul(JExpr.lit(31)).plus(fieldHash));
        }

        // Add super.hashCode()
        if (!jclass._extends().fullName().equals(Object.class.getName())) {
            body.assign(result, result.mul(JExpr.lit(31)).plus(JExpr._super().invoke(""hashCode"")));
        }

        body._return(result);
        hashCode.annotate(Override.class);
    }",False,False,"The function of the given method is to generate a hashCode() method for a given class. It calculates the hash code by incorporating the hash codes of each non-excluded field in the class, using a specific algorithm. It also includes the hash code of the superclass if it is not the Object class.",True,"This code defines a private method called ""addHashCode"" that generates a hashCode() method for a given class. The method calculates the hashCode by incorporating the values of non-excluded fields using specific rules for primitive types, arrays, and objects. The resulting hashCode is then returned."
16,"removeFieldsExcludedFromEqualsAndHashCode(Map<String,JFieldVar>,JsonNode)",remove fields excluded from equals and hash code fields node ,Method,"addHashCode(JDefinedClass,JsonNode) addEquals(JDefinedClass,JsonNode)",,"org.jsonschema2pojo.util.NameHelper+getPropertyName(String,JsonNode) org.jsonschema2pojo.rules.RuleFactory+getNameHelper() org.jsonschema2pojo.rules.RuleFactory+getNameHelper() org.jsonschema2pojo.util.NameHelper+getPropertyName(String,JsonNode) org.jsonschema2pojo.util.NameHelper+getPropertyName(String,JsonNode) org.jsonschema2pojo.rules.RuleFactory+getNameHelper() org.jsonschema2pojo.rules.RuleFactory+getNameHelper() org.jsonschema2pojo.util.NameHelper+getPropertyName(String,JsonNode)",org.jsonschema2pojo.rules.ObjectRule+ruleFactory org.jsonschema2pojo.rules.ObjectRule+ruleFactory,1510,30,2,,"private Map<String, JFieldVar> removeFieldsExcludedFromEqualsAndHashCode(Map<String, JFieldVar> fields, JsonNode node) {
        Map<String, JFieldVar> filteredFields = new HashMap<>(fields);

        JsonNode properties = node.get(""properties"");

        if (properties != null) {
            if (node.has(""excludedFromEqualsAndHashCode"")) {
                JsonNode excludedArray = node.get(""excludedFromEqualsAndHashCode"");

                for (Iterator<JsonNode> iterator = excludedArray.elements(); iterator.hasNext(); ) {
                    String excludedPropertyName = iterator.next().asText();
                    JsonNode excludedPropertyNode = properties.get(excludedPropertyName);
                    filteredFields.remove(ruleFactory.getNameHelper().getPropertyName(excludedPropertyName, excludedPropertyNode));
                }
            }

            for (Iterator<Map.Entry<String, JsonNode>> iterator = properties.fields(); iterator.hasNext(); ) {
                Map.Entry<String, JsonNode> entry = iterator.next();
                String propertyName = entry.getKey();
                JsonNode propertyNode = entry.getValue();

                if (propertyNode.has(""excludedFromEqualsAndHashCode"") &&
                        propertyNode.get(""excludedFromEqualsAndHashCode"").asBoolean()) {
                    filteredFields.remove(ruleFactory.getNameHelper().getPropertyName(propertyName, propertyNode));
                }
            }
        }

        return filteredFields;
    }",False,False,"This method removes fields from a given map that are excluded from the equals and hashCode methods. It takes a map of fields and a JSON node as input, and returns a new map with the excluded fields removed.",False,This code is a private method that removes fields from a given map based on exclusion criteria specified in a JSON node. It iterates through the properties of the JSON node and removes fields from the map if they are marked as excluded from equals and hashCode calculations. The filtered map is then returned.
17,"addConstructors(JDefinedClass,JsonNode,Schema,boolean)",add constructors jclass node schema only required ,Method,"apply(String,JsonNode,JsonNode,JPackage,Schema)",,"org.jsonschema2pojo.rules.ObjectRule+getConstructorProperties(JsonNode,boolean) org.jsonschema2pojo.rules.ObjectRule+getConstructorProperties(JsonNode,boolean) org.jsonschema2pojo.rules.ObjectRule+getSuperTypeConstructorPropertiesRecursive(JsonNode,Schema,boolean) org.jsonschema2pojo.rules.ObjectRule+getSuperTypeConstructorPropertiesRecursive(JsonNode,Schema,boolean) java.util.HashSet+isEmpty() java.util.HashSet+isEmpty() java.util.HashSet+isEmpty() java.util.HashSet+isEmpty() java.lang.IllegalStateException+IllegalStateException(String) org.jsonschema2pojo.rules.ObjectRule+searchSuperClassesForField(String,JDefinedClass) org.jsonschema2pojo.rules.ObjectRule+searchSuperClassesForField(String,JDefinedClass) java.lang.IllegalStateException+IllegalStateException(String)",,2498,59,2,,"private void addConstructors(JDefinedClass jclass, JsonNode node, Schema schema, boolean onlyRequired) {

        LinkedHashSet<String> classProperties = getConstructorProperties(node, onlyRequired);
        LinkedHashSet<String> combinedSuperProperties = getSuperTypeConstructorPropertiesRecursive(node, schema, onlyRequired);

        // no properties to put in the constructor => default constructor is good enough.
        if (classProperties.isEmpty() && combinedSuperProperties.isEmpty()) {
            return;
        }

        // add a no-args constructor for serialization purposes
        JMethod noargsConstructor = jclass.constructor(JMod.PUBLIC);
        noargsConstructor.javadoc().add(""No args constructor for use in serialization"");

        // add the public constructor with property parameters
        JMethod fieldsConstructor = jclass.constructor(JMod.PUBLIC);
        JBlock constructorBody = fieldsConstructor.body();
        JInvocation superInvocation = constructorBody.invoke(""super"");

        Map<String, JFieldVar> fields = jclass.fields();
        Map<String, JVar> classFieldParams = new HashMap<>();

        for (String property : classProperties) {
            JFieldVar field = fields.get(property);

            if (field == null) {
                throw new IllegalStateException(""Property "" + property + "" hasn't been added to JDefinedClass before calling addConstructors"");
            }

            fieldsConstructor.javadoc().addParam(property);
            JVar param = fieldsConstructor.param(field.type(), field.name());
            constructorBody.assign(JExpr._this().ref(field), param);
            classFieldParams.put(property, param);
        }

        List<JVar> superConstructorParams = new ArrayList<>();


        for (String property : combinedSuperProperties) {
            JFieldVar field = searchSuperClassesForField(property, jclass);

            if (field == null) {
                throw new IllegalStateException(""Property "" + property + "" hasn't been added to JDefinedClass before calling addConstructors"");
            }

            JVar param = classFieldParams.get(property);

            if (param == null) {
                param = fieldsConstructor.param(field.type(), field.name());
            }

            fieldsConstructor.javadoc().addParam(property);
            superConstructorParams.add(param);
        }

        for (JVar param : superConstructorParams) {
            superInvocation.arg(param);
        }
    }",False,True,This method adds constructors to a given class based on the properties of a JSON node and a schema. It creates a no-args constructor for serialization purposes and a constructor with property parameters. It also handles properties from superclasses.,True,"The code defines a method called ""addConstructors"" that adds constructors to a given class based on a JSON schema. It creates a no-args constructor for serialization purposes and a constructor with property parameters. It also handles properties from superclasses by searching for fields and adding them as parameters to the constructor."
18,definedClassOrNullFromType(JType),defined class or null from type type ,Method,"searchSuperClassesForField(String,JDefinedClass)",,,,320,10,10,,"private static JDefinedClass definedClassOrNullFromType(JType type)
    {
        if (type == null || type.isPrimitive())
        {
            return null;
        }
        JClass fieldClass = type.boxify();
        JPackage jPackage = fieldClass._package();
        return jPackage._getClass(fieldClass.name());
    }",True,True,"This method takes a JType as input and returns a JDefinedClass. It checks if the input type is null or a primitive type, and if so, returns null. Otherwise, it converts the type to a boxed type, gets the package of the boxed type, and returns the class with the same name in that package.",False,"The given code is a private static method named `definedClassOrNullFromType` that takes a `JType` object as input. It checks if the input type is null or a primitive type, and if so, it returns null. Otherwise, it converts the type to its boxed form, retrieves the package of the boxed type, and returns the corresponding class from the package."
19,"searchSuperClassesForField(String,JDefinedClass)",search super classes for field property jclass this is recursive with search class and super classes for field ,Method,"addConstructors(JDefinedClass,JsonNode,Schema,boolean) searchClassAndSuperClassesForField(String,JDefinedClass)",,"org.jsonschema2pojo.rules.ObjectRule+definedClassOrNullFromType(JType) org.jsonschema2pojo.rules.ObjectRule+definedClassOrNullFromType(JType) org.jsonschema2pojo.rules.ObjectRule+searchClassAndSuperClassesForField(String,JDefinedClass) org.jsonschema2pojo.rules.ObjectRule+searchClassAndSuperClassesForField(String,JDefinedClass)",,457,11,2,"/** 
 * This is recursive with searchClassAndSuperClassesForField
 */
","/**
     * This is recursive with searchClassAndSuperClassesForField
     */
    private JFieldVar searchSuperClassesForField(String property, JDefinedClass jclass) {
        JClass superClass = jclass._extends();
        JDefinedClass definedSuperClass = definedClassOrNullFromType(superClass);
        if (definedSuperClass == null) {
            return null;
        }
        return searchClassAndSuperClassesForField(property, definedSuperClass);
    }",True,True,"This method searches for a field with a given property in the superclasses of a given class. It recursively calls the method ""searchClassAndSuperClassesForField"" to search in the superclasses of the superclass.",True,"The code defines a private method called ""searchSuperClassesForField"" that takes a property name and a class as parameters. It recursively searches for the specified property in the superclasses of the given class and returns the corresponding field variable if found, or null if not found."
20,"searchClassAndSuperClassesForField(String,JDefinedClass)",search class and super classes for field property jclass ,Method,"searchSuperClassesForField(String,JDefinedClass)",,"org.jsonschema2pojo.rules.ObjectRule+searchSuperClassesForField(String,JDefinedClass) org.jsonschema2pojo.rules.ObjectRule+searchSuperClassesForField(String,JDefinedClass)",,330,8,2,,"private JFieldVar searchClassAndSuperClassesForField(String property, JDefinedClass jclass) {
        Map<String, JFieldVar> fields = jclass.fields();
        JFieldVar field = fields.get(property);
        if (field == null) {
            return searchSuperClassesForField(property, jclass);
        }
        return field;
    }",False,True,"This method searches for a field with a given property name in a given class and its superclasses. If the field is found, it is returned. If not, the method calls another method to search in the superclasses and returns the result.",True,"The given code is a private method that searches for a field with a given property in a specified class and its superclasses. It returns the field if found, otherwise it calls another method to search in the superclasses and returns the result."
21,"addEquals(JDefinedClass,JsonNode)",add equals jclass node ,Method,"apply(String,JsonNode,JsonNode,JPackage,Schema)",,"org.jsonschema2pojo.rules.ObjectRule+removeFieldsExcludedFromEqualsAndHashCode(Map<String,JFieldVar>,JsonNode) org.jsonschema2pojo.rules.ObjectRule+removeFieldsExcludedFromEqualsAndHashCode(Map<String,JFieldVar>,JsonNode) java.lang.Class+getName() java.lang.Class+getName() java.lang.String+equals(Object) java.lang.String+equals(Object) java.lang.String+equals(Object) java.lang.String+equals(Object) java.lang.UnsupportedOperationException+UnsupportedOperationException(String)",,2923,62,2,,"private void addEquals(JDefinedClass jclass, JsonNode node) {
        Map<String, JFieldVar> fields = removeFieldsExcludedFromEqualsAndHashCode(jclass.fields(), node);

        JMethod equals = jclass.method(JMod.PUBLIC, boolean.class, ""equals"");
        JVar otherObject = equals.param(Object.class, ""other"");

        JBlock body = equals.body();

        body._if(otherObject.eq(JExpr._this()))._then()._return(JExpr.TRUE);
        body._if(otherObject._instanceof(jclass).eq(JExpr.FALSE))._then()._return(JExpr.FALSE);

        JVar rhsVar = body.decl(jclass, ""rhs"").init(JExpr.cast(jclass, otherObject));

        JExpression result = JExpr.lit(true);

        // First, check super.equals(other)
        if (!jclass._extends().fullName().equals(Object.class.getName())) {
            result = result.cand(JExpr._super().invoke(""equals"").arg(rhsVar));
        }

        // Chain the results of checking all other fields
        for (JFieldVar fieldVar : fields.values()) {
            if ((fieldVar.mods().getValue() & JMod.STATIC) == JMod.STATIC) {
                continue;
            }

            JFieldRef thisFieldRef = JExpr.refthis(fieldVar.name());
            JFieldRef otherFieldRef = JExpr.ref(rhsVar, fieldVar.name());
            JExpression fieldEquals;

            if (fieldVar.type().isPrimitive()) {
                if (""double"".equals(fieldVar.type().name())) {
                    JClass doubleClass = jclass.owner().ref(Double.class);
                    fieldEquals = doubleClass.staticInvoke(""doubleToLongBits"").arg(thisFieldRef).eq(
                            doubleClass.staticInvoke(""doubleToLongBits"").arg(otherFieldRef));
                } else if (""float"".equals(fieldVar.type().name())) {
                    JClass floatClass = jclass.owner().ref(Float.class);
                    fieldEquals = floatClass.staticInvoke(""floatToIntBits"").arg(thisFieldRef).eq(
                            floatClass.staticInvoke(""floatToIntBits"").arg(otherFieldRef));
                } else {
                    fieldEquals = thisFieldRef.eq(otherFieldRef);
                }
            } else if (fieldVar.type().isArray()) {
                if (!fieldVar.type().elementType().isPrimitive()) {
                    throw new UnsupportedOperationException(""Only primitive arrays are supported"");
                }

                fieldEquals = jclass.owner().ref(Arrays.class).staticInvoke(""equals"").arg(thisFieldRef).arg(otherFieldRef);
            } else {
                fieldEquals = thisFieldRef.eq(otherFieldRef).cor(
                        thisFieldRef.ne(JExpr._null())
                                .cand(thisFieldRef.invoke(""equals"").arg(otherFieldRef)));
            }

            // Chain the equality of this field with the previous comparisons
            result = result.cand(fieldEquals);
        }

        body._return(result);

        equals.annotate(Override.class);
    }",False,False,"This method adds an ""equals"" method to a given class. It compares the fields of the class with the fields of another object to determine if they are equal. It also checks if the object being compared is an instance of the class.",True,"The code defines a private method called ""addEquals"" that adds an ""equals"" method to a given class. The method compares the fields of the class with the fields of another object to determine if they are equal, taking into account various scenarios such as primitive types, arrays, and object references. The method also includes an annotation to indicate that it overrides the ""equals"" method from the superclass."
22,"addInterfaces(JDefinedClass,JsonNode)",add interfaces jclass java interfaces ,Method,"apply(String,JsonNode,JsonNode,JPackage,Schema)",,,,211,5,2,,"private void addInterfaces(JDefinedClass jclass, JsonNode javaInterfaces) {
        for (JsonNode i : javaInterfaces) {
            jclass._implements(resolveType(jclass._package(), i.asText()));
        }
    }",False,False,This method adds interfaces to a defined class in Java by iterating through a list of interfaces and implementing them using the resolveType method.,True,"The given code is a private method named ""addInterfaces"" that takes in a JDefinedClass object and a JsonNode object as parameters. It iterates over the elements in the JsonNode object and adds each element as an implemented interface to the JDefinedClass object by resolving the type using the ""resolveType"" method."
23,usesPolymorphicDeserialization(JsonNode),uses polymorphic deserialization node ,Method,"createClass(String,JsonNode,JPackage)",,org.jsonschema2pojo.GenerationConfig+getAnnotationStyle() org.jsonschema2pojo.rules.RuleFactory+getGenerationConfig() org.jsonschema2pojo.rules.RuleFactory+getGenerationConfig() org.jsonschema2pojo.GenerationConfig+getAnnotationStyle(),org.jsonschema2pojo.rules.ObjectRule+ruleFactory,260,6,2,,"private boolean usesPolymorphicDeserialization(JsonNode node) {
        if (ruleFactory.getGenerationConfig().getAnnotationStyle() == AnnotationStyle.JACKSON2) {
            return node.has(""deserializationClassProperty"");
        }
        return false;
    }",False,False,"This method checks if the given JsonNode uses polymorphic deserialization by checking if it has a ""deserializationClassProperty"" field, based on the AnnotationStyle set in the ruleFactory's GenerationConfig.",True,"The method ""usesPolymorphicDeserialization"" checks if the given JsonNode object uses polymorphic deserialization. It does this by checking if the ""deserializationClassProperty"" field is present in the node, but only if the annotation style is set to JACKSON2. If the condition is met, the method returns true; otherwise, it returns false."
