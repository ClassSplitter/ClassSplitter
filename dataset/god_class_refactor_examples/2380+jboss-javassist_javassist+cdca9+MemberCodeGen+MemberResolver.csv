index,name,document,type,inner invocations,external invocations,calls,visits,length,lines,modifier,commit,full text,moved,removed,gpt text,gpt response,code summary
1,classPool,class pool ,Field,,,,,30,1,4,,protected ClassPool classPool;,True,True,,False,
2,thisClass,this class ,Field,,,,,30,1,4,,protected CtClass   thisClass;,False,False,,False,
3,thisMethod,this method ,Field,,,,,32,1,4,,protected MethodInfo thisMethod;,False,False,,False,
4,resultStatic,result static ,Field,,,,,31,1,4,,protected boolean resultStatic;,False,False,,False,
5,"MemberCodeGen(Bytecode,CtClass,ClassPool)",member code gen b cc cp ,Method,,,,javassist.compiler.MemberCodeGen+classPool javassist.compiler.MemberCodeGen+thisClass javassist.compiler.MemberCodeGen+thisMethod,159,6,1,,"public MemberCodeGen(Bytecode b, CtClass cc, ClassPool cp) {
        super(b);
        classPool = cp;
        thisClass = cc;
        thisMethod = null;
    }",False,False,"The function of the given method is to initialize the MemberCodeGen object with the provided Bytecode, CtClass, and ClassPool parameters, and set the classPool, thisClass, and thisMethod variables accordingly.",True,"The code defines a constructor for the class ""MemberCodeGen"" that takes three parameters: a ""Bytecode"" object, a ""CtClass"" object, and a ""ClassPool"" object. It initializes the classPool, thisClass, and thisMethod variables of the class."
6,setThisMethod(CtMethod),set this method m records the currently compiled method ,Method,,"javassist.compiler.Javac+compileMethod(Parser,MethodDecl) javassist.compiler.Javac+compileBody(CtBehavior,String)",javassist.CtBehavior+getMethodInfo2() javassist.CtBehavior+getMethodInfo2(),javassist.compiler.MemberCodeGen+thisMethod,148,6,1,"/** 
 * Records the currently compiled method.
 */
","/**
     * Records the currently compiled method.
     */
    public void setThisMethod(CtMethod m) {
        thisMethod = m.getMethodInfo2();
    }",False,False,"The function of this method is to record the currently compiled method by setting the value of the variable ""thisMethod"" to the method information obtained from the input CtMethod object.",True,"The given code defines a method named ""setThisMethod"" which takes a CtMethod object as a parameter. It sets the value of the ""thisMethod"" variable to the MethodInfo2 of the provided CtMethod object."
7,getThisClass(),get this class ,Method,,"javassist.compiler.Javac+compileField(FieldDecl) javassist.compiler.Javac+compileMethod(Parser,MethodDecl) javassist.compiler.Javac+compileMethod(Parser,MethodDecl)",,javassist.compiler.MemberCodeGen+thisClass,51,1,1,,public CtClass getThisClass() { return thisClass; },False,False,"This method returns the value of the variable ""thisClass"" of type CtClass.",True,"The code defines a method named ""getThisClass"" that returns the value of the variable ""thisClass"". It is a public method and does not take any parameters."
8,getThisName(),get this name returns the jvm internal representation of this class name ,Method,,"javassist.compiler.JvstCodeGen+recordParams(CtClass[],boolean,String,String,String,SymbolTable)",javassist.compiler.MemberCodeGen+javaToJvmName(String) javassist.compiler.MemberCodeGen+javaToJvmName(String) javassist.CtClass+getName() javassist.CtClass+getName(),javassist.compiler.MemberCodeGen+thisClass,172,6,4,"/** 
 * Returns the JVM-internal representation of this class name.
 */
","/**
     * Returns the JVM-internal representation of this class name.
     */
    protected String getThisName() {
        return javaToJvmName(thisClass.getName());
    }",False,False,The function of this method is to return the JVM-internal representation of the class name by calling the javaToJvmName method on the name of the current class.,True,"The method ""getThisName"" returns the JVM-internal representation of the class name. It calls the ""javaToJvmName"" function to convert the Java class name to the JVM format before returning it. The method is protected, indicating that it can only be accessed within the class or its subclasses."
9,getSuperName(),get super name returns the jvm internal representation of this super class name ,Method,,,javassist.compiler.MemberCodeGen+javaToJvmName(String) javassist.compiler.MemberCodeGen+javaToJvmName(String) javassist.CtClass+getName() javassist.compiler.MemberCodeGen+getSuperclass(CtClass) javassist.compiler.MemberCodeGen+getSuperclass(CtClass) javassist.CtClass+getName(),javassist.compiler.MemberCodeGen+thisClass,214,6,4,"/** 
 * Returns the JVM-internal representation of this super class name.
 */
","/**
     * Returns the JVM-internal representation of this super class name.
     */
    protected String getSuperName() throws CompileError {
        return javaToJvmName(getSuperclass(thisClass).getName());
    }",False,False,This method returns the JVM-internal representation of the super class name by converting the Java class name to the JVM format.,True,"The method ""getSuperName()"" is a protected method that returns the JVM-internal representation of the super class name of the current class. It throws a ""CompileError"" exception and uses the ""javaToJvmName()"" function to convert the superclass name from Java to JVM format."
10,insertDefaultSuperCall(),insert default super call ,Method,,,"javassist.bytecode.Bytecode+addAload(int) javassist.bytecode.Bytecode+addAload(int) javassist.bytecode.Bytecode+addInvokespecial(CtClass,String,String) javassist.bytecode.Bytecode+addInvokespecial(CtClass,String,String) javassist.compiler.MemberCodeGen+getSuperclass(CtClass) javassist.compiler.MemberCodeGen+getSuperclass(CtClass)",javassist.compiler.CodeGen+bytecode javassist.compiler.CodeGen+bytecode javassist.compiler.MemberCodeGen+thisClass,175,4,4,,"protected void insertDefaultSuperCall() throws CompileError {
        bytecode.addAload(0);
        bytecode.addInvokespecial(getSuperclass(thisClass), ""<init>"", ""()V"");
    }",False,False,This method inserts a default super call in the bytecode. It loads the object reference onto the stack and invokes the superclass's constructor with no arguments.,True,"The code defines a protected method called ""insertDefaultSuperCall"" that adds bytecode instructions to load an object onto the stack and invoke a superclass constructor with no arguments. It throws a CompileError exception."
11,atTryStmnt(Stmnt),at try stmnt st ,Method,,,"javassist.compiler.ast.ASTList+getLeft() javassist.compiler.ast.ASTList+getLeft() javassist.bytecode.Bytecode+currentPc() javassist.bytecode.Bytecode+currentPc() javassist.compiler.ast.Stmnt+accept(Visitor) javassist.compiler.ast.Stmnt+accept(Visitor) javassist.bytecode.Bytecode+currentPc() javassist.bytecode.Bytecode+currentPc() javassist.compiler.CompileError+CompileError(String) javassist.bytecode.Bytecode+addOpcode(int) javassist.bytecode.Bytecode+addOpcode(int) javassist.bytecode.Bytecode+currentPc() javassist.bytecode.Bytecode+currentPc() javassist.bytecode.Bytecode+addIndex(int) javassist.bytecode.Bytecode+addIndex(int) javassist.compiler.CodeGen+getMaxLocals() javassist.compiler.CodeGen+getMaxLocals() javassist.compiler.CodeGen+incMaxLocals(int) javassist.compiler.CodeGen+incMaxLocals(int) javassist.compiler.ast.ASTree+getLeft() javassist.compiler.ast.ASTList+getRight() javassist.compiler.ast.ASTList+getRight() javassist.compiler.ast.ASTree+getLeft() javassist.compiler.ast.ASTList+head() javassist.compiler.ast.ASTList+head() javassist.compiler.ast.ASTList+tail() javassist.compiler.ast.ASTList+tail() javassist.compiler.ast.Pair+getLeft() javassist.compiler.ast.Pair+getLeft() javassist.compiler.ast.Pair+getRight() javassist.compiler.ast.Pair+getRight() javassist.compiler.ast.Declarator+setLocalVar(int) javassist.compiler.ast.Declarator+setLocalVar(int) javassist.compiler.MemberCodeGen+lookupJvmClass(String) javassist.compiler.MemberCodeGen+lookupJvmClass(String) javassist.compiler.ast.Declarator+getClassName() javassist.compiler.ast.Declarator+getClassName() javassist.compiler.ast.Declarator+setClassName(String) javassist.compiler.ast.Declarator+setClassName(String) javassist.compiler.MemberCodeGen+javaToJvmName(String) javassist.compiler.MemberCodeGen+javaToJvmName(String) javassist.CtClass+getName() javassist.CtClass+getName() javassist.bytecode.Bytecode+addExceptionHandler(int,int,int,CtClass) javassist.bytecode.Bytecode+addExceptionHandler(int,int,int,CtClass) javassist.bytecode.Bytecode+currentPc() javassist.bytecode.Bytecode+currentPc() javassist.bytecode.Bytecode+growStack(int) javassist.bytecode.Bytecode+growStack(int) javassist.bytecode.Bytecode+addAstore(int) javassist.bytecode.Bytecode+addAstore(int) javassist.compiler.ast.Stmnt+accept(Visitor) javassist.compiler.ast.Stmnt+accept(Visitor) javassist.bytecode.Bytecode+addOpcode(int) javassist.bytecode.Bytecode+addOpcode(int) javassist.bytecode.Bytecode+addIndex(int) javassist.bytecode.Bytecode+addIndex(int) javassist.bytecode.Bytecode+currentPc() javassist.bytecode.Bytecode+currentPc() javassist.compiler.ast.ASTree+getLeft() javassist.compiler.ast.ASTree+getRight() javassist.compiler.ast.ASTList+getRight() javassist.compiler.ast.ASTList+getRight() javassist.compiler.ast.ASTree+getRight() javassist.compiler.ast.ASTree+getLeft() javassist.compiler.CompileError+CompileError(String) javassist.bytecode.Bytecode+write16bit(int,int) javassist.bytecode.Bytecode+write16bit(int,int) javassist.bytecode.Bytecode+currentPc() javassist.bytecode.Bytecode+currentPc()",javassist.compiler.CodeGen+bytecode javassist.compiler.CodeGen+bytecode javassist.compiler.CodeGen+bytecode javassist.bytecode.Opcode+GOTO javassist.compiler.CodeGen+bytecode javassist.compiler.CodeGen+bytecode javassist.compiler.CodeGen+bytecode javassist.compiler.CodeGen+bytecode javassist.compiler.CodeGen+bytecode javassist.compiler.CodeGen+bytecode javassist.compiler.CodeGen+bytecode javassist.bytecode.Opcode+GOTO javassist.compiler.CodeGen+bytecode javassist.compiler.CodeGen+bytecode javassist.compiler.CodeGen+bytecode javassist.compiler.CodeGen+bytecode javassist.compiler.CodeGen+hasReturned,1665,47,4,,"protected void atTryStmnt(Stmnt st) throws CompileError {
        Stmnt body = (Stmnt)st.getLeft();
        if (body == null)
            return;

        int start = bytecode.currentPc();
        body.accept(this);
        int end = bytecode.currentPc();
        if (start == end)
            throw new CompileError(""empty try block"");

        bytecode.addOpcode(Opcode.GOTO);
        int pc = bytecode.currentPc();
        bytecode.addIndex(0);   // correct later

        int var = getMaxLocals();
        incMaxLocals(1);
        ASTList catchList = (ASTList)st.getRight().getLeft();
        while (catchList != null) {
            Pair p = (Pair)catchList.head();
            catchList = catchList.tail();
            Declarator decl = (Declarator)p.getLeft();
            Stmnt block = (Stmnt)p.getRight();

            decl.setLocalVar(var);

            CtClass type = lookupJvmClass(decl.getClassName());
            decl.setClassName(javaToJvmName(type.getName()));
            bytecode.addExceptionHandler(start, end, bytecode.currentPc(),
                                         type);
            bytecode.growStack(1);
            bytecode.addAstore(var);
            if (block != null)
                block.accept(this);

            bytecode.addOpcode(Opcode.GOTO);
            bytecode.addIndex(pc - bytecode.currentPc());
        }

        Stmnt finallyBlock = (Stmnt)st.getRight().getRight().getLeft();
        if (finallyBlock != null)
            throw new CompileError(
                        ""sorry, finally has not been supported yet"");

        bytecode.write16bit(pc, bytecode.currentPc() - pc + 1);
        hasReturned = false;
    }",False,False,"This method is used to handle the ""try"" statement in a Java program. It executes the code inside the ""try"" block, handles any exceptions that occur, and optionally executes a ""finally"" block.",True,"The given code represents a method called `atTryStmnt` that handles the compilation of a try-catch block. It processes the body of the try block, sets up exception handlers for each catch block, and throws an error if a finally block is encountered."
12,atNewExpr(NewExpr),at new expr expr ,Method,,,"javassist.compiler.ast.NewExpr+isArray() javassist.compiler.ast.NewExpr+isArray() javassist.compiler.MemberCodeGen+atNewArrayExpr(NewExpr) javassist.compiler.MemberCodeGen+atNewArrayExpr(NewExpr) javassist.compiler.MemberCodeGen+lookupClass(ASTList) javassist.compiler.MemberCodeGen+lookupClass(ASTList) javassist.compiler.ast.NewExpr+getClassName() javassist.compiler.ast.NewExpr+getClassName() javassist.CtClass+getName() javassist.CtClass+getName() javassist.compiler.ast.NewExpr+getArguments() javassist.compiler.ast.NewExpr+getArguments() javassist.bytecode.Bytecode+addNew(String) javassist.bytecode.Bytecode+addNew(String) javassist.bytecode.Bytecode+addOpcode(int) javassist.bytecode.Bytecode+addOpcode(int) javassist.compiler.MemberCodeGen+atMethodCall2(CtClass,String,ASTList,boolean,boolean,int) javassist.compiler.MemberCodeGen+atMethodCall2(CtClass,String,ASTList,boolean,boolean,int) javassist.compiler.MemberCodeGen+javaToJvmName(String) javassist.compiler.MemberCodeGen+javaToJvmName(String)",javassist.compiler.CodeGen+bytecode javassist.compiler.CodeGen+bytecode javassist.bytecode.Opcode+DUP javassist.bytecode.MethodInfo+nameInit javassist.compiler.CodeGen+exprType javassist.compiler.TokenId+CLASS javassist.compiler.CodeGen+arrayDim javassist.compiler.CodeGen+className,559,17,1,,"public void atNewExpr(NewExpr expr) throws CompileError {
        if (expr.isArray())
            atNewArrayExpr(expr);
        else {
            CtClass clazz = lookupClass(expr.getClassName());
            String cname = clazz.getName();
            ASTList args = expr.getArguments();
            bytecode.addNew(cname);
            bytecode.addOpcode(DUP);

            atMethodCall2(clazz, MethodInfo.nameInit, args, false, true, -1);

            exprType = CLASS;
            arrayDim = 0;
            className = javaToJvmName(cname);
        }
    }",False,False,"The function of this method is to handle a new expression. It checks if the expression is an array and calls another method if it is. Otherwise, it looks up the class, adds bytecode instructions, and sets the expression type, array dimension, and class name.",True,"The given code is a method named ""atNewExpr"" that takes a ""NewExpr"" object as a parameter. It checks if the expression represents an array or a class, and based on that, it either calls the ""atNewArrayExpr"" method or performs bytecode operations to create a new instance of the class and initialize it using the appropriate constructor."
13,atNewArrayExpr(NewExpr),at new array expr expr ,Method,atNewExpr(NewExpr),,"javassist.compiler.ast.NewExpr+getInitializer() javassist.compiler.ast.NewExpr+getInitializer() javassist.compiler.CompileError+CompileError(String) javassist.compiler.ast.NewExpr+getArrayType() javassist.compiler.ast.NewExpr+getArrayType() javassist.compiler.ast.NewExpr+getArraySize() javassist.compiler.ast.NewExpr+getArraySize() javassist.compiler.ast.NewExpr+getClassName() javassist.compiler.ast.NewExpr+getClassName() javassist.compiler.ast.ASTList+length() javassist.compiler.ast.ASTList+length() javassist.compiler.MemberCodeGen+atMultiNewArray(int,ASTList,ASTList) javassist.compiler.MemberCodeGen+atMultiNewArray(int,ASTList,ASTList) javassist.compiler.ast.ASTree+accept(Visitor) javassist.compiler.ast.ASTList+head() javassist.compiler.ast.ASTList+head() javassist.compiler.ast.ASTree+accept(Visitor) javassist.compiler.MemberCodeGen+resolveClassName(ASTList) javassist.compiler.MemberCodeGen+resolveClassName(ASTList) javassist.bytecode.Bytecode+addAnewarray(String) javassist.bytecode.Bytecode+addAnewarray(String) javassist.compiler.MemberCodeGen+jvmToJavaName(String) javassist.compiler.MemberCodeGen+jvmToJavaName(String) javassist.compiler.MemberCodeGen+badNewExpr() javassist.compiler.MemberCodeGen+badNewExpr() javassist.bytecode.Bytecode+addOpcode(int) javassist.bytecode.Bytecode+addOpcode(int) javassist.bytecode.Bytecode+add(int) javassist.bytecode.Bytecode+add(int)",javassist.compiler.CodeGen+exprType javassist.compiler.CodeGen+arrayDim javassist.compiler.TokenId+CLASS javassist.compiler.CodeGen+className javassist.compiler.CodeGen+bytecode javassist.compiler.CodeGen+className javassist.compiler.CodeGen+className javassist.compiler.TokenId+BOOLEAN javassist.bytecode.Opcode+T_BOOLEAN javassist.compiler.TokenId+CHAR javassist.bytecode.Opcode+T_CHAR javassist.compiler.TokenId+FLOAT javassist.bytecode.Opcode+T_FLOAT javassist.compiler.TokenId+DOUBLE javassist.bytecode.Opcode+T_DOUBLE javassist.compiler.TokenId+BYTE javassist.bytecode.Opcode+T_BYTE javassist.compiler.TokenId+SHORT javassist.bytecode.Opcode+T_SHORT javassist.compiler.TokenId+INT javassist.bytecode.Opcode+T_INT javassist.compiler.TokenId+LONG javassist.bytecode.Opcode+T_LONG javassist.compiler.CodeGen+bytecode javassist.bytecode.Opcode+NEWARRAY javassist.compiler.CodeGen+bytecode,1588,56,1,,"public void atNewArrayExpr(NewExpr expr) throws CompileError {
        if (expr.getInitializer() != null)
            throw new CompileError(""array initializer is not supported"");

        int type = expr.getArrayType();
        ASTList size = expr.getArraySize();
        ASTList classname = expr.getClassName();
        if (size.length() > 1) {
            atMultiNewArray(type, classname, size);
            return;
        }

        size.head().accept(this);
        exprType = type;
        arrayDim = 1;
        if (type == CLASS) {
            className = resolveClassName(classname);
            bytecode.addAnewarray(jvmToJavaName(className));
        }
        else {
            className = null;
            int atype = 0;
            switch (type) {
            case BOOLEAN :
                atype = T_BOOLEAN;
                break;
            case CHAR :
                atype = T_CHAR;
                break;
            case FLOAT :
                atype = T_FLOAT;
                break;
            case DOUBLE :
                atype = T_DOUBLE;
                break;
            case BYTE :
                atype = T_BYTE;
                break;
            case SHORT :
                atype = T_SHORT;
                break;
            case INT :
                atype = T_INT;
                break;
            case LONG :
                atype = T_LONG;
                break;
            default :
                badNewExpr();
                break;
            }

            bytecode.addOpcode(NEWARRAY);
            bytecode.add(atype);
        }
    }",False,False,"The function of this method is to handle the creation of a new array. It checks if the array has an initializer, and if so, throws an error. It then determines the type, size, and class name of the array. If the size is greater than 1, it calls another method to handle multi-dimensional arrays. Otherwise, it adds the appropriate bytecode instructions to create the array.",True,"The given code is a method named `atNewArrayExpr` that handles the creation of new arrays in Java. It checks if the array has an initializer, throws an exception if it does, and then determines the type and size of the array. If the array has multiple dimensions, it calls another method to handle it, otherwise it generates bytecode instructions to create the array."
14,badNewExpr(),bad new expr ,Method,atNewArrayExpr(NewExpr),,javassist.compiler.CompileError+CompileError(String),,114,3,10,,"private static void badNewExpr() throws CompileError {
        throw new CompileError(""bad new expression"");
    }",False,False,"The function of the method ""badNewExpr"" is to throw a CompileError exception with the message ""bad new expression"".",True,"The code defines a private static method called ""badNewExpr()"" that throws a CompileError exception with the message ""bad new expression"". This method is likely used to handle errors related to incorrect usage of the ""new"" keyword in the codebase."
15,"atMultiNewArray(int,ASTList,ASTList)",at multi new array type classname size ,Method,atNewArrayExpr(NewExpr),,"javassist.compiler.ast.ASTList+length() javassist.compiler.ast.ASTList+length() javassist.compiler.ast.ASTList+tail() javassist.compiler.ast.ASTList+tail() javassist.compiler.ast.ASTList+head() javassist.compiler.ast.ASTList+head() javassist.compiler.ast.ASTree+accept(Visitor) javassist.compiler.ast.ASTree+accept(Visitor) javassist.compiler.CompileError+CompileError(String) javassist.compiler.MemberCodeGen+resolveClassName(ASTList) javassist.compiler.MemberCodeGen+resolveClassName(ASTList) javassist.compiler.CodeGen+toJvmArrayName(String,int) javassist.compiler.CodeGen+toJvmArrayName(String,int) javassist.compiler.CodeGen+toJvmTypeName(int,int) javassist.compiler.CodeGen+toJvmTypeName(int,int) javassist.bytecode.Bytecode+addMultiNewarray(String,int) javassist.bytecode.Bytecode+addMultiNewarray(String,int)",javassist.compiler.CodeGen+exprType javassist.compiler.TokenId+INT javassist.compiler.CodeGen+exprType javassist.compiler.CodeGen+arrayDim javassist.compiler.TokenId+CLASS javassist.compiler.CodeGen+className javassist.compiler.CodeGen+className javassist.compiler.CodeGen+bytecode,836,28,4,,"protected void atMultiNewArray(int type, ASTList classname, ASTList size)
        throws CompileError
    {
        int count, dim;
        dim = size.length();
        for (count = 0; size != null; size = size.tail()) {
            ASTree s = size.head();
            if (s == null)
                break;          // int[][][] a = new int[3][4][];

            ++count;
            s.accept(this);
            if (exprType != INT)
                throw new CompileError(""bad type for array size"");
        }

        String desc;
        exprType = type;
        arrayDim = dim;
        if (type == CLASS) {
            className = resolveClassName(classname);
            desc = toJvmArrayName(className, dim);
        }
        else
            desc = toJvmTypeName(type, dim);

        bytecode.addMultiNewarray(desc, count);
    }",False,False,"This method is used to create a new multi-dimensional array. It takes the type, classname, and size of the array as parameters, and adds the bytecode instruction to create the array. It also performs some error checking and resolves the classname if the type is a class.",True,"This code defines a protected method called `atMultiNewArray` that is used to handle the creation of multi-dimensional arrays in Java. It takes in the type of the array, the class name, and the size of each dimension as parameters, and then generates bytecode instructions to create the array."
16,atMethodCall(Expr),at method call expr ,Method,,,"javassist.compiler.ast.Expr+oprand1() javassist.compiler.ast.Expr+oprand1() javassist.compiler.ast.Expr+oprand2() javassist.compiler.ast.Expr+oprand2() javassist.compiler.ast.Symbol+get() javassist.compiler.ast.Symbol+get() javassist.bytecode.Bytecode+currentPc() javassist.bytecode.Bytecode+currentPc() javassist.bytecode.Bytecode+addAload(int) javassist.bytecode.Bytecode+addAload(int) javassist.compiler.CompileError+CompileError(String) javassist.bytecode.Bytecode+addAload(int) javassist.bytecode.Bytecode+addAload(int) javassist.compiler.ast.Keyword+get() javassist.compiler.ast.Keyword+get() javassist.compiler.MemberCodeGen+getSuperclass(CtClass) javassist.compiler.MemberCodeGen+getSuperclass(CtClass) javassist.compiler.ast.Symbol+get() javassist.compiler.ast.Expr+oprand2() javassist.compiler.ast.Expr+oprand2() javassist.compiler.ast.Symbol+get() javassist.compiler.ast.Expr+getOperator() javassist.compiler.ast.Expr+getOperator() javassist.compiler.MemberCodeGen+lookupJavaClass(String) javassist.compiler.MemberCodeGen+lookupJavaClass(String) javassist.compiler.ast.Symbol+get() javassist.compiler.ast.Expr+oprand1() javassist.compiler.ast.Expr+oprand1() javassist.compiler.ast.Symbol+get() javassist.compiler.ast.Expr+oprand1() javassist.compiler.ast.Expr+oprand1() javassist.compiler.ast.Keyword+get() javassist.compiler.ast.Keyword+get() javassist.compiler.ast.ASTree+accept(Visitor) javassist.compiler.ast.ASTree+accept(Visitor) javassist.compiler.NoFieldException+getExpr() javassist.compiler.NoFieldException+getExpr() javassist.compiler.NoFieldException+getField() javassist.compiler.NoFieldException+getField() javassist.compiler.MemberCodeGen+lookupJavaClass(String) javassist.compiler.MemberCodeGen+lookupJavaClass(String) javassist.compiler.MemberCodeGen+lookupJvmClass(String) javassist.compiler.MemberCodeGen+lookupJvmClass(String) javassist.compiler.MemberCodeGen+badMethod() javassist.compiler.MemberCodeGen+badMethod() javassist.compiler.MemberCodeGen+badMethod() javassist.compiler.MemberCodeGen+badMethod() javassist.compiler.CodeGen+fatal() javassist.compiler.CodeGen+fatal() javassist.compiler.MemberCodeGen+atMethodCall2(CtClass,String,ASTList,boolean,boolean,int) javassist.compiler.MemberCodeGen+atMethodCall2(CtClass,String,ASTList,boolean,boolean,int)",javassist.compiler.MemberCodeGen+thisClass javassist.compiler.CodeGen+inStaticMethod javassist.compiler.CodeGen+bytecode javassist.compiler.CodeGen+bytecode javassist.bytecode.MethodInfo+nameInit javassist.compiler.MemberCodeGen+thisClass javassist.compiler.CodeGen+inStaticMethod javassist.compiler.CodeGen+bytecode javassist.compiler.TokenId+SUPER javassist.compiler.TokenId+MEMBER javassist.compiler.TokenId+SUPER javassist.compiler.CodeGen+exprType javassist.compiler.TokenId+CLASS javassist.compiler.CodeGen+arrayDim javassist.compiler.CodeGen+className javassist.compiler.CodeGen+arrayDim javassist.compiler.CodeGen+javaLangObject javassist.compiler.CodeGen+exprType javassist.compiler.TokenId+CLASS javassist.compiler.CodeGen+className,2686,75,4,,"protected void atMethodCall(Expr expr) throws CompileError {
        String mname = null;
        CtClass targetClass = null;
        ASTree method = expr.oprand1();
        ASTList args = (ASTList)expr.oprand2();
        boolean isStatic = false;
        boolean isSpecial = false;
        int aload0pos = -1;

        if (method instanceof Member) {
            mname = ((Member)method).get();
            targetClass = thisClass;
            if (inStaticMethod)
                isStatic = true;            // should be static
            else {
                aload0pos = bytecode.currentPc();
                bytecode.addAload(0);       // this
            }
        }
        else if (method instanceof Keyword) {   // constructor
            isSpecial = true;
            mname = MethodInfo.nameInit;        // <init>
            targetClass = thisClass;
            if (inStaticMethod)
                throw new CompileError(""a constructor cannot be static"");
            else
                bytecode.addAload(0);   // this

            if (((Keyword)method).get() == SUPER)
                targetClass = getSuperclass(targetClass);
        }
        else if (method instanceof Expr) {
            Expr e = (Expr)method;
            mname = ((Symbol)e.oprand2()).get();
            int op = e.getOperator();
            if (op == MEMBER) {                 // static method
                targetClass = lookupJavaClass(((Symbol)e.oprand1()).get());
                isStatic = true;
            }
            else if (op == '.') {
                ASTree target = e.oprand1();
                if (target instanceof Keyword)
                    if (((Keyword)target).get() == SUPER)
                        isSpecial = true;

                try {
                    target.accept(this);
                }
                catch (NoFieldException nfe) {
                    if (nfe.getExpr() != target)
                        throw nfe;

                    // it should be a static method.
                    exprType = CLASS;
                    arrayDim = 0;
                    className = nfe.getField(); // JVM-internal
                    isStatic = true;
                }

                if (arrayDim > 0)
                    targetClass = lookupJavaClass(javaLangObject);
                else if (exprType == CLASS /* && arrayDim == 0 */)
                    targetClass = lookupJvmClass(className);
                else
                    badMethod();
            }
            else
                badMethod();
        }
        else
            fatal();

        atMethodCall2(targetClass, mname, args, isStatic, isSpecial,
                      aload0pos);
    }",False,False,"This method is used to process method calls in a Java program. It determines the name of the method, the target class, whether the method is static or special, and the arguments passed to the method. It then calls another method to further process the method call.",True,"The given code is a method called ""atMethodCall"" that handles method calls in a Java program. It determines the name of the method, the target class, and whether the method is static or special. It then calls another method called ""atMethodCall2"" with the relevant information."
17,badMethod(),bad method ,Method,"atMethodCall(Expr) atMethodCall(Expr) setReturnType(String,boolean,boolean) setReturnType(String,boolean,boolean)",,javassist.compiler.CompileError+CompileError(String),,105,3,10,,"private static void badMethod() throws CompileError {
        throw new CompileError(""bad method"");
    }",False,False,"The function of the method is to throw a CompileError exception with the message ""bad method"".",False,"The code contains a private static method called ""badMethod"" that throws a custom exception called ""CompileError"" with the message ""bad method"". This method does not have any parameters and does not return any value."
18,getSuperclass(CtClass),get superclass c ,Method,getSuperName() insertDefaultSuperCall() atMethodCall(Expr),,javassist.CtClass+getSuperclass() javassist.CtClass+getSuperclass() javassist.compiler.CompileError+CompileError(String) javassist.CtClass+getName() javassist.CtClass+getName(),,305,9,10,,"private static CtClass getSuperclass(CtClass c) throws CompileError {
        try {
            return c.getSuperclass();
        }
        catch (NotFoundException e) {
            throw new CompileError(""cannot find the super class of ""
                                   + c.getName());
        }
    }",True,True,"The function of this method is to retrieve the superclass of a given CtClass object. If the superclass is not found, it throws a CompileError with a message indicating that the superclass cannot be found.",False,"The given code is a method named ""getSuperclass"" that takes a CtClass object as input and returns its superclass. If the superclass is not found, it throws a CompileError with a message indicating the inability to find the superclass."
19,"atMethodCall2(CtClass,String,ASTList,boolean,boolean,int)",at method call2 target class mname args is static is special aload0pos ,Method,atNewExpr(NewExpr) atMethodCall(Expr),"javassist.expr.NewExpr+ProceedForNew.doit(JvstCodeGen,Bytecode,ASTList)","javassist.compiler.MemberCodeGen+getMethodArgsLength(ASTList) javassist.compiler.MemberCodeGen+getMethodArgsLength(ASTList) javassist.bytecode.Bytecode+getStackDepth() javassist.bytecode.Bytecode+getStackDepth() javassist.compiler.MemberCodeGen+atMethodArgs(ASTList,int[],int[],String[]) javassist.compiler.MemberCodeGen+atMethodArgs(ASTList,int[],int[],String[]) javassist.bytecode.Bytecode+getStackDepth() javassist.bytecode.Bytecode+getStackDepth() javassist.compiler.MemberCodeGen+lookupMethod(CtClass,MethodInfo,String,int[],int[],String[],boolean) javassist.compiler.MemberCodeGen+lookupMethod(CtClass,MethodInfo,String,int[],int[],String[],boolean) java.lang.String+equals(Object) java.lang.String+equals(Object) javassist.CtClass+getName() javassist.CtClass+getName() javassist.compiler.CompileError+CompileError(String) javassist.bytecode.MethodInfo+getDescriptor() javassist.bytecode.MethodInfo+getDescriptor() javassist.bytecode.MethodInfo+getAccessFlags() javassist.bytecode.MethodInfo+getAccessFlags() java.lang.String+equals(Object) java.lang.String+equals(Object) javassist.compiler.CompileError+CompileError(String) javassist.compiler.CompileError+CompileError(String) javassist.bytecode.Bytecode+write(int,int) javassist.bytecode.Bytecode+write(int,int) javassist.bytecode.Bytecode+addInvokestatic(CtClass,String,String) javassist.bytecode.Bytecode+addInvokestatic(CtClass,String,String) javassist.bytecode.Bytecode+addInvokespecial(CtClass,String,String) javassist.bytecode.Bytecode+addInvokespecial(CtClass,String,String) javassist.CtClass+isInterface() javassist.CtClass+isInterface() javassist.bytecode.Bytecode+addInvokeinterface(CtClass,String,String,int) javassist.bytecode.Bytecode+addInvokeinterface(CtClass,String,String,int) javassist.compiler.CompileError+CompileError(String) javassist.bytecode.Bytecode+addInvokevirtual(CtClass,String,String) javassist.bytecode.Bytecode+addInvokevirtual(CtClass,String,String) javassist.compiler.MemberCodeGen+setReturnType(String,boolean,boolean) javassist.compiler.MemberCodeGen+setReturnType(String,boolean,boolean)",javassist.compiler.CodeGen+bytecode javassist.compiler.CodeGen+bytecode javassist.compiler.MemberCodeGen+thisMethod javassist.bytecode.MethodInfo+nameInit javassist.bytecode.MethodInfo+nameInit javassist.bytecode.AccessFlag+PRIVATE javassist.bytecode.AccessFlag+STATIC javassist.compiler.CodeGen+bytecode javassist.bytecode.Opcode+NOP javassist.compiler.CodeGen+bytecode javassist.compiler.CodeGen+bytecode javassist.compiler.CodeGen+bytecode javassist.compiler.CodeGen+bytecode,2715,75,1,,"public void atMethodCall2(CtClass targetClass, String mname,
                        ASTList args, boolean isStatic, boolean isSpecial,
                        int aload0pos)
        throws CompileError
    {
        int nargs = getMethodArgsLength(args);
        int[] types = new int[nargs];
        int[] dims = new int[nargs];
        String[] cnames = new String[nargs];

        int stack = bytecode.getStackDepth();

        atMethodArgs(args, types, dims, cnames);

        // used by invokeinterface
        int count = bytecode.getStackDepth() - stack + 1;

        Object[] found = lookupMethod(targetClass, thisMethod, mname,
                                      types, dims, cnames, false);
        if (found == null) {
            String msg;
            if (mname.equals(MethodInfo.nameInit))
                msg = ""constructor not found"";
            else
                msg = ""Method "" + mname + "" not found in ""
                    + targetClass.getName();

            throw new CompileError(msg);
        }

        CtClass declClass = (CtClass)found[0];
        MethodInfo minfo = (MethodInfo)found[1];
        String desc = minfo.getDescriptor();
        int acc = minfo.getAccessFlags();

        if (mname.equals(MethodInfo.nameInit)) {
            isSpecial = true;
            if (declClass != targetClass)
                throw new CompileError(""no such a constructor"");
        }
        else if ((acc & AccessFlag.PRIVATE) != 0) {
            isSpecial = true;
            if (declClass != targetClass)
                throw new CompileError(""Method "" + mname + ""is private"");
        }

        boolean popTarget = false;
        if ((acc & AccessFlag.STATIC) != 0) {
            if (!isStatic) {
                /* this method is static but the target object is
                   on stack.  It must be popped out.  If aload0pos >= 0,
                   then the target object was pushed by aload_0.  It is
                   overwritten by NOP.
                */
                isStatic = true;
                if (aload0pos >= 0)
                    bytecode.write(aload0pos, NOP);
                else
                    popTarget = true;
            }

            bytecode.addInvokestatic(declClass, mname, desc);
        }
        else if (isSpecial)
            bytecode.addInvokespecial(declClass, mname, desc);
        else if (declClass.isInterface())
            bytecode.addInvokeinterface(declClass, mname, desc, count);
        else
            if (isStatic)
                throw new CompileError(mname + "" is not static"");
            else
                bytecode.addInvokevirtual(declClass, mname, desc);

        setReturnType(desc, isStatic, popTarget);
    }",False,False,"This method is used to generate bytecode instructions for invoking a method. It takes in various parameters such as the target class, method name, arguments, and flags, and uses them to determine the appropriate bytecode instructions to generate. It also handles error cases such as when the method is not found or when the method is not accessible.",True,"This code defines a method that handles method calls in a Java class. It takes in parameters such as the target class, method name, arguments, and flags indicating if the method is static or special. It performs various checks and invokes the appropriate bytecode instructions based on the method's access flags and type."
20,getMethodArgsLength(ASTList),get method args length args ,Method,"atMethodCall2(CtClass,String,ASTList,boolean,boolean,int)",,javassist.compiler.ast.ASTList+length(ASTList) javassist.compiler.ast.ASTList+length(ASTList),,89,3,1,,"public int getMethodArgsLength(ASTList args) {
        return ASTList.length(args);
    }",False,False,"This method returns the length of the given ASTList object, which represents the number of arguments passed to a method.",True,"The given code defines a method named ""getMethodArgsLength"" that takes an argument of type ""ASTList"" and returns the length of the given argument using a static method ""length"" of the ""ASTList"" class. The method is expected to return an integer value representing the length of the argument."
21,"atMethodArgs(ASTList,int[],int[],String[])",at method args args types dims cnames ,Method,"atMethodCall2(CtClass,String,ASTList,boolean,boolean,int)",,javassist.compiler.ast.ASTList+head() javassist.compiler.ast.ASTList+head() javassist.compiler.ast.ASTree+accept(Visitor) javassist.compiler.ast.ASTree+accept(Visitor) javassist.compiler.ast.ASTList+tail() javassist.compiler.ast.ASTList+tail(),javassist.compiler.CodeGen+exprType javassist.compiler.CodeGen+arrayDim javassist.compiler.CodeGen+className,410,13,1,,"public void atMethodArgs(ASTList args, int[] types, int[] dims,
                             String[] cnames) throws CompileError {
        int i = 0;
        while (args != null) {
            ASTree a = args.head();
            a.accept(this);
            types[i] = exprType;
            dims[i] = arrayDim;
            cnames[i] = className;
            ++i;
            args = args.tail();
        }
    }",False,False,"This method accepts an ASTList of arguments, along with arrays for types, dimensions, and class names. It iterates through the arguments, calling the accept method on each one, and assigns the expression type, array dimension, and class name to the corresponding arrays.",True,"The given code is a method named ""atMethodArgs"" that takes in an ASTList of arguments, along with arrays for types, dimensions, and class names. It iterates through the arguments, calling the ""accept"" method on each one and storing the resulting expression type, array dimension, and class name in the respective arrays."
22,"setReturnType(String,boolean,boolean)",set return type desc is static pop target ,Method,"atMethodCall2(CtClass,String,ASTList,boolean,boolean,int)","javassist.compiler.JvstCodeGen+compileInvokeSpecial(ASTree,String,String,String,ASTList)","java.lang.String+indexOf(int) java.lang.String+indexOf(int) javassist.compiler.MemberCodeGen+badMethod() javassist.compiler.MemberCodeGen+badMethod() java.lang.String+charAt(int) java.lang.String+charAt(int) java.lang.String+charAt(int) java.lang.String+charAt(int) java.lang.String+indexOf(int,int) java.lang.String+indexOf(int,int) javassist.compiler.MemberCodeGen+badMethod() javassist.compiler.MemberCodeGen+badMethod() java.lang.String+substring(int,int) java.lang.String+substring(int,int) javassist.compiler.MemberCodeGen+descToType(char) javassist.compiler.MemberCodeGen+descToType(char) javassist.compiler.CodeGen+is2word(int,int) javassist.compiler.CodeGen+is2word(int,int) javassist.bytecode.Bytecode+addOpcode(int) javassist.bytecode.Bytecode+addOpcode(int) javassist.bytecode.Bytecode+addOpcode(int) javassist.bytecode.Bytecode+addOpcode(int) javassist.bytecode.Bytecode+addOpcode(int) javassist.bytecode.Bytecode+addOpcode(int) javassist.bytecode.Bytecode+addOpcode(int) javassist.bytecode.Bytecode+addOpcode(int) javassist.bytecode.Bytecode+addOpcode(int) javassist.bytecode.Bytecode+addOpcode(int) javassist.bytecode.Bytecode+addOpcode(int) javassist.bytecode.Bytecode+addOpcode(int)",javassist.compiler.CodeGen+arrayDim javassist.compiler.CodeGen+exprType javassist.compiler.TokenId+CLASS javassist.compiler.CodeGen+className javassist.compiler.CodeGen+exprType javassist.compiler.CodeGen+className javassist.compiler.CodeGen+exprType javassist.compiler.CodeGen+bytecode javassist.bytecode.Opcode+DUP2_X1 javassist.compiler.CodeGen+bytecode javassist.bytecode.Opcode+POP2 javassist.compiler.CodeGen+bytecode javassist.bytecode.Opcode+POP javassist.compiler.TokenId+VOID javassist.compiler.CodeGen+bytecode javassist.bytecode.Opcode+POP javassist.compiler.CodeGen+bytecode javassist.bytecode.Opcode+SWAP javassist.compiler.CodeGen+bytecode javassist.bytecode.Opcode+POP,1191,45,0,,"void setReturnType(String desc, boolean isStatic, boolean popTarget)
        throws CompileError
    {
        int i = desc.indexOf(')');
        if (i < 0)
            badMethod();

        char c = desc.charAt(++i);
        int dim = 0;
        while (c == '[') {
            ++dim;
            c = desc.charAt(++i);
        }

        arrayDim = dim;
        if (c == 'L') {
            int j = desc.indexOf(';', i + 1);
            if (j < 0)
                badMethod();

            exprType = CLASS;
            className = desc.substring(i + 1, j);
        }
        else {
            exprType = descToType(c);
            className = null;
        }

        int etype = exprType;
        if (isStatic) {
            if (popTarget) {
                if (is2word(etype, dim)) {
                    bytecode.addOpcode(DUP2_X1);
                    bytecode.addOpcode(POP2);
                    bytecode.addOpcode(POP);
                }
                else if (etype == VOID)
                    bytecode.addOpcode(POP);
                else {
                    bytecode.addOpcode(SWAP);
                    bytecode.addOpcode(POP);
                }
            }
        }
    }",False,False,"This method sets the return type of a method based on the given description. It determines the array dimension and class name (if applicable) of the return type. It then adds bytecode instructions to the method's bytecode based on the return type, isStatic, and popTarget parameters.",True,"This code is a method that sets the return type of a method in a Java class. It parses the method descriptor, determines the return type, and handles different scenarios based on whether the method is static and whether the target needs to be popped from the stack."
23,"lookupMethod(CtClass,MethodInfo,String,int[],int[],String[],boolean)",lookup method clazz current method name arg types arg dims arg class names only exact ,Method,"atMethodCall2(CtClass,String,ASTList,boolean,boolean,int) lookupMethod(CtClass,MethodInfo,String,int[],int[],String[],boolean)",,"java.lang.String+equals(Object) javassist.bytecode.MethodInfo+getName() javassist.bytecode.MethodInfo+getName() java.lang.String+equals(Object) javassist.compiler.MemberCodeGen+compareSignature(String,int[],int[],String[]) javassist.compiler.MemberCodeGen+compareSignature(String,int[],int[],String[]) javassist.bytecode.MethodInfo+getDescriptor() javassist.bytecode.MethodInfo+getDescriptor() javassist.bytecode.ClassFile+getMethods() javassist.CtClass+getClassFile2() javassist.CtClass+getClassFile2() javassist.bytecode.ClassFile+getMethods() java.util.List+size() java.util.List+size() java.util.List+get(int) java.util.List+get(int) java.lang.String+equals(Object) javassist.bytecode.MethodInfo+getName() javassist.bytecode.MethodInfo+getName() java.lang.String+equals(Object) javassist.compiler.MemberCodeGen+compareSignature(String,int[],int[],String[]) javassist.compiler.MemberCodeGen+compareSignature(String,int[],int[],String[]) javassist.bytecode.MethodInfo+getDescriptor() javassist.bytecode.MethodInfo+getDescriptor() javassist.CtClass+getSuperclass() javassist.CtClass+getSuperclass() javassist.compiler.MemberCodeGen+lookupMethod(CtClass,MethodInfo,String,int[],int[],String[],boolean) javassist.compiler.MemberCodeGen+lookupMethod(CtClass,MethodInfo,String,int[],int[],String[],boolean)",javassist.compiler.MemberCodeGen+YES javassist.compiler.MemberCodeGen+MAYBE javassist.compiler.MemberCodeGen+YES javassist.compiler.MemberCodeGen+MAYBE,2410,65,2,,"private Object[] lookupMethod(CtClass clazz, MethodInfo current,
                                  String methodName,
                                  int[] argTypes, int[] argDims,
                                  String[] argClassNames, boolean onlyExact)
        throws CompileError
    {
        Object[] maybe = null;

        if (current != null)
            if (current.getName().equals(methodName)) {
                int res = compareSignature(current.getDescriptor(),
                                           argTypes, argDims, argClassNames);
                Object[] r = new Object[] { clazz, current };
                if (res == YES)
                    return r;
                else if (res == MAYBE && maybe == null)
                    maybe = r;
            }

        List list = clazz.getClassFile2().getMethods();
        int n = list.size();
        for (int i = 0; i < n; ++i) {
            MethodInfo minfo = (MethodInfo)list.get(i);
            if (minfo.getName().equals(methodName)) {
                int res = compareSignature(minfo.getDescriptor(),
                                           argTypes, argDims, argClassNames);
                Object[] r = new Object[] { clazz, minfo };
                if (res == YES)
                    return r;
                else if (res == MAYBE && maybe == null)
                    maybe = r;
            }
        }

        try {
            CtClass pclazz = clazz.getSuperclass();
            if (pclazz != null) {
                Object[] r = lookupMethod(pclazz, null, methodName, argTypes,
                                          argDims, argClassNames,
                                          (onlyExact || maybe != null));
                if (r != null)
                    return r;
            }
        }
        catch (NotFoundException e) {}

        /* -- not necessary to search implemented interfaces.
        try {
            CtClass[] ifs = clazz.getInterfaces();
            int size = ifs.length;
            for (int i = 0; i < size; ++i) {
                Object[] r = lookupMethod(ifs[i], methodName, argTypes,
                                          argDims, argClassNames);
                if (r != null)
                    return r;
            }
        }
        catch (NotFoundException e) {}
        */

        if (onlyExact)
            return null;
        else
            return maybe;
    }",True,True,"The function of this method is to lookup a method in a given class and its superclass hierarchy, based on the method name and its argument types. It returns an array containing the class and method information if a matching method is found, otherwise it returns null.",False,"The code defines a method called `lookupMethod` that searches for a method with a given name and matching arguments in a given class and its superclass. It returns an array containing the class and method information if a match is found, otherwise it returns `null` or an array with a possible match if `onlyExact` is `false`."
24,YES,yes ,Field,,,,,33,1,26,,private static final int YES = 2;,True,True,,False,
25,MAYBE,maybe ,Field,,,,,35,1,26,,private static final int MAYBE = 1;,False,False,,False,
26,NO,no ,Field,,,,,32,1,26,,private static final int NO = 0;,True,True,,False,
27,"compareSignature(String,int[],int[],String[])",compare signature desc arg types arg dims arg class names ,Method,"lookupMethod(CtClass,MethodInfo,String,int[],int[],String[],boolean) lookupMethod(CtClass,MethodInfo,String,int[],int[],String[],boolean)",,"javassist.bytecode.Descriptor+numOfParameters(String) javassist.bytecode.Descriptor+numOfParameters(String) java.lang.String+length() java.lang.String+length() java.lang.String+charAt(int) java.lang.String+charAt(int) java.lang.String+charAt(int) java.lang.String+charAt(int) java.lang.String+startsWith(String,int) java.lang.String+startsWith(String,int) java.lang.String+indexOf(int,int) java.lang.String+indexOf(int,int) java.lang.String+indexOf(int,int) java.lang.String+indexOf(int,int) java.lang.String+substring(int,int) java.lang.String+substring(int,int) java.lang.String+equals(Object) java.lang.String+equals(Object) javassist.compiler.MemberCodeGen+lookupJvmClass(String) javassist.compiler.MemberCodeGen+lookupJvmClass(String) javassist.CtClass+subtypeOf(CtClass) javassist.CtClass+subtypeOf(CtClass) javassist.compiler.MemberCodeGen+lookupJvmClass(String) javassist.compiler.MemberCodeGen+lookupJvmClass(String) javassist.compiler.MemberCodeGen+descToType(char) javassist.compiler.MemberCodeGen+descToType(char)",javassist.compiler.MemberCodeGen+YES javassist.compiler.MemberCodeGen+NO javassist.compiler.MemberCodeGen+NO javassist.compiler.MemberCodeGen+NO javassist.compiler.TokenId+NULL javassist.compiler.MemberCodeGen+NO javassist.compiler.MemberCodeGen+NO javassist.compiler.MemberCodeGen+MAYBE javassist.compiler.MemberCodeGen+NO javassist.compiler.TokenId+CLASS javassist.compiler.MemberCodeGen+NO javassist.compiler.MemberCodeGen+MAYBE javassist.compiler.MemberCodeGen+NO javassist.compiler.MemberCodeGen+MAYBE javassist.compiler.TokenId+INT javassist.compiler.TokenId+SHORT javassist.compiler.TokenId+BYTE javassist.compiler.TokenId+CHAR javassist.compiler.MemberCodeGen+MAYBE javassist.compiler.MemberCodeGen+NO javassist.compiler.MemberCodeGen+NO,2410,74,2,,"private int compareSignature(String desc, int[] argTypes,
                                 int[] argDims, String[] argClassNames)
        throws CompileError
    {
        int result = YES;
        int i = 1;
        int nArgs = argTypes.length;
        if (nArgs != Descriptor.numOfParameters(desc))
            return NO;

        int len = desc.length();
        for (int n = 0; i < len; ++n) {
            char c = desc.charAt(i++);
            if (c == ')')
                return (n == nArgs ? result : NO);
            else if (n >= nArgs)
                return NO;

            int dim = 0;
            while (c == '[') {
                ++dim;
                c = desc.charAt(i++);
            }

            if (argTypes[n] == NULL) {
                if (dim == 0 && c != 'L')
                    return NO;
            }
            else if (argDims[n] != dim) {
                if (!(dim == 0 && c == 'L'
                      && desc.startsWith(""java/lang/Object;"", i)))
                    return NO;

                // if the thread reaches here, c must be 'L'.
                i = desc.indexOf(';', i) + 1;
                result = MAYBE;
                if (i <= 0)
                    return NO;  // invalid descriptor?
            }
            else if (c == 'L') {        // not compare
                int j = desc.indexOf(';', i);
                if (j < 0 || argTypes[n] != CLASS)
                    return NO;

                String cname = desc.substring(i, j);
                if (!cname.equals(argClassNames[n])) {
                    CtClass clazz = lookupJvmClass(argClassNames[n]);
                    try {
                        if (clazz.subtypeOf(lookupJvmClass(cname)))
                            result = MAYBE;
                        else
                            return NO;
                    }
                    catch (NotFoundException e) {
                        result = MAYBE; // should be NO?
                    }
                }

                i = j + 1;
            }
            else {
                int t = descToType(c);
                int at = argTypes[n];
                if (t != at)
                    if (t == INT
                        && (at == SHORT || at == BYTE || at == CHAR))
                        result = MAYBE;
                    else
                        return NO;
            }
        }

        return NO;
    }",True,True,"This method compares the signature of a method with the given arguments. It checks if the number of arguments matches the method's descriptor, and then compares each argument type with the corresponding argument in the descriptor. It returns YES if the signature matches, MAYBE if there is a potential match, and NO if there is no match.",True,The code is a private method that compares the signature of a method with the provided arguments. It checks if the number of arguments matches the method's descriptor and compares the types and dimensions of the arguments. It returns a result indicating whether the signature matches or not.
28,descToType(char),desc to type c ,Method,"setReturnType(String,boolean,boolean) compareSignature(String,int[],int[],String[]) atFieldRead(CtField,boolean,boolean)","javassist.compiler.JvstCodeGen+setType(CtClass,int) javassist.compiler.JvstCodeGen+doNumCast(CtClass)",javassist.compiler.CodeGen+fatal() javassist.compiler.CodeGen+fatal(),javassist.compiler.TokenId+BOOLEAN javassist.compiler.TokenId+CHAR javassist.compiler.TokenId+BYTE javassist.compiler.TokenId+SHORT javassist.compiler.TokenId+INT javassist.compiler.TokenId+LONG javassist.compiler.TokenId+FLOAT javassist.compiler.TokenId+DOUBLE javassist.compiler.TokenId+VOID javassist.compiler.TokenId+CLASS javassist.compiler.TokenId+VOID,629,28,12,,"protected static int descToType(char c) throws CompileError {
        switch (c) {
        case 'Z' :
            return BOOLEAN;
        case 'C' :
            return CHAR;
        case 'B' :
            return  BYTE;
        case 'S' :
            return SHORT;
        case 'I' :
            return INT;
        case 'J' :
            return LONG;
        case 'F' :
            return FLOAT;
        case 'D' :
            return DOUBLE;
        case 'V' :
            return VOID;
        case 'L' :
        case '[' :
            return CLASS;
        default :
            fatal();
            return VOID;
        }
    }",True,True,The function of this method is to convert a character representing a type descriptor into an integer value representing the corresponding type.,True,"The code is a method that takes a character as input and returns an integer value representing the type of the character. It uses a switch statement to map each character to its corresponding type, and throws a CompileError if an invalid character is encountered."
29,"atFieldAssign(Expr,int,ASTree,ASTree,boolean)",at field assign expr op left right do dup ,Method,,,"javassist.compiler.MemberCodeGen+fieldAccess(ASTree) javassist.compiler.MemberCodeGen+fieldAccess(ASTree) javassist.bytecode.Bytecode+addOpcode(int) javassist.bytecode.Bytecode+addOpcode(int) javassist.compiler.MemberCodeGen+atFieldRead(CtField,boolean,boolean) javassist.compiler.MemberCodeGen+atFieldRead(CtField,boolean,boolean) javassist.compiler.CodeGen+atAssignCore(Expr,int,ASTree,int,int,String) javassist.compiler.CodeGen+atAssignCore(Expr,int,ASTree,int,int,String) javassist.compiler.CodeGen+is2word(int,int) javassist.compiler.CodeGen+is2word(int,int) javassist.bytecode.Bytecode+addOpcode(int) javassist.bytecode.Bytecode+addOpcode(int) javassist.bytecode.Bytecode+add(int) javassist.bytecode.Bytecode+add(int) javassist.bytecode.Bytecode+growStack(int) javassist.bytecode.Bytecode+growStack(int) javassist.bytecode.Bytecode+add(int) javassist.bytecode.Bytecode+add(int) javassist.bytecode.Bytecode+growStack(int) javassist.bytecode.Bytecode+growStack(int) javassist.bytecode.Bytecode+addIndex(int) javassist.bytecode.Bytecode+addIndex(int)",javassist.compiler.MemberCodeGen+resultStatic javassist.compiler.CodeGen+bytecode javassist.bytecode.Opcode+DUP javassist.compiler.CodeGen+exprType javassist.compiler.CodeGen+arrayDim javassist.compiler.CodeGen+className javassist.bytecode.Opcode+DUP2 javassist.bytecode.Opcode+DUP javassist.bytecode.Opcode+DUP2_X1 javassist.bytecode.Opcode+DUP_X1 javassist.compiler.CodeGen+bytecode javassist.compiler.CodeGen+bytecode javassist.bytecode.Opcode+PUTSTATIC javassist.compiler.CodeGen+bytecode javassist.compiler.CodeGen+bytecode javassist.bytecode.Opcode+PUTFIELD javassist.compiler.CodeGen+bytecode javassist.compiler.CodeGen+bytecode javassist.compiler.CodeGen+exprType javassist.compiler.CodeGen+arrayDim javassist.compiler.CodeGen+className,1141,40,4,,"protected void atFieldAssign(Expr expr, int op, ASTree left,
                        ASTree right, boolean doDup) throws CompileError
    {
        CtField f = fieldAccess(left);
        boolean is_static = resultStatic;
        if (op != '=' && !is_static)
            bytecode.addOpcode(DUP);

        int fi = atFieldRead(f, is_static, op == '=');
        int fType = exprType;
        int fDim = arrayDim;
        String cname = className;

        atAssignCore(expr, op, right, fType, fDim, cname);

        boolean is2w = is2word(fType, fDim);
        if (doDup) {
            int dup_code;
            if (is_static)
                dup_code = (is2w ? DUP2 : DUP);
            else
                dup_code = (is2w ? DUP2_X1 : DUP_X1);

            bytecode.addOpcode(dup_code);
        }

        if (is_static) {
            bytecode.add(PUTSTATIC);
            bytecode.growStack(is2w ? -2 : -1);
        }
        else {
            bytecode.add(PUTFIELD);
            bytecode.growStack(is2w ? -3 : -2);
        }

        bytecode.addIndex(fi);
        exprType = fType;
        arrayDim = fDim;
        className = cname;
    }",False,False,"The function of the method is to handle field assignments in a Java program. It takes in an expression, operator, left and right ASTree nodes, and a boolean flag. It performs various operations such as field access, adding opcodes to the bytecode, and updating the expression type, array dimension, and class name.",True,"The code defines a protected method called `atFieldAssign` that handles field assignments in a Java program. It takes in various parameters such as the expression, operator, left and right operands, and a boolean flag. The method performs operations such as field access, field read, assignment, and bytecode generation based on the provided inputs."
30,atMember(Member),at member mem ,Method,,,javassist.compiler.MemberCodeGen+atFieldRead(ASTree) javassist.compiler.MemberCodeGen+atFieldRead(ASTree),,86,3,1,,"public void atMember(Member mem) throws CompileError {
        atFieldRead(mem);
    }",False,False,"The function of the given method is to call the ""atFieldRead"" method with a parameter of type ""Member"" and throw a ""CompileError"" exception.",True,"The given code defines a method named ""atMember"" that takes a parameter of type ""Member"" and throws a ""CompileError"" exception. This method internally calls another method named ""atFieldRead"" with the same parameter."
31,atFieldRead(ASTree),at field read expr ,Method,atMember(Member),,"javassist.compiler.MemberCodeGen+fieldAccess(ASTree) javassist.compiler.MemberCodeGen+fieldAccess(ASTree) javassist.compiler.MemberCodeGen+atFieldRead(CtField,boolean,boolean) javassist.compiler.MemberCodeGen+atFieldRead(CtField,boolean,boolean)",javassist.compiler.MemberCodeGen+resultStatic,194,6,4,,"protected void atFieldRead(ASTree expr) throws CompileError
    {
        CtField f = fieldAccess(expr);
        boolean is_static = resultStatic;
        atFieldRead(f, is_static, false);
    }",False,False,"This method is used to handle the reading of a field in an abstract syntax tree. It retrieves the field from the expression, determines if it is static, and then performs the necessary actions for reading the field.",True,"The given code defines a protected method called ""atFieldRead"" that takes an ASTree object as a parameter. It retrieves a CtField object using the ""fieldAccess"" method and then calls another method ""atFieldRead"" with the retrieved field, a boolean value indicating if the field is static, and a false value indicating if the field is being read. The purpose and functionality of the method are not clear from the provided code snippet."
32,"atFieldRead(CtField,boolean,boolean)",at field read f is static no read ,Method,"atFieldAssign(Expr,int,ASTree,ASTree,boolean) atFieldRead(ASTree) atFieldPlusPlus(int,boolean,ASTree,Expr,boolean)",,"javassist.CtField+getFieldInfo2() javassist.CtField+getFieldInfo2() javassist.bytecode.FieldInfo+getDescriptor() javassist.bytecode.FieldInfo+getDescriptor() javassist.compiler.MemberCodeGen+addFieldrefInfo(CtField,FieldInfo,String) javassist.compiler.MemberCodeGen+addFieldrefInfo(CtField,FieldInfo,String) java.lang.String+charAt(int) java.lang.String+charAt(int) java.lang.String+charAt(int) java.lang.String+charAt(int) javassist.compiler.MemberCodeGen+descToType(char) javassist.compiler.MemberCodeGen+descToType(char) java.lang.String+substring(int,int) java.lang.String+substring(int,int) java.lang.String+indexOf(int,int) java.lang.String+indexOf(int,int) javassist.bytecode.Bytecode+add(int) javassist.bytecode.Bytecode+add(int) javassist.bytecode.Bytecode+growStack(int) javassist.bytecode.Bytecode+growStack(int) javassist.bytecode.Bytecode+add(int) javassist.bytecode.Bytecode+add(int) javassist.bytecode.Bytecode+growStack(int) javassist.bytecode.Bytecode+growStack(int) javassist.bytecode.Bytecode+addIndex(int) javassist.bytecode.Bytecode+addIndex(int)",javassist.compiler.CodeGen+arrayDim javassist.compiler.CodeGen+exprType javassist.compiler.CodeGen+className javassist.compiler.CodeGen+className javassist.compiler.CodeGen+bytecode javassist.bytecode.Opcode+GETSTATIC javassist.compiler.CodeGen+bytecode javassist.compiler.CodeGen+bytecode javassist.bytecode.Opcode+GETFIELD javassist.compiler.CodeGen+bytecode javassist.compiler.CodeGen+bytecode,987,40,2,,"private int atFieldRead(CtField f, boolean isStatic, boolean noRead)
        throws CompileError
    {
        FieldInfo finfo = f.getFieldInfo2();
        String type = finfo.getDescriptor();

        int fi = addFieldrefInfo(f, finfo, type);

        int i = 0;
        int dim = 0;
        char c = type.charAt(i);
        while (c == '[') {
            ++dim;
            c = type.charAt(++i);
        }

        arrayDim = dim;
        boolean is2byte = (c == 'J' || c == 'D');
        exprType = descToType(c);

        if (c == 'L')
            className = type.substring(i + 1, type.indexOf(';', i + 1));
        else
            className = null;

        if (noRead)
            return fi;

        if (isStatic) {
            bytecode.add(GETSTATIC);
            bytecode.growStack(is2byte ? 2 : 1);
        }
        else {
            bytecode.add(GETFIELD);
            bytecode.growStack(is2byte ? 1 : 0);
        }

        bytecode.addIndex(fi);
        return fi;
    }",False,False,"This method is used to read a field from a class. It takes in a CtField object, along with boolean values indicating whether the field is static and whether it should not be read. It returns the index of the field.",True,"This code is a private method that reads a field in a class. It determines the type and dimensions of the field, sets the appropriate variables, and adds bytecode instructions to get the value of the field. The method returns the field index."
33,"addFieldrefInfo(CtField,FieldInfo,String)",add fieldref info f finfo type ,Method,"atFieldRead(CtField,boolean,boolean)",,"javassist.bytecode.Bytecode+getConstPool() javassist.bytecode.Bytecode+getConstPool() javassist.CtClass+getName() javassist.CtField+getDeclaringClass() javassist.CtField+getDeclaringClass() javassist.CtClass+getName() javassist.bytecode.ConstPool+addClassInfo(String) javassist.bytecode.ConstPool+addClassInfo(String) javassist.bytecode.FieldInfo+getName() javassist.bytecode.FieldInfo+getName() javassist.bytecode.ConstPool+addFieldrefInfo(int,String,String) javassist.bytecode.ConstPool+addFieldrefInfo(int,String,String)",javassist.compiler.CodeGen+bytecode,313,7,4,,"protected int addFieldrefInfo(CtField f, FieldInfo finfo, String type) {
        ConstPool cp = bytecode.getConstPool();
        String cname = f.getDeclaringClass().getName();
        int ci = cp.addClassInfo(cname);
        String name = finfo.getName();
        return cp.addFieldrefInfo(ci, name, type);
    }",False,False,"The function of the given method is to add a field reference information to the constant pool of a bytecode. It takes a CtField object, a FieldInfo object, and a String type as parameters, and returns an integer value.",True,"The given code is a method named ""addFieldrefInfo"" that takes a CtField object, a FieldInfo object, and a String type as parameters. It retrieves the constant pool from the bytecode, adds the class information of the declaring class of the CtField object to the constant pool, retrieves the name of the FieldInfo object, and finally adds the field reference information to the constant pool using the class information, field name, and type."
34,"atFieldPlusPlus(int,boolean,ASTree,Expr,boolean)",at field plus plus token is post oprand expr do dup ,Method,,,"javassist.compiler.MemberCodeGen+fieldAccess(ASTree) javassist.compiler.MemberCodeGen+fieldAccess(ASTree) javassist.bytecode.Bytecode+addOpcode(int) javassist.bytecode.Bytecode+addOpcode(int) javassist.compiler.MemberCodeGen+atFieldRead(CtField,boolean,boolean) javassist.compiler.MemberCodeGen+atFieldRead(CtField,boolean,boolean) javassist.compiler.CodeGen+is2word(int,int) javassist.compiler.CodeGen+is2word(int,int) javassist.compiler.CodeGen+atPlusPlusCore(int,boolean,int,boolean,Expr) javassist.compiler.CodeGen+atPlusPlusCore(int,boolean,int,boolean,Expr) javassist.bytecode.Bytecode+add(int) javassist.bytecode.Bytecode+add(int) javassist.bytecode.Bytecode+growStack(int) javassist.bytecode.Bytecode+growStack(int) javassist.bytecode.Bytecode+add(int) javassist.bytecode.Bytecode+add(int) javassist.bytecode.Bytecode+growStack(int) javassist.bytecode.Bytecode+growStack(int) javassist.bytecode.Bytecode+addIndex(int) javassist.bytecode.Bytecode+addIndex(int)",javassist.compiler.MemberCodeGen+resultStatic javassist.compiler.CodeGen+bytecode javassist.bytecode.Opcode+DUP javassist.compiler.CodeGen+exprType javassist.compiler.CodeGen+arrayDim javassist.bytecode.Opcode+DUP2 javassist.bytecode.Opcode+DUP javassist.bytecode.Opcode+DUP2_X1 javassist.bytecode.Opcode+DUP_X1 javassist.compiler.CodeGen+bytecode javassist.bytecode.Opcode+PUTSTATIC javassist.compiler.CodeGen+bytecode javassist.compiler.CodeGen+bytecode javassist.bytecode.Opcode+PUTFIELD javassist.compiler.CodeGen+bytecode javassist.compiler.CodeGen+bytecode,918,32,4,,"protected void atFieldPlusPlus(int token, boolean isPost,
                                   ASTree oprand, Expr expr, boolean doDup)
        throws CompileError
    {
        CtField f = fieldAccess(oprand);
        boolean is_static = resultStatic;
        if (!is_static)
            bytecode.addOpcode(DUP);

        int fi = atFieldRead(f, is_static, false);
        int t = exprType;
        boolean is2w = is2word(t, arrayDim);

        int dup_code;
        if (is_static)
            dup_code = (is2w ? DUP2 : DUP);
        else
            dup_code = (is2w ? DUP2_X1 : DUP_X1);

        atPlusPlusCore(dup_code, doDup, token, isPost, expr);

        if (is_static) {
            bytecode.add(PUTSTATIC);
            bytecode.growStack(is2w ? -2 : -1);
        }
        else {
            bytecode.add(PUTFIELD);
            bytecode.growStack(is2w ? -3 : -2);
        }

        bytecode.addIndex(fi);
    }",False,False,"The function of the given method is to increment the value of a field in a class. It takes in parameters such as the token, whether it is a post-increment or pre-increment, the operand, the expression, and whether to duplicate the value. It then performs the necessary operations and updates the field value.",True,"This code defines a protected method called `atFieldPlusPlus` that is used to increment the value of a field in a Java class. The method takes in various parameters such as the token, whether it is a post-increment or pre-increment operation, the operand, and the expression. It performs the necessary bytecode operations to increment the field value and updates the stack accordingly."
35,fieldAccess(ASTree),field access expr ,Method,"atFieldAssign(Expr,int,ASTree,ASTree,boolean) atFieldRead(ASTree) atFieldPlusPlus(int,boolean,ASTree,Expr,boolean)",,"javassist.compiler.ast.Symbol+get() javassist.compiler.ast.Symbol+get() javassist.CtClass+getField(String) javassist.CtClass+getField(String) javassist.compiler.NoFieldException+NoFieldException(String,ASTree) javassist.Modifier+isStatic(int) javassist.Modifier+isStatic(int) javassist.CtField+getModifiers() javassist.CtField+getModifiers() javassist.compiler.CompileError+CompileError(String) javassist.bytecode.Bytecode+addAload(int) javassist.bytecode.Bytecode+addAload(int) javassist.compiler.ast.Expr+getOperator() javassist.compiler.ast.Expr+getOperator() javassist.compiler.MemberCodeGen+lookupJavaField(String,Symbol) javassist.compiler.MemberCodeGen+lookupJavaField(String,Symbol) javassist.compiler.ast.Symbol+get() javassist.compiler.ast.Expr+oprand1() javassist.compiler.ast.Expr+oprand1() javassist.compiler.ast.Symbol+get() javassist.compiler.ast.Expr+oprand2() javassist.compiler.ast.Expr+oprand2() javassist.compiler.ast.ASTree+accept(Visitor) javassist.compiler.ast.Expr+oprand1() javassist.compiler.ast.Expr+oprand1() javassist.compiler.ast.ASTree+accept(Visitor) javassist.compiler.MemberCodeGen+lookupJvmField(String,Symbol) javassist.compiler.MemberCodeGen+lookupJvmField(String,Symbol) javassist.compiler.ast.Expr+oprand2() javassist.compiler.ast.Expr+oprand2() javassist.compiler.MemberCodeGen+badLvalue() javassist.compiler.MemberCodeGen+badLvalue() javassist.Modifier+isStatic(int) javassist.Modifier+isStatic(int) javassist.CtField+getModifiers() javassist.CtField+getModifiers() javassist.bytecode.Bytecode+addOpcode(int) javassist.bytecode.Bytecode+addOpcode(int) javassist.compiler.NoFieldException+getExpr() javassist.compiler.NoFieldException+getExpr() javassist.compiler.ast.Expr+oprand1() javassist.compiler.ast.Expr+oprand1() javassist.compiler.ast.Expr+oprand2() javassist.compiler.ast.Expr+oprand2() javassist.compiler.MemberCodeGen+lookupJvmField(String,Symbol) javassist.compiler.MemberCodeGen+lookupJvmField(String,Symbol) javassist.compiler.NoFieldException+getField() javassist.compiler.NoFieldException+getField() javassist.compiler.NoFieldException+NoFieldException(String,ASTree) javassist.compiler.NoFieldException+getField() javassist.compiler.NoFieldException+getField() javassist.compiler.ast.Symbol+get() javassist.compiler.ast.Symbol+get() javassist.compiler.MemberCodeGen+badLvalue() javassist.compiler.MemberCodeGen+badLvalue() javassist.compiler.MemberCodeGen+badLvalue() javassist.compiler.MemberCodeGen+badLvalue()",javassist.compiler.MemberCodeGen+thisClass javassist.compiler.CodeGen+inStaticMethod javassist.compiler.CodeGen+bytecode javassist.compiler.TokenId+MEMBER javassist.compiler.CodeGen+exprType javassist.compiler.TokenId+CLASS javassist.compiler.CodeGen+arrayDim javassist.compiler.CodeGen+className javassist.compiler.CodeGen+bytecode javassist.bytecode.Opcode+POP javassist.compiler.MemberCodeGen+resultStatic,2461,67,4,,"protected CtField fieldAccess(ASTree expr) throws CompileError {
        CtField f = null;
        boolean is_static = false;
        if (expr instanceof Member) {
            String name = ((Member)expr).get();
            try {
                f = thisClass.getField(name);
            }
            catch (NotFoundException e) {
                // EXPR might be part of a static member access?
                throw new NoFieldException(name, expr);
            }

            is_static = Modifier.isStatic(f.getModifiers());
            if (!is_static)
                if (inStaticMethod)
                    throw new CompileError(
                                ""not available in a static method: "" + name);
                else
                    bytecode.addAload(0);       // this
        }
        else if (expr instanceof Expr) {
            Expr e = (Expr)expr;
            int op = e.getOperator();
            if (op == MEMBER) {
                f = lookupJavaField(((Symbol)e.oprand1()).get(),
                                    (Symbol)e.oprand2());
                is_static = true;
            }
            else if (op == '.') {
                try {
                    e.oprand1().accept(this);
                    if (exprType == CLASS && arrayDim == 0)
                        f = lookupJvmField(className, (Symbol)e.oprand2());
                    else
                        badLvalue();

                    is_static = Modifier.isStatic(f.getModifiers());
                    if (is_static)
                        bytecode.addOpcode(POP);
                }
                catch (NoFieldException nfe) {
                    if (nfe.getExpr() != e.oprand1())
                        throw nfe;

                    Symbol fname = (Symbol)e.oprand2();
                    // it should be a static field.
                    try {
                        f = lookupJvmField(nfe.getField(), fname);
                        is_static = true;
                    }
                    catch (CompileError ce) {
                        // EXPR might be part of a qualified class name.
                        throw new NoFieldException(nfe.getField() + ""/""
                                                   + fname.get(), expr);
                    }
                }
            }
            else
                badLvalue();
        }
        else
            badLvalue();

        resultStatic = is_static;
        return f;
    }",False,False,"This method serves to access a field in a class. It takes an ASTree expression as input and returns a CtField object representing the accessed field. It handles both static and non-static field access, and throws exceptions for invalid field access.",True,"This code defines a method called `fieldAccess` that takes an `ASTree` object as a parameter and returns a `CtField` object. The method checks the type of the `expr` object and performs different operations based on its type, such as looking up fields, checking modifiers, and adding bytecode instructions. It also handles exceptions and sets a boolean flag indicating whether the field is static or not."
36,badLvalue(),bad lvalue ,Method,fieldAccess(ASTree) fieldAccess(ASTree) fieldAccess(ASTree),,javassist.compiler.CompileError+CompileError(String),,106,3,10,,"private static void badLvalue() throws CompileError {
        throw new CompileError(""bad l-value"");
    }",False,False,"The function of the method is to throw a CompileError exception with the message ""bad l-value"".",True,"The code defines a private static method called ""badLvalue"" that throws a CompileError with the message ""bad l-value"". This method is likely used to handle cases where an invalid left-hand value is encountered during compilation."
37,makeParamList(MethodDecl),make param list md ,Method,,"javassist.compiler.Javac+compileMethod(Parser,MethodDecl)",javassist.compiler.ast.MethodDecl+getParams() javassist.compiler.ast.MethodDecl+getParams() javassist.compiler.ast.ASTList+length() javassist.compiler.ast.ASTList+length() javassist.compiler.MemberCodeGen+lookupClass(Declarator) javassist.compiler.MemberCodeGen+lookupClass(Declarator) javassist.compiler.ast.ASTList+head() javassist.compiler.ast.ASTList+head() javassist.compiler.ast.ASTList+tail() javassist.compiler.ast.ASTList+tail(),,482,16,1,,"public CtClass[] makeParamList(MethodDecl md) throws CompileError {
        CtClass[] params;
        ASTList plist = md.getParams();
        if (plist == null)
            params = new CtClass[0];
        else {
            int i = 0;
            params = new CtClass[plist.length()];
            while (plist != null) {
                params[i++] = lookupClass((Declarator)plist.head());
                plist = plist.tail();
            }
        }

        return params;
    }",False,False,"This method takes a MethodDecl object as input and returns an array of CtClass objects. It extracts the parameters from the MethodDecl object and assigns them to the CtClass array. If there are no parameters, it returns an empty array.",True,This code defines a method called `makeParamList` that takes a `MethodDecl` object as a parameter and returns an array of `CtClass` objects. It extracts the parameters from the `MethodDecl` object and assigns them to the `params` array by iterating over the `ASTList` of parameters.
38,makeThrowsList(MethodDecl),make throws list md ,Method,,"javassist.compiler.Javac+compileMethod(Parser,MethodDecl)",javassist.compiler.ast.MethodDecl+getThrows() javassist.compiler.ast.MethodDecl+getThrows() javassist.compiler.ast.ASTList+length() javassist.compiler.ast.ASTList+length() javassist.compiler.MemberCodeGen+lookupClass(ASTList) javassist.compiler.MemberCodeGen+lookupClass(ASTList) javassist.compiler.ast.ASTList+head() javassist.compiler.ast.ASTList+head() javassist.compiler.ast.ASTList+tail() javassist.compiler.ast.ASTList+tail(),,461,16,1,,"public CtClass[] makeThrowsList(MethodDecl md) throws CompileError {
        CtClass[] clist;
        ASTList list = md.getThrows();
        if (list == null)
            return null;
        else {
            int i = 0;
            clist = new CtClass[list.length()];
            while (list != null) {
                clist[i++] = lookupClass((ASTList)list.head());
                list = list.tail();
            }

            return clist;
        }
    }",False,False,"This method takes a MethodDecl object as input and returns an array of CtClass objects. It extracts the list of thrown exceptions from the MethodDecl object, creates a new array of CtClass objects, and populates it with the corresponding CtClass objects for each exception in the list.",True,"This code defines a method called ""makeThrowsList"" that takes a MethodDecl object as a parameter and returns an array of CtClass objects. It retrieves a list of exceptions thrown by the method, creates an array of CtClass objects based on the list, and returns the array. If the list is null, it returns null."
39,getModifiers(ASTList),get modifiers mods ,Method,,"javassist.compiler.Javac+compileField(FieldDecl) javassist.compiler.Javac+compileMethod(Parser,MethodDecl)",javassist.compiler.ast.ASTList+head() javassist.compiler.ast.ASTList+head() javassist.compiler.ast.ASTList+tail() javassist.compiler.ast.ASTList+tail() javassist.compiler.ast.Keyword+get() javassist.compiler.ast.Keyword+get(),javassist.compiler.TokenId+STATIC javassist.Modifier+STATIC javassist.compiler.TokenId+FINAL javassist.Modifier+FINAL javassist.compiler.TokenId+SYNCHRONIZED javassist.Modifier+SYNCHRONIZED javassist.compiler.TokenId+ABSTRACT javassist.Modifier+ABSTRACT javassist.compiler.TokenId+PUBLIC javassist.Modifier+PUBLIC javassist.compiler.TokenId+PROTECTED javassist.Modifier+PROTECTED javassist.compiler.TokenId+PRIVATE javassist.Modifier+PRIVATE javassist.compiler.TokenId+VOLATILE javassist.Modifier+VOLATILE javassist.compiler.TokenId+TRANSIENT javassist.Modifier+TRANSIENT javassist.compiler.TokenId+STRICT javassist.Modifier+STRICT,1156,41,9,,"public static int getModifiers(ASTList mods) {
        int m = 0;
        while (mods != null) {
            Keyword k = (Keyword)mods.head();
            mods = mods.tail();
            switch (k.get()) {
            case STATIC :
                m |= Modifier.STATIC;
                break;
            case FINAL :
                m |= Modifier.FINAL;
                break;
            case SYNCHRONIZED :
                m |= Modifier.SYNCHRONIZED;
                break;
            case ABSTRACT :
                m |= Modifier.ABSTRACT;
                break;
            case PUBLIC :
                m |= Modifier.PUBLIC;
                break;
            case PROTECTED :
                m |= Modifier.PROTECTED;
                break;
            case PRIVATE :
                m |= Modifier.PRIVATE;
                break;
            case VOLATILE :
                m |= Modifier.VOLATILE;
                break;
            case TRANSIENT :
                m |= Modifier.TRANSIENT;
                break;
            case STRICT :
                m |= Modifier.STRICT;
                break;
            }
        }

        return m;
    }",True,True,"This method takes an ASTList of modifiers and returns an integer representing the combined modifiers. It iterates through the list, converting each modifier keyword to its corresponding integer value and bitwise OR-ing it with the current value of m. Finally, it returns the resulting integer.",True,"This code defines a method called ""getModifiers"" that takes an ASTList as input and returns an integer representing the modifiers of a class or method. It iterates through the list of modifiers, converts them to their corresponding Modifier constants, and combines them using bitwise OR operations."
40,resolveClassName(ASTList),resolve class name name ,Method,"atNewArrayExpr(NewExpr) atMultiNewArray(int,ASTList,ASTList)",,javassist.compiler.MemberCodeGen+javaToJvmName(String) javassist.compiler.MemberCodeGen+javaToJvmName(String) javassist.CtClass+getName() javassist.compiler.MemberCodeGen+lookupClass(ASTList) javassist.compiler.MemberCodeGen+lookupClass(ASTList) javassist.CtClass+getName(),,202,6,4,,"protected String resolveClassName(ASTList name) throws CompileError {
        if (name == null)
            return null;
        else
            return javaToJvmName(lookupClass(name).getName());
    }",False,False,"The function of this method is to resolve the class name by converting it from Java to JVM format, using the lookupClass method to find the class name from the ASTList input.",True,"The given code is a protected method named ""resolveClassName"" that takes an ASTList object as a parameter. It checks if the name is null and returns null if true, otherwise it returns the JVM name of the class obtained by looking up the class name using the ""lookupClass"" method. It throws a CompileError exception."
41,resolveClassName(String),resolve class name jvm name ,Method,,,javassist.compiler.MemberCodeGen+javaToJvmName(String) javassist.compiler.MemberCodeGen+javaToJvmName(String) javassist.CtClass+getName() javassist.compiler.MemberCodeGen+lookupJvmClass(String) javassist.compiler.MemberCodeGen+lookupJvmClass(String) javassist.CtClass+getName(),,213,6,4,,"protected String resolveClassName(String jvmName) throws CompileError {
        if (jvmName == null)
            return null;
        else
            return javaToJvmName(lookupJvmClass(jvmName).getName());
    }",False,False,This method resolves the class name from a given JVM name by looking up the JVM class and converting it to a Java class name. It returns the resolved class name or null if the JVM name is null.,True,"The given code is a protected method named ""resolveClassName"" that takes a String parameter ""jvmName"" and returns a String. It checks if the input is null and returns null if true, otherwise it looks up the JVM class using the input and returns the corresponding Java class name. It throws a CompileError if any exception occurs during the process."
42,lookupClass(Declarator),lookup class decl ,Method,makeParamList(MethodDecl),"javassist.compiler.Javac+compileField(FieldDecl) javassist.compiler.Javac+compileMethod(Parser,MethodDecl)","javassist.compiler.MemberCodeGen+lookupClass(int,int,String) javassist.compiler.MemberCodeGen+lookupClass(int,int,String) javassist.compiler.ast.Declarator+getType() javassist.compiler.ast.Declarator+getType() javassist.compiler.ast.Declarator+getArrayDim() javassist.compiler.ast.Declarator+getArrayDim() javassist.compiler.ast.Declarator+getClassName() javassist.compiler.ast.Declarator+getClassName()",,186,4,4,,"protected CtClass lookupClass(Declarator decl) throws CompileError {
        return lookupClass(decl.getType(), decl.getArrayDim(),
                           decl.getClassName());
    }",True,True,"The function of the method ""lookupClass"" is to search for a class based on the information provided by the ""decl"" parameter, which includes the type, array dimension, and class name. It returns the found class as a CtClass object.",True,"The code defines a protected method called ""lookupClass"" that takes a ""Declarator"" object as a parameter. It returns a ""CtClass"" object by calling another overloaded version of the ""lookupClass"" method with the type, array dimension, and class name obtained from the ""Declarator"" object. The method throws a ""CompileError"" exception."
43,"lookupClass(int,int,String)",lookup class type dim classname ,Method,lookupClass(Declarator),javassist.compiler.JvstCodeGen+atCastToWrapper(CastExpr),javassist.compiler.MemberCodeGen+lookupJvmClass(String) javassist.compiler.MemberCodeGen+lookupJvmClass(String) javassist.CtClass+getName() javassist.CtClass+getName() javassist.compiler.CodeGen+fatal() javassist.compiler.CodeGen+fatal() javassist.compiler.MemberCodeGen+lookupJavaClass(String) javassist.compiler.MemberCodeGen+lookupJavaClass(String),javassist.compiler.TokenId+CLASS javassist.compiler.TokenId+BOOLEAN javassist.compiler.TokenId+CHAR javassist.compiler.TokenId+BYTE javassist.compiler.TokenId+SHORT javassist.compiler.TokenId+INT javassist.compiler.TokenId+LONG javassist.compiler.TokenId+FLOAT javassist.compiler.TokenId+DOUBLE javassist.compiler.TokenId+VOID,1139,50,4,,"protected CtClass lookupClass(int type, int dim, String classname)
        throws CompileError
    {
        String cname = """";
        CtClass clazz;
        switch (type) {
        case CLASS :
            clazz = lookupJvmClass(classname);
            if (dim > 0)
                cname = clazz.getName();
            else
                return clazz;

            break;
        case BOOLEAN :
            cname = ""boolean"";
            break;
        case CHAR :
            cname = ""char"";
            break;
        case BYTE :
            cname = ""byte"";
            break;
        case SHORT :
            cname = ""short"";
            break;
        case INT :
            cname = ""int"";
            break;
        case LONG :
            cname = ""long"";
            break;
        case FLOAT :
            cname = ""float"";
            break;
        case DOUBLE :
            cname = ""double"";
            break;
        case VOID :
            cname = ""void"";
            break;
        default :
            fatal();
        }

        while (dim-- > 0)
            cname += ""[]"";

        return lookupJavaClass(cname);
    }",True,True,"This method is used to lookup and return a CtClass object based on the given type, dimension, and classname. It handles different cases for primitive types and arrays, and throws a CompileError if the type is not recognized.",True,"This code defines a protected method called `lookupClass` that takes in three parameters: `type`, `dim`, and `classname`. It performs a switch case on the `type` parameter and based on the value, it constructs a class name string. It then appends square brackets to the class name based on the value of `dim` and returns the result of calling `lookupJavaClass` with the constructed class name."
44,lookupClass(ASTList),lookup class name ,Method,atNewExpr(NewExpr) makeThrowsList(MethodDecl) resolveClassName(ASTList),,"javassist.compiler.MemberCodeGen+lookupJavaClass(String) javassist.compiler.MemberCodeGen+lookupJavaClass(String) javassist.compiler.ast.Declarator+astToClassName(ASTList,char) javassist.compiler.ast.Declarator+astToClassName(ASTList,char)",,141,3,4,,"protected CtClass lookupClass(ASTList name) throws CompileError {
        return lookupJavaClass(Declarator.astToClassName(name, '.'));
    }",True,True,The function of the given method is to lookup and return a CtClass object by converting the given ASTList name into a Java class name and then using it to lookup the corresponding Java class.,True,"The given code snippet defines a protected method named `lookupClass` that takes an `ASTList` parameter named `name`. This method converts the `name` parameter into a class name using the `astToClassName` method and then calls the `lookupJavaClass` method to retrieve the corresponding `CtClass` object, which is then returned."
45,lookupJvmClass(String),lookup jvm class jvm name ,Method,"atTryStmnt(Stmnt) atMethodCall(Expr) compareSignature(String,int[],int[],String[]) compareSignature(String,int[],int[],String[]) resolveClassName(String) lookupClass(int,int,String)",,javassist.compiler.MemberCodeGen+lookupJavaClass(String) javassist.compiler.MemberCodeGen+lookupJavaClass(String) javassist.compiler.MemberCodeGen+jvmToJavaName(String) javassist.compiler.MemberCodeGen+jvmToJavaName(String),,132,3,4,,"protected CtClass lookupJvmClass(String jvmName) throws CompileError {
        return lookupJavaClass(jvmToJavaName(jvmName));
    }",False,True,"The method ""lookupJvmClass"" takes a JVM class name as input, converts it to a Java class name, and then looks up the corresponding Java class. It returns the found Java class as a CtClass object.",True,"The given code snippet defines a protected method named `lookupJvmClass` that takes a `String` parameter `jvmName`. This method converts the `jvmName` to a Java class name using the `jvmToJavaName` method and then calls the `lookupJavaClass` method with the converted name as an argument, returning the result."
46,lookupJavaClass(String),lookup java class name param name a qualified class name e g java lang string ,Method,"atMethodCall(Expr) atMethodCall(Expr) lookupClass(int,int,String) lookupClass(ASTList) lookupJvmClass(String) lookupJavaField(String,Symbol)",,javassist.ClassPool+get(String) javassist.ClassPool+get(String) java.lang.String+indexOf(int) java.lang.String+indexOf(int) javassist.ClassPool+get(String) javassist.ClassPool+get(String) javassist.compiler.CompileError+CompileError(String),javassist.compiler.MemberCodeGen+classPool javassist.compiler.MemberCodeGen+classPool,482,17,2,"/** 
 * @param name      a qualified class name. e.g. java.lang.String
 */
","/**
     * @param name      a qualified class name. e.g. java.lang.String
     */
    private CtClass lookupJavaClass(String name) throws CompileError {
        try {
            return classPool.get(name);
        }
        catch (NotFoundException e) {}

        try {
            if (name.indexOf('.') < 0)
                return classPool.get(""java.lang."" + name);
        }
        catch (NotFoundException e) {}

        throw new CompileError(""no such class: "" + name);
    }",True,True,"This method looks up a Java class based on its qualified class name. It first tries to get the class from the class pool. If not found, it checks if the class name is missing the package and tries to get the class from the ""java.lang"" package. If still not found, it throws a CompileError.",True,"The given code is a private method named `lookupJavaClass` that takes a qualified class name as a parameter and returns a `CtClass` object. It tries to retrieve the class using the `classPool.get()` method, first with the given name and then with the name prefixed by ""java.lang."" if no package is specified. If the class is not found in either case, it throws a `CompileError` with an appropriate message."
47,"lookupField(ASTList,Symbol)",lookup field class name field name ,Method,,,"javassist.compiler.MemberCodeGen+lookupJavaField(String,Symbol) javassist.compiler.MemberCodeGen+lookupJavaField(String,Symbol) javassist.compiler.ast.Declarator+astToClassName(ASTList,char) javassist.compiler.ast.Declarator+astToClassName(ASTList,char)",,217,6,1,,"public CtField lookupField(ASTList className, Symbol fieldName)
        throws CompileError
    {
        return lookupJavaField(Declarator.astToClassName(className, '.'),
                            fieldName);
    }",True,True,"The method ""lookupField"" takes an ASTList className and a Symbol fieldName as parameters, and returns a CtField object. It calls the method ""lookupJavaField"" with the converted className and fieldName as arguments.",True,"The given code defines a method named ""lookupField"" that takes an ASTList object and a Symbol object as parameters. It throws a CompileError exception. The method returns a CtField object by calling the ""lookupJavaField"" method with the converted class name and field name as arguments."
48,"lookupJvmField(String,Symbol)",lookup jvm field class name field name ,Method,fieldAccess(ASTree) fieldAccess(ASTree),,"javassist.compiler.MemberCodeGen+lookupJavaField(String,Symbol) javassist.compiler.MemberCodeGen+lookupJavaField(String,Symbol) javassist.compiler.MemberCodeGen+jvmToJavaName(String) javassist.compiler.MemberCodeGen+jvmToJavaName(String)",,174,5,1,,"public CtField lookupJvmField(String className, Symbol fieldName)
        throws CompileError
    {
        return lookupJavaField(jvmToJavaName(className), fieldName);
    }",False,True,"The method ""lookupJvmField"" takes a class name and a field name as parameters, and returns a CtField object. It calls the ""lookupJavaField"" method with the converted class name and the field name as arguments.",True,"The given code defines a method named `lookupJvmField` that takes a class name and a symbol as parameters and returns a `CtField` object. It internally calls another method `lookupJavaField` by converting the class name to a Java name and passing the symbol as an argument. If an exception of type `CompileError` occurs, it is thrown."
49,"lookupJavaField(String,Symbol)",lookup java field class name field name param name a qualified class name e g java lang string ,Method,"fieldAccess(ASTree) lookupField(ASTList,Symbol) lookupJvmField(String,Symbol)",,javassist.compiler.MemberCodeGen+lookupJavaClass(String) javassist.compiler.MemberCodeGen+lookupJavaClass(String) javassist.CtClass+getField(String) javassist.CtClass+getField(String) javassist.compiler.ast.Symbol+get() javassist.compiler.ast.Symbol+get() javassist.compiler.CompileError+CompileError(String) javassist.compiler.ast.Symbol+get() javassist.compiler.ast.Symbol+get(),,423,13,2,"/** 
 * @param name      a qualified class name. e.g. java.lang.String
 */
","/**
     * @param name      a qualified class name. e.g. java.lang.String
     */
    private CtField lookupJavaField(String className, Symbol fieldName)
        throws CompileError
    {
        CtClass cc = lookupJavaClass(className);
        try {
            return cc.getField(fieldName.get());
        }
        catch (NotFoundException e) {}
        throw new CompileError(""no such field: "" + fieldName.get());
    }",True,True,"This method looks up a Java field by its name in a specified class. It returns the corresponding CtField object if found, otherwise it throws a CompileError exception.",False,"The given code is a private method named ""lookupJavaField"" that takes a qualified class name and a symbol representing a field name as parameters. It tries to find and return the field with the given name in the specified class. If the field is not found, it throws a CompileError exception."
50,javaToJvmName(String),java to jvm name classname ,Method,getThisName() getSuperName() atTryStmnt(Stmnt) atNewExpr(NewExpr) resolveClassName(ASTList) resolveClassName(String),"javassist.compiler.JvstCodeGen+recordParams(CtClass[],boolean,String,String,String,boolean,int,String,SymbolTable) javassist.compiler.JvstCodeGen+setType(CtClass,int)","java.lang.String+replace(char,char) java.lang.String+replace(char,char)",,107,3,12,,"protected static String javaToJvmName(String classname) {
        return classname.replace('.', '/');
    }",True,True,This method converts a Java class name to its corresponding JVM name by replacing the dots with slashes.,True,"The given code is a method named ""javaToJvmName"" that takes a string parameter ""classname"" and returns a modified version of the classname by replacing all occurrences of '.' with '/'. It is a utility method used to convert a Java class name to its corresponding JVM (Java Virtual Machine) name."
51,jvmToJavaName(String),jvm to java name classname ,Method,"atNewArrayExpr(NewExpr) lookupJvmClass(String) lookupJvmField(String,Symbol)","javassist.compiler.JvstCodeGen+recordParams(CtClass[],boolean,String,String,String,boolean,int,String,SymbolTable)","java.lang.String+replace(char,char) java.lang.String+replace(char,char)",,107,3,12,,"protected static String jvmToJavaName(String classname) {
        return classname.replace('/', '.');
    }",True,True,This method converts a JVM-style class name to a Java-style class name by replacing forward slashes with dots.,True,"The given code is a method named ""jvmToJavaName"" that takes a string parameter ""classname"" representing a JVM (Java Virtual Machine) class name. It replaces all occurrences of '/' with '.' and returns the modified string, effectively converting the JVM class name to a Java class name."
