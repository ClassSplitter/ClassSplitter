index,name,type,inner invocations,external invocations,calls,visits,length,lines,modifier,annotation,full text,removed
1,logger,Field,,,,,126,5,26,"/** 
 * Our class logger.
 */
","/**
     * Our class logger.
     */
    private static final Logger logger
        = Logger.getLogger(CallPeerSipImpl.class);",False
2,peerAddress,Field,"CallPeerSipImpl(Address,CallSipImpl,Transaction,SipProvider) setDisplayName(String)",,,,87,4,2,"/** 
 * The sip address of this peer
 */
","/**
     * The sip address of this peer
     */
    private Address peerAddress = null;",False
3,image,Field,setImage(byte[]),,,,112,4,2,"/** 
 * A byte array containing the image/photo representing the call peer.
 */
","/**
     * A byte array containing the image/photo representing the call peer.
     */
    private byte[] image;",True
4,peerID,Field,"CallPeerSipImpl(Address,CallSipImpl,Transaction,SipProvider) setPeerID(String)",,,,85,4,2,"/** 
 * A string uniquely identifying the peer.
 */
","/**
     * A string uniquely identifying the peer.
     */
    private String peerID;",True
5,call,Field,"CallPeerSipImpl(Address,CallSipImpl,Transaction,SipProvider) setCall(CallSipImpl)",,,,79,4,2,"/** 
 * The call this peer belongs to.
 */
","/**
     * The call this peer belongs to.
     */
    private CallSipImpl call;",False
6,jainSipDialog,Field,setDialog(Dialog),,,,166,5,2,"/** 
 * The JAIN SIP dialog that has been created by the application for communication with this call peer.
 */
","/**
     * The JAIN SIP dialog that has been created by the application for
     * communication with this call peer.
     */
    private Dialog jainSipDialog = null;",False
7,latestInviteTransaction,Field,setLatestInviteTransaction(Transaction),,,,239,6,2,"/** 
 * The SIP transaction that established this call. This was previously kept in the jain-sip dialog but got deprecated there so we're now keeping it here.
 */
","/**
     * The SIP transaction that established this call. This was previously kept
     * in the jain-sip dialog but got deprecated there so we're now keeping it
     * here.
     */
    private Transaction latestInviteTransaction = null;",False
8,jainSipProvider,Field,setJainSipProvider(SipProvider),,,,200,5,2,"/** 
 * The jain sip provider instance that is responsible for sending and receiving requests and responses related to this call peer.
 */
","/**
     * The jain sip provider instance that is responsible for sending and
     * receiving requests and responses related to this call peer.
     */
    private SipProvider jainSipProvider = null;",False
9,transportAddress,Field,setTransportAddress(InetSocketAddress) setTransportAddress(InetSocketAddress),,,,257,6,2,"/** 
 * The transport address that we are using to address the peer or the first one that we'll try when we next send them a message (could be the address of our sip registrar).
 */
","/**
     * The transport address that we are using to address the peer or the
     * first one that we'll try when we next send them a message (could be the
     * address of our sip registrar).
     */
    private InetSocketAddress transportAddress = null;",False
10,mediaHandler,Field,"CallPeerSipImpl(Address,CallSipImpl,Transaction,SipProvider)",,,,451,8,18,"/** 
 * The media handler class handles all media management for a single <tt>CallPeer</tt>. This includes initializing and configuring streams, generating SDP, handling ICE, etc. One instance of <tt>CallPeer</tt>always corresponds to exactly one instance of <tt>CallPeerMediaHandler</tt> and both classes are only separated for reasons of readability.
 */
","/**
     * The media handler class handles all media management for a single
     * <tt>CallPeer</tt>. This includes initializing and configuring streams,
     * generating SDP, handling ICE, etc. One instance of <tt>CallPeer</tt>always
     * corresponds to exactly one instance of <tt>CallPeerMediaHandler</tt> and
     * both classes are only separated for reasons of readability.
     */
    private final CallPeerMediaHandlerSipImpl mediaHandler;",True
11,mediaHandlerPropertyChangeListener,Field,,,,,216,5,2,"/** 
 * The <tt>PropertyChangeListener</tt> which listens to {@link #mediaHandler} for changes in the values of its properties.
 */
","/**
     * The <tt>PropertyChangeListener</tt> which listens to
     * {@link #mediaHandler} for changes in the values of its properties.
     */
    private PropertyChangeListener mediaHandlerPropertyChangeListener;",True
12,messageFactory,Field,"CallPeerSipImpl(Address,CallSipImpl,Transaction,SipProvider)",,,,175,5,18,"/** 
 * A reference to the <tt>SipMessageFactory</tt> instance that we should use when creating requests.
 */
","/**
     * A reference to the <tt>SipMessageFactory</tt> instance that we should
     * use when creating requests.
     */
    private final SipMessageFactory messageFactory;",False
13,methodProcessorListeners,Field,,,,,272,6,18,"/** 
 * The <tt>List</tt> of <tt>MethodProcessorListener</tt>s interested in how this <tt>CallPeer</tt> processes SIP signaling.
 */
","/**
     * The <tt>List</tt> of <tt>MethodProcessorListener</tt>s interested in how
     * this <tt>CallPeer</tt> processes SIP signaling.
     */
    private final List<MethodProcessorListener> methodProcessorListeners
        = new LinkedList<MethodProcessorListener>();",False
14,videoPropertyChangeListeners,Field,,,,,316,7,18,"/** 
 * The <tt>List</tt> of <tt>PropertyChangeListener</tt>s listening to this <tt>CallPeer</tt> for changes in the values of its properties related to video.
 */
","/**
     * The <tt>List</tt> of <tt>PropertyChangeListener</tt>s listening to this
     * <tt>CallPeer</tt> for changes in the values of its properties related to
     * video.
     */
    private final List<PropertyChangeListener> videoPropertyChangeListeners
            = new LinkedList<PropertyChangeListener>();",True
15,streamAudioLevelListeners,Field,,,,,243,6,18,"/** 
 * Holds listeners registered for level changes in the audio we are getting from the remote participant.
 */
","/**
     * Holds listeners registered for level changes in the audio we are getting
     * from the remote participant.
     */
    private final List<SoundLevelListener> streamAudioLevelListeners
        = new ArrayList<SoundLevelListener>();",True
16,conferenceMemberAudioLevelListeners,Field,,,,,358,8,18,"/** 
 * Holds listeners registered for level changes in the audio of participants that this peer might be mixing and that we are not directly communicating with.
 */
","/**
     * Holds listeners registered for level changes in the audio of participants
     * that this peer might be mixing and that we are not directly communicating
     * with.
     */
    private final List<ConferenceMembersSoundLevelListener>
        conferenceMemberAudioLevelListeners
            = new ArrayList<ConferenceMembersSoundLevelListener>();",True
17,"CallPeerSipImpl(Address,CallSipImpl,Transaction,SipProvider)",Method,,,net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl+getMessageFactory() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getProtocolProvider() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getProtocolProvider() net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl+getMessageFactory() net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl+CallPeerMediaHandlerSipImpl(CallPeerSipImpl) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+setDialog(Dialog) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+setDialog(Dialog) javax.sip.Transaction+getDialog() javax.sip.Transaction+getDialog() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+setLatestInviteTransaction(Transaction) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+setLatestInviteTransaction(Transaction) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+setJainSipProvider(SipProvider) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+setJainSipProvider(SipProvider) java.lang.String+valueOf(long) java.lang.String+valueOf(long) java.lang.System+currentTimeMillis() java.lang.System+currentTimeMillis() java.lang.String+valueOf(int) java.lang.String+valueOf(int) java.lang.Object+hashCode() java.lang.Object+hashCode() net.java.sip.communicator.service.protocol.AbstractCallPeer+addCallPeerConferenceListener(CallPeerConferenceListener),net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+peerAddress net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+peerAddress net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+call net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+call net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+messageFactory net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+messageFactory net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+mediaHandler net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+mediaHandler net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+peerID net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+peerID,1351,32,1,"/** 
 * Creates a new call peer with address <tt>peerAddress</tt>.
 * @param peerAddress the JAIN SIP <tt>Address</tt> of the new call peer.
 * @param owningCall the call that contains this call peer.
 * @param containingTransaction the transaction that created the call peer.
 * @param sourceProvider the provider that the containingTransaction belongsto.
 */
","/**
     * Creates a new call peer with address <tt>peerAddress</tt>.
     *
     * @param peerAddress the JAIN SIP <tt>Address</tt> of the new call peer.
     * @param owningCall the call that contains this call peer.
     * @param containingTransaction the transaction that created the call peer.
     * @param sourceProvider the provider that the containingTransaction belongs
     * to.
     */
    public CallPeerSipImpl(Address     peerAddress,
                           CallSipImpl owningCall,
                           Transaction containingTransaction,
                           SipProvider sourceProvider)
    {
        this.peerAddress = peerAddress;
        this.call = owningCall;
        this.messageFactory = getProtocolProvider().getMessageFactory();

        this.mediaHandler = new CallPeerMediaHandlerSipImpl(this);

        setDialog(containingTransaction.getDialog());
        setLatestInviteTransaction(containingTransaction);
        setJainSipProvider(sourceProvider);

        //create the uid
        this.peerID = String.valueOf(System.currentTimeMillis())
                             + String.valueOf(hashCode());

        // we listen fr events when the call will become focus or not
        // of a conference so we will add or remove our sound level listeners
        super.addCallPeerConferenceListener(this);
    }",False
18,getAddress(),Method,"getContact() processAck(ServerTransaction,Request) processSessionProgress(ClientTransaction,Response) processInviteOK(ClientTransaction,Response)","net.java.sip.communicator.impl.protocol.sip.OperationSetTelephonyConferencingSipImpl+getUserXML(CallPeerSipImpl,StringBuffer)",javax.sip.address.URI+toString() javax.sip.address.Address+getURI() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getPeerAddress() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getPeerAddress() javax.sip.address.Address+getURI() javax.sip.address.URI+toString(),,217,9,1,"/** 
 * Returns a String locator for that peer.
 * @return the peer's address or phone number.
 */
","/**
     * Returns a String locator for that peer.
     *
     * @return the peer's address or phone number.
     */
    public String getAddress()
    {
        return this.getPeerAddress().getURI().toString();
    }",False
19,getPeerAddress(),Method,getAddress() getDisplayName() getDisplayName(),"net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl+getIntendedDestination(CallPeerSipImpl) net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl+transfer(CallPeer,Address) net.java.sip.communicator.impl.protocol.sip.OperationSetTelephonyConferencingSipImpl+ConferenceSubscriberSubscription.ConferenceSubscriberSubscription(CallPeerSipImpl)",net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getDialog() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getDialog() javax.sip.Dialog+getRemoteParty() javax.sip.Dialog+getRemoteParty(),net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+peerAddress net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+peerAddress,647,23,1,"/** 
 * Returns the address of the remote party (making sure that it corresponds to the latest address we've received) and caches it.
 * @return the most recent <tt>javax.sip.address.Address</tt> that we havefor the remote party.
 */
","/**
     * Returns the address of the remote party (making sure that it corresponds
     * to the latest address we've received) and caches it.
     *
     * @return the most recent <tt>javax.sip.address.Address</tt> that we have
     * for the remote party.
     */
    public Address getPeerAddress()
    {
        Dialog dialog = getDialog();

        if (dialog != null)
        {
            Address remoteParty = dialog.getRemoteParty();

            if (remoteParty != null)
            {
                //update the address we've cached.
                peerAddress = remoteParty;
            }
        }
        return peerAddress;
    }",False
20,getDisplayName(),Method,"setDisplayName(String) processAck(ServerTransaction,Request) processSessionProgress(ClientTransaction,Response) processInviteOK(ClientTransaction,Response)","net.java.sip.communicator.impl.protocol.sip.OperationSetTelephonyConferencingSipImpl+getUserXML(CallPeerSipImpl,StringBuffer)",javax.sip.address.Address+getDisplayName() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getPeerAddress() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getPeerAddress() javax.sip.address.Address+getDisplayName() javax.sip.address.URI+toString() javax.sip.address.Address+getURI() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getPeerAddress() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getPeerAddress() javax.sip.address.Address+getURI() javax.sip.address.URI+toString(),,378,12,1,"/** 
 * Returns a human readable name representing this peer.
 * @return a String containing a name for that peer.
 */
","/**
     * Returns a human readable name representing this peer.
     *
     * @return a String containing a name for that peer.
     */
    public String getDisplayName()
    {
        String displayName = getPeerAddress().getDisplayName();
        return (displayName == null)
                    ? getPeerAddress().getURI().toString()
                    : displayName;
    }",False
21,setDisplayName(String),Method,,"net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl+processRinging(ClientTransaction,Response)","net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getDisplayName() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getDisplayName() javax.sip.address.Address+setDisplayName(String) javax.sip.address.Address+setDisplayName(String) net.java.sip.communicator.util.Logger+error(Object,Throwable) net.java.sip.communicator.util.Logger+error(Object,Throwable) java.lang.Throwable+getMessage() java.lang.Throwable+getMessage() java.lang.IllegalArgumentException+IllegalArgumentException(String) java.lang.Throwable+getMessage() java.lang.Throwable+getMessage() net.java.sip.communicator.service.protocol.AbstractCallPeer+fireCallPeerChangeEvent(String,Object,Object) net.java.sip.communicator.service.protocol.AbstractCallPeer+fireCallPeerChangeEvent(String,Object,Object)",net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+peerAddress net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+peerAddress net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger net.java.sip.communicator.service.protocol.event.CallPeerChangeEvent+CALL_PEER_DISPLAY_NAME_CHANGE,702,25,4,"/** 
 * Sets a human readable name representing this peer.
 * @param displayName the peer's display name
 */
","/**
     * Sets a human readable name representing this peer.
     *
     * @param displayName the peer's display name
     */
    protected void setDisplayName(String displayName)
    {
        String oldName = getDisplayName();
        try
        {
            this.peerAddress.setDisplayName(displayName);
        }
        catch (ParseException ex)
        {
            //couldn't happen
            logger.error(ex.getMessage(), ex);
            throw new IllegalArgumentException(ex.getMessage());
        }

        //Fire the Event
        fireCallPeerChangeEvent(
                CallPeerChangeEvent.CALL_PEER_DISPLAY_NAME_CHANGE,
                oldName,
                displayName);
    }",False
22,getImage(),Method,setImage(byte[]),,,net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+image,273,11,1,"/** 
 * The method returns an image representation of the call peer if one is available.
 * @return byte[] a byte array containing the image or null if no image isavailable.
 */
","/**
     * The method returns an image representation of the call peer if one is
     * available.
     *
     * @return byte[] a byte array containing the image or null if no image is
     * available.
     */
    public byte[] getImage()
    {
        return image;
    }",True
23,setImage(byte[]),Method,,,"net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getImage() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getImage() net.java.sip.communicator.service.protocol.AbstractCallPeer+fireCallPeerChangeEvent(String,Object,Object) net.java.sip.communicator.service.protocol.AbstractCallPeer+fireCallPeerChangeEvent(String,Object,Object)",net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+image net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+image net.java.sip.communicator.service.protocol.event.CallPeerChangeEvent+CALL_PEER_IMAGE_CHANGE,467,17,4,"/** 
 * Sets the byte array containing an image representation (photo or picture) of the call peer.
 * @param image a byte array containing the image
 */
","/**
     * Sets the byte array containing an image representation (photo or picture)
     * of the call peer.
     *
     * @param image a byte array containing the image
     */
    protected void setImage(byte[] image)
    {
        byte[] oldImage = getImage();
        this.image = image;

        //Fire the Event
        fireCallPeerChangeEvent(
                CallPeerChangeEvent.CALL_PEER_IMAGE_CHANGE,
                oldImage,
                image);
    }",True
24,getPeerID(),Method,,,,net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+peerID,200,9,1,"/** 
 * Returns a unique identifier representing this peer.
 * @return an identifier representing this call peer.
 */
","/**
     * Returns a unique identifier representing this peer.
     *
     * @return an identifier representing this call peer.
     */
    public String getPeerID()
    {
        return peerID;
    }",True
25,setPeerID(String),Method,,,,net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+peerID net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+peerID,227,9,4,"/** 
 * Sets the String that serves as a unique identifier of this CallPeer.
 * @param peerID the ID of this call peer.
 */
","/**
     * Sets the String that serves as a unique identifier of this
     * CallPeer.
     * @param peerID the ID of this call peer.
     */
    protected void setPeerID(String peerID)
    {
        this.peerID = peerID;
    }",True
26,getCall(),Method,"getProtocolProvider() processAck(ServerTransaction,Request) processAck(ServerTransaction,Request) processInviteOK(ClientTransaction,Response) processInviteOK(ClientTransaction,Response) reflectConferenceFocus(javax.sip.message.Message) securityTurnedOff(int)","net.java.sip.communicator.impl.protocol.sip.ActiveCallsRepositorySipImpl+findCall(String,String,String) net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl+getDefaultDevice(MediaType) net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl+createMediaDescriptions() net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl+processInvite(SipProvider,ServerTransaction) net.java.sip.communicator.impl.protocol.sip.OperationSetTelephonyConferencingSipImpl+getConferenceInfoXML(CallPeerSipImpl,int) net.java.sip.communicator.impl.protocol.sip.OperationSetTelephonyConferencingSipImpl+propertyChange(PropertyChangeEvent) net.java.sip.communicator.impl.protocol.sip.OperationSetTelephonyConferencingSipImpl+ConferenceNotifierSubscription.getCall() net.java.sip.communicator.impl.protocol.sip.OperationSetVideoTelephonySipImpl+answerVideoCallPeer(CallPeer)",,net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+call,286,10,1,"/** 
 * Returns a reference to the call that this peer belongs to. Calls are created by underlying telephony protocol implementations.
 * @return a reference to the call containing this peer.
 */
","/**
     * Returns a reference to the call that this peer belongs to. Calls
     * are created by underlying telephony protocol implementations.
     *
     * @return a reference to the call containing this peer.
     */
    public CallSipImpl getCall()
    {
        return call;
    }",True
27,setCall(CallSipImpl),Method,,,,net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+call net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+call,214,9,4,"/** 
 * Sets the call containing this peer.
 * @param call the call that this call peer ispartdicipating in.
 */
","/**
     * Sets the call containing this peer.
     * @param call the call that this call peer is
     * partdicipating in.
     */
    protected void setCall(CallSipImpl call)
    {
        this.call = call;
    }",True
28,setDialog(Dialog),Method,"CallPeerSipImpl(Address,CallSipImpl,Transaction,SipProvider) handleAuthenticationChallenge(ClientTransaction)","net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl+processInviteOK(ClientTransaction,Response)",,net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+jainSipDialog net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+jainSipDialog,324,10,1,"/** 
 * Sets the JAIN SIP dialog that has been created by the application for communication with this call peer.
 * @param dialog the JAIN SIP dialog that has been created by theapplication for this call.
 */
","/**
     * Sets the JAIN SIP dialog that has been created by the application for
     * communication with this call peer.
     * @param dialog the JAIN SIP dialog that has been created by the
     * application for this call.
     */
    public void setDialog(Dialog dialog)
    {
        this.jainSipDialog = dialog;
    }",False
29,getDialog(),Method,getPeerAddress() sayBye() sendReInvite(String),"net.java.sip.communicator.impl.protocol.sip.ActiveCallsRepositorySipImpl+findCallPeer(String,String,String) net.java.sip.communicator.impl.protocol.sip.ActiveCallsRepositorySipImpl+findCallPeer(String,String) net.java.sip.communicator.impl.protocol.sip.CallSipImpl+findCallPeer(Dialog) net.java.sip.communicator.impl.protocol.sip.CallSipImpl+findCallPeer(Dialog) net.java.sip.communicator.impl.protocol.sip.dtmf.DTMFInfo+sayInfo(CallPeerSipImpl,DTMFTone,long) net.java.sip.communicator.impl.protocol.sip.dtmf.DTMFInfo+sayInfo(CallPeerSipImpl,DTMFTone,long) net.java.sip.communicator.impl.protocol.sip.dtmf.DTMFInfo+sayInfo(CallPeerSipImpl,DTMFTone,long) net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl+transfer(CallPeer,Address) net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl+transfer(CallPeer,CallPeer) net.java.sip.communicator.impl.protocol.sip.OperationSetTelephonyConferencingSipImpl+getConferenceInfoXML(CallPeerSipImpl,int) net.java.sip.communicator.impl.protocol.sip.OperationSetTelephonyConferencingSipImpl+ConferenceSubscriberSubscription.getDialog()",,net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+jainSipDialog,334,11,1,"/** 
 * Returns the JAIN SIP dialog that has been created by the application for communication with this call peer.
 * @return the JAIN SIP dialog that has been created by the application forcommunication with this call peer.
 */
","/**
     * Returns the JAIN SIP dialog that has been created by the application for
     * communication with this call peer.
     *
     * @return the JAIN SIP dialog that has been created by the application for
     * communication with this call peer.
     */
    public Dialog getDialog()
    {
        return jainSipDialog;
    }",False
30,setLatestInviteTransaction(Transaction),Method,"CallPeerSipImpl(Address,CallSipImpl,Transaction,SipProvider) processReInvite(ServerTransaction) handleAuthenticationChallenge(ClientTransaction)",,,net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+latestInviteTransaction net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+latestInviteTransaction,312,10,1,"/** 
 * Sets the transaction instance that contains the INVITE which started this call.
 * @param transaction the Transaction that initiated this call.
 */
","/**
     * Sets the transaction instance that contains the INVITE which started
     * this call.
     *
     * @param transaction the Transaction that initiated this call.
     */
    public void setLatestInviteTransaction(Transaction transaction)
    {
        this.latestInviteTransaction = transaction;
    }",False
31,getLatestInviteTransaction(),Method,processCancel(ServerTransaction) processCancel(ServerTransaction) hangup() sayBusyHere() sayBusyHere() sayBusyHere() sayCancel() sayCancel() answer() invite(),"net.java.sip.communicator.impl.protocol.sip.ActiveCallsRepositorySipImpl+findCallPeer(String,String) net.java.sip.communicator.impl.protocol.sip.ActiveCallsRepositorySipImpl+findCallPeer(String,String)",,net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+latestInviteTransaction,276,10,1,"/** 
 * Returns the transaction instance that contains the INVITE which started this call.
 * @return the Transaction that initiated this call.
 */
","/**
     * Returns the transaction instance that contains the INVITE which started
     * this call.
     *
     * @return the Transaction that initiated this call.
     */
    public Transaction getLatestInviteTransaction()
    {
        return latestInviteTransaction;
    }",False
32,setJainSipProvider(SipProvider),Method,"CallPeerSipImpl(Address,CallSipImpl,Transaction,SipProvider) handleAuthenticationChallenge(ClientTransaction)",,,net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+jainSipProvider net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+jainSipProvider,378,11,1,"/** 
 * Sets the jain sip provider instance that is responsible for sending and receiving requests and responses related to this call peer.
 * @param jainSipProvider the <tt>SipProvider</tt> that serves this callpeer.
 */
","/**
     * Sets the jain sip provider instance that is responsible for sending and
     * receiving requests and responses related to this call peer.
     *
     * @param jainSipProvider the <tt>SipProvider</tt> that serves this call
     * peer.
     */
    public void setJainSipProvider(SipProvider jainSipProvider)
    {
        this.jainSipProvider = jainSipProvider;
    }",False
33,getJainSipProvider(),Method,sayCancel() sayBye() sendReInvite(String),"net.java.sip.communicator.impl.protocol.sip.dtmf.DTMFInfo+sayInfo(CallPeerSipImpl,DTMFTone,long) net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl+transfer(CallPeer,Address)",,net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+jainSipProvider,404,11,1,"/** 
 * Returns the jain sip provider instance that is responsible for sending and receiving requests and responses related to this call peer.
 * @return the jain sip provider instance that is responsible for sendingand receiving requests and responses related to this call peer.
 */
","/**
     * Returns the jain sip provider instance that is responsible for sending
     * and receiving requests and responses related to this call peer.
     *
     * @return the jain sip provider instance that is responsible for sending
     * and receiving requests and responses related to this call peer.
     */
    public SipProvider getJainSipProvider()
    {
        return jainSipProvider;
    }",False
34,setTransportAddress(InetSocketAddress),Method,,,"net.java.sip.communicator.service.protocol.AbstractCallPeer+fireCallPeerChangeEvent(String,Object,Object) net.java.sip.communicator.service.protocol.AbstractCallPeer+fireCallPeerChangeEvent(String,Object,Object)",net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+transportAddress net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+transportAddress net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+transportAddress net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+transportAddress net.java.sip.communicator.service.protocol.event.CallPeerChangeEvent+CALL_PEER_TRANSPORT_ADDRESS_CHANGE,829,19,1,"/** 
 * The address that we have used to contact this peer. In cases where no direct connection has been established with the peer, this method will return the address that will be first tried when connection is established (often the one used to connect with the protocol server). The address may change during a session and
 * @param transportAddress The address that we have used to contact thispeer.
 */
","/**
     * The address that we have used to contact this peer. In cases
     * where no direct connection has been established with the peer,
     * this method will return the address that will be first tried when
     * connection is established (often the one used to connect with the
     * protocol server). The address may change during a session and
     *
     * @param transportAddress The address that we have used to contact this
     * peer.
     */
    public void setTransportAddress(InetSocketAddress transportAddress)
    {
        InetSocketAddress oldTransportAddress = this.transportAddress;
        this.transportAddress = transportAddress;

        this.fireCallPeerChangeEvent(
            CallPeerChangeEvent.CALL_PEER_TRANSPORT_ADDRESS_CHANGE,
                oldTransportAddress, transportAddress);
    }",False
35,getProtocolProvider(),Method,"CallPeerSipImpl(Address,CallSipImpl,Transaction,SipProvider) processReInvite(ServerTransaction) processReInvite(ServerTransaction) processInviteOK(ClientTransaction,Response) sayBye() answer() answer() sendReInvite(String) sendReInvite(String) invite()",net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl+createFirstOffer() net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl+getUserName() net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl+getIntendedDestination(CallPeerSipImpl),net.java.sip.communicator.impl.protocol.sip.CallSipImpl+getProtocolProvider() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getCall() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getCall() net.java.sip.communicator.impl.protocol.sip.CallSipImpl+getProtocolProvider(),,312,10,1,"/** 
 * Returns the protocol provider that this peer belongs to.
 * @return a reference to the <tt>ProtocolProviderService</tt> that thispeer belongs to.
 */
","/**
     * Returns the protocol provider that this peer belongs to.
     *
     * @return a reference to the <tt>ProtocolProviderService</tt> that this
     * peer belongs to.
     */
    public ProtocolProviderServiceSipImpl getProtocolProvider()
    {
        return this.getCall().getProtocolProvider();
    }",True
36,getContact(),Method,,,net.java.sip.communicator.impl.protocol.sip.CallSipImpl+getProtocolProvider() net.java.sip.communicator.impl.protocol.sip.CallSipImpl+getProtocolProvider() net.java.sip.communicator.service.protocol.ProtocolProviderService+getOperationSet(Class<T>) net.java.sip.communicator.service.protocol.ProtocolProviderService+getOperationSet(Class<T>) net.java.sip.communicator.impl.protocol.sip.OperationSetPresenceSipImpl+resolveContactID(String) net.java.sip.communicator.impl.protocol.sip.OperationSetPresenceSipImpl+resolveContactID(String) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getAddress() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getAddress(),net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+call,593,16,1,"/** 
 * Returns the contact corresponding to this peer or null if no particular contact has been associated. <p>
 * @return the <tt>Contact</tt> corresponding to this peer or nullif no particular contact has been associated.
 */
","/**
     * Returns the contact corresponding to this peer or null if no
     * particular contact has been associated.
     * <p>
     * @return the <tt>Contact</tt> corresponding to this peer or null
     * if no particular contact has been associated.
     */
    public Contact getContact()
    {
        ProtocolProviderService pps = call.getProtocolProvider();
        OperationSetPresenceSipImpl opSetPresence
            = (OperationSetPresenceSipImpl) pps
                .getOperationSet(OperationSetPresence.class);

        return opSetPresence.resolveContactID(getAddress());
    }",False
37,getCallInfoURL(),Method,,,net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl+getCallInfoURL() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl+getCallInfoURL(),,469,14,1,"/** 
 * Returns a URL pointing to a location with call control information for this peer or <tt>null</tt> if no such URL is available for this call peer.
 * @return a URL link to a location with call information or a call controlweb interface related to this peer or <tt>null</tt> if no such URL is available.
 */
","/**
     * Returns a URL pointing to a location with call control information for
     * this peer or <tt>null</tt> if no such URL is available for this
     * call peer.
     *
     * @return a URL link to a location with call information or a call control
     * web interface related to this peer or <tt>null</tt> if no such URL
     * is available.
     */
    @Override
    public URL getCallInfoURL()
    {
        return getMediaHandler().getCallInfoURL();
    }",False
38,isMute(),Method,"processAck(ServerTransaction,Request) processInviteOK(ClientTransaction,Response)",,net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler+isMute() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler+isMute(),,349,12,1,"/** 
 * Determines whether the audio stream (if any) being sent to this peer is mute.
 * @return <tt>true</tt> if an audio stream is being sent to thispeer and it is currently mute; <tt>false</tt>, otherwise
 */
","/**
     * Determines whether the audio stream (if any) being sent to this
     * peer is mute.
     *
     * @return <tt>true</tt> if an audio stream is being sent to this
     *         peer and it is currently mute; <tt>false</tt>, otherwise
     */
    @Override
    public boolean isMute()
    {
        return getMediaHandler().isMute();
    }",True
39,"securityOn(int,String,String,boolean)",Method,,,"net.java.sip.communicator.service.protocol.AbstractCallPeer+fireCallPeerSecurityOnEvent(int,String,String,boolean) net.java.sip.communicator.service.protocol.AbstractCallPeer+fireCallPeerSecurityOnEvent(int,String,String,boolean)",,605,16,1,"/** 
 * Sets the security status to ON for this call peer.
 * @param sessionType the type of the call session - audio or video.
 * @param cipher the cipher
 * @param securityString the SAS
 * @param isVerified indicates if the SAS has been verified
 */
","/**
     * Sets the security status to ON for this call peer.
     *
     * @param sessionType the type of the call session - audio or video.
     * @param cipher the cipher
     * @param securityString the SAS
     * @param isVerified indicates if the SAS has been verified
     */
    public void securityOn(  int sessionType,
                                String cipher,
                                String securityString,
                                boolean isVerified)
    {
        fireCallPeerSecurityOnEvent(
                        sessionType, cipher, securityString, isVerified);
    }",True
40,securityOff(int),Method,,,net.java.sip.communicator.service.protocol.AbstractCallPeer+fireCallPeerSecurityOffEvent(int) net.java.sip.communicator.service.protocol.AbstractCallPeer+fireCallPeerSecurityOffEvent(int),,258,9,1,"/** 
 * Sets the security status to OFF for this call peer.
 * @param sessionType the type of the call session - audio or video.
 */
","/**
     * Sets the security status to OFF for this call peer.
     *
     * @param sessionType the type of the call session - audio or video.
     */
    public void securityOff(int sessionType)
    {
        fireCallPeerSecurityOffEvent(sessionType);
    }",True
41,"securityMessage(String,String,int)",Method,,,"net.java.sip.communicator.service.protocol.AbstractCallPeer+fireCallPeerSecurityMessageEvent(String,String,int) net.java.sip.communicator.service.protocol.AbstractCallPeer+fireCallPeerSecurityMessageEvent(String,String,int)",,602,16,1,"/** 
 * Sets the security message associated with a failure/warning or information coming from the encryption protocol.
 * @param messageType the type of the message.
 * @param i18nMessage the message
 * @param severity severity level
 */
","/**
     * Sets the security message associated with a failure/warning or
     * information coming from the encryption protocol.
     *
     * @param messageType the type of the message.
     * @param i18nMessage the message
     * @param severity severity level
     */
    public void securityMessage( String messageType,
                                    String i18nMessage,
                                    int severity)
    {
        fireCallPeerSecurityMessageEvent(messageType,
                                         i18nMessage,
                                         severity);
    }",True
42,processReInvite(ServerTransaction),Method,,"net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl+processInvite(SipProvider,ServerTransaction)","javax.sip.Transaction+getRequest() javax.sip.Transaction+getRequest() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+setLatestInviteTransaction(Transaction) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+setLatestInviteTransaction(Transaction) javax.sip.message.Message+getContentLength() javax.sip.message.Message+getContentLength() javax.sip.header.ContentLengthHeader+getContentLength() javax.sip.header.ContentLengthHeader+getContentLength() net.java.sip.communicator.impl.protocol.sip.sdp.SdpUtils+getContentAsString(Message) net.java.sip.communicator.impl.protocol.sip.sdp.SdpUtils+getContentAsString(Message) net.java.sip.communicator.impl.protocol.sip.SipMessageFactory+createResponse(int,Request) net.java.sip.communicator.impl.protocol.sip.SipMessageFactory+createResponse(int,Request) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+reflectConferenceFocus(Message) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+reflectConferenceFocus(Message) net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl+processOffer(String) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl+processOffer(String) net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl+createOffer() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl+createOffer() javax.sip.message.Message+setContent(Object,ContentTypeHeader) javax.sip.message.Message+setContent(Object,ContentTypeHeader) javax.sip.header.HeaderFactory+createContentTypeHeader(String,String) net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl+getHeaderFactory() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getProtocolProvider() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getProtocolProvider() net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl+getHeaderFactory() javax.sip.header.HeaderFactory+createContentTypeHeader(String,String) net.java.sip.communicator.util.Logger+isTraceEnabled() net.java.sip.communicator.util.Logger+isTraceEnabled() net.java.sip.communicator.util.Logger+trace(Object) net.java.sip.communicator.util.Logger+trace(Object) javax.sip.ServerTransaction+sendResponse(Response) javax.sip.ServerTransaction+sendResponse(Response) net.java.sip.communicator.util.Logger+isDebugEnabled() net.java.sip.communicator.util.Logger+isDebugEnabled() net.java.sip.communicator.util.Logger+debug(Object) net.java.sip.communicator.util.Logger+debug(Object) net.java.sip.communicator.util.Logger+error(Object,Throwable) net.java.sip.communicator.util.Logger+error(Object,Throwable) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+setState(CallPeerState,String) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+setState(CallPeerState,String) java.lang.Throwable+getMessage() java.lang.Throwable+getMessage() net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl+sayErrorSilently(ServerTransaction,int) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getProtocolProvider() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getProtocolProvider() net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl+sayErrorSilently(ServerTransaction,int) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+reevalRemoteHoldStatus() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+reevalRemoteHoldStatus() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+fireRequestProcessed(Request,Response) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+fireRequestProcessed(Request,Response)",net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+messageFactory javax.sip.message.Response+OK net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger net.java.sip.communicator.service.protocol.CallPeerState+FAILED javax.sip.message.Response+SERVER_INTERNAL_ERROR,2292,63,1,"/** 
 * Reinitializes the media session of the <tt>CallPeer</tt> that this INVITE request is destined to.
 * @param serverTransaction a reference to the {@link ServerTransaction}that contains the reINVITE request.
 */
","/**
     * Reinitializes the media session of the <tt>CallPeer</tt> that this
     * INVITE request is destined to.
     *
     * @param serverTransaction a reference to the {@link ServerTransaction}
     * that contains the reINVITE request.
     */
    public void processReInvite(ServerTransaction serverTransaction)
    {
        Request invite = serverTransaction.getRequest();

        setLatestInviteTransaction(serverTransaction);

        // SDP description may be in ACKs - bug report Laurent Michel
        String sdpOffer = null;
        ContentLengthHeader cl = invite.getContentLength();
        if (cl != null && cl.getContentLength() > 0)
        {
            sdpOffer = SdpUtils.getContentAsString(invite);
        }

        Response response = null;
        try
        {
            response = messageFactory.createResponse(Response.OK, invite);

            /*
             * If the local peer represented by the Call of this CallPeer is
             * acting as a conference focus, it must indicate it in its Contact
             * header.
             */
            reflectConferenceFocus(response);

            String sdpAnswer;
            if(sdpOffer != null)
                sdpAnswer = getMediaHandler().processOffer( sdpOffer );
            else
                sdpAnswer = getMediaHandler().createOffer();

            response.setContent( sdpAnswer, getProtocolProvider()
                .getHeaderFactory().createContentTypeHeader(
                                ""application"", ""sdp""));

            if (logger.isTraceEnabled())
                logger.trace(""will send an OK response: "" + response);
            serverTransaction.sendResponse(response);
            if (logger.isDebugEnabled())
                logger.debug(""OK response sent"");
        }
        catch (Exception ex)//no need to distinguish among exceptions.
        {
            logger.error(""Error while trying to send a response"", ex);
            setState(CallPeerState.FAILED,
                ""Internal Error: "" + ex.getMessage());
            getProtocolProvider().sayErrorSilently(
                            serverTransaction, Response.SERVER_INTERNAL_ERROR);
            return;
        }

        reevalRemoteHoldStatus();

        fireRequestProcessed(invite, response);
    }",False
43,reevalRemoteHoldStatus(),Method,processReInvite(ServerTransaction),,net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler+isRemotelyOnHold() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler+isRemotelyOnHold() net.java.sip.communicator.service.protocol.AbstractCallPeer+getState() net.java.sip.communicator.service.protocol.AbstractCallPeer+getState() java.lang.Object+equals(Object) java.lang.Object+equals(Object) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) java.lang.Object+equals(Object) java.lang.Object+equals(Object) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) java.lang.Object+equals(Object) java.lang.Object+equals(Object) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState),net.java.sip.communicator.service.protocol.CallPeerState+ON_HOLD_LOCALLY net.java.sip.communicator.service.protocol.CallPeerState+ON_HOLD_MUTUALLY net.java.sip.communicator.service.protocol.CallPeerState+ON_HOLD_MUTUALLY net.java.sip.communicator.service.protocol.CallPeerState+ON_HOLD_LOCALLY net.java.sip.communicator.service.protocol.CallPeerState+ON_HOLD_REMOTELY net.java.sip.communicator.service.protocol.CallPeerState+CONNECTED net.java.sip.communicator.service.protocol.CallPeerState+ON_HOLD_REMOTELY,910,29,2,"/** 
 * Updates the state of this <tt>CallPeer</tt> to match the remotely-on-hold status of our media handler.
 */
","/**
     * Updates the state of this <tt>CallPeer</tt> to match the remotely-on-hold
     * status of our media handler.
     */
    private void reevalRemoteHoldStatus()
    {
        boolean remotelyOnHold = getMediaHandler().isRemotelyOnHold();

        CallPeerState state = getState();
        if (CallPeerState.ON_HOLD_LOCALLY.equals(state))
        {
            if (remotelyOnHold)
                setState(CallPeerState.ON_HOLD_MUTUALLY);
        }
        else if (CallPeerState.ON_HOLD_MUTUALLY.equals(state))
        {
            if (!remotelyOnHold)
                setState(CallPeerState.ON_HOLD_LOCALLY);
        }
        else if (CallPeerState.ON_HOLD_REMOTELY.equals(state))
        {
            if (!remotelyOnHold)
                setState(CallPeerState.CONNECTED);
        }
        else if (remotelyOnHold)
        {
            setState(CallPeerState.ON_HOLD_REMOTELY);
        }
    }",True
44,reevalLocalHoldStatus(),Method,putOnHold(boolean),,net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler+isLocallyOnHold() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler+isLocallyOnHold() net.java.sip.communicator.service.protocol.AbstractCallPeer+getState() net.java.sip.communicator.service.protocol.AbstractCallPeer+getState() java.lang.Object+equals(Object) java.lang.Object+equals(Object) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) java.lang.Object+equals(Object) java.lang.Object+equals(Object) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) java.lang.Object+equals(Object) java.lang.Object+equals(Object) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState),net.java.sip.communicator.service.protocol.CallPeerState+ON_HOLD_LOCALLY net.java.sip.communicator.service.protocol.CallPeerState+CONNECTED net.java.sip.communicator.service.protocol.CallPeerState+ON_HOLD_MUTUALLY net.java.sip.communicator.service.protocol.CallPeerState+ON_HOLD_REMOTELY net.java.sip.communicator.service.protocol.CallPeerState+ON_HOLD_REMOTELY net.java.sip.communicator.service.protocol.CallPeerState+ON_HOLD_MUTUALLY net.java.sip.communicator.service.protocol.CallPeerState+ON_HOLD_LOCALLY,902,29,2,"/** 
 * Updates the state of this <tt>CallPeer</tt> to match the locally-on-hold status of our media handler.
 */
","/**
     * Updates the state of this <tt>CallPeer</tt> to match the locally-on-hold
     * status of our media handler.
     */
    private void reevalLocalHoldStatus()
    {
        boolean locallyOnHold = getMediaHandler().isLocallyOnHold();

        CallPeerState state = getState();
        if (CallPeerState.ON_HOLD_LOCALLY.equals(state))
        {
            if (!locallyOnHold)
                setState(CallPeerState.CONNECTED);
        }
        else if (CallPeerState.ON_HOLD_MUTUALLY.equals(state))
        {
            if (!locallyOnHold)
                setState(CallPeerState.ON_HOLD_REMOTELY);
        }
        else if (CallPeerState.ON_HOLD_REMOTELY.equals(state))
        {
            if (locallyOnHold)
                setState(CallPeerState.ON_HOLD_MUTUALLY);
        }
        else if (locallyOnHold)
        {
            setState(CallPeerState.ON_HOLD_LOCALLY);
        }
    }",True
45,processBye(ServerTransaction),Method,,"net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl+processBye(ServerTransaction,Request)","javax.sip.Transaction+getRequest() javax.sip.Transaction+getRequest() net.java.sip.communicator.impl.protocol.sip.SipMessageFactory+createResponse(int,Request) net.java.sip.communicator.impl.protocol.sip.SipMessageFactory+createResponse(int,Request) net.java.sip.communicator.util.Logger+error(Object,Throwable) net.java.sip.communicator.util.Logger+error(Object,Throwable) javax.sip.ServerTransaction+sendResponse(Response) javax.sip.ServerTransaction+sendResponse(Response) net.java.sip.communicator.util.Logger+isDebugEnabled() net.java.sip.communicator.util.Logger+isDebugEnabled() net.java.sip.communicator.util.Logger+debug(Object) net.java.sip.communicator.util.Logger+debug(Object) net.java.sip.communicator.util.Logger+error(Object,Throwable) net.java.sip.communicator.util.Logger+error(Object,Throwable) net.java.sip.communicator.impl.protocol.sip.EventPackageUtils+processByeThenIsDialogAlive(Dialog) net.java.sip.communicator.impl.protocol.sip.EventPackageUtils+processByeThenIsDialogAlive(Dialog) javax.sip.Transaction+getDialog() javax.sip.Transaction+getDialog() net.java.sip.communicator.util.Logger+error(Object,Throwable) net.java.sip.communicator.util.Logger+error(Object,Throwable) net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler+close() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler+close() net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState)",net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+messageFactory javax.sip.message.Response+OK net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger net.java.sip.communicator.service.protocol.CallPeerState+DISCONNECTED,2262,70,1,"/** 
 * Sets the state of the corresponding call peer to DISCONNECTED and sends an OK response.
 * @param byeTran the ServerTransaction the the BYE request arrived in.
 */
","/**
     * Sets the state of the corresponding call peer to DISCONNECTED and
     * sends an OK response.
     *
     * @param byeTran the ServerTransaction the the BYE request arrived in.
     */
    public void processBye(ServerTransaction byeTran)
    {
        Request byeRequest = byeTran.getRequest();
        // Send OK
        Response ok = null;
        try
        {
            ok = messageFactory.createResponse(Response.OK, byeRequest);
        }
        catch (ParseException ex)
        {
            logger.error(""Error while trying to send a response to a bye"", ex);
            /*
             * No need to let the user know about the error since it doesn't
             * affect them. And just as the comment on sendResponse bellow
             * says, this is not really a problem according to the RFC so we
             * should proceed with the execution bellow in order to gracefully
             * hangup the call.
             */
        }

        if (ok != null)
            try
            {
                byeTran.sendResponse(ok);
                if (logger.isDebugEnabled())
                    logger.debug(""sent response "" + ok);
            }
            catch (Exception ex)
            {
                /*
                 * This is not really a problem according to the RFC so just
                 * dump to stdout should someone be interested.
                 */
                logger.error(""Failed to send an OK response to BYE request,""
                    + ""exception was:\n"", ex);
            }

        // change status
        boolean dialogIsAlive;
        try
        {
            dialogIsAlive = EventPackageUtils.processByeThenIsDialogAlive(
                            byeTran.getDialog());
        }
        catch (SipException ex)
        {
            dialogIsAlive = false;

            logger.error(
                ""Failed to determine whether the dialog should stay alive."",ex);
        }

        //if the Dialog is still alive (i.e. we are in the middle of a xfer)
        //then only stop streaming, otherwise Disconnect.
        if (dialogIsAlive)
        {
            getMediaHandler().close();
        }
        else
        {
            setState(CallPeerState.DISCONNECTED);
        }
    }",False
46,processCancel(ServerTransaction),Method,,"net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl+processCancel(ServerTransaction,Request)","javax.sip.Transaction+getRequest() javax.sip.Transaction+getRequest() net.java.sip.communicator.impl.protocol.sip.SipMessageFactory+createResponse(int,Request) net.java.sip.communicator.impl.protocol.sip.SipMessageFactory+createResponse(int,Request) javax.sip.ServerTransaction+sendResponse(Response) javax.sip.ServerTransaction+sendResponse(Response) net.java.sip.communicator.util.Logger+isDebugEnabled() net.java.sip.communicator.util.Logger+isDebugEnabled() net.java.sip.communicator.util.Logger+debug(Object) net.java.sip.communicator.util.Logger+debug(Object) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logAndFail(String,Throwable) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logAndFail(String,Throwable) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logAndFail(String,Throwable) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logAndFail(String,Throwable) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getLatestInviteTransaction() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getLatestInviteTransaction() net.java.sip.communicator.util.Logger+error(Object) net.java.sip.communicator.util.Logger+error(Object) javax.sip.Transaction+getRequest() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getLatestInviteTransaction() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getLatestInviteTransaction() javax.sip.Transaction+getRequest() net.java.sip.communicator.impl.protocol.sip.SipMessageFactory+createResponse(int,Request) net.java.sip.communicator.impl.protocol.sip.SipMessageFactory+createResponse(int,Request) javax.sip.ServerTransaction+sendResponse(Response) javax.sip.ServerTransaction+sendResponse(Response) net.java.sip.communicator.util.Logger+isDebugEnabled() net.java.sip.communicator.util.Logger+isDebugEnabled() net.java.sip.communicator.util.Logger+debug(Object) net.java.sip.communicator.util.Logger+debug(Object) net.java.sip.communicator.util.Logger+error(Object,Throwable) net.java.sip.communicator.util.Logger+error(Object,Throwable) net.java.sip.communicator.util.Logger+error(Object,Throwable) net.java.sip.communicator.util.Logger+error(Object,Throwable) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState)",net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+messageFactory javax.sip.message.Response+OK net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+messageFactory javax.sip.message.Response+REQUEST_TERMINATED net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger net.java.sip.communicator.service.protocol.CallPeerState+DISCONNECTED,2353,65,1,"/** 
 * Sets the state of the specifies call peer as DISCONNECTED.
 * @param serverTransaction the transaction that the cancel was received in.
 */
","/**
     * Sets the state of the specifies call peer as DISCONNECTED.
     *
     * @param serverTransaction the transaction that the cancel was received in.
     */
    public void processCancel(ServerTransaction serverTransaction)
    {
        // Cancels should be OK-ed and the initial transaction - terminated
        // (report and fix by Ranga)
        Request cancel = serverTransaction.getRequest();
        try
        {
            Response ok = messageFactory.createResponse(Response.OK, cancel);
            serverTransaction.sendResponse(ok);

            if (logger.isDebugEnabled())
                logger.debug(""sent an ok response to a CANCEL request:\n"" + ok);
        }
        catch (ParseException ex)
        {
            logAndFail(""Failed to create an OK Response to a CANCEL."", ex);
            return;
        }
        catch (Exception ex)
        {
            logAndFail(""Failed to send an OK Response to a CANCEL."", ex);
            return;
        }

        try
        {
            // stop the invite transaction as well
            Transaction tran = getLatestInviteTransaction();
            // should be server transaction and misplaced cancels should be
            // filtered by the stack but it doesn't hurt checking anyway
            if (!(tran instanceof ServerTransaction))
            {
                logger.error(""Received a misplaced CANCEL request!"");
                return;
            }

            ServerTransaction inviteTran = (ServerTransaction) tran;
            Request invite = getLatestInviteTransaction().getRequest();
            Response requestTerminated = messageFactory
                .createResponse(Response.REQUEST_TERMINATED, invite);

            inviteTran.sendResponse(requestTerminated);
            if (logger.isDebugEnabled())
                logger.debug(""sent request terminated response:\n""
                    + requestTerminated);
        }
        catch (ParseException ex)
        {
            logger.error(""Failed to create a REQUEST_TERMINATED Response to ""
                + ""an INVITE request."", ex);
        }
        catch (Exception ex)
        {
            logger.error(""Failed to send an REQUEST_TERMINATED Response to ""
                + ""an INVITE request."", ex);
        }

        // change status
        setState(CallPeerState.DISCONNECTED);
    }",False
47,setMute(boolean),Method,"processAck(ServerTransaction,Request) processInviteOK(ClientTransaction,Response)",,net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler+setMute(boolean) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler+setMute(boolean) net.java.sip.communicator.service.protocol.AbstractCallPeer+setMute(boolean),,307,11,1,"/** 
 * Sets the mute property for this call peer.
 * @param newMuteValue the new value of the mute property for this call peer
 */
","/**
     * Sets the mute property for this call peer.
     *
     * @param newMuteValue the new value of the mute property for this call peer
     */
    @Override
    public void setMute(boolean newMuteValue)
    {
        getMediaHandler().setMute(newMuteValue);
        super.setMute(newMuteValue);
    }",True
48,"logAndFail(String,Throwable)",Method,"processCancel(ServerTransaction) processCancel(ServerTransaction) processAck(ServerTransaction,Request) processSessionProgress(ClientTransaction,Response) processInviteOK(ClientTransaction,Response) processInviteOK(ClientTransaction,Response) processInviteOK(ClientTransaction,Response)","net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl+processAuthenticationChallenge(ClientTransaction,Response,SipProvider)","net.java.sip.communicator.util.Logger+error(Object,Throwable) net.java.sip.communicator.util.Logger+error(Object,Throwable) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+setState(CallPeerState,String) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+setState(CallPeerState,String)",net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger net.java.sip.communicator.service.protocol.CallPeerState+FAILED,447,12,1,"/** 
 * Logs <tt>message</tt> and <tt>cause</tt> and sets this <tt>peer</tt>'s state to <tt>CallPeerState.FAILED</tt>
 * @param message a message to log and display to the user.
 * @param throwable the exception that cause the error we are logging
 */
","/**
     * Logs <tt>message</tt> and <tt>cause</tt> and sets this <tt>peer</tt>'s
     * state to <tt>CallPeerState.FAILED</tt>
     *
     * @param message a message to log and display to the user.
     * @param throwable the exception that cause the error we are logging
     */
    public void logAndFail(String message, Throwable throwable)
    {
        logger.error(message, throwable);
        setState(CallPeerState.FAILED, message);
    }",True
49,"processAck(ServerTransaction,Request)",Method,,"net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl+processAck(ServerTransaction,Request)","javax.sip.message.Message+getContentLength() javax.sip.message.Message+getContentLength() javax.sip.header.ContentLengthHeader+getContentLength() javax.sip.header.ContentLengthHeader+getContentLength() net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl+processAnswer(String) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl+processAnswer(String) net.java.sip.communicator.impl.protocol.sip.sdp.SdpUtils+getContentAsString(Message) net.java.sip.communicator.impl.protocol.sip.sdp.SdpUtils+getContentAsString(Message) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logAndFail(String,Throwable) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logAndFail(String,Throwable) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getDisplayName() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getDisplayName() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getAddress() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getAddress() net.java.sip.communicator.service.protocol.AbstractCallPeer+getState() net.java.sip.communicator.service.protocol.AbstractCallPeer+getState() net.java.sip.communicator.service.protocol.CallPeerState+isOnHold(CallPeerState) net.java.sip.communicator.service.protocol.CallPeerState+isOnHold(CallPeerState) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+isMute() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+isMute() net.java.sip.communicator.service.protocol.media.AbstractMediaAwareCall+isMute() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getCall() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getCall() net.java.sip.communicator.service.protocol.media.AbstractMediaAwareCall+isMute() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+setMute(boolean) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+setMute(boolean) net.java.sip.communicator.service.protocol.media.AbstractMediaAwareCall+isMute() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getCall() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getCall() net.java.sip.communicator.service.protocol.media.AbstractMediaAwareCall+isMute()",net.java.sip.communicator.service.protocol.CallPeerState+CONNECTED,1325,37,1,"/** 
 * Updates the session description and sends the state of the corresponding call peer to CONNECTED.
 * @param serverTransaction the transaction that the ACK was received in.
 * @param ack the ACK <tt>Request</tt> we need to process
 */
","/**
     * Updates the session description and sends the state of the corresponding
     * call peer to CONNECTED.
     *
     * @param serverTransaction the transaction that the ACK was received in.
     * @param ack the ACK <tt>Request</tt> we need to process
     */
    public void processAck(ServerTransaction serverTransaction, Request ack)
    {
        ContentLengthHeader contentLength = ack.getContentLength();
        if ((contentLength != null) && (contentLength.getContentLength() > 0))
        {
            try
            {
                getMediaHandler().processAnswer(
                                    SdpUtils.getContentAsString(ack));
            }
            catch (Exception exc)
            {
                logAndFail(""There was an error parsing the SDP description of ""
                            + getDisplayName() + ""("" + getAddress() + "")"", exc);
                return;
            }
        }

        // change status
        CallPeerState peerState = getState();
        if (!CallPeerState.isOnHold(peerState))
        {
            setState(CallPeerState.CONNECTED);

            // as its connected, set initial mute status,
            // corresponding call status
            if(isMute() != this.getCall().isMute())
                setMute(this.getCall().isMute());
        }
    }",False
50,"processSessionProgress(ClientTransaction,Response)",Method,,"net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl+processSessionProgress(ClientTransaction,Response)","javax.sip.header.ContentLengthHeader+getContentLength() javax.sip.message.Message+getContentLength() javax.sip.message.Message+getContentLength() javax.sip.header.ContentLengthHeader+getContentLength() net.java.sip.communicator.util.Logger+isDebugEnabled() net.java.sip.communicator.util.Logger+isDebugEnabled() net.java.sip.communicator.util.Logger+debug(Object) net.java.sip.communicator.util.Logger+debug(Object) javax.sip.message.Message+getHeader(String) javax.sip.message.Message+getHeader(String) java.lang.String+equalsIgnoreCase(String) javax.sip.header.MediaType+getContentType() javax.sip.header.MediaType+getContentType() java.lang.String+equalsIgnoreCase(String) java.lang.String+equalsIgnoreCase(String) javax.sip.header.MediaType+getContentSubType() javax.sip.header.MediaType+getContentSubType() java.lang.String+equalsIgnoreCase(String) net.java.sip.communicator.util.Logger+warn(Object) net.java.sip.communicator.util.Logger+warn(Object) net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl+processAnswer(String) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl+processAnswer(String) net.java.sip.communicator.impl.protocol.sip.sdp.SdpUtils+getContentAsString(Message) net.java.sip.communicator.impl.protocol.sip.sdp.SdpUtils+getContentAsString(Message) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logAndFail(String,Throwable) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logAndFail(String,Throwable) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getDisplayName() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getDisplayName() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getAddress() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getAddress() net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState)",net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger javax.sip.header.ContentTypeHeader+NAME net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger net.java.sip.communicator.service.protocol.CallPeerState+CONNECTING_WITH_EARLY_MEDIA,1745,47,1,"/** 
 * Handles early media in 183 Session Progress responses. Retrieves the SDP and makes sure that we start transmitting and playing early media that we receive. Puts the call into a CONNECTING_WITH_EARLY_MEDIA state.
 * @param tran the <tt>ClientTransaction</tt> that the responsearrived in.
 * @param response the 183 <tt>Response</tt> to process
 */
","/**
     * Handles early media in 183 Session Progress responses. Retrieves the SDP
     * and makes sure that we start transmitting and playing early media that we
     * receive. Puts the call into a CONNECTING_WITH_EARLY_MEDIA state.
     *
     * @param tran the <tt>ClientTransaction</tt> that the response
     * arrived in.
     * @param response the 183 <tt>Response</tt> to process
     */
    public void processSessionProgress(ClientTransaction tran,
                                       Response          response)
    {
        if (response.getContentLength().getContentLength() == 0)
        {
            if (logger.isDebugEnabled())
                logger.debug(""Ignoring a 183 with no content"");
            return;
        }

        ContentTypeHeader contentTypeHeader = (ContentTypeHeader) response
                .getHeader(ContentTypeHeader.NAME);

        if (!contentTypeHeader.getContentType().equalsIgnoreCase(""application"")
            || !contentTypeHeader.getContentSubType().equalsIgnoreCase(""sdp""))
        {
            //This can happen when receiving early media for a second time.
            logger.warn(""Ignoring invite 183 since call peer is ""
                + ""already exchanging early media."");
            return;
        }

        //handle media
        try
        {
            getMediaHandler().processAnswer(
                            SdpUtils.getContentAsString(response));
        }
        catch (Exception exc)
        {
            logAndFail(""There was an error parsing the SDP description of ""
                + getDisplayName() + ""("" + getAddress() + "")"", exc);
            return;
        }

        // change status
        setState(CallPeerState.CONNECTING_WITH_EARLY_MEDIA);
    }",False
51,"processInviteOK(ClientTransaction,Response)",Method,,"net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl+processInviteOK(ClientTransaction,Response)","net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl+sendAck(ClientTransaction) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getProtocolProvider() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getProtocolProvider() net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl+sendAck(ClientTransaction) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logAndFail(String,Throwable) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logAndFail(String,Throwable) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logAndFail(String,Throwable) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logAndFail(String,Throwable) java.lang.Object+equals(Object) java.lang.Object+equals(Object) net.java.sip.communicator.service.protocol.AbstractCallPeer+getState() net.java.sip.communicator.service.protocol.AbstractCallPeer+getState() net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl+processAnswer(String) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl+processAnswer(String) net.java.sip.communicator.impl.protocol.sip.sdp.SdpUtils+getContentAsString(Message) net.java.sip.communicator.impl.protocol.sip.sdp.SdpUtils+getContentAsString(Message) net.java.sip.communicator.util.Logger+error(Object,Throwable) net.java.sip.communicator.util.Logger+error(Object,Throwable) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getDisplayName() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getDisplayName() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getAddress() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getAddress() net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+hangup() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+hangup() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logAndFail(String,Throwable) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logAndFail(String,Throwable) net.java.sip.communicator.service.protocol.CallPeerState+isOnHold(CallPeerState) net.java.sip.communicator.service.protocol.CallPeerState+isOnHold(CallPeerState) net.java.sip.communicator.service.protocol.AbstractCallPeer+getState() net.java.sip.communicator.service.protocol.AbstractCallPeer+getState() net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+isMute() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+isMute() net.java.sip.communicator.service.protocol.media.AbstractMediaAwareCall+isMute() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getCall() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getCall() net.java.sip.communicator.service.protocol.media.AbstractMediaAwareCall+isMute() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+setMute(boolean) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+setMute(boolean) net.java.sip.communicator.service.protocol.media.AbstractMediaAwareCall+isMute() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getCall() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getCall() net.java.sip.communicator.service.protocol.media.AbstractMediaAwareCall+isMute() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+fireResponseProcessed(Response,Request) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+fireResponseProcessed(Response,Request)",net.java.sip.communicator.service.protocol.CallPeerState+CONNECTING_WITH_EARLY_MEDIA net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger net.java.sip.communicator.service.protocol.CallPeerState+CONNECTED net.java.sip.communicator.service.protocol.CallPeerState+CONNECTED,2673,77,1,"/** 
 * Sets our state to CONNECTED, sends an ACK and processes the SDP description in the <tt>ok</tt> <tt>Response</tt>.
 * @param clientTransaction the <tt>ClientTransaction</tt> that the responsearrived in.
 * @param ok the OK <tt>Response</tt> to process
 */
","/**
     * Sets our state to CONNECTED, sends an ACK and processes the SDP
     * description in the <tt>ok</tt> <tt>Response</tt>.
     *
     * @param clientTransaction the <tt>ClientTransaction</tt> that the response
     * arrived in.
     * @param ok the OK <tt>Response</tt> to process
     */
    public void processInviteOK(ClientTransaction clientTransaction,
                                 Response         ok)
    {
        try
        {
            // Send the ACK. Do it now since we already got all the info we need
            // and processSdpAnswer() can take a while (patch by Michael Koch)
            getProtocolProvider().sendAck(clientTransaction);
        }
        catch (InvalidArgumentException ex)
        {
            // Shouldn't happen
            logAndFail(""Error creating an ACK (CSeq?)"", ex);
            return;
        }
        catch (SipException ex)
        {
            logAndFail(""Failed to create ACK request!"", ex);
            return;
        }

        try
        {
             //Process SDP unless we've just had an answer in a 18X response
            if (!CallPeerState.CONNECTING_WITH_EARLY_MEDIA.equals(getState()))
            {
                getMediaHandler()
                    .processAnswer(SdpUtils.getContentAsString(ok));
            }
        }
        //at this point we have already sent our ack so in addition to logging
        //an error we also need to hangup the call peer.
        catch (Exception exc)//Media or parse exception.
        {
            logger.error(""There was an error parsing the SDP description of ""
                + getDisplayName() + ""("" + getAddress() + "")"", exc);
            try
            {
                //we are connected from a SIP point of view (cause we sent our
                //ACK) so make sure we set the state accordingly or the hangup
                //method won't know how to end the call.
                setState(CallPeerState.CONNECTED);
                hangup();
            }
            catch (Exception e)
            {
                //handle in finally.
            }
            finally
            {
                logAndFail(""Remote party sent a faulty session description."",
                        exc);
            }
            return;
        }

        // change status
        if (!CallPeerState.isOnHold(getState()))
        {
            setState(CallPeerState.CONNECTED);

            // as its connected, set initial mute status,
            // corresponding call status
            if(isMute() != this.getCall().isMute())
                setMute(this.getCall().isMute());
        }

        fireResponseProcessed(ok, null);
    }",False
52,hangup(),Method,"processInviteOK(ClientTransaction,Response)","net.java.sip.communicator.impl.protocol.sip.CallSipImpl+processReplacingInvite(SipProvider,ServerTransaction,CallPeerSipImpl) net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl+processNotify(ServerTransaction,Request) net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl+hangupCallPeer(CallPeer)",java.lang.Object+equals(Object) java.lang.Object+equals(Object) net.java.sip.communicator.service.protocol.AbstractCallPeer+getState() net.java.sip.communicator.service.protocol.AbstractCallPeer+getState() java.lang.Object+equals(Object) java.lang.Object+equals(Object) net.java.sip.communicator.service.protocol.AbstractCallPeer+getState() net.java.sip.communicator.service.protocol.AbstractCallPeer+getState() net.java.sip.communicator.util.Logger+isDebugEnabled() net.java.sip.communicator.util.Logger+isDebugEnabled() net.java.sip.communicator.util.Logger+debug(Object) net.java.sip.communicator.util.Logger+debug(Object) net.java.sip.communicator.service.protocol.AbstractCallPeer+getState() net.java.sip.communicator.service.protocol.AbstractCallPeer+getState() java.lang.Object+equals(Object) java.lang.Object+equals(Object) net.java.sip.communicator.service.protocol.CallPeerState+isOnHold(CallPeerState) net.java.sip.communicator.service.protocol.CallPeerState+isOnHold(CallPeerState) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+sayBye() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+sayBye() net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) java.lang.Object+equals(Object) java.lang.Object+equals(Object) net.java.sip.communicator.service.protocol.AbstractCallPeer+getState() net.java.sip.communicator.service.protocol.AbstractCallPeer+getState() java.lang.Object+equals(Object) java.lang.Object+equals(Object) net.java.sip.communicator.service.protocol.AbstractCallPeer+getState() net.java.sip.communicator.service.protocol.AbstractCallPeer+getState() java.lang.Object+equals(Object) java.lang.Object+equals(Object) net.java.sip.communicator.service.protocol.AbstractCallPeer+getState() net.java.sip.communicator.service.protocol.AbstractCallPeer+getState() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getLatestInviteTransaction() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getLatestInviteTransaction() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+sayCancel() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+sayCancel() net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) java.lang.Object+equals(Object) java.lang.Object+equals(Object) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+sayBusyHere() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+sayBusyHere() java.lang.Object+equals(Object) java.lang.Object+equals(Object) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) java.lang.Object+equals(Object) java.lang.Object+equals(Object) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) net.java.sip.communicator.util.Logger+error(Object) net.java.sip.communicator.util.Logger+error(Object),net.java.sip.communicator.service.protocol.CallPeerState+DISCONNECTED net.java.sip.communicator.service.protocol.CallPeerState+FAILED net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger net.java.sip.communicator.service.protocol.CallPeerState+CONNECTED net.java.sip.communicator.service.protocol.CallPeerState+DISCONNECTED net.java.sip.communicator.service.protocol.CallPeerState+CONNECTING net.java.sip.communicator.service.protocol.CallPeerState+CONNECTING_WITH_EARLY_MEDIA net.java.sip.communicator.service.protocol.CallPeerState+ALERTING_REMOTE_SIDE net.java.sip.communicator.service.protocol.CallPeerState+DISCONNECTED net.java.sip.communicator.service.protocol.CallPeerState+INCOMING_CALL net.java.sip.communicator.service.protocol.CallPeerState+DISCONNECTED net.java.sip.communicator.service.protocol.CallPeerState+BUSY net.java.sip.communicator.service.protocol.CallPeerState+DISCONNECTED net.java.sip.communicator.service.protocol.CallPeerState+FAILED net.java.sip.communicator.service.protocol.CallPeerState+DISCONNECTED net.java.sip.communicator.service.protocol.CallPeerState+DISCONNECTED net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger,2195,62,1,"/** 
 * Ends the call with for this <tt>CallPeer</tt>. Depending on the state of the peer the method would send a CANCEL, BYE, or BUSY_HERE message and set the new state to DISCONNECTED.
 * @throws OperationFailedException if we fail to terminate the call.
 */
","/**
     * Ends the call with for this <tt>CallPeer</tt>. Depending on the state
     * of the peer the method would send a CANCEL, BYE, or BUSY_HERE message
     * and set the new state to DISCONNECTED.
     *
     * @throws OperationFailedException if we fail to terminate the call.
     */
    public void hangup()
        throws OperationFailedException
    {
        // do nothing if the call is already ended
        if (CallPeerState.DISCONNECTED.equals(getState())
            || CallPeerState.FAILED.equals(getState()))
        {
            if (logger.isDebugEnabled())
                logger.debug(""Ignoring a request to hangup a call peer ""
                        + ""that is already DISCONNECTED"");
            return;
        }

        CallPeerState peerState = getState();
        if (peerState.equals(CallPeerState.CONNECTED)
            || CallPeerState.isOnHold(peerState))
        {
            boolean dialogIsAlive = sayBye();
            if (!dialogIsAlive)
            {
                setState(CallPeerState.DISCONNECTED);
            }
        }
        else if (CallPeerState.CONNECTING.equals(getState())
            || CallPeerState.CONNECTING_WITH_EARLY_MEDIA.equals(getState())
            || CallPeerState.ALERTING_REMOTE_SIDE.equals(getState()))
        {
            if (getLatestInviteTransaction() != null)
            {
                // Someone knows about us. Let's be polite and say we are
                // leaving
                sayCancel();
            }
            setState(CallPeerState.DISCONNECTED);
        }
        else if (peerState.equals(CallPeerState.INCOMING_CALL))
        {
            setState(CallPeerState.DISCONNECTED);
            sayBusyHere();
        }
        // For FAILED and BUSY we only need to update CALL_STATUS
        else if (peerState.equals(CallPeerState.BUSY))
        {
            setState(CallPeerState.DISCONNECTED);
        }
        else if (peerState.equals(CallPeerState.FAILED))
        {
            setState(CallPeerState.DISCONNECTED);
        }
        else
        {
            setState(CallPeerState.DISCONNECTED);
            logger.error(""Could not determine call peer state!"");
        }
    }",False
53,sayBusyHere(),Method,hangup(),,"net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getLatestInviteTransaction() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getLatestInviteTransaction() net.java.sip.communicator.util.Logger+error(Object) net.java.sip.communicator.util.Logger+error(Object) net.java.sip.communicator.service.protocol.OperationFailedException+OperationFailedException(String,int) javax.sip.Transaction+getRequest() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getLatestInviteTransaction() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getLatestInviteTransaction() javax.sip.Transaction+getRequest() net.java.sip.communicator.impl.protocol.sip.SipMessageFactory+createResponse(int,Request) net.java.sip.communicator.impl.protocol.sip.SipMessageFactory+createResponse(int,Request) net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl+throwOperationFailedException(String,int,Throwable,Logger) net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl+throwOperationFailedException(String,int,Throwable,Logger) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getLatestInviteTransaction() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getLatestInviteTransaction() javax.sip.ServerTransaction+sendResponse(Response) javax.sip.ServerTransaction+sendResponse(Response) net.java.sip.communicator.util.Logger+isDebugEnabled() net.java.sip.communicator.util.Logger+isDebugEnabled() net.java.sip.communicator.util.Logger+debug(Object) net.java.sip.communicator.util.Logger+debug(Object) net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl+throwOperationFailedException(String,int,Throwable,Logger) net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl+throwOperationFailedException(String,int,Throwable,Logger)",net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger net.java.sip.communicator.service.protocol.OperationFailedException+INTERNAL_ERROR net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+messageFactory javax.sip.message.Response+BUSY_HERE net.java.sip.communicator.service.protocol.OperationFailedException+INTERNAL_ERROR net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger net.java.sip.communicator.service.protocol.OperationFailedException+NETWORK_FAILURE net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger,1665,47,2,"/** 
 * Sends a BUSY_HERE response to the peer represented by this instance.
 * @throws OperationFailedException if we fail to create or send theresponse
 */
","/**
     * Sends a BUSY_HERE response to the peer represented by this instance.
     *
     * @throws OperationFailedException if we fail to create or send the
     * response
     */
    private void sayBusyHere()
        throws OperationFailedException
    {
        if (!(getLatestInviteTransaction() instanceof ServerTransaction))
        {
            logger.error(""Cannot send BUSY_HERE in a client transaction"");
            throw new OperationFailedException(
                ""Cannot send BUSY_HERE in a client transaction"",
                OperationFailedException.INTERNAL_ERROR);
        }

        Request request = getLatestInviteTransaction().getRequest();
        Response busyHere = null;
        try
        {
            busyHere = messageFactory.createResponse(
                                Response.BUSY_HERE, request);
        }
        catch (ParseException ex)
        {
            ProtocolProviderServiceSipImpl.throwOperationFailedException(
                ""Failed to create the BUSY_HERE response!"",
                OperationFailedException.INTERNAL_ERROR, ex, logger);
        }

        ServerTransaction serverTransaction =
            (ServerTransaction) getLatestInviteTransaction();

        try
        {
            serverTransaction.sendResponse(busyHere);
            if (logger.isDebugEnabled())
                logger.debug(""sent response:\n"" + busyHere);
        }
        catch (Exception ex)
        {
            ProtocolProviderServiceSipImpl.throwOperationFailedException(
                ""Failed to send the BUSY_HERE response"",
                OperationFailedException.NETWORK_FAILURE, ex, logger);
        }
    }",False
54,sayCancel(),Method,hangup(),,"net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getLatestInviteTransaction() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getLatestInviteTransaction() net.java.sip.communicator.util.Logger+error(Object) net.java.sip.communicator.util.Logger+error(Object) net.java.sip.communicator.service.protocol.OperationFailedException+OperationFailedException(String,int) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getLatestInviteTransaction() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getLatestInviteTransaction() javax.sip.ClientTransaction+createCancel() javax.sip.ClientTransaction+createCancel() javax.sip.SipProvider+getNewClientTransaction(Request) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getJainSipProvider() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getJainSipProvider() javax.sip.SipProvider+getNewClientTransaction(Request) javax.sip.ClientTransaction+sendRequest() javax.sip.ClientTransaction+sendRequest() net.java.sip.communicator.util.Logger+isDebugEnabled() net.java.sip.communicator.util.Logger+isDebugEnabled() net.java.sip.communicator.util.Logger+debug(Object) net.java.sip.communicator.util.Logger+debug(Object) net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl+throwOperationFailedException(String,int,Throwable,Logger) net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl+throwOperationFailedException(String,int,Throwable,Logger)",net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger net.java.sip.communicator.service.protocol.OperationFailedException+INTERNAL_ERROR net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger net.java.sip.communicator.service.protocol.OperationFailedException+NETWORK_FAILURE net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger,1323,36,2,"/** 
 * Sends a Cancel request to the peer represented by this instance.
 * @throws OperationFailedException we failed to construct or send theCANCEL request.
 */
","/**
     * Sends a Cancel request to the peer represented by this instance.
     *
     * @throws OperationFailedException we failed to construct or send the
     * CANCEL request.
     */
    private void sayCancel()
        throws OperationFailedException
    {
        if (getLatestInviteTransaction() instanceof ServerTransaction)
        {
            logger.error(""Cannot cancel a server transaction"");
            throw new OperationFailedException(
                ""Cannot cancel a server transaction"",
                OperationFailedException.INTERNAL_ERROR);
        }

        ClientTransaction clientTransaction =
            (ClientTransaction) getLatestInviteTransaction();
        try
        {
            Request cancel = clientTransaction.createCancel();
            ClientTransaction cancelTransaction =
                getJainSipProvider().getNewClientTransaction(
                    cancel);
            cancelTransaction.sendRequest();
            if (logger.isDebugEnabled())
                logger.debug(""sent request:\n"" + cancel);
        }
        catch (SipException ex)
        {
            ProtocolProviderServiceSipImpl.throwOperationFailedException(
                ""Failed to send the CANCEL request"",
                OperationFailedException.NETWORK_FAILURE, ex, logger);
        }
    }",False
55,sayBye(),Method,hangup(),,"net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getDialog() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getDialog() net.java.sip.communicator.impl.protocol.sip.SipMessageFactory+createRequest(Dialog,String) net.java.sip.communicator.impl.protocol.sip.SipMessageFactory+createRequest(Dialog,String) net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl+sendInDialogRequest(SipProvider,Request,Dialog) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getProtocolProvider() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getProtocolProvider() net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl+sendInDialogRequest(SipProvider,Request,Dialog) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getJainSipProvider() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getJainSipProvider() net.java.sip.communicator.impl.protocol.sip.EventPackageUtils+processByeThenIsDialogAlive(Dialog) net.java.sip.communicator.impl.protocol.sip.EventPackageUtils+processByeThenIsDialogAlive(Dialog) net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl+throwOperationFailedException(String,int,Throwable,Logger) net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl+throwOperationFailedException(String,int,Throwable,Logger)",net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+messageFactory javax.sip.message.Request+BYE net.java.sip.communicator.service.protocol.OperationFailedException+INTERNAL_ERROR net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger,1267,36,2,"/** 
 * Sends a BYE request to <tt>callPeer</tt>.
 * @return <tt>true</tt> if the <tt>Dialog</tt> should be consideredalive after sending the BYE request (e.g. when there're still active subscriptions); <tt>false</tt>, otherwise
 * @throws OperationFailedException if we failed constructing or sending aSIP Message.
 */
","/**
     * Sends a BYE request to <tt>callPeer</tt>.
     *
     * @return <tt>true</tt> if the <tt>Dialog</tt> should be considered
     * alive after sending the BYE request (e.g. when there're still active
     * subscriptions); <tt>false</tt>, otherwise
     *
     * @throws OperationFailedException if we failed constructing or sending a
     * SIP Message.
     */
    private boolean sayBye() throws OperationFailedException
    {
        Dialog dialog = getDialog();

        Request bye = messageFactory.createRequest(dialog, Request.BYE);

        getProtocolProvider().sendInDialogRequest(
                        getJainSipProvider(), bye, dialog);

        /*
         * Let subscriptions such as the ones associated with REFER requests
         * keep the dialog alive and correctly delete it when they are
         * terminated.
         */
        try
        {
            return EventPackageUtils.processByeThenIsDialogAlive(dialog);
        }
        catch (SipException ex)
        {
            ProtocolProviderServiceSipImpl.throwOperationFailedException(
                ""Failed to determine whether the dialog should stay alive."",
                OperationFailedException.INTERNAL_ERROR, ex, logger);
            return false;
        }
    }",False
56,answer(),Method,,"net.java.sip.communicator.impl.protocol.sip.CallSipImpl+processReplacingInvite(SipProvider,ServerTransaction,CallPeerSipImpl) net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl+answerCallPeer(CallPeer) net.java.sip.communicator.impl.protocol.sip.OperationSetVideoTelephonySipImpl+answerVideoCallPeer(CallPeer)","net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getLatestInviteTransaction() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getLatestInviteTransaction() net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) net.java.sip.communicator.service.protocol.OperationFailedException+OperationFailedException(String,int) net.java.sip.communicator.service.protocol.AbstractCallPeer+getState() net.java.sip.communicator.service.protocol.AbstractCallPeer+getState() java.lang.Object+equals(Object) java.lang.Object+equals(Object) net.java.sip.communicator.service.protocol.CallPeerState+isOnHold(CallPeerState) net.java.sip.communicator.service.protocol.CallPeerState+isOnHold(CallPeerState) net.java.sip.communicator.util.Logger+isInfoEnabled() net.java.sip.communicator.util.Logger+isInfoEnabled() net.java.sip.communicator.util.Logger+info(Object) net.java.sip.communicator.util.Logger+info(Object) javax.sip.Transaction+getRequest() javax.sip.Transaction+getRequest() net.java.sip.communicator.impl.protocol.sip.SipMessageFactory+createResponse(int,Request) net.java.sip.communicator.impl.protocol.sip.SipMessageFactory+createResponse(int,Request) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+reflectConferenceFocus(Message) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+reflectConferenceFocus(Message) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl+throwOperationFailedException(String,int,Throwable,Logger) net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl+throwOperationFailedException(String,int,Throwable,Logger) javax.sip.header.HeaderFactory+createContentTypeHeader(String,String) net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl+getHeaderFactory() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getProtocolProvider() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getProtocolProvider() net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl+getHeaderFactory() javax.sip.header.HeaderFactory+createContentTypeHeader(String,String) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl+throwOperationFailedException(String,int,Throwable,Logger) net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl+throwOperationFailedException(String,int,Throwable,Logger) javax.sip.message.Message+getContentLength() javax.sip.message.Message+getContentLength() javax.sip.header.ContentLengthHeader+getContentLength() javax.sip.header.ContentLengthHeader+getContentLength() net.java.sip.communicator.impl.protocol.sip.sdp.SdpUtils+getContentAsString(Message) net.java.sip.communicator.impl.protocol.sip.sdp.SdpUtils+getContentAsString(Message) java.lang.String+length() java.lang.String+length() net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl+processOffer(String) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl+processOffer(String) net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl+createOffer() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl+createOffer() javax.sip.message.Message+setContent(Object,ContentTypeHeader) javax.sip.message.Message+setContent(Object,ContentTypeHeader) net.java.sip.communicator.util.Logger+error(Object,Throwable) net.java.sip.communicator.util.Logger+error(Object,Throwable) net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl+sayError(ServerTransaction,int) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getProtocolProvider() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getProtocolProvider() net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl+sayError(ServerTransaction,int) javax.sip.ServerTransaction+sendResponse(Response) javax.sip.ServerTransaction+sendResponse(Response) net.java.sip.communicator.util.Logger+isDebugEnabled() net.java.sip.communicator.util.Logger+isDebugEnabled() net.java.sip.communicator.util.Logger+debug(Object) net.java.sip.communicator.util.Logger+debug(Object) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl+throwOperationFailedException(String,int,Throwable,Logger) net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl+throwOperationFailedException(String,int,Throwable,Logger) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+fireRequestProcessed(Request,Response) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+fireRequestProcessed(Request,Response) java.lang.String+length() java.lang.String+length() net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState) net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState)",net.java.sip.communicator.service.protocol.CallPeerState+DISCONNECTED net.java.sip.communicator.service.protocol.OperationFailedException+INTERNAL_ERROR net.java.sip.communicator.service.protocol.CallPeerState+CONNECTED net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+messageFactory javax.sip.message.Response+OK net.java.sip.communicator.service.protocol.CallPeerState+DISCONNECTED net.java.sip.communicator.service.protocol.OperationFailedException+INTERNAL_ERROR net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger net.java.sip.communicator.service.protocol.CallPeerState+DISCONNECTED net.java.sip.communicator.service.protocol.OperationFailedException+INTERNAL_ERROR net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger javax.sip.message.Response+NOT_ACCEPTABLE_HERE net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger net.java.sip.communicator.service.protocol.CallPeerState+DISCONNECTED net.java.sip.communicator.service.protocol.OperationFailedException+NETWORK_FAILURE net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger net.java.sip.communicator.service.protocol.CallPeerState+CONNECTING_INCOMING_CALL_WITH_MEDIA net.java.sip.communicator.service.protocol.CallPeerState+CONNECTING_INCOMING_CALL,5105,136,33,"/** 
 * Indicates a user request to answer an incoming call from this <tt>CallPeer</tt>. Sends an OK response to <tt>callPeer</tt>. Make sure that the call peer contains an SDP description when you call this method.
 * @throws OperationFailedException if we fail to create or send theresponse.
 */
","/**
     * Indicates a user request to answer an incoming call from this
     * <tt>CallPeer</tt>.
     *
     * Sends an OK response to <tt>callPeer</tt>. Make sure that the call
     * peer contains an SDP description when you call this method.
     *
     * @throws OperationFailedException if we fail to create or send the
     * response.
     */
    public synchronized void answer()
        throws OperationFailedException
    {
        Transaction transaction = getLatestInviteTransaction();

        if (transaction == null ||
            !(transaction instanceof ServerTransaction))
        {
            setState(CallPeerState.DISCONNECTED);
            throw new OperationFailedException(
                ""Failed to extract a ServerTransaction ""
                    + ""from the call's associated dialog!"",
                OperationFailedException.INTERNAL_ERROR);
        }

        CallPeerState peerState = getState();

        if (peerState.equals(CallPeerState.CONNECTED)
            || CallPeerState.isOnHold(peerState))
        {
            if (logger.isInfoEnabled())
                logger.info(""Ignoring user request to answer a CallPeer ""
                        + ""that is already connected. CP:"");
            return;
        }

        ServerTransaction serverTransaction = (ServerTransaction) transaction;
        Request invite = serverTransaction.getRequest();
        Response ok = null;
        try
        {
            ok = messageFactory.createResponse(Response.OK, invite);

            /*
             * If the local peer represented by the Call of this CallPeer is
             * acting as a conference focus, it must indicate it in its Contact
             * header.
             */
            reflectConferenceFocus(ok);
        }
        catch (ParseException ex)
        {
            setState(CallPeerState.DISCONNECTED);
            ProtocolProviderServiceSipImpl.throwOperationFailedException(
                ""Failed to construct an OK response to an INVITE request"",
                OperationFailedException.INTERNAL_ERROR, ex, logger);
        }

        // Content
        ContentTypeHeader contentTypeHeader = null;
        try
        {
            // content type should be application/sdp (not applications)
            // reported by Oleg Shevchenko (Miratech)
            contentTypeHeader = getProtocolProvider().getHeaderFactory()
                .createContentTypeHeader(""application"", ""sdp"");
        }
        catch (ParseException ex)
        {
            // Shouldn't happen
            setState(CallPeerState.DISCONNECTED);
            ProtocolProviderServiceSipImpl.throwOperationFailedException(
                ""Failed to create a content type header for the OK response"",
                OperationFailedException.INTERNAL_ERROR, ex, logger);
        }

        // This is the sdp offer that came from the initial invite,
        // also that invite can have no offer.
        String sdpOffer = null;
        try
        {
            // extract the SDP description.
            // beware: SDP description may be in ACKs so it could be that
            // there's nothing here - bug report Laurent Michel
            ContentLengthHeader cl = invite.getContentLength();
            if (cl != null && cl.getContentLength() > 0)
            {
                sdpOffer = SdpUtils.getContentAsString(invite);
            }

            String sdp;
            // if the offer was in the invite create an SDP answer
            if ((sdpOffer != null) && (sdpOffer.length() > 0))
            {
                sdp = getMediaHandler().processOffer(sdpOffer);
            }
            // if there was no offer in the invite - create an offer
            else
            {
                sdp = getMediaHandler().createOffer();
            }
            ok.setContent(sdp, contentTypeHeader);
        }
        catch (Exception ex)
        {
            //log, the error and tell the remote party. do not throw an
            //exception as it would go to the stack and there's nothing it could
            //do with it.
            logger.error(
                ""Failed to create an SDP description for an OK response ""
                    + ""to an INVITE request!"", ex);
            getProtocolProvider().sayError(
                            serverTransaction, Response.NOT_ACCEPTABLE_HERE);
        }

        try
        {
            serverTransaction.sendResponse(ok);
            if (logger.isDebugEnabled())
                logger.debug(""sent response\n"" + ok);
        }
        catch (Exception ex)
        {
            setState(CallPeerState.DISCONNECTED);
            ProtocolProviderServiceSipImpl.throwOperationFailedException(
                ""Failed to send an OK response to an INVITE request"",
                OperationFailedException.NETWORK_FAILURE, ex, logger);
        }

        fireRequestProcessed(invite, ok);

        if(sdpOffer != null && sdpOffer.length() > 0)
            setState(CallPeerState.CONNECTING_INCOMING_CALL_WITH_MEDIA);
        else
            setState(CallPeerState.CONNECTING_INCOMING_CALL);
    }",False
57,putOnHold(boolean),Method,,"net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl+putOnHold(CallPeer,boolean)","net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler+setLocallyOnHold(boolean) net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler+setLocallyOnHold(boolean) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+sendReInvite(String) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+sendReInvite(String) net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl+createOffer() net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl+createOffer() net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl+throwOperationFailedException(String,int,Throwable,Logger) net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl+throwOperationFailedException(String,int,Throwable,Logger) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+reevalLocalHoldStatus() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+reevalLocalHoldStatus()",net.java.sip.communicator.service.protocol.OperationFailedException+INTERNAL_ERROR net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger,931,29,1,"/** 
 * Puts the <tt>CallPeer</tt> represented by this instance on or off hold.
 * @param onHold <tt>true</tt> to have the <tt>CallPeer</tt> put on hold;<tt>false</tt>, otherwise
 * @throws OperationFailedException if we fail to construct or send theINVITE request putting the remote side on/off hold.
 */
","/**
     * Puts the <tt>CallPeer</tt> represented by this instance on or off hold.
     *
     * @param onHold <tt>true</tt> to have the <tt>CallPeer</tt> put on hold;
     * <tt>false</tt>, otherwise
     *
     * @throws OperationFailedException if we fail to construct or send the
     * INVITE request putting the remote side on/off hold.
     */
    public void putOnHold(boolean onHold)
        throws OperationFailedException
    {
        CallPeerMediaHandlerSipImpl mediaHandler = getMediaHandler();

        mediaHandler.setLocallyOnHold(onHold);

        try
        {
            sendReInvite(mediaHandler.createOffer());
        }
        catch (Exception ex)
        {
            ProtocolProviderServiceSipImpl.throwOperationFailedException(
                ""Failed to create SDP offer to hold."",
                OperationFailedException.INTERNAL_ERROR, ex, logger);
        }

        reevalLocalHoldStatus();
    }",False
58,sendReInvite(),Method,,"net.java.sip.communicator.impl.protocol.sip.CallSipImpl+reInvite() net.java.sip.communicator.impl.protocol.sip.OperationSetTelephonyConferencingSipImpl+inviteCalleeToCall(Address,CallSipImpl)",net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+sendReInvite(String) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+sendReInvite(String) net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl+createOffer() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl+createOffer(),,328,11,0,"/** 
 * Sends a reINVITE request to this <tt>CallPeer</tt> within its current <tt>Dialog</tt>.
 * @throws OperationFailedException if sending the reINVITE request fails
 */
","/**
     * Sends a reINVITE request to this <tt>CallPeer</tt> within its current
     * <tt>Dialog</tt>.
     *
     * @throws OperationFailedException if sending the reINVITE request fails
     */
    void sendReInvite()
        throws OperationFailedException
    {
        sendReInvite(getMediaHandler().createOffer());
    }",False
59,sendReInvite(String),Method,putOnHold(boolean) sendReInvite(),,"net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getDialog() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getDialog() net.java.sip.communicator.impl.protocol.sip.SipMessageFactory+createRequest(Dialog,String) net.java.sip.communicator.impl.protocol.sip.SipMessageFactory+createRequest(Dialog,String) javax.sip.message.Message+setContent(Object,ContentTypeHeader) javax.sip.message.Message+setContent(Object,ContentTypeHeader) javax.sip.header.HeaderFactory+createContentTypeHeader(String,String) net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl+getHeaderFactory() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getProtocolProvider() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getProtocolProvider() net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl+getHeaderFactory() javax.sip.header.HeaderFactory+createContentTypeHeader(String,String) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+reflectConferenceFocus(Message) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+reflectConferenceFocus(Message) net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl+throwOperationFailedException(String,int,Throwable,Logger) net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl+throwOperationFailedException(String,int,Throwable,Logger) net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl+sendInDialogRequest(SipProvider,Request,Dialog) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getProtocolProvider() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getProtocolProvider() net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl+sendInDialogRequest(SipProvider,Request,Dialog) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getJainSipProvider() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getJainSipProvider()",net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+messageFactory javax.sip.message.Request+INVITE net.java.sip.communicator.service.protocol.OperationFailedException+INTERNAL_ERROR net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger,1452,40,2,"/** 
 * Sends a reINVITE request with a specific <tt>sdpOffer</tt> (description) within the current <tt>Dialog</tt> with the call peer represented by this instance.
 * @param sdpOffer the offer that we'd like to use for the newly createdINVITE request.
 * @throws OperationFailedException if sending the request fails for somereason.
 */
","/**
     * Sends a reINVITE request with a specific <tt>sdpOffer</tt> (description)
     * within the current <tt>Dialog</tt> with the call peer represented by
     * this instance.
     *
     * @param sdpOffer the offer that we'd like to use for the newly created
     * INVITE request.
     *
     * @throws OperationFailedException if sending the request fails for some
     * reason.
     */
    private void sendReInvite(String sdpOffer)
        throws OperationFailedException
    {
        Dialog dialog = getDialog();
        Request invite = messageFactory.createRequest(dialog, Request.INVITE);

        try
        {
            // Content-Type
            invite.setContent(sdpOffer, getProtocolProvider().getHeaderFactory()
                .createContentTypeHeader(""application"", ""sdp""));

            /*
             * If the local peer represented by the Call of this CallPeer is
             * acting as a conference focus, it must indicate it in its Contact
             * header.
             */
            reflectConferenceFocus(invite);
        }
        catch (ParseException ex)
        {
            ProtocolProviderServiceSipImpl.throwOperationFailedException(
                ""Failed to parse SDP offer for the new invite."",
                OperationFailedException.INTERNAL_ERROR, ex, logger);
        }

        getProtocolProvider().sendInDialogRequest(
                        getJainSipProvider(), invite, dialog);
    }",False
60,invite(),Method,,"net.java.sip.communicator.impl.protocol.sip.CallSipImpl+invite(Address,javax.sip.message.Message)","net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getLatestInviteTransaction() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getLatestInviteTransaction() javax.sip.Transaction+getRequest() javax.sip.Transaction+getRequest() javax.sip.header.HeaderFactory+createContentTypeHeader(String,String) net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl+getHeaderFactory() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getProtocolProvider() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getProtocolProvider() net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl+getHeaderFactory() javax.sip.header.HeaderFactory+createContentTypeHeader(String,String) javax.sip.message.Message+setContent(Object,ContentTypeHeader) javax.sip.message.Message+setContent(Object,ContentTypeHeader) net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl+createOffer() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.impl.protocol.sip.CallPeerMediaHandlerSipImpl+createOffer() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+reflectConferenceFocus(Message) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+reflectConferenceFocus(Message) javax.sip.ClientTransaction+sendRequest() javax.sip.ClientTransaction+sendRequest() net.java.sip.communicator.util.Logger+isDebugEnabled() net.java.sip.communicator.util.Logger+isDebugEnabled() net.java.sip.communicator.util.Logger+debug(Object) net.java.sip.communicator.util.Logger+debug(Object) javax.sip.Transaction+getRequest() javax.sip.Transaction+getRequest() net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl+throwOperationFailedException(String,int,Throwable,Logger) net.java.sip.communicator.impl.protocol.sip.ProtocolProviderServiceSipImpl+throwOperationFailedException(String,int,Throwable,Logger)",net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger net.java.sip.communicator.service.protocol.OperationFailedException+NETWORK_FAILURE net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+logger,1816,46,1,"/** 
 * Creates a <tt>CallPeerSipImpl</tt> from <tt>calleeAddress</tt> and sends them an invite request. The invite request will be initialized according to any relevant parameters in the <tt>cause</tt> message (if different from <tt>null</tt>) that is the reason for creating this call.
 * @throws OperationFailedException  with the corresponding code if we failto create the call or in case we someone calls us mistakenly while we are actually wrapped around an invite transaction.
 */
","/**
     * Creates a <tt>CallPeerSipImpl</tt> from <tt>calleeAddress</tt> and sends
     * them an invite request. The invite request will be initialized according
     * to any relevant parameters in the <tt>cause</tt> message (if different
     * from <tt>null</tt>) that is the reason for creating this call.
     *
     * @throws OperationFailedException  with the corresponding code if we fail
     *  to create the call or in case we someone calls us mistakenly while we
     *  are actually wrapped around an invite transaction.
     */
    public void invite()
        throws OperationFailedException
    {
        try
        {
            ClientTransaction inviteTran
                = (ClientTransaction) getLatestInviteTransaction();
            Request invite = inviteTran.getRequest();

            // Content-Type
            ContentTypeHeader contentTypeHeader
                = getProtocolProvider()
                    .getHeaderFactory()
                        .createContentTypeHeader(""application"", ""sdp"");

            invite
                .setContent(getMediaHandler().createOffer(), contentTypeHeader);

            /*
             * If the local peer represented by the Call of this CallPeer is
             * acting as a conference focus, it must indicate it in its Contact
             * header.
             */
            reflectConferenceFocus(invite);

            inviteTran.sendRequest();
            if (logger.isDebugEnabled())
                logger.debug(""sent request:\n"" + inviteTran.getRequest());
        }
        catch (Exception ex)
        {
            ProtocolProviderServiceSipImpl.throwOperationFailedException(
                ""An error occurred while sending invite request"",
                OperationFailedException.NETWORK_FAILURE, ex, logger);
        }
    }",False
61,reflectConferenceFocus(javax.sip.message.Message),Method,,,"javax.sip.message.Message+getHeader(String) javax.sip.message.Message+getHeader(String) net.java.sip.communicator.service.protocol.media.AbstractMediaAwareCall+isConferenceFocus() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getCall() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getCall() net.java.sip.communicator.service.protocol.media.AbstractMediaAwareCall+isConferenceFocus() javax.sip.header.Parameters+setParameter(String,String) javax.sip.header.Parameters+setParameter(String,String) javax.sip.header.Parameters+removeParameter(String) javax.sip.header.Parameters+removeParameter(String)",javax.sip.header.ContactHeader+NAME,1204,29,2,"/** 
 * Reflects the value of the <tt>conferenceFocus</tt> property of the <tt>Call</tt> of this <tt>CallPeer</tt> in the specified SIP <tt>Message</tt>.
 * @param message the SIP <tt>Message</tt> in which the value of the<tt>conferenceFocus</tt> property of the <tt>Call</tt> of this <tt>CallPeer</tt> is to be reflected
 * @throws ParseException if modifying the specified SIP <tt>Message</tt> toreflect the <tt>conferenceFocus</tt> property of the <tt>Call</tt> of this <tt>CallPeer</tt> fails
 */
","/**
     * Reflects the value of the <tt>conferenceFocus</tt> property of the
     * <tt>Call</tt> of this <tt>CallPeer</tt> in the specified SIP
     * <tt>Message</tt>.
     *
     * @param message the SIP <tt>Message</tt> in which the value of the
     * <tt>conferenceFocus</tt> property of the <tt>Call</tt> of this
     * <tt>CallPeer</tt> is to be reflected
     * @throws ParseException if modifying the specified SIP <tt>Message</tt> to
     * reflect the <tt>conferenceFocus</tt> property of the <tt>Call</tt> of
     * this <tt>CallPeer</tt> fails
     */
    private void reflectConferenceFocus(javax.sip.message.Message message)
        throws ParseException
    {
        ContactHeader contactHeader
            = (ContactHeader) message.getHeader(ContactHeader.NAME);

        if (contactHeader != null)
        {
            // we must set the value of the parameter as null
            // in order to avoid wrong generation of the tag - ';isfocus='
            // as it must be ';isfocus'
            if (getCall().isConferenceFocus())
                contactHeader.setParameter(""isfocus"", null);
            else
                contactHeader.removeParameter(""isfocus"");
        }
    }",False
62,setLocalVideoAllowed(boolean),Method,,"net.java.sip.communicator.impl.protocol.sip.CallSipImpl+setLocalVideoAllowed(boolean,MediaUseCase)",net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler+isLocalVideoTransmissionEnabled() net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler+isLocalVideoTransmissionEnabled() net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler+setLocalVideoTransmissionEnabled(boolean) net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler+setLocalVideoTransmissionEnabled(boolean),,880,22,1,"/** 
 * Modifies the local media setup to reflect the requested setting for the streaming of the local video and then re-invites the peer represented by this class using a corresponding SDP description..
 * @param allowed <tt>true</tt> if local video transmission is allowed and<tt>false</tt> otherwise.
 * @throws OperationFailedException if video initialization fails.
 */
","/**
     * Modifies the local media setup to reflect the requested setting for the
     * streaming of the local video and then re-invites the peer represented by
     * this class using a corresponding SDP description..
     *
     * @param allowed <tt>true</tt> if local video transmission is allowed and
     * <tt>false</tt> otherwise.
     *
     *  @throws OperationFailedException if video initialization fails.
     */
    public void setLocalVideoAllowed(boolean allowed)
        throws OperationFailedException
    {
        CallPeerMediaHandlerSipImpl mediaHandler = getMediaHandler();

        if(mediaHandler.isLocalVideoTransmissionEnabled() == allowed)
            return;

        // Modify the local media setup to reflect the requested setting for
        // the streaming of the local video.
        mediaHandler.setLocalVideoTransmissionEnabled(allowed);
    }",True
63,isLocalVideoStreaming(),Method,,net.java.sip.communicator.impl.protocol.sip.CallSipImpl+isLocalVideoStreaming(),net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler+isLocalVideoTransmissionEnabled() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler+isLocalVideoTransmissionEnabled(),,398,11,1,"/** 
 * Determines whether we are currently streaming video toward whoever this <tt>CallPeerSipImpl</tt> represents.
 * @return <tt>true</tt> if we are currently streaming video toward this<tt>CallPeer</tt> and  <tt>false</tt> otherwise.
 */
","/**
     * Determines whether we are currently streaming video toward whoever this
     * <tt>CallPeerSipImpl</tt> represents.
     *
     * @return <tt>true</tt> if we are currently streaming video toward this
     *  <tt>CallPeer</tt> and  <tt>false</tt> otherwise.
     */
    public boolean isLocalVideoStreaming()
    {
        return getMediaHandler().isLocalVideoTransmissionEnabled();
    }",True
64,addVideoPropertyChangeListener(PropertyChangeListener),Method,,net.java.sip.communicator.impl.protocol.sip.CallSipImpl+addVideoPropertyChangeListener(PropertyChangeListener),java.lang.NullPointerException+NullPointerException(String) java.util.List+contains(Object) java.util.List+contains(Object) java.util.List+add(E) java.util.List+add(E) +() +propertyChange(PropertyChangeEvent),net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+videoPropertyChangeListeners net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+videoPropertyChangeListeners net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+videoPropertyChangeListeners net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+mediaHandlerPropertyChangeListener net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+mediaHandlerPropertyChangeListener,2525,58,1,"/** 
 * Adds a specific <tt>PropertyChangeListener</tt> to the list of listeners which get notified when the properties (e.g. LOCAL_VIDEO_STREAMING) associated with this <tt>CallPeer</tt> change their values.
 * @param listener the <tt>PropertyChangeListener</tt> to be notifiedwhen the properties associated with the specified <tt>Call</tt> change their values
 */
","/**
     * Adds a specific <tt>PropertyChangeListener</tt> to the list of
     * listeners which get notified when the properties (e.g.
     * LOCAL_VIDEO_STREAMING) associated with this <tt>CallPeer</tt> change
     * their values.
     *
     * @param listener the <tt>PropertyChangeListener</tt> to be notified
     * when the properties associated with the specified <tt>Call</tt> change
     * their values
     */
    public void addVideoPropertyChangeListener(PropertyChangeListener listener)
    {
        if (listener == null)
            throw new NullPointerException(""listener"");

        synchronized (videoPropertyChangeListeners)
        {
            /*
             * The video is part of the media-related functionality and thus it
             * is the responsibility of mediaHandler. So listen to mediaHandler
             * for video-related property changes and re-fire them as
             * originating from this instance.
             */
            if (!videoPropertyChangeListeners.contains(listener)
                    && videoPropertyChangeListeners.add(listener)
                    && (mediaHandlerPropertyChangeListener == null))
            {
                mediaHandlerPropertyChangeListener
                    = new PropertyChangeListener()
                    {
                        public void propertyChange(PropertyChangeEvent event)
                        {
                            Iterable<PropertyChangeListener> listeners;

                            synchronized (videoPropertyChangeListeners)
                            {
                                listeners
                                    = new LinkedList<PropertyChangeListener>(
                                            videoPropertyChangeListeners);
                            }

                            PropertyChangeEvent thisEvent
                                = new PropertyChangeEvent(
                                        this,
                                        event.getPropertyName(),
                                        event.getOldValue(),
                                        event.getNewValue());

                            for (PropertyChangeListener listener : listeners)
                                listener.propertyChange(thisEvent);
                        }
                    };
                getMediaHandler()
                    .addPropertyChangeListener(
                        mediaHandlerPropertyChangeListener);
            }
        }
    }",True
65,removeVideoPropertyChangeListener(PropertyChangeListener),Method,,net.java.sip.communicator.impl.protocol.sip.CallSipImpl+removeVideoPropertyChangeListener(PropertyChangeListener),java.util.List+remove(Object) java.util.List+remove(Object) java.util.List+isEmpty() java.util.List+isEmpty(),net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+videoPropertyChangeListeners net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+videoPropertyChangeListeners net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+videoPropertyChangeListeners net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+mediaHandlerPropertyChangeListener net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+mediaHandlerPropertyChangeListener,1704,36,1,"/** 
 * Removes a specific <tt>PropertyChangeListener</tt> from the list of listeners which get notified when the properties (e.g. LOCAL_VIDEO_STREAMING) associated with this <tt>CallPeer</tt> change their values.
 * @param listener the <tt>PropertyChangeListener</tt> to no longer benotified when the properties associated with the specified <tt>Call</tt> change their values
 */
","/**
     * Removes a specific <tt>PropertyChangeListener</tt> from the list of
     * listeners which get notified when the properties (e.g.
     * LOCAL_VIDEO_STREAMING) associated with this <tt>CallPeer</tt> change
     * their values.
     *
     * @param listener the <tt>PropertyChangeListener</tt> to no longer be
     * notified when the properties associated with the specified <tt>Call</tt>
     * change their values
     */
    public void removeVideoPropertyChangeListener(
                                               PropertyChangeListener listener)
    {
        if (listener != null)
            synchronized (videoPropertyChangeListeners)
            {
                /*
                 * The video is part of the media-related functionality and thus
                 * it is the responsibility of mediaHandler. So we're listening
                 * to mediaHandler for video-related property changes and w're
                 * re-firing them as originating from this instance. Make sure
                 * that we're not listening to mediaHandler if noone is
                 * interested in video-related property changes originating from
                 * this instance.
                 */
                if (videoPropertyChangeListeners.remove(listener)
                        && videoPropertyChangeListeners.isEmpty()
                        && (mediaHandlerPropertyChangeListener != null))
                {
//                    getMediaHandler()
//                        .removePropertyChangeListener(
//                            mediaHandlerPropertyChangeListener);
                    mediaHandlerPropertyChangeListener = null;
                }
            }
    }",True
66,addMethodProcessorListener(MethodProcessorListener),Method,,net.java.sip.communicator.impl.protocol.sip.OperationSetTelephonyConferencingSipImpl+callPeerAdded(CallPeerEvent),java.lang.NullPointerException+NullPointerException(String) java.util.List+contains(Object) java.util.List+contains(Object) java.util.List+add(E) java.util.List+add(E),net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+methodProcessorListeners net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+methodProcessorListeners net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+methodProcessorListeners,853,21,0,"/** 
 * Registers a specific <tt>MethodProcessorListener</tt> with this <tt>CallPeer</tt> so that it gets notified by this instance about the processing of SIP signaling. If the specified <tt>listener</tt> is already registered with this instance, does nothing
 * @param listener the <tt>MethodProcessorListener</tt> to be registeredwith this <tt>CallPeer</tt> so that it gets notified by this instance about the processing of SIP signaling
 */
","/**
     * Registers a specific <tt>MethodProcessorListener</tt> with this
     * <tt>CallPeer</tt> so that it gets notified by this instance about the
     * processing of SIP signaling. If the specified <tt>listener</tt> is
     * already registered with this instance, does nothing
     *
     * @param listener the <tt>MethodProcessorListener</tt> to be registered
     * with this <tt>CallPeer</tt> so that it gets notified by this instance
     * about the processing of SIP signaling
     */
    void addMethodProcessorListener(MethodProcessorListener listener)
    {
        if (listener == null)
            throw new NullPointerException(""listener"");

        synchronized (methodProcessorListeners)
        {
            if (!methodProcessorListeners.contains(listener))
                methodProcessorListeners.add(listener);
        }
    }",False
67,"fireRequestProcessed(Request,Response)",Method,processReInvite(ServerTransaction) answer(),,"java.util.LinkedList+LinkedList(Collection) net.java.sip.communicator.impl.protocol.sip.MethodProcessorListener+requestProcessed(CallPeerSipImpl,Request,Response) net.java.sip.communicator.impl.protocol.sip.MethodProcessorListener+requestProcessed(CallPeerSipImpl,Request,Response)",net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+methodProcessorListeners net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+methodProcessorListeners,924,24,4,"/** 
 * Notifies the <tt>MethodProcessorListener</tt>s registered with this <tt>CallPeer</tt> that it has processed a specific SIP <tt>Request</tt> by sending a specific SIP <tt>Response</tt>.
 * @param request the SIP <tt>Request</tt> processed by this<tt>CallPeer</tt>
 * @param response the SIP <tt>Response</tt> this <tt>CallPeer</tt> sent aspart of its processing of the specified <tt>request</tt>
 */
","/**
     * Notifies the <tt>MethodProcessorListener</tt>s registered with this
     * <tt>CallPeer</tt> that it has processed a specific SIP <tt>Request</tt>
     * by sending a specific SIP <tt>Response</tt>.
     *
     * @param request the SIP <tt>Request</tt> processed by this
     * <tt>CallPeer</tt>
     * @param response the SIP <tt>Response</tt> this <tt>CallPeer</tt> sent as
     * part of its processing of the specified <tt>request</tt>
     */
    protected void fireRequestProcessed(Request request, Response response)
    {
        Iterable<MethodProcessorListener> listeners;

        synchronized (methodProcessorListeners)
        {
            listeners
                = new LinkedList<MethodProcessorListener>(
                        methodProcessorListeners);
        }

        for (MethodProcessorListener listener : listeners)
            listener.requestProcessed(this, request, response);
    }",False
68,"fireResponseProcessed(Response,Request)",Method,"processInviteOK(ClientTransaction,Response)",,"java.util.LinkedList+LinkedList(Collection) net.java.sip.communicator.impl.protocol.sip.MethodProcessorListener+responseProcessed(CallPeerSipImpl,Response,Request) net.java.sip.communicator.impl.protocol.sip.MethodProcessorListener+responseProcessed(CallPeerSipImpl,Response,Request)",net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+methodProcessorListeners net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+methodProcessorListeners,927,24,4,"/** 
 * Notifies the <tt>MethodProcessorListener</tt>s registered with this <tt>CallPeer</tt> that it has processed a specific SIP <tt>Response</tt> by sending a specific SIP <tt>Request</tt>.
 * @param response the SIP <tt>Response</tt> processed by this<tt>CallPeer</tt>
 * @param request the SIP <tt>Request</tt> this <tt>CallPeer</tt> sent aspart of its processing of the specified <tt>response</tt>
 */
","/**
     * Notifies the <tt>MethodProcessorListener</tt>s registered with this
     * <tt>CallPeer</tt> that it has processed a specific SIP <tt>Response</tt>
     * by sending a specific SIP <tt>Request</tt>.
     *
     * @param response the SIP <tt>Response</tt> processed by this
     * <tt>CallPeer</tt>
     * @param request the SIP <tt>Request</tt> this <tt>CallPeer</tt> sent as
     * part of its processing of the specified <tt>response</tt>
     */
    protected void fireResponseProcessed(Response response, Request request)
    {
        Iterable<MethodProcessorListener> listeners;

        synchronized (methodProcessorListeners)
        {
            listeners
                = new LinkedList<MethodProcessorListener>(
                        methodProcessorListeners);
        }

        for (MethodProcessorListener listener : listeners)
            listener.responseProcessed(this, response, request);
    }",False
69,removeMethodProcessorListener(MethodProcessorListener),Method,,net.java.sip.communicator.impl.protocol.sip.OperationSetTelephonyConferencingSipImpl+callPeerRemoved(CallPeerEvent),java.util.List+remove(Object) java.util.List+remove(Object),net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+methodProcessorListeners net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+methodProcessorListeners,773,18,0,"/** 
 * Unregisters a specific <tt>MethodProcessorListener</tt> from this <tt>CallPeer</tt> so that it no longer gets notified by this instance about the processing of SIP signaling. If the specified <tt>listener</tt> is not registered with this instance, does nothing.
 * @param listener the <tt>MethodProcessorListener</tt> to be unregisteredfrom this <tt>CallPeer</tt> so that it no longer gets notified by this instance about the processing of SIP signaling
 */
","/**
     * Unregisters a specific <tt>MethodProcessorListener</tt> from this
     * <tt>CallPeer</tt> so that it no longer gets notified by this instance
     * about the processing of SIP signaling. If the specified <tt>listener</tt>
     * is not registered with this instance, does nothing.
     *
     * @param listener the <tt>MethodProcessorListener</tt> to be unregistered
     * from this <tt>CallPeer</tt> so that it no longer gets notified by this
     * instance about the processing of SIP signaling
     */
    void removeMethodProcessorListener(MethodProcessorListener listener)
    {
        if (listener != null)
            synchronized (methodProcessorListeners)
            {
                methodProcessorListeners.remove(listener);
            }
    }",False
70,handleAuthenticationChallenge(ClientTransaction),Method,,"net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl+processAuthenticationChallenge(ClientTransaction,Response,SipProvider)",net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+setDialog(Dialog) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+setDialog(Dialog) javax.sip.Transaction+getDialog() javax.sip.Transaction+getDialog() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+setLatestInviteTransaction(Transaction) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+setLatestInviteTransaction(Transaction) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+setJainSipProvider(SipProvider) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+setJainSipProvider(SipProvider),net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+jainSipProvider,744,17,1,"/** 
 * Updates this call so that it would record a new transaction and dialog that have been recreated because of a re-authentication.
 * @param retryTran the new transaction
 */
","/**
     * Updates this call so that it would record a new transaction and dialog
     * that have been recreated because of a re-authentication.
     *
     * @param retryTran the new transaction
     */
    public void handleAuthenticationChallenge(ClientTransaction retryTran)
    {
        // There is a new dialog that will be started with this request. Get
        // that dialog and record it into the Call object for later use (by
        // BYEs for example).
        // if the request was BYE then we need to authorize it anyway even
        // if the call and the call peer are no longer there
        setDialog(retryTran.getDialog());
        setLatestInviteTransaction(retryTran);
        setJainSipProvider(jainSipProvider);
    }",False
71,getMediaHandler(),Method,"getCallInfoURL() isMute() processReInvite(ServerTransaction) processReInvite(ServerTransaction) reevalRemoteHoldStatus() reevalLocalHoldStatus() processBye(ServerTransaction) setMute(boolean) processAck(ServerTransaction,Request) processSessionProgress(ClientTransaction,Response) processInviteOK(ClientTransaction,Response) answer() answer() putOnHold(boolean) sendReInvite() invite() setLocalVideoAllowed(boolean) isLocalVideoStreaming() setState(CallPeerState,String) setState(CallPeerState,String) addStreamSoundLevelListener(SoundLevelListener) removeStreamSoundLevelListener(SoundLevelListener) addConferenceMembersSoundLevelListener(ConferenceMembersSoundLevelListener) removeConferenceMembersSoundLevelListener(ConferenceMembersSoundLevelListener) securityTurnedOn(int,String,String,boolean,byte[]) conferenceMemberAdded(CallPeerConferenceEvent) conferenceMemberRemoved(CallPeerConferenceEvent) audioLevelChanged(int)","net.java.sip.communicator.impl.protocol.sip.CallSipImpl+invite(Address,javax.sip.message.Message) net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl+isSecure(CallPeer) net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl+setSasVerified(CallPeer,boolean) net.java.sip.communicator.impl.protocol.sip.OperationSetDTMFSipImpl+startSendingDTMF(CallPeer,DTMFTone) net.java.sip.communicator.impl.protocol.sip.OperationSetDTMFSipImpl+stopSendingDTMF(CallPeer) net.java.sip.communicator.impl.protocol.sip.OperationSetDTMFSipImpl+isRFC4733Active(CallPeerSipImpl) net.java.sip.communicator.impl.protocol.sip.OperationSetTelephonyConferencingSipImpl+callPeerAdded(CallPeerEvent) net.java.sip.communicator.impl.protocol.sip.OperationSetTelephonyConferencingSipImpl+callPeerRemoved(CallPeerEvent) net.java.sip.communicator.impl.protocol.sip.OperationSetTelephonyConferencingSipImpl+getMediaXML(CallPeerSipImpl,boolean,StringBuffer) net.java.sip.communicator.impl.protocol.sip.OperationSetVideoTelephonySipImpl+addVideoListener(CallPeer,VideoListener) net.java.sip.communicator.impl.protocol.sip.OperationSetVideoTelephonySipImpl+createLocalVisualComponent(CallPeer,VideoListener) net.java.sip.communicator.impl.protocol.sip.OperationSetVideoTelephonySipImpl+disposeLocalVisualComponent(CallPeer,Component) net.java.sip.communicator.impl.protocol.sip.OperationSetVideoTelephonySipImpl+getVisualComponent(CallPeer) net.java.sip.communicator.impl.protocol.sip.OperationSetVideoTelephonySipImpl+removeVideoListener(CallPeer,VideoListener)",,net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+mediaHandler,722,16,1,"/** 
 * Returns a reference to the <tt>CallPeerMediaHandler</tt> used by this peer. The media handler class handles all media management for a single <tt>CallPeer</tt>. This includes initializing and configuring streams, generating SDP, handling ICE, etc. One instance of <tt>CallPeer</tt> always corresponds to exactly one instance of <tt>CallPeerMediaHandler</tt> and both classes are only separated for reasons of readability.
 * @return a reference to the <tt>CallPeerMediaHandler</tt> instance thatthis peer uses for media related tips and tricks.
 */
","/**
     * Returns a reference to the <tt>CallPeerMediaHandler</tt> used by this
     * peer. The media handler class handles all media management for a single
     * <tt>CallPeer</tt>. This includes initializing and configuring streams,
     * generating SDP, handling ICE, etc. One instance of <tt>CallPeer</tt>
     * always corresponds to exactly one instance of
     * <tt>CallPeerMediaHandler</tt> and both classes are only separated for
     * reasons of readability.
     *
     * @return a reference to the <tt>CallPeerMediaHandler</tt> instance that
     * this peer uses for media related tips and tricks.
     */
    public CallPeerMediaHandlerSipImpl getMediaHandler()
    {
        return mediaHandler;
    }",False
72,"setState(CallPeerState,String)",Method,"processReInvite(ServerTransaction) logAndFail(String,Throwable)","net.java.sip.communicator.impl.protocol.sip.CallSipImpl+processReplacingInvite(SipProvider,ServerTransaction,CallPeerSipImpl) net.java.sip.communicator.impl.protocol.sip.CallSipImpl+processInvite(SipProvider,ServerTransaction) net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl+processTimeout(TimeoutEvent) net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl+processNotify(ServerTransaction,Request) net.java.sip.communicator.impl.protocol.sip.OperationSetBasicTelephonySipImpl+processNotify(ServerTransaction,Request)","net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.service.protocol.AbstractCallPeer+setState(CallPeerState,String) java.lang.Object+equals(Object) java.lang.Object+equals(Object) java.lang.Object+equals(Object) java.lang.Object+equals(Object) net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler+close() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler+close()",net.java.sip.communicator.service.protocol.CallPeerState+DISCONNECTED net.java.sip.communicator.service.protocol.CallPeerState+FAILED,1184,28,1,"/** 
 * Overrides the parent set state method in order to make sure that we close our media handler whenever we enter a disconnected state.
 * @param newState the <tt>CallPeerState</tt> that we are about to enter andthat we pass to our predecessor.
 * @param reason a reason phrase explaining the state (e.g. if newStateindicates a failure) and that we pass to our predecessor.
 */
","/**
     * Overrides the parent set state method in order to make sure that we
     * close our media handler whenever we enter a disconnected state.
     *
     * @param newState the <tt>CallPeerState</tt> that we are about to enter and
     * that we pass to our predecessor.
     * @param reason a reason phrase explaining the state (e.g. if newState
     * indicates a failure) and that we pass to our predecessor.
     */
    @Override
    public void setState(CallPeerState newState, String reason)
    {
        // synchronized to mediaHandler if there are currently jobs of
        // initializing, configuring and starting streams (method processAnswer
        // of CallPeerMediaHandler) we won't set and fire the current state
        // to Disconnected. Before closing the mediaHandler is setting the state
        // in order to deliver states as quick as possible.
        synchronized(getMediaHandler())
        {
            super.setState(newState, reason);

            if (CallPeerState.DISCONNECTED.equals(newState)
                    || CallPeerState.FAILED.equals(newState))
            {
                getMediaHandler().close();
            }
        }
    }",True
73,addStreamSoundLevelListener(SoundLevelListener),Method,,,java.util.List+size() java.util.List+size() net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler+setStreamAudioLevelListener(SimpleAudioLevelListener) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler+setStreamAudioLevelListener(SimpleAudioLevelListener) java.util.List+add(E) java.util.List+add(E),net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+streamAudioLevelListeners net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+streamAudioLevelListeners net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+streamAudioLevelListeners,1217,27,1,"/** 
 * Adds a specific <tt>SoundLevelListener</tt> to the list of listeners interested in and notified about changes in the sound level of the audio sent by the remote party. When the first listener is being registered the method also registers its single listener with the media handler so that it would receive level change events and delegate them to the listeners that have registered with us.
 * @param listener the <tt>SoundLevelListener</tt> to add
 */
","/**
     * Adds a specific <tt>SoundLevelListener</tt> to the list of listeners
     * interested in and notified about changes in the sound level of the audio
     * sent by the remote party. When the first listener is being registered
     * the method also registers its single listener with the media handler so
     * that it would receive level change events and delegate them to the
     * listeners that have registered with us.
     *
     * @param listener the <tt>SoundLevelListener</tt> to add
     */
    public void addStreamSoundLevelListener(SoundLevelListener listener)
    {
        synchronized (streamAudioLevelListeners)
        {
            if (streamAudioLevelListeners.size() == 0)
            {
                // if this is the first listener that's being registered with
                // us, we also need to register ourselves as an audio level
                // listener with the media handler. we do this so that audio
                // levels would only be calculated if anyone is interested in
                // receiving them.
                getMediaHandler().setStreamAudioLevelListener(this);
            }

            streamAudioLevelListeners.add(listener);
        }
    }",True
74,removeStreamSoundLevelListener(SoundLevelListener),Method,,,java.util.List+remove(Object) java.util.List+remove(Object) java.util.List+size() java.util.List+size() net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler+setStreamAudioLevelListener(SimpleAudioLevelListener) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler+setStreamAudioLevelListener(SimpleAudioLevelListener),net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+streamAudioLevelListeners net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+streamAudioLevelListeners net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+streamAudioLevelListeners,858,22,1,"/** 
 * Removes a specific <tt>SoundLevelListener</tt> of the list of listeners interested in and notified about changes in stream sound level related information.
 * @param listener the <tt>SoundLevelListener</tt> to remove
 */
","/**
     * Removes a specific <tt>SoundLevelListener</tt> of the list of
     * listeners interested in and notified about changes in stream sound level
     * related information.
     *
     * @param listener the <tt>SoundLevelListener</tt> to remove
     */
    public void removeStreamSoundLevelListener(SoundLevelListener listener)
    {
        synchronized (streamAudioLevelListeners)
        {
            streamAudioLevelListeners.remove(listener);

            if (streamAudioLevelListeners.size() == 0)
            {
                // if this was the last listener then we also need to remove
                // ourselves as an audio level so that audio levels would only
                // be calculated if anyone is interested in receiving them.
                getMediaHandler().setStreamAudioLevelListener(null);
            }
        }
    }",True
75,addConferenceMembersSoundLevelListener(ConferenceMembersSoundLevelListener),Method,,,java.util.List+size() java.util.List+size() net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler+setCsrcAudioLevelListener(CsrcAudioLevelListener) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler+setCsrcAudioLevelListener(CsrcAudioLevelListener) java.util.List+add(E) java.util.List+add(E),net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+conferenceMemberAudioLevelListeners net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+conferenceMemberAudioLevelListeners net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+conferenceMemberAudioLevelListeners,940,24,1,"/** 
 * Adds a specific <tt>ConferenceMembersSoundLevelListener</tt> to the list of listeners interested in and notified about changes in conference members sound level.
 * @param listener the <tt>ConferenceMembersSoundLevelListener</tt> to add
 */
","/**
     * Adds a specific <tt>ConferenceMembersSoundLevelListener</tt> to the list
     * of listeners interested in and notified about changes in conference
     * members sound level.
     *
     * @param listener the <tt>ConferenceMembersSoundLevelListener</tt> to add
     */
    public void addConferenceMembersSoundLevelListener(
                                ConferenceMembersSoundLevelListener listener)
    {
        synchronized (conferenceMemberAudioLevelListeners)
        {

            if (conferenceMemberAudioLevelListeners.size() == 0)
            {
                // if this is the first listener that's being registered with
                // us, we also need to register ourselves as a CSRC audio level
                // listener with the media handler.
                getMediaHandler().setCsrcAudioLevelListener(this);
            }

            conferenceMemberAudioLevelListeners.add(listener);
        }
    }",True
76,removeConferenceMembersSoundLevelListener(ConferenceMembersSoundLevelListener),Method,,,java.util.List+remove(Object) java.util.List+remove(Object) java.util.List+size() java.util.List+size() net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler+setCsrcAudioLevelListener(CsrcAudioLevelListener) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler+setCsrcAudioLevelListener(CsrcAudioLevelListener),net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+conferenceMemberAudioLevelListeners net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+conferenceMemberAudioLevelListeners net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+conferenceMemberAudioLevelListeners,999,25,1,"/** 
 * Removes a specific <tt>ConferenceMembersSoundLevelListener</tt> of the list of listeners interested in and notified about changes in conference members sound level.
 * @param listener the <tt>ConferenceMembersSoundLevelListener</tt> toremove
 */
","/**
     * Removes a specific <tt>ConferenceMembersSoundLevelListener</tt> of the
     * list of listeners interested in and notified about changes in conference
     * members sound level.
     *
     * @param listener the <tt>ConferenceMembersSoundLevelListener</tt> to
     * remove
     */
    public void removeConferenceMembersSoundLevelListener(
        ConferenceMembersSoundLevelListener listener)
    {
        synchronized (conferenceMemberAudioLevelListeners)
        {
            conferenceMemberAudioLevelListeners.remove(listener);

            if (conferenceMemberAudioLevelListeners.size() == 0)
            {
                // if this was the last listener then we also remove ourselves
                // as a CSRC audio level listener from the handler so that we
                // don't have to create new events and maps for something no one
                // is interested in.
                getMediaHandler().setCsrcAudioLevelListener(null);
            }
        }
    }",True
77,audioLevelsReceived(long[][]),Method,audioLevelChanged(int),,"net.java.sip.communicator.service.protocol.AbstractCallPeer+getConferenceMemberCount() net.java.sip.communicator.service.protocol.AbstractCallPeer+getConferenceMemberCount() java.util.HashMap+HashMap() net.java.sip.communicator.service.protocol.AbstractCallPeer+findConferenceMember(long) net.java.sip.communicator.service.protocol.AbstractCallPeer+findConferenceMember(long) java.util.Map+put(K,V) java.util.Map+put(K,V) net.java.sip.communicator.service.protocol.event.ConferenceMembersSoundLevelEvent+ConferenceMembersSoundLevelEvent(CallPeer,Map<ConferenceMember,Integer>) java.util.List+size() java.util.List+size() net.java.sip.communicator.service.protocol.event.ConferenceMembersSoundLevelListener+soundLevelChanged(ConferenceMembersSoundLevelEvent) java.util.List+get(int) java.util.List+get(int) net.java.sip.communicator.service.protocol.event.ConferenceMembersSoundLevelListener+soundLevelChanged(ConferenceMembersSoundLevelEvent)",net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+conferenceMemberAudioLevelListeners net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+conferenceMemberAudioLevelListeners net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+conferenceMemberAudioLevelListeners,1429,40,1,"/** 
 * Implements  {@link CsrcAudioLevelListener#audioLevelsReceived(long[][])}so that we could deliver to  {@link ConferenceMembersSoundLevelListener}s the events corresponding to the audio level changes that are being reported here.
 * @param audioLevels the levels that we need to dispatch to all registered<tt>ConferenceMemberSoundLevelListeners</tt>.
 */
","/**
     * Implements {@link CsrcAudioLevelListener#audioLevelsReceived(long[][])}
     * so that we could deliver to {@link ConferenceMembersSoundLevelListener}s
     * the events corresponding to the audio level changes that are being
     * reported here.
     *
     * @param audioLevels the levels that we need to dispatch to all registered
     * <tt>ConferenceMemberSoundLevelListeners</tt>.
     */
    public void audioLevelsReceived(long[][] audioLevels)
    {
        if (getConferenceMemberCount() == 0)
            return;

        Map<ConferenceMember, Integer> levelsMap
            = new HashMap<ConferenceMember, Integer>();

        for (int i = 0; i < audioLevels.length; i++)
        {
            ConferenceMember mmbr = findConferenceMember(audioLevels[i][0]);

            if (mmbr == null)
                continue;
            else
                levelsMap.put(mmbr, (int)audioLevels[i][1]);
        }

        ConferenceMembersSoundLevelEvent evt
            = new ConferenceMembersSoundLevelEvent(this, levelsMap);

        synchronized( conferenceMemberAudioLevelListeners)
        {
            int conferenceMemberAudioLevelListenerCount
                = conferenceMemberAudioLevelListeners.size();

            for (int i = 0; i < conferenceMemberAudioLevelListenerCount; i++)
                conferenceMemberAudioLevelListeners
                    .get(i).soundLevelChanged(evt);
        }
    }",True
78,callPeerAdded(CallPeerEvent),Method,,,,,117,6,1,"/** 
 * Does nothing.
 * @param evt the event.
 */
","/**
     * Does nothing.
     * @param evt the event.
     */
    public void callPeerAdded(CallPeerEvent evt)
    {}",True
79,callPeerRemoved(CallPeerEvent),Method,,,,,119,6,1,"/** 
 * Does nothing.
 * @param evt the event.
 */
","/**
     * Does nothing.
     * @param evt the event.
     */
    public void callPeerRemoved(CallPeerEvent evt)
    {}",True
80,"securityTurnedOn(int,String,String,boolean,byte[])",Method,,,"net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler+startZrtpMultistream(byte[]) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler+startZrtpMultistream(byte[]) net.java.sip.communicator.service.protocol.AbstractCallPeer+fireCallPeerSecurityOnEvent(int,String,String,boolean) net.java.sip.communicator.service.protocol.AbstractCallPeer+fireCallPeerSecurityOnEvent(int,String,String,boolean)",,789,23,1,"/** 
 * Sets the security status to ON for this call peer.
 * @param sessionType the type of the call session - audio or video.
 * @param cipher the cipher
 * @param securityString the SAS
 * @param isVerified indicates if the SAS has been verified
 * @param multiStreamData the data for the multistreamused by non master streams.
 */
","/**
     * Sets the security status to ON for this call peer.
     *
     * @param sessionType the type of the call session - audio or video.
     * @param cipher the cipher
     * @param securityString the SAS
     * @param isVerified indicates if the SAS has been verified
     * @param multiStreamData the data for the multistream
     *        used by non master streams.
     */
    public void securityTurnedOn(
        int sessionType,
        String cipher, String securityString, boolean isVerified,
        byte[] multiStreamData)
    {
        if(multiStreamData != null)
        {
            getMediaHandler().startZrtpMultistream(multiStreamData);
        }

        fireCallPeerSecurityOnEvent(
                        sessionType, cipher, securityString, isVerified);
    }",True
81,securityTurnedOff(int),Method,,,net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getCall() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getCall() java.lang.Object+equals(Object) net.java.sip.communicator.service.protocol.Call+getCallState() net.java.sip.communicator.service.protocol.Call+getCallState() java.lang.Object+equals(Object) net.java.sip.communicator.service.protocol.AbstractCallPeer+fireCallPeerSecurityOffEvent(int) net.java.sip.communicator.service.protocol.AbstractCallPeer+fireCallPeerSecurityOffEvent(int),net.java.sip.communicator.service.protocol.CallState+CALL_ENDED,554,15,1,"/** 
 * Sets the security status to OFF for this call peer.
 * @param sessionType the type of the call session - audio or video.
 */
","/**
     * Sets the security status to OFF for this call peer.
     *
     * @param sessionType the type of the call session - audio or video.
     */
    public void securityTurnedOff(int sessionType)
    {
        // If this event has been triggered because of a call end event and the
        // call is already ended we don't need to alert the user for
        // security off.
        Call call = getCall();

        if((call != null) && !call.getCallState().equals(CallState.CALL_ENDED))
            fireCallPeerSecurityOffEvent(sessionType);
    }",True
82,"securityMessageReceived(String,String,int)",Method,,,"net.java.sip.communicator.service.protocol.AbstractCallPeer+fireCallPeerSecurityMessageEvent(String,String,int) net.java.sip.communicator.service.protocol.AbstractCallPeer+fireCallPeerSecurityMessageEvent(String,String,int)",,546,15,1,"/** 
 * Sets the security message associated with a failure/warning or information coming from the encryption protocol.
 * @param messageType the type of the message.
 * @param i18nMessage the message
 * @param severity severity level
 */
","/**
     * Sets the security message associated with a failure/warning or
     * information coming from the encryption protocol.
     *
     * @param messageType the type of the message.
     * @param i18nMessage the message
     * @param severity severity level
     */
    public void securityMessageReceived(
        String messageType, String i18nMessage, int severity)
    {
        fireCallPeerSecurityMessageEvent(messageType,
                                         i18nMessage,
                                         severity);
    }",True
83,conferenceFocusChanged(CallPeerConferenceEvent),Method,,,,,247,9,1,"/** 
 * Dummy implementation of  {@link CallPeerConferenceListener#conferenceFocusChanged(CallPeerConferenceEvent)}.
 * @param evt ignored
 */
","/**
     * Dummy implementation of {@link CallPeerConferenceListener
     * #conferenceFocusChanged(CallPeerConferenceEvent)}.
     *
     * @param evt ignored
     */
    public void conferenceFocusChanged(CallPeerConferenceEvent evt)
    {
    }",True
84,conferenceMemberAdded(CallPeerConferenceEvent),Method,,,net.java.sip.communicator.service.protocol.AbstractCallPeer+getConferenceMemberCount() net.java.sip.communicator.service.protocol.AbstractCallPeer+getConferenceMemberCount() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler+setStreamAudioLevelListener(SimpleAudioLevelListener) net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler+setStreamAudioLevelListener(SimpleAudioLevelListener) net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler+setCsrcAudioLevelListener(CsrcAudioLevelListener) net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler+setCsrcAudioLevelListener(CsrcAudioLevelListener),,1162,25,1,"/** 
 * Called when this peer becomes a mixer. The method add removes this class as the stream audio level listener for the media coming from this peer because the levels it delivers no longer represent the level of a particular member. The method also adds this class as a member (CSRC) audio level listener.
 * @param conferenceEvent the event containing information (that we don'treally use) on the newly add member.
 */
","/**
     * Called when this peer becomes a mixer. The method add removes this class
     * as the stream audio level listener for the media coming from this peer
     * because the levels it delivers no longer represent the level of a
     * particular member. The method also adds this class as a member (CSRC)
     * audio level listener.
     *
     * @param conferenceEvent the event containing information (that we don't
     * really use) on the newly add member.
     */
    public void conferenceMemberAdded(CallPeerConferenceEvent conferenceEvent)
    {
        if (getConferenceMemberCount() > 2)
        {
            // this peer is now a conference focus with more than three
            // participants. This means that the this peer is mixing and sending
            // us audio for at least two separate participants. We therefore
            // need to remove the stream level listeners and switch to CSRC
            // level listening
            CallPeerMediaHandlerSipImpl mediaHandler = getMediaHandler();

            mediaHandler.setStreamAudioLevelListener(null);
            mediaHandler.setCsrcAudioLevelListener(this);
        }
    }",True
85,conferenceMemberRemoved(CallPeerConferenceEvent),Method,,,net.java.sip.communicator.service.protocol.AbstractCallPeer+getConferenceMemberCount() net.java.sip.communicator.service.protocol.AbstractCallPeer+getConferenceMemberCount() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler+setStreamAudioLevelListener(SimpleAudioLevelListener) net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler+setStreamAudioLevelListener(SimpleAudioLevelListener) net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler+setCsrcAudioLevelListener(CsrcAudioLevelListener) net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler+setCsrcAudioLevelListener(CsrcAudioLevelListener),,1100,24,1,"/** 
 * Called when this peer stops being a mixer. The method add removes this class as the stream audio level listener for the media coming from this peer because the levels it delivers no longer represent the level of a particular member. The method also adds this class as a member (CSRC) audio level listener.
 * @param conferenceEvent the event containing information (that we don'treally use) on the freshly removed member.
 */
","/**
     * Called when this peer stops being a mixer. The method add removes this
     * class as the stream audio level listener for the media coming from this
     * peer because the levels it delivers no longer represent the level of a
     * particular member. The method also adds this class as a member (CSRC)
     * audio level listener.
     *
     * @param conferenceEvent the event containing information (that we don't
     * really use) on the freshly removed member.
     */
    public void conferenceMemberRemoved(CallPeerConferenceEvent conferenceEvent)
    {
        if (getConferenceMemberCount() < 3)
        {
            // this call peer is no longer mixing audio from multiple sources
            // since there's only us and her in the call. Lets stop being a CSRC
            // listener and move back to listening the audio level of the
            // stream itself.
            CallPeerMediaHandlerSipImpl mediaHandler = getMediaHandler();

            mediaHandler.setStreamAudioLevelListener(this);
            mediaHandler.setCsrcAudioLevelListener(null);
        }
    }",True
86,audioLevelChanged(int),Method,,,"net.java.sip.communicator.service.protocol.AbstractCallPeer+isConferenceFocus() net.java.sip.communicator.service.protocol.AbstractCallPeer+isConferenceFocus() net.java.sip.communicator.service.protocol.AbstractCallPeer+getConferenceMemberCount() net.java.sip.communicator.service.protocol.AbstractCallPeer+getConferenceMemberCount() net.java.sip.communicator.service.protocol.AbstractCallPeer+getConferenceMemberCount() net.java.sip.communicator.service.protocol.AbstractCallPeer+getConferenceMemberCount() net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler+getAudioRemoteSSRC() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+getMediaHandler() net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler+getAudioRemoteSSRC() net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+audioLevelsReceived(long[][]) net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+audioLevelsReceived(long[][]) java.util.List+size() java.util.List+size() net.java.sip.communicator.service.protocol.event.SoundLevelChangeEvent+SoundLevelChangeEvent(Object,int) net.java.sip.communicator.service.protocol.event.SoundLevelListener+soundLevelChanged(SoundLevelChangeEvent) net.java.sip.communicator.service.protocol.event.SoundLevelListener+soundLevelChanged(SoundLevelChangeEvent)",net.java.sip.communicator.service.protocol.media.CallPeerMediaHandler+SSRC_UNKNOWN net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+streamAudioLevelListeners net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+streamAudioLevelListeners net.java.sip.communicator.impl.protocol.sip.CallPeerSipImpl+streamAudioLevelListeners,2109,52,1,"/** 
 * Notified by its very majesty the media service about changes in the audio level of the stream coming from this peer, this method generates the corresponding events and delivers them to the listeners that have registered here.
 * @param newLevel the new audio level of the local user.
 */
","/**
     * Notified by its very majesty the media service about changes in the
     * audio level of the stream coming from this peer, this method generates
     * the corresponding events and delivers them to the listeners that have
     * registered here.
     *
     * @param newLevel the new audio level of the local user.
     */
    public void audioLevelChanged(int newLevel)
    {
        /*
         * If we're in a conference in which this CallPeer is the focus and
         * we're the only member in it besides the focus, we will not receive
         * audio levels in the RTP and our media will instead measure the audio
         * levels of the received media. In order to make the UI oblivious of
         * the difference, we have to translate the event to the appropriate
         * type of listener.
         *
         * We may end up in a conference call with 0 members if the server
         * for some reason doesn't support sip conference (our subscribes
         * doesn't go to the focus of the conference) and so we must
         * pass the sound levels measured on the stream so we can see
         * the stream activity of the call.
         */
        if (isConferenceFocus() && (getConferenceMemberCount() > 0)
            && (getConferenceMemberCount() < 3))
        {
            long audioRemoteSSRC = getMediaHandler().getAudioRemoteSSRC();

            if (audioRemoteSSRC != CallPeerMediaHandler.SSRC_UNKNOWN)
            {
                long[][] audioLevels = new long[1][2];
                audioLevels[0][0] = audioRemoteSSRC;
                audioLevels[0][1] = newLevel;

                audioLevelsReceived(audioLevels);
                return;
            }
        }

        synchronized( streamAudioLevelListeners )
        {
            if (streamAudioLevelListeners.size() > 0)
            {
                SoundLevelChangeEvent evt
                    = new SoundLevelChangeEvent(this, newLevel);

                for(SoundLevelListener listener : streamAudioLevelListeners)
                    listener.soundLevelChanged(evt);
            }
        }
    }",True
