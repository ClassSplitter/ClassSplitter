index,name,document,type,inner invocations,external invocations,calls,visits,length,lines,modifier,commit,full text,moved,removed,gpt text,gpt response,code summary
1,scanIndex,scan index ,Field,,,,,24,1,2,,private Index scanIndex;,False,False,,False,
2,rowCount,row count ,Field,setRowCount(long),,,,22,1,2,,private long rowCount;,False,False,,False,
3,lockExclusiveSession,lock exclusive session ,Field,"getDeadlockDetails(ArrayList<Session>,boolean)",,,,46,1,66,,private volatile Session lockExclusiveSession;,True,True,,False,
4,lockSharedSessions,lock shared sessions ,Field,,,,,103,2,2,,"private ConcurrentHashMap<Session, Session> lockSharedSessions =
            new ConcurrentHashMap<>();",True,True,,False,
5,waitingSessions,waiting sessions the queue of sessions waiting to lock the table it is a fifo queue to prevent starvation since java s synchronized locking is biased ,Field,,,,,237,5,18,"/** 
 * The queue of sessions waiting to lock the table. It is a FIFO queue to prevent starvation, since Java's synchronized locking is biased.
 */
","/**
     * The queue of sessions waiting to lock the table. It is a FIFO queue to
     * prevent starvation, since Java's synchronized locking is biased.
     */
    private final ArrayDeque<Session> waitingSessions = new ArrayDeque<>();",False,False,"/** 
 * The queue of sessions waiting to lock the table. It is a FIFO queue to prevent starvation, since Java's synchronized locking is biased.
 */
",False,"/** 
 * The queue of sessions waiting to lock the table. It is a FIFO queue to prevent starvation, since Java's synchronized locking is biased.
 */
"
6,traceLock,trace lock ,Field,,,,,30,1,18,,private final Trace traceLock;,False,False,,False,
7,indexes,indexes ,Field,,,,,67,1,18,,private final ArrayList<Index> indexes = Utils.newSmallArrayList();,False,False,,False,
8,lastModificationId,last modification id ,Field,,,,,32,1,2,,private long lastModificationId;,False,False,,False,
9,containsLargeObject,contains large object ,Field,,,,,42,1,18,,private final boolean containsLargeObject;,True,True,,False,
10,mainIndex,main index ,Field,,,,,38,1,18,,private final PageDataIndex mainIndex;,False,False,,False,
11,changesSinceAnalyze,changes since analyze ,Field,,,,,32,1,2,,private int changesSinceAnalyze;,False,False,,False,
12,nextAnalyze,next analyze ,Field,,,,,24,1,2,,private int nextAnalyze;,False,False,,False,
13,rowIdColumn,row id column ,Field,,,,,27,1,2,,private Column rowIdColumn;,True,True,,False,
14,PageStoreTable(CreateTableData),page store table data ,Method,,,"org.h2.engine.Database+getSettings() org.h2.engine.Database+getSettings() org.h2.table.Table+getColumns() org.h2.table.Table+getColumns() org.h2.value.DataType+isLargeObject(int) org.h2.value.DataType+isLargeObject(int) org.h2.value.TypeInfo+getValueType() org.h2.table.Column+getType() org.h2.table.Column+getType() org.h2.value.TypeInfo+getValueType() org.h2.engine.Database+isPersistent() org.h2.engine.Database+isPersistent() org.h2.index.PageDataIndex+PageDataIndex(PageStoreTable,int,IndexColumn[],IndexType,boolean,Session) org.h2.table.IndexColumn+wrap(Column[]) org.h2.table.IndexColumn+wrap(Column[]) org.h2.table.Table+getColumns() org.h2.table.Table+getColumns() org.h2.index.IndexType+createScan(boolean) org.h2.index.IndexType+createScan(boolean) org.h2.index.ScanIndex+ScanIndex(PageStoreTable,int,IndexColumn[],IndexType) org.h2.table.IndexColumn+wrap(Column[]) org.h2.table.IndexColumn+wrap(Column[]) org.h2.table.Table+getColumns() org.h2.table.Table+getColumns() org.h2.index.IndexType+createScan(boolean) org.h2.index.IndexType+createScan(boolean) java.util.ArrayList+add(E) java.util.ArrayList+add(E) org.h2.engine.Database+getTrace(int) org.h2.engine.Database+getTrace(int)",org.h2.table.PageStoreTable+nextAnalyze org.h2.engine.DbSettings+analyzeAuto org.h2.engine.DbObjectBase+database org.h2.engine.DbSettings+analyzeAuto org.h2.table.Table+isHidden org.h2.table.Table+isHidden org.h2.command.ddl.CreateTableData+isHidden org.h2.table.PageStoreTable+containsLargeObject org.h2.command.ddl.CreateTableData+persistData org.h2.engine.DbObjectBase+database org.h2.table.PageStoreTable+mainIndex org.h2.command.ddl.CreateTableData+id org.h2.command.ddl.CreateTableData+persistData org.h2.command.ddl.CreateTableData+create org.h2.command.ddl.CreateTableData+session org.h2.table.PageStoreTable+scanIndex org.h2.table.PageStoreTable+mainIndex org.h2.table.PageStoreTable+mainIndex org.h2.table.PageStoreTable+scanIndex org.h2.command.ddl.CreateTableData+id org.h2.command.ddl.CreateTableData+persistData org.h2.table.PageStoreTable+indexes org.h2.table.PageStoreTable+scanIndex org.h2.table.PageStoreTable+traceLock org.h2.engine.DbObjectBase+database org.h2.message.Trace+LOCK,1013,26,1,,"public PageStoreTable(CreateTableData data) {
        super(data);
        nextAnalyze = database.getSettings().analyzeAuto;
        this.isHidden = data.isHidden;
        boolean b = false;
        for (Column col : getColumns()) {
            if (DataType.isLargeObject(col.getType().getValueType())) {
                b = true;
                break;
            }
        }
        containsLargeObject = b;
        if (data.persistData && database.isPersistent()) {
            mainIndex = new PageDataIndex(this, data.id,
                    IndexColumn.wrap(getColumns()),
                    IndexType.createScan(data.persistData),
                    data.create, data.session);
            scanIndex = mainIndex;
        } else {
            mainIndex = null;
            scanIndex = new ScanIndex(this, data.id,
                    IndexColumn.wrap(getColumns()), IndexType.createScan(data.persistData));
        }
        indexes.add(scanIndex);
        traceLock = database.getTrace(Trace.LOCK);
    }",False,False,The function of this method is to create a PageStoreTable object. It initializes various variables and creates indexes based on the provided CreateTableData object.,True,"This code initializes a PageStoreTable object by setting its properties based on the CreateTableData provided. It checks if the table contains large objects, creates the main and scan indexes based on the data, and adds the scan index to the list of indexes."
15,close(Session),close session ,Method,,,org.h2.index.Index+close(Session) org.h2.index.Index+close(Session),org.h2.table.PageStoreTable+indexes,138,6,1,,"@Override
    public void close(Session session) {
        for (Index index : indexes) {
            index.close(session);
        }
    }",False,False,This method closes all indexes associated with a session.,False,"The given code snippet represents a method named ""close"" that is overridden from a parent class or interface. This method takes a ""Session"" object as a parameter and iterates through a collection of ""Index"" objects, calling the ""close"" method on each index with the session object. The purpose of this method is to close all the indexes associated with the session."
16,"getRow(Session,long)",get row session key ,Method,,"org.h2.index.HashIndex+find(Session,SearchRow,SearchRow) org.h2.index.NonUniqueHashCursor+get() org.h2.index.PageBtreeIndex+getRow(Session,long) org.h2.index.PageBtreeIndex+readRow(Data,int,boolean,boolean) org.h2.index.PageBtreeIndex+readRow(long)","org.h2.index.Index+getRow(Session,long) org.h2.index.Index+getRow(Session,long)",org.h2.table.PageStoreTable+scanIndex,113,4,1,,"@Override
    public Row getRow(Session session, long key) {
        return scanIndex.getRow(session, key);
    }",False,False,"The function of the given method is to override the ""getRow"" method and return a row by calling the ""getRow"" method of the ""scanIndex"" object with the provided session and key parameters.",True,The given code snippet is an overridden method that returns a row from a session using a specified key. It utilizes the `scanIndex` object to retrieve the row based on the provided session and key parameters.
17,"addRow(Session,Row)",add row session row ,Method,,,"org.h2.engine.Database+getNextModificationDataId() org.h2.engine.Database+getNextModificationDataId() java.util.ArrayList+size() java.util.ArrayList+size() java.util.ArrayList+get(int) java.util.ArrayList+get(int) org.h2.index.Index+add(Session,Row) org.h2.index.Index+add(Session,Row) org.h2.table.PageStoreTable+checkRowCount(Session,Index,int) org.h2.table.PageStoreTable+checkRowCount(Session,Index,int) java.util.ArrayList+get(int) java.util.ArrayList+get(int) org.h2.index.Index+remove(Session,Row) org.h2.index.Index+remove(Session,Row) org.h2.table.PageStoreTable+checkRowCount(Session,Index,int) org.h2.table.PageStoreTable+checkRowCount(Session,Index,int) org.h2.message.Trace+error(Throwable,String) org.h2.message.Trace+error(Throwable,String) org.h2.message.DbException+convert(Throwable) org.h2.message.DbException+convert(Throwable) org.h2.table.PageStoreTable+analyzeIfRequired(Session) org.h2.table.PageStoreTable+analyzeIfRequired(Session)",org.h2.table.PageStoreTable+lastModificationId org.h2.engine.DbObjectBase+database org.h2.table.PageStoreTable+indexes org.h2.table.PageStoreTable+indexes org.h2.table.PageStoreTable+rowCount org.h2.table.PageStoreTable+indexes org.h2.engine.DbObjectBase+trace,1079,29,1,,"@Override
    public void addRow(Session session, Row row) {
        lastModificationId = database.getNextModificationDataId();
        int i = 0;
        try {
            for (int size = indexes.size(); i < size; i++) {
                Index index = indexes.get(i);
                index.add(session, row);
                checkRowCount(session, index, 1);
            }
            rowCount++;
        } catch (Throwable e) {
            try {
                while (--i >= 0) {
                    Index index = indexes.get(i);
                    index.remove(session, row);
                    checkRowCount(session, index, 0);
                }
            } catch (DbException e2) {
                // this could happen, for example on failure in the storage
                // but if that is not the case it means there is something wrong
                // with the database
                trace.error(e2, ""could not undo operation"");
                throw e2;
            }
            throw DbException.convert(e);
        }
        analyzeIfRequired(session);
    }",False,False,"The function of this method is to add a row to a database table. It first gets the next modification data ID, then iterates through the indexes of the table and adds the row to each index. It also checks the row count for each index. If an exception occurs, it removes the row from the indexes and throws the exception. Finally, it analyzes the table if required.",True,"This code represents the implementation of the `addRow` method, which adds a new row to a database table. It iterates through the indexes of the table, adding the row to each index and checking the row count. If an exception occurs during the process, it attempts to undo the operation and throws a converted exception. Finally, it analyzes the table if required."
18,"checkRowCount(Session,Index,int)",check row count session index offset ,Method,"addRow(Session,Row) addRow(Session,Row) removeRow(Session,Row) removeRow(Session,Row)",,org.h2.index.Index+getRowCount(Session) org.h2.index.Index+getRowCount(Session) org.h2.message.DbException+throwInternalError(String) org.h2.message.DbException+throwInternalError(String) org.h2.engine.DbObjectBase+getName() org.h2.engine.DbObjectBase+getName() org.h2.engine.DbObject+getName() org.h2.engine.DbObject+getName(),org.h2.engine.SysProperties+CHECK org.h2.table.PageStoreTable+rowCount org.h2.table.PageStoreTable+rowCount,521,12,2,,"private void checkRowCount(Session session, Index index, int offset) {
        if (SysProperties.CHECK) {
            if (!(index instanceof PageDelegateIndex)) {
                long rc = index.getRowCount(session);
                if (rc != rowCount + offset) {
                    DbException.throwInternalError(
                            ""rowCount expected "" + (rowCount + offset) +
                            "" got "" + rc + "" "" + getName() + ""."" + index.getName());
                }
            }
        }
    }",False,False,"This method checks the row count of an index in a session. If the index is not an instance of PageDelegateIndex, it compares the row count with the expected value and throws an internal error if they do not match.",False,"The `checkRowCount` method is used to verify the correctness of the row count for a given index in a database session. It compares the expected row count (based on the current `rowCount` and an offset) with the actual row count obtained from the index. If they don't match, it throws an internal error with a descriptive message."
19,getScanIndex(Session),get scan index session ,Method,"addIndex(Session,String,int,IndexColumn[],IndexType,boolean,String)","org.h2.store.PageStore+openMetaIndex() org.h2.store.PageStore+addMeta(Row,Session,boolean)",java.util.ArrayList+get(int) java.util.ArrayList+get(int),org.h2.table.PageStoreTable+indexes,95,4,1,,"@Override
    public Index getScanIndex(Session session) {
        return indexes.get(0);
    }",False,False,This method overrides a superclass method and returns the first index from a list of indexes.,True,"The code is implementing a method called ""getScanIndex"" which returns the first index from a list of indexes. It takes a session as a parameter and returns an Index object."
20,getUniqueIndex(),get unique index ,Method,,,org.h2.index.IndexType+isUnique() org.h2.index.Index+getIndexType() org.h2.index.Index+getIndexType() org.h2.index.IndexType+isUnique(),org.h2.table.PageStoreTable+indexes,209,9,1,,"@Override
    public Index getUniqueIndex() {
        for (Index idx : indexes) {
            if (idx.getIndexType().isUnique()) {
                return idx;
            }
        }
        return null;
    }",False,False,"This method returns the first unique index from a collection of indexes. If no unique index is found, it returns null.",True,"The code is implementing a method called ""getUniqueIndex"" which iterates through a collection of indexes and returns the first index that is marked as unique. If no unique index is found, it returns null."
21,getIndexes(),get indexes ,Method,,"org.h2.test.db.TestTableEngines+addIndex(Session,String,int,IndexColumn[],IndexType,boolean,String)",,org.h2.table.PageStoreTable+indexes,82,4,1,,"@Override
    public ArrayList<Index> getIndexes() {
        return indexes;
    }",False,False,This method serves to return the ArrayList of Index objects.,True,"The code is implementing a method called ""getIndexes"" which returns an ArrayList of objects of type ""Index"". This method is overriding a superclass method, indicating that it is providing a specific implementation for retrieving the indexes."
22,"addIndex(Session,String,int,IndexColumn[],IndexType,boolean,String)",add index session index name index id cols index type create index comment ,Method,,"org.h2.store.PageStore+addMeta(Row,Session,boolean)","org.h2.index.IndexType+isPrimaryKey() org.h2.index.IndexType+isPrimaryKey() org.h2.table.Column+isNullable() org.h2.table.Column+isNullable() org.h2.message.DbException+get(int,String) org.h2.message.DbException+get(int,String) org.h2.table.Column+getName() org.h2.table.Column+getName() org.h2.table.Column+setPrimaryKey(boolean) org.h2.table.Column+setPrimaryKey(boolean) org.h2.engine.DbObjectBase+isTemporary() org.h2.engine.DbObjectBase+isTemporary() org.h2.table.TableBase+isGlobalTemporary() org.h2.table.TableBase+isGlobalTemporary() org.h2.engine.Database+lockMeta(Session) org.h2.engine.Database+lockMeta(Session) org.h2.table.Table+isPersistIndexes() org.h2.table.Table+isPersistIndexes() org.h2.index.IndexType+isPersistent() org.h2.index.IndexType+isPersistent() org.h2.engine.Database+isStarting() org.h2.engine.Database+isStarting() org.h2.store.PageStore+getRootPageId(int) org.h2.engine.Database+getPageStore() org.h2.engine.Database+getPageStore() org.h2.store.PageStore+getRootPageId(int) org.h2.engine.Database+isStarting() org.h2.engine.Database+isStarting() org.h2.index.PageDataIndex+getRowCount(Session) org.h2.index.PageDataIndex+getRowCount(Session) org.h2.index.PageDataIndex+getMainIndexColumn() org.h2.index.PageDataIndex+getMainIndexColumn() org.h2.table.TableBase+getMainIndexColumn(IndexType,IndexColumn[]) org.h2.table.TableBase+getMainIndexColumn(IndexType,IndexColumn[]) org.h2.index.PageDataIndex+setMainIndexColumn(int) org.h2.index.PageDataIndex+setMainIndexColumn(int) org.h2.index.PageDelegateIndex+PageDelegateIndex(PageStoreTable,int,String,IndexType,PageDataIndex,boolean,Session) org.h2.index.IndexType+isSpatial() org.h2.index.IndexType+isSpatial() org.h2.index.SpatialTreeIndex+SpatialTreeIndex(Table,int,String,IndexColumn[],IndexType,boolean,boolean,Session) org.h2.index.PageBtreeIndex+PageBtreeIndex(PageStoreTable,int,String,IndexColumn[],IndexType,boolean,Session) org.h2.index.IndexType+isHash() org.h2.index.IndexType+isHash() org.h2.message.DbException+getUnsupportedException(String) org.h2.message.DbException+getUnsupportedException(String) org.h2.index.IndexType+isUnique() org.h2.index.IndexType+isUnique() org.h2.index.HashIndex+HashIndex(PageStoreTable,int,String,IndexColumn[],IndexType) org.h2.index.NonUniqueHashIndex+NonUniqueHashIndex(PageStoreTable,int,String,IndexColumn[],IndexType) org.h2.index.IndexType+isSpatial() org.h2.index.IndexType+isSpatial() org.h2.index.SpatialTreeIndex+SpatialTreeIndex(Table,int,String,IndexColumn[],IndexType,boolean,boolean,Session) org.h2.index.TreeIndex+TreeIndex(PageStoreTable,int,String,IndexColumn[],IndexType) org.h2.index.Index+needRebuild() org.h2.index.Index+needRebuild() org.h2.table.PageStoreTable+getScanIndex(Session) org.h2.table.PageStoreTable+getScanIndex(Session) org.h2.index.Index+getRowCount(Session) org.h2.index.Index+getRowCount(Session) org.h2.index.Index+find(Session,SearchRow,SearchRow) org.h2.index.Index+find(Session,SearchRow,SearchRow) java.lang.Math+min(long,long) java.lang.Math+min(long,long) org.h2.engine.Database+getMaxMemoryRows() org.h2.engine.Database+getMaxMemoryRows() org.h2.engine.DbObjectBase+getName() org.h2.engine.DbObjectBase+getName() org.h2.engine.DbObject+getName() org.h2.engine.DbObject+getName() org.h2.util.MathUtils+convertLongToInt(long) org.h2.util.MathUtils+convertLongToInt(long) org.h2.index.Cursor+next() org.h2.index.Cursor+next() org.h2.engine.Database+setProgress(int,String,int,int) org.h2.engine.Database+setProgress(int,String,int,int) org.h2.util.MathUtils+convertLongToInt(long) org.h2.util.MathUtils+convertLongToInt(long) org.h2.index.Cursor+get() org.h2.index.Cursor+get() java.util.ArrayList+add(E) java.util.ArrayList+add(E) java.util.ArrayList+size() java.util.ArrayList+size() org.h2.table.PageStoreTable+addRowsToIndex(Session,ArrayList<Row>,Index) org.h2.table.PageStoreTable+addRowsToIndex(Session,ArrayList<Row>,Index) org.h2.table.PageStoreTable+addRowsToIndex(Session,ArrayList<Row>,Index) org.h2.table.PageStoreTable+addRowsToIndex(Session,ArrayList<Row>,Index) org.h2.message.DbException+throwInternalError(String) org.h2.message.DbException+throwInternalError(String) org.h2.engine.DbObjectBase+getName() org.h2.engine.DbObjectBase+getName() org.h2.schema.Schema+freeUniqueName(String) org.h2.schema.SchemaObjectBase+getSchema() org.h2.schema.SchemaObjectBase+getSchema() org.h2.schema.Schema+freeUniqueName(String) org.h2.index.Index+remove(Session) org.h2.index.Index+remove(Session) org.h2.message.Trace+error(Throwable,String) org.h2.message.Trace+error(Throwable,String) org.h2.engine.DbObject+setTemporary(boolean) org.h2.engine.DbObject+setTemporary(boolean) org.h2.engine.DbObjectBase+isTemporary() org.h2.engine.DbObjectBase+isTemporary() org.h2.engine.DbObject+getCreateSQL() org.h2.engine.DbObject+getCreateSQL() org.h2.engine.DbObject+setComment(String) org.h2.engine.DbObject+setComment(String) org.h2.engine.Session+addLocalTempTableIndex(Index) org.h2.engine.Session+addLocalTempTableIndex(Index) org.h2.engine.Database+addSchemaObject(Session,SchemaObject) org.h2.engine.Database+addSchemaObject(Session,SchemaObject) java.util.ArrayList+add(E) java.util.ArrayList+add(E) org.h2.engine.DbObjectBase+setModified() org.h2.engine.DbObjectBase+setModified()",org.h2.table.IndexColumn+column org.h2.api.ErrorCode+COLUMN_MUST_NOT_BE_NULLABLE_1 org.h2.engine.DbObjectBase+database org.h2.engine.DbObjectBase+database org.h2.engine.DbObjectBase+database org.h2.engine.DbObjectBase+database org.h2.table.PageStoreTable+mainIndex org.h2.table.PageStoreTable+mainIndex org.h2.table.PageStoreTable+mainIndex org.h2.table.PageStoreTable+mainIndex org.h2.table.PageStoreTable+rowCount org.h2.table.PageStoreTable+rowCount org.h2.engine.DbObjectBase+database org.h2.engine.DbObjectBase+database org.h2.api.DatabaseEventListener+STATE_CREATE_INDEX org.h2.engine.DbObjectBase+trace org.h2.engine.DbObjectBase+database org.h2.table.PageStoreTable+indexes,5034,114,1,,"@Override
    public Index addIndex(Session session, String indexName, int indexId,
            IndexColumn[] cols, IndexType indexType, boolean create,
            String indexComment) {
        if (indexType.isPrimaryKey()) {
            for (IndexColumn c : cols) {
                Column column = c.column;
                if (column.isNullable()) {
                    throw DbException.get(
                            ErrorCode.COLUMN_MUST_NOT_BE_NULLABLE_1, column.getName());
                }
                column.setPrimaryKey(true);
            }
        }
        boolean isSessionTemporary = isTemporary() && !isGlobalTemporary();
        if (!isSessionTemporary) {
            database.lockMeta(session);
        }
        Index index;
        if (isPersistIndexes() && indexType.isPersistent()) {
            int mainIndexColumn;
            if (database.isStarting() &&
                    database.getPageStore().getRootPageId(indexId) != 0) {
                mainIndexColumn = -1;
            } else if (!database.isStarting() && mainIndex.getRowCount(session) != 0
                    || mainIndex.getMainIndexColumn() != -1) {
                mainIndexColumn = -1;
            } else {
                mainIndexColumn = getMainIndexColumn(indexType, cols);
            }
            if (mainIndexColumn != -1) {
                mainIndex.setMainIndexColumn(mainIndexColumn);
                index = new PageDelegateIndex(this, indexId, indexName,
                        indexType, mainIndex, create, session);
            } else if (indexType.isSpatial()) {
                index = new SpatialTreeIndex(this, indexId, indexName, cols,
                        indexType, true, create, session);
            } else {
                index = new PageBtreeIndex(this, indexId, indexName, cols,
                        indexType, create, session);
            }
        } else {
            if (indexType.isHash()) {
                if (cols.length != 1) {
                    throw DbException.getUnsupportedException(
                            ""hash indexes may index only one column"");
                }
                if (indexType.isUnique()) {
                    index = new HashIndex(this, indexId, indexName, cols,
                            indexType);
                } else {
                    index = new NonUniqueHashIndex(this, indexId, indexName,
                            cols, indexType);
                }
            } else if (indexType.isSpatial()) {
                index = new SpatialTreeIndex(this, indexId, indexName, cols,
                        indexType, false, true, session);
            } else {
                index = new TreeIndex(this, indexId, indexName, cols, indexType);
            }
        }
        if (index.needRebuild() && rowCount > 0) {
            try {
                Index scan = getScanIndex(session);
                long remaining = scan.getRowCount(session);
                long total = remaining;
                Cursor cursor = scan.find(session, null, null);
                long i = 0;
                int bufferSize = (int) Math.min(rowCount, database.getMaxMemoryRows());
                ArrayList<Row> buffer = new ArrayList<>(bufferSize);
                String n = getName() + "":"" + index.getName();
                int t = MathUtils.convertLongToInt(total);
                while (cursor.next()) {
                    database.setProgress(DatabaseEventListener.STATE_CREATE_INDEX, n,
                            MathUtils.convertLongToInt(i++), t);
                    Row row = cursor.get();
                    buffer.add(row);
                    if (buffer.size() >= bufferSize) {
                        addRowsToIndex(session, buffer, index);
                    }
                    remaining--;
                }
                addRowsToIndex(session, buffer, index);
                if (remaining != 0) {
                    DbException.throwInternalError(""rowcount remaining="" +
                            remaining + "" "" + getName());
                }
            } catch (DbException e) {
                getSchema().freeUniqueName(indexName);
                try {
                    index.remove(session);
                } catch (DbException e2) {
                    // this could happen, for example on failure in the storage
                    // but if that is not the case it means
                    // there is something wrong with the database
                    trace.error(e2, ""could not remove index"");
                    throw e2;
                }
                throw e;
            }
        }
        index.setTemporary(isTemporary());
        if (index.getCreateSQL() != null) {
            index.setComment(indexComment);
            if (isSessionTemporary) {
                session.addLocalTempTableIndex(index);
            } else {
                database.addSchemaObject(session, index);
            }
        }
        indexes.add(index);
        setModified();
        return index;
    }",False,False,"This method adds an index to a database table. It checks if the index is a primary key and sets the corresponding column as not nullable. It then creates the index based on its type (persistent, hash, spatial, or tree). If the index needs to be rebuilt, it scans the table and adds the rows to the index. Finally, it sets the index as temporary or permanent and adds it to the database.",True,This code is a method that adds an index to a database table. It checks if the index is a primary key and throws an exception if any of the indexed columns are nullable. It then creates the appropriate type of index based on the index type and adds it to the table's list of indexes.
23,canGetRowCount(),can get row count ,Method,,,,,74,4,1,,"@Override
    public boolean canGetRowCount() {
        return true;
    }",True,True,"The function of the method is to determine whether it is possible to retrieve the number of rows in a data structure or database table. It returns a boolean value of true if it is possible, and false otherwise.",True,"The code snippet is implementing the method `canGetRowCount()` which returns a boolean value indicating whether the row count can be obtained. The method always returns `true`, implying that the row count can be determined."
24,"addRowsToIndex(Session,ArrayList<Row>,Index)",add rows to index session list index ,Method,"addIndex(Session,String,int,IndexColumn[],IndexType,boolean,String) addIndex(Session,String,int,IndexColumn[],IndexType,boolean,String)",,"java.util.Collections+sort(List,Comparator) java.util.Collections+sort(List,Comparator) +() +compare(Row,Row)",,438,14,10,,"private static void addRowsToIndex(Session session, ArrayList<Row> list,
            Index index) {
        final Index idx = index;
        Collections.sort(list, new Comparator<Row>() {
            @Override
            public int compare(Row r1, Row r2) {
                return idx.compareRows(r1, r2);
            }
        });
        for (Row row : list) {
            index.add(session, row);
        }
        list.clear();
    }",True,True,"This method adds rows to an index by sorting them using a comparator based on the index's compareRows method, and then adding each row to the index using the index's add method. Finally, it clears the list of rows.",False,"This code defines a method called ""addRowsToIndex"" that takes a session, a list of rows, and an index as parameters. It sorts the list of rows using the compareRows method of the index, and then adds each row to the index using the add method. Finally, it clears the list."
25,canDrop(),can drop ,Method,,,,,67,4,1,,"@Override
    public boolean canDrop() {
        return true;
    }",True,True,"The function of the method is to determine whether an object can be dropped. It returns a boolean value of true if the object can be dropped, and false otherwise.",True,"The code snippet defines a method named ""canDrop()"" that returns a boolean value. The method is overridden from a superclass or interface and always returns true, indicating that an object can be dropped."
26,getRowCount(Session),get row count session ,Method,,"org.h2.index.PageBtreeIndex+getCost(Session,int[],TableFilter[],int,SortOrder,AllColumnsForPlan)",,org.h2.table.PageStoreTable+rowCount,87,4,1,,"@Override
    public long getRowCount(Session session) {
        return rowCount;
    }",False,False,"The method ""getRowCount"" returns the value of the variable ""rowCount"" as a long data type. It takes a Session object as a parameter.",True,"The given code is a method named ""getRowCount"" that overrides a method from a superclass or interface. It takes a session object as a parameter and returns a long value representing the row count. The value returned is stored in a variable named ""rowCount""."
27,"removeRow(Session,Row)",remove row session row ,Method,,,"org.h2.engine.Database+getNextModificationDataId() org.h2.engine.Database+getNextModificationDataId() java.util.ArrayList+size() java.util.ArrayList+size() java.util.ArrayList+get(int) java.util.ArrayList+get(int) org.h2.index.Index+remove(Session,Row) org.h2.index.Index+remove(Session,Row) org.h2.table.PageStoreTable+checkRowCount(Session,Index,int) org.h2.table.PageStoreTable+checkRowCount(Session,Index,int) java.util.ArrayList+size() java.util.ArrayList+size() java.util.ArrayList+get(int) java.util.ArrayList+get(int) org.h2.index.Index+add(Session,Row) org.h2.index.Index+add(Session,Row) org.h2.table.PageStoreTable+checkRowCount(Session,Index,int) org.h2.table.PageStoreTable+checkRowCount(Session,Index,int) org.h2.message.Trace+error(Throwable,String) org.h2.message.Trace+error(Throwable,String) org.h2.message.DbException+convert(Throwable) org.h2.message.DbException+convert(Throwable) org.h2.table.PageStoreTable+analyzeIfRequired(Session) org.h2.table.PageStoreTable+analyzeIfRequired(Session)",org.h2.table.PageStoreTable+lastModificationId org.h2.engine.DbObjectBase+database org.h2.table.PageStoreTable+indexes org.h2.table.PageStoreTable+indexes org.h2.table.PageStoreTable+rowCount org.h2.table.PageStoreTable+indexes org.h2.table.PageStoreTable+indexes org.h2.engine.DbObjectBase+trace,1085,29,1,,"@Override
    public void removeRow(Session session, Row row) {
        lastModificationId = database.getNextModificationDataId();
        int i = indexes.size() - 1;
        try {
            for (; i >= 0; i--) {
                Index index = indexes.get(i);
                index.remove(session, row);
                checkRowCount(session, index, -1);
            }
            rowCount--;
        } catch (Throwable e) {
            try {
                while (++i < indexes.size()) {
                    Index index = indexes.get(i);
                    index.add(session, row);
                    checkRowCount(session, index, 0);
                }
            } catch (DbException e2) {
                // this could happen, for example on failure in the storage
                // but if that is not the case it means there is something wrong
                // with the database
                trace.error(e2, ""could not undo operation"");
                throw e2;
            }
            throw DbException.convert(e);
        }
        analyzeIfRequired(session);
    }",False,False,"The function of this method is to remove a row from a database table. It updates the last modification ID, removes the row from all indexes, checks the row count, and analyzes the table if required. If an exception occurs, it attempts to undo the operation and throws a database exception.",True,"This code represents the implementation of a method called `removeRow` that removes a given row from a table. It iterates through the indexes of the table, removing the row from each index and updating the row count accordingly. If an exception occurs during the removal process, it attempts to undo the operation by adding the row back to the indexes and throws the exception. Finally, it analyzes the table if required."
28,truncate(Session),truncate session ,Method,removeChildrenAndResources(Session),,org.h2.engine.Database+getNextModificationDataId() org.h2.engine.Database+getNextModificationDataId() java.util.ArrayList+size() java.util.ArrayList+size() java.util.ArrayList+get(int) java.util.ArrayList+get(int) org.h2.index.Index+truncate(Session) org.h2.index.Index+truncate(Session),org.h2.table.PageStoreTable+lastModificationId org.h2.engine.DbObjectBase+database org.h2.table.PageStoreTable+indexes org.h2.table.PageStoreTable+indexes org.h2.table.PageStoreTable+rowCount org.h2.table.PageStoreTable+changesSinceAnalyze,326,10,1,,"@Override
    public void truncate(Session session) {
        lastModificationId = database.getNextModificationDataId();
        for (int i = indexes.size() - 1; i >= 0; i--) {
            Index index = indexes.get(i);
            index.truncate(session);
        }
        rowCount = 0;
        changesSinceAnalyze = 0;
    }",False,False,"This method truncates all indexes in the session, resets the row count and changes since analyze counters, and updates the last modification ID.",True,"This code snippet represents a method called ""truncate"" that is part of a class. It is responsible for resetting the state of the object by setting the lastModificationId to the next available data id, truncating all indexes associated with the object, and resetting the rowCount and changesSinceAnalyze variables to zero."
29,analyzeIfRequired(Session),analyze if required session ,Method,"addRow(Session,Row) removeRow(Session,Row)",,org.h2.engine.Session+markTableForAnalyze(Table) org.h2.engine.Session+markTableForAnalyze(Table),org.h2.table.PageStoreTable+nextAnalyze org.h2.table.PageStoreTable+nextAnalyze org.h2.table.PageStoreTable+changesSinceAnalyze org.h2.table.PageStoreTable+changesSinceAnalyze org.h2.table.PageStoreTable+nextAnalyze org.h2.table.PageStoreTable+nextAnalyze,325,11,2,,"private void analyzeIfRequired(Session session) {
        if (nextAnalyze == 0 || nextAnalyze > changesSinceAnalyze++) {
            return;
        }
        changesSinceAnalyze = 0;
        int n = 2 * nextAnalyze;
        if (n > 0) {
            nextAnalyze = n;
        }
        session.markTableForAnalyze(this);
    }",False,False,"This method analyzes if a session requires further analysis. It checks if the next analyze is 0 or greater than the changes since the last analyze. If so, it marks the table for analysis in the session.",False,"This code is a method called `analyzeIfRequired` that takes a `Session` object as a parameter. It checks if the `nextAnalyze` variable is equal to 0 or greater than the `changesSinceAnalyze` variable, and if so, it returns. Otherwise, it updates the `changesSinceAnalyze` variable, calculates a new value for `nextAnalyze`, and marks the table for analysis in the given session."
30,"lock(Session,boolean,boolean)",lock session exclusive force lock even in mvcc ,Method,,,"org.h2.engine.Database+getLockMode() org.h2.engine.Database+getLockMode() java.util.concurrent.ConcurrentHashMap+containsKey(Object) java.util.concurrent.ConcurrentHashMap+containsKey(Object) java.util.concurrent.ConcurrentHashMap+contains(Object) java.util.concurrent.ConcurrentHashMap+contains(Object) org.h2.engine.Session+setWaitForLock(Table,Thread) org.h2.engine.Session+setWaitForLock(Table,Thread) java.lang.Thread+currentThread() java.lang.Thread+currentThread() java.util.ArrayDeque+addLast(E) java.util.ArrayDeque+addLast(E) org.h2.table.PageStoreTable+doLock1(Session,int,boolean) org.h2.table.PageStoreTable+doLock1(Session,int,boolean) org.h2.engine.Session+setWaitForLock(Table,Thread) org.h2.engine.Session+setWaitForLock(Table,Thread) java.util.ArrayDeque+remove(Object) java.util.ArrayDeque+remove(Object)",org.h2.engine.DbObjectBase+database org.h2.engine.Constants+LOCK_MODE_OFF org.h2.table.PageStoreTable+lockExclusiveSession org.h2.table.PageStoreTable+lockExclusiveSession org.h2.table.PageStoreTable+lockSharedSessions org.h2.engine.DbObjectBase+database org.h2.table.PageStoreTable+lockSharedSessions org.h2.table.PageStoreTable+waitingSessions org.h2.table.PageStoreTable+waitingSessions,964,28,1,,"@Override
    public boolean lock(Session session, boolean exclusive,
            boolean forceLockEvenInMvcc) {
        int lockMode = database.getLockMode();
        if (lockMode == Constants.LOCK_MODE_OFF) {
            return lockExclusiveSession != null;
        }
        if (lockExclusiveSession == session) {
            return true;
        }
        if (!exclusive && lockSharedSessions.containsKey(session)) {
            return true;
        }
        synchronized (database) {
            if (!exclusive && lockSharedSessions.contains(session)) {
                return true;
            }
            session.setWaitForLock(this, Thread.currentThread());
            waitingSessions.addLast(session);
            try {
                doLock1(session, lockMode, exclusive);
            } finally {
                session.setWaitForLock(null, null);
                waitingSessions.remove(session);
            }
        }
        return false;
    }",False,False,"This method is used to lock a session in a database. It checks the lock mode of the database and determines whether the session should be locked exclusively or shared. It also handles waiting sessions and removes them once the lock is acquired. The method returns true if the session is successfully locked, and false otherwise.",True,"This code is a method that is used to lock a session in a database. It checks the lock mode of the database and determines if the session can be locked based on certain conditions. If the session can be locked, it performs the lock operation and returns false if the lock was unsuccessful."
31,"doLock1(Session,int,boolean)",do lock1 session lock mode exclusive ,Method,"lock(Session,boolean,boolean)",,"org.h2.table.PageStoreTable+traceLock(Session,boolean,String) org.h2.table.PageStoreTable+traceLock(Session,boolean,String) java.util.ArrayDeque+getFirst() java.util.ArrayDeque+getFirst() org.h2.table.PageStoreTable+doLock2(Session,int,boolean) org.h2.table.PageStoreTable+doLock2(Session,int,boolean) org.h2.table.PageStoreTable+checkDeadlock(Session,Session,Set<Session>) org.h2.table.PageStoreTable+checkDeadlock(Session,Session,Set<Session>) org.h2.message.DbException+get(int,String) org.h2.message.DbException+get(int,String) org.h2.table.PageStoreTable+getDeadlockDetails(ArrayList<Session>,boolean) org.h2.table.PageStoreTable+getDeadlockDetails(ArrayList<Session>,boolean) java.lang.System+nanoTime() java.lang.System+nanoTime() java.util.concurrent.TimeUnit+toNanos(long) java.util.concurrent.TimeUnit+toNanos(long) org.h2.engine.Session+getLockTimeout() org.h2.engine.Session+getLockTimeout() org.h2.table.PageStoreTable+traceLock(Session,boolean,String) org.h2.table.PageStoreTable+traceLock(Session,boolean,String) org.h2.engine.Session+getLockTimeout() org.h2.engine.Session+getLockTimeout() org.h2.message.DbException+get(int,String) org.h2.message.DbException+get(int,String) org.h2.engine.DbObjectBase+getName() org.h2.engine.DbObjectBase+getName() org.h2.table.PageStoreTable+traceLock(Session,boolean,String) org.h2.table.PageStoreTable+traceLock(Session,boolean,String) org.h2.engine.Database+getLockMode() org.h2.engine.Database+getLockMode() java.lang.Runtime+freeMemory() java.lang.Runtime+getRuntime() java.lang.Runtime+getRuntime() java.lang.Runtime+freeMemory() java.lang.System+gc() java.lang.System+gc() java.lang.Runtime+freeMemory() java.lang.Runtime+getRuntime() java.lang.Runtime+getRuntime() java.lang.Runtime+freeMemory() java.lang.Math+min(long,long) java.lang.Math+min(long,long) java.util.concurrent.TimeUnit+toMillis(long) java.util.concurrent.TimeUnit+toMillis(long) java.lang.Object+wait(long) java.lang.Object+wait(long)",org.h2.table.PageStoreTable+waitingSessions org.h2.api.ErrorCode+DEADLOCK_1 java.util.concurrent.TimeUnit+MILLISECONDS org.h2.api.ErrorCode+LOCK_TIMEOUT_1 org.h2.engine.DbObjectBase+database org.h2.engine.Constants+LOCK_MODE_TABLE_GC org.h2.engine.Constants+DEADLOCK_CHECK java.util.concurrent.TimeUnit+NANOSECONDS org.h2.engine.DbObjectBase+database,2311,54,2,,"private void doLock1(Session session, int lockMode, boolean exclusive) {
        traceLock(session, exclusive, ""requesting for"");
        // don't get the current time unless necessary
        long max = 0;
        boolean checkDeadlock = false;
        while (true) {
            // if I'm the next one in the queue
            if (waitingSessions.getFirst() == session) {
                if (doLock2(session, lockMode, exclusive)) {
                    return;
                }
            }
            if (checkDeadlock) {
                ArrayList<Session> sessions = checkDeadlock(session, null, null);
                if (sessions != null) {
                    throw DbException.get(ErrorCode.DEADLOCK_1,
                            getDeadlockDetails(sessions, exclusive));
                }
            } else {
                // check for deadlocks from now on
                checkDeadlock = true;
            }
            long now = System.nanoTime();
            if (max == 0) {
                // try at least one more time
                max = now + TimeUnit.MILLISECONDS.toNanos(session.getLockTimeout());
            } else if (now >= max) {
                traceLock(session, exclusive, ""timeout after "" + session.getLockTimeout());
                throw DbException.get(ErrorCode.LOCK_TIMEOUT_1, getName());
            }
            try {
                traceLock(session, exclusive, ""waiting for"");
                if (database.getLockMode() == Constants.LOCK_MODE_TABLE_GC) {
                    for (int i = 0; i < 20; i++) {
                        long free = Runtime.getRuntime().freeMemory();
                        System.gc();
                        long free2 = Runtime.getRuntime().freeMemory();
                        if (free == free2) {
                            break;
                        }
                    }
                }
                // don't wait too long so that deadlocks are detected early
                long sleep = Math.min(Constants.DEADLOCK_CHECK,
                        TimeUnit.NANOSECONDS.toMillis(max - now));
                if (sleep == 0) {
                    sleep = 1;
                }
                database.wait(sleep);
            } catch (InterruptedException e) {
                // ignore
            }
        }
    }",False,False,"The function of this method is to request a lock for a session, and wait until the lock is granted or a timeout occurs. It also checks for deadlocks and throws an exception if a deadlock is detected.",False,"The given code represents a method called `doLock1` that is responsible for requesting and waiting for a lock in a session. It checks for deadlocks, handles timeouts, and waits for a specified amount of time before retrying."
32,"doLock2(Session,int,boolean)",do lock2 session lock mode exclusive ,Method,"doLock1(Session,int,boolean)",,"java.util.concurrent.ConcurrentHashMap+isEmpty() java.util.concurrent.ConcurrentHashMap+isEmpty() org.h2.table.PageStoreTable+traceLock(Session,boolean,String) org.h2.table.PageStoreTable+traceLock(Session,boolean,String) org.h2.engine.Session+addLock(Table) org.h2.engine.Session+addLock(Table) java.util.concurrent.ConcurrentHashMap+size() java.util.concurrent.ConcurrentHashMap+size() java.util.concurrent.ConcurrentHashMap+containsKey(Object) java.util.concurrent.ConcurrentHashMap+containsKey(Object) org.h2.table.PageStoreTable+traceLock(Session,boolean,String) org.h2.table.PageStoreTable+traceLock(Session,boolean,String) org.h2.engine.Database+isMultiThreaded() org.h2.engine.Database+isMultiThreaded() java.util.concurrent.ConcurrentHashMap+containsKey(Object) java.util.concurrent.ConcurrentHashMap+containsKey(Object) org.h2.table.PageStoreTable+traceLock(Session,boolean,String) org.h2.table.PageStoreTable+traceLock(Session,boolean,String) org.h2.engine.Session+addLock(Table) org.h2.engine.Session+addLock(Table) java.util.concurrent.ConcurrentHashMap+put(K,V) java.util.concurrent.ConcurrentHashMap+put(K,V)",org.h2.table.PageStoreTable+lockExclusiveSession org.h2.table.PageStoreTable+lockSharedSessions org.h2.table.PageStoreTable+lockExclusiveSession org.h2.table.PageStoreTable+lockSharedSessions org.h2.table.PageStoreTable+lockSharedSessions org.h2.table.PageStoreTable+lockExclusiveSession org.h2.table.PageStoreTable+lockExclusiveSession org.h2.engine.Constants+LOCK_MODE_READ_COMMITTED org.h2.engine.DbObjectBase+database org.h2.table.PageStoreTable+lockSharedSessions org.h2.table.PageStoreTable+lockSharedSessions,1658,38,2,,"private boolean doLock2(Session session, int lockMode, boolean exclusive) {
        if (exclusive) {
            if (lockExclusiveSession == null) {
                if (lockSharedSessions.isEmpty()) {
                    traceLock(session, exclusive, ""added for"");
                    session.addLock(this);
                    lockExclusiveSession = session;
                    return true;
                } else if (lockSharedSessions.size() == 1 &&
                        lockSharedSessions.containsKey(session)) {
                    traceLock(session, exclusive, ""add (upgraded) for "");
                    lockExclusiveSession = session;
                    return true;
                }
            }
        } else {
            if (lockExclusiveSession == null) {
                if (lockMode == Constants.LOCK_MODE_READ_COMMITTED) {
                    if (!database.isMultiThreaded()) {
                        // READ_COMMITTED: a read lock is acquired,
                        // but released immediately after the operation
                        // is complete.
                        // When allowing only one thread, no lock is
                        // required.
                        // Row level locks work like read committed.
                        return true;
                    }
                }
                if (!lockSharedSessions.containsKey(session)) {
                    traceLock(session, exclusive, ""ok"");
                    session.addLock(this);
                    lockSharedSessions.put(session, session);
                }
                return true;
            }
        }
        return false;
    }",False,False,"This method serves to lock a session based on the given lock mode and exclusivity. It checks if the session is exclusive and if the lockExclusiveSession is null. If true, it adds the session to the lockExclusiveSession and returns true. If false, it checks if the lockSharedSessions is empty or if there is only one session in lockSharedSessions and it matches the given session. If true, it adds the session to the lockExclusiveSession and returns true. If false, it checks if the lockExclusiveSession is null and if the lockMode is Constants.LOCK_MODE_READ_COMMITTED. If true, it checks if the database is not multi-threaded and returns true. If false, it checks if the session is not in lockSharedSessions. If true, it adds the session to lockSharedSessions and returns true. If false, it returns false.",False,"The `doLock2` method is used to acquire locks on a session in a database. It checks if the lock is exclusive or shared, and based on that, it either adds the session to the lock or upgrades the lock to exclusive mode. If the lock is shared, it checks if the session already has the lock and adds it if not."
33,"getDeadlockDetails(ArrayList<Session>,boolean)",get deadlock details sessions exclusive ,Method,"doLock1(Session,int,boolean)",,java.lang.StringBuilder+StringBuilder() org.h2.engine.Session+getWaitForLock() org.h2.engine.Session+getWaitForLock() org.h2.engine.Session+getWaitForLockThread() org.h2.engine.Session+getWaitForLockThread() java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) org.h2.engine.Session+toString() org.h2.engine.Session+toString() java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.Thread+getName() java.lang.Thread+getName() java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) org.h2.engine.DbObjectBase+toString() org.h2.engine.DbObjectBase+toString() java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) org.h2.engine.Session+getLocks() org.h2.engine.Session+getLocks() java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) org.h2.engine.DbObjectBase+toString() org.h2.engine.DbObjectBase+toString() java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(String) java.lang.StringBuilder+append(char) java.lang.StringBuilder+append(char) java.lang.StringBuilder+toString() java.lang.StringBuilder+toString(),org.h2.table.PageStoreTable+lockExclusiveSession org.h2.table.PageStoreTable+lockExclusiveSession,1357,33,10,,"private static String getDeadlockDetails(ArrayList<Session> sessions, boolean exclusive) {
        // We add the thread details here to make it easier for customers to
        // match up these error messages with their own logs.
        StringBuilder buff = new StringBuilder();
        for (Session s : sessions) {
            Table lock = s.getWaitForLock();
            Thread thread = s.getWaitForLockThread();
            buff.append(""\nSession "").
                append(s.toString()).
                append("" on thread "").
                append(thread.getName()).
                append("" is waiting to lock "").
                append(lock.toString()).
                append(exclusive ? "" (exclusive)"" : "" (shared)"").
                append("" while locking "");
            int i = 0;
            for (Table t : s.getLocks()) {
                if (i++ > 0) {
                    buff.append("", "");
                }
                buff.append(t.toString());
                if (t instanceof PageStoreTable) {
                    if (((PageStoreTable) t).lockExclusiveSession == s) {
                        buff.append("" (exclusive)"");
                    } else {
                        buff.append("" (shared)"");
                    }
                }
            }
            buff.append('.');
        }
        return buff.toString();
    }",True,True,"This method takes an ArrayList of Session objects and a boolean value as parameters. It iterates through each Session object in the list and retrieves the lock and thread details. It then appends these details to a StringBuilder object. Finally, it returns the string representation of the StringBuilder object.",False,This code defines a private static method called `getDeadlockDetails` that takes an ArrayList of Session objects and a boolean value as parameters. It iterates over the sessions and retrieves information about the locks and threads involved in a potential deadlock scenario. It then appends this information to a StringBuilder and returns the resulting string.
34,"checkDeadlock(Session,Session,Set<Session>)",check deadlock session clash visited ,Method,"doLock1(Session,int,boolean)",,"java.util.Set+contains(Object) java.util.Set+contains(Object) java.util.Set+add(E) java.util.Set+add(E) java.util.concurrent.ConcurrentHashMap+keySet() java.util.concurrent.ConcurrentHashMap+keySet() org.h2.engine.Session+getWaitForLock() org.h2.engine.Session+getWaitForLock() org.h2.table.Table+checkDeadlock(Session,Session,Set<Session>) org.h2.table.Table+checkDeadlock(Session,Session,Set<Session>) java.util.ArrayList+add(E) java.util.ArrayList+add(E) org.h2.engine.Session+getWaitForLock() org.h2.engine.Session+getWaitForLock() org.h2.table.Table+checkDeadlock(Session,Session,Set<Session>) org.h2.table.Table+checkDeadlock(Session,Session,Set<Session>) java.util.ArrayList+add(E) java.util.ArrayList+add(E)",org.h2.table.PageStoreTable+lockSharedSessions org.h2.table.PageStoreTable+lockExclusiveSession,2077,49,1,,"@Override
    public ArrayList<Session> checkDeadlock(Session session, Session clash,
            Set<Session> visited) {
        // only one deadlock check at any given time
        synchronized (PageStoreTable.class) {
            if (clash == null) {
                // verification is started
                clash = session;
                visited = new HashSet<>();
            } else if (clash == session) {
                // we found a cycle where this session is involved
                return new ArrayList<>(0);
            } else if (visited.contains(session)) {
                // we have already checked this session.
                // there is a cycle, but the sessions in the cycle need to
                // find it out themselves
                return null;
            }
            visited.add(session);
            ArrayList<Session> error = null;
            for (Session s : lockSharedSessions.keySet()) {
                if (s == session) {
                    // it doesn't matter if we have locked the object already
                    continue;
                }
                Table t = s.getWaitForLock();
                if (t != null) {
                    error = t.checkDeadlock(s, clash, visited);
                    if (error != null) {
                        error.add(session);
                        break;
                    }
                }
            }
            // take a local copy so we don't see inconsistent data, since we are
            // not locked while checking the lockExclusiveSession value
            Session copyOfLockExclusiveSession = lockExclusiveSession;
            if (error == null && copyOfLockExclusiveSession != null) {
                Table t = copyOfLockExclusiveSession.getWaitForLock();
                if (t != null) {
                    error = t.checkDeadlock(copyOfLockExclusiveSession, clash, visited);
                    if (error != null) {
                        error.add(session);
                    }
                }
            }
            return error;
        }
    }",False,True,"The function of this method is to check for deadlocks in a system by recursively checking if a session is involved in a cycle of dependencies. It returns an ArrayList of sessions that are involved in the deadlock, or null if no deadlock is found.",False,"This code is a method that checks for deadlocks in a database system. It takes a session and a clash session as input, and recursively checks if there is a cycle involving the sessions. If a deadlock is detected, it returns a list of sessions involved in the deadlock."
35,"traceLock(Session,boolean,String)",trace lock session exclusive s ,Method,"doLock1(Session,int,boolean) doLock1(Session,int,boolean) doLock1(Session,int,boolean) doLock2(Session,int,boolean) doLock2(Session,int,boolean) doLock2(Session,int,boolean) unlock(Session)",,"org.h2.message.Trace+isDebugEnabled() org.h2.message.Trace+isDebugEnabled() org.h2.message.Trace+debug(String,Object[]) org.h2.message.Trace+debug(String,Object[]) org.h2.engine.Session+getId() org.h2.engine.Session+getId() org.h2.engine.DbObjectBase+getName() org.h2.engine.DbObjectBase+getName()",org.h2.table.PageStoreTable+traceLock org.h2.table.PageStoreTable+traceLock,284,6,2,,"private void traceLock(Session session, boolean exclusive, String s) {
        if (traceLock.isDebugEnabled()) {
            traceLock.debug(""{0} {1} {2} {3}"", session.getId(),
                    exclusive ? ""exclusive write lock"" : ""shared read lock"", s, getName());
        }
    }",False,False,"This method is used to trace and log the lock status of a session. It takes the session, lock type (exclusive or shared), and a string as input, and logs the lock status using the session ID and lock type.",False,"The `traceLock` method is a private method that takes in a `Session` object, a boolean value indicating whether the lock is exclusive or shared, and a string. It logs a debug message using the `traceLock` logger, including the session ID, the type of lock, the string, and the name of the object."
36,isLockedExclusively(),is locked exclusively ,Method,,,,org.h2.table.PageStoreTable+lockExclusiveSession,103,4,1,,"@Override
    public boolean isLockedExclusively() {
        return lockExclusiveSession != null;
    }",True,True,This method checks if the lockExclusiveSession is not null and returns a boolean value indicating whether the lock is exclusively locked or not.,True,"The code defines a method named ""isLockedExclusively"" which returns a boolean value. It checks if the ""lockExclusiveSession"" variable is not null and returns true if it is not null, indicating that the lock is held exclusively; otherwise, it returns false."
37,isLockedExclusivelyBy(Session),is locked exclusively by session ,Method,,,,org.h2.table.PageStoreTable+lockExclusiveSession,123,4,1,,"@Override
    public boolean isLockedExclusivelyBy(Session session) {
        return lockExclusiveSession == session;
    }",True,True,"This method checks if the lock is exclusively held by a specific session. It returns true if the lock is held by the given session, and false otherwise.",True,"The code defines a method named `isLockedExclusivelyBy` that checks if a given session is the exclusive lock holder. It returns `true` if the provided session matches the `lockExclusiveSession` variable, indicating that the lock is held exclusively by that session, otherwise it returns `false`."
38,unlock(Session),unlock s ,Method,,,"org.h2.table.PageStoreTable+traceLock(Session,boolean,String) org.h2.table.PageStoreTable+traceLock(Session,boolean,String) java.util.concurrent.ConcurrentHashMap+remove(Object) java.util.concurrent.ConcurrentHashMap+remove(Object) java.util.concurrent.ConcurrentHashMap+isEmpty() java.util.concurrent.ConcurrentHashMap+isEmpty() java.util.concurrent.ConcurrentHashMap+remove(Object) java.util.concurrent.ConcurrentHashMap+remove(Object) java.util.ArrayDeque+isEmpty() java.util.ArrayDeque+isEmpty() java.lang.Object+notifyAll() java.lang.Object+notifyAll()",org.h2.engine.DbObjectBase+database org.h2.table.PageStoreTable+lockExclusiveSession org.h2.table.PageStoreTable+lockExclusiveSession org.h2.table.PageStoreTable+lockSharedSessions org.h2.table.PageStoreTable+lockExclusiveSession org.h2.engine.DbObjectBase+database org.h2.table.PageStoreTable+lockSharedSessions org.h2.table.PageStoreTable+lockSharedSessions org.h2.table.PageStoreTable+waitingSessions org.h2.engine.DbObjectBase+database,589,18,1,,"@Override
    public void unlock(Session s) {
        if (database != null) {
            traceLock(s, lockExclusiveSession == s, ""unlock"");
            if (lockExclusiveSession == s) {
                lockSharedSessions.remove(s);
                lockExclusiveSession = null;
            }
            synchronized (database) {
                if (!lockSharedSessions.isEmpty()) {
                    lockSharedSessions.remove(s);
                }
                if (!waitingSessions.isEmpty()) {
                    database.notifyAll();
                }
            }
        }
    }",False,False,"This method unlocks a session by removing it from the list of shared sessions or exclusive session, and notifies waiting sessions if there are any.",True,"This code is a method called ""unlock"" that is used to release a lock on a session. It checks if the database is not null, traces the lock, and if the lock is exclusive to the session, it removes the session from the shared sessions and sets the exclusive session to null. It then synchronizes with the database, removes the session from the shared sessions if it is not empty, and notifies all waiting sessions if there are any."
39,setRowCount(long),set row count count set the row count of this table param count the row count ,Method,,"org.h2.index.PageBtreeIndex+truncate(Session) org.h2.index.PageDataIndex+PageDataIndex(PageStoreTable,int,IndexColumn[],IndexType,boolean,Session) org.h2.index.PageDataIndex+truncate(Session) org.h2.index.ScanIndex+truncate(Session)",,org.h2.table.PageStoreTable+rowCount org.h2.table.PageStoreTable+rowCount,171,8,1,"/** 
 * Set the row count of this table.
 * @param count the row count
 */
","/**
     * Set the row count of this table.
     *
     * @param count the row count
     */
    public void setRowCount(long count) {
        this.rowCount = count;
    }",False,False,This method sets the row count of a table. It takes a long value as a parameter and assigns it to the rowCount variable of the table.,False,"This code defines a method called ""setRowCount"" that takes a long value as a parameter and sets it as the row count for a table. The method does not return any value."
40,removeChildrenAndResources(Session),remove children and resources session ,Method,,,"org.h2.table.PageStoreTable+truncate(Session) org.h2.table.PageStoreTable+truncate(Session) org.h2.store.LobStorageInterface+removeAllForTable(int) org.h2.engine.Database+getLobStorage() org.h2.engine.Database+getLobStorage() org.h2.store.LobStorageInterface+removeAllForTable(int) org.h2.engine.DbObjectBase+getId() org.h2.engine.DbObjectBase+getId() org.h2.engine.Database+lockMeta(Session) org.h2.engine.Database+lockMeta(Session) org.h2.table.Table+removeChildrenAndResources(Session) java.util.ArrayList+size() java.util.ArrayList+size() java.util.ArrayList+get(int) java.util.ArrayList+get(int) org.h2.engine.DbObject+getName() org.h2.engine.DbObject+getName() org.h2.engine.Database+removeSchemaObject(Session,SchemaObject) org.h2.engine.Database+removeSchemaObject(Session,SchemaObject) java.util.ArrayList+remove(Object) java.util.ArrayList+remove(Object) org.h2.engine.Database+getAllSchemaObjects(int) org.h2.engine.Database+getAllSchemaObjects(int) org.h2.index.Index+getTable() org.h2.index.Index+getTable() org.h2.message.DbException+throwInternalError(String) org.h2.message.DbException+throwInternalError(String) org.h2.engine.DbObject+getName() org.h2.engine.DbObject+getName() org.h2.index.Index+remove(Session) org.h2.index.Index+remove(Session) org.h2.engine.Database+removeMeta(Session,int) org.h2.engine.Database+removeMeta(Session,int) org.h2.engine.DbObjectBase+getId() org.h2.engine.DbObjectBase+getId() org.h2.engine.DbObjectBase+invalidate() org.h2.engine.DbObjectBase+invalidate()",org.h2.table.PageStoreTable+containsLargeObject org.h2.engine.DbObjectBase+database org.h2.engine.DbObjectBase+database org.h2.table.PageStoreTable+indexes org.h2.table.PageStoreTable+indexes org.h2.engine.DbObjectBase+database org.h2.table.PageStoreTable+indexes org.h2.engine.SysProperties+CHECK org.h2.engine.DbObjectBase+database org.h2.engine.DbObject+INDEX org.h2.table.PageStoreTable+scanIndex org.h2.engine.DbObjectBase+database org.h2.table.PageStoreTable+scanIndex org.h2.table.PageStoreTable+lockExclusiveSession org.h2.table.PageStoreTable+lockSharedSessions,1290,33,1,,"@Override
    public void removeChildrenAndResources(Session session) {
        if (containsLargeObject) {
            // unfortunately, the data is gone on rollback
            truncate(session);
            database.getLobStorage().removeAllForTable(getId());
            database.lockMeta(session);
        }
        super.removeChildrenAndResources(session);
        // go backwards because database.removeIndex will call table.removeIndex
        while (indexes.size() > 1) {
            Index index = indexes.get(1);
            if (index.getName() != null) {
                database.removeSchemaObject(session, index);
            }
            // needed for session temporary indexes
            indexes.remove(index);
        }
        if (SysProperties.CHECK) {
            for (SchemaObject obj : database.getAllSchemaObjects(DbObject.INDEX)) {
                Index index = (Index) obj;
                if (index.getTable() == this) {
                    DbException.throwInternalError(""index not dropped: "" + index.getName());
                }
            }
        }
        scanIndex.remove(session);
        database.removeMeta(session, getId());
        scanIndex = null;
        lockExclusiveSession = null;
        lockSharedSessions = null;
        invalidate();
    }",False,False,"This method removes children and resources associated with a session. If a large object is present, it truncates the session, removes all large objects for the table, and locks the meta session. It then removes indexes, checks for dropped indexes, removes the scan index, removes meta information, and invalidates the session.",True,"This code is a method that removes children and resources associated with a database table. It first checks if the table contains a large object, and if so, truncates the table, removes all large objects for the table, and locks the metadata. Then, it removes all indexes except for the primary index, checks if any indexes were not dropped, removes the scan index, removes the metadata for the table, and invalidates the table."
41,toString(),to string ,Method,,,org.h2.schema.SchemaObjectBase+getSQL(boolean) org.h2.schema.SchemaObjectBase+getSQL(boolean),,76,4,1,,"@Override
    public String toString() {
        return getSQL(false);
    }",True,True,The method overrides the toString() function and returns the result of the getSQL() method with a parameter value of false.,False,The code overrides the `toString()` method and returns the result of calling the `getSQL()` method with a `false` parameter. The `getSQL()` method likely generates and returns a SQL query as a string.
42,checkRename(),check rename ,Method,,,,,61,4,1,,"@Override
    public void checkRename() {
        // ok
    }",True,True,"This method serves as an override for the checkRename() method. It does not have any specific functionality as it only contains a comment saying ""ok"".",True,"The code snippet contains a method named ""checkRename"" which does not take any parameters and does not have any implementation logic. It is annotated with ""@Override"" indicating that it overrides a method from a superclass or interface."
43,checkSupportAlter(),check support alter ,Method,,,,,67,4,1,,"@Override
    public void checkSupportAlter() {
        // ok
    }",True,True,"This method serves as an override for the checkSupportAlter() method. It does not have any specific functionality and only contains a comment stating ""ok"".",True,"The code snippet is a method named ""checkSupportAlter"" that does not take any parameters and does not return any value. It is annotated with ""@Override"" indicating that it overrides a method from a superclass or interface. The method does not contain any logic or functionality as it only contains a comment saying ""ok""."
44,canTruncate(),can truncate ,Method,,,org.h2.table.Table+getCheckForeignKeyConstraints() org.h2.table.Table+getCheckForeignKeyConstraints() org.h2.engine.Database+getReferentialIntegrity() org.h2.engine.Database+getReferentialIntegrity() org.h2.table.Table+getConstraints() org.h2.table.Table+getConstraints() org.h2.constraint.Constraint+getConstraintType() org.h2.constraint.Constraint+getConstraintType() org.h2.constraint.ConstraintReferential+getRefTable() org.h2.constraint.ConstraintReferential+getRefTable(),org.h2.engine.DbObjectBase+database,678,18,1,,"@Override
    public boolean canTruncate() {
        if (getCheckForeignKeyConstraints() && database.getReferentialIntegrity()) {
            ArrayList<Constraint> constraints = getConstraints();
            if (constraints != null) {
                for (Constraint c : constraints) {
                    if (c.getConstraintType() != Constraint.Type.REFERENTIAL) {
                        continue;
                    }
                    ConstraintReferential ref = (ConstraintReferential) c;
                    if (ref.getRefTable() == this) {
                        return false;
                    }
                }
            }
        }
        return true;
    }",True,True,"This method checks if a table can be truncated by verifying if there are any referential constraints that reference the table. If there are no such constraints, it returns true; otherwise, it returns false.",True,"The `canTruncate()` method checks if a table can be truncated by verifying if there are any foreign key constraints and if referential integrity is enabled. It iterates through the constraints of the table and returns false if it finds a referential constraint that references the table itself, otherwise it returns true."
45,getTableType(),get table type ,Method,,,,,85,4,1,,"@Override
    public TableType getTableType() {
        return TableType.TABLE;
    }",False,False,This method returns the TableType of a table.,True,"The code snippet defines a method named `getTableType()` that returns a value of type `TableType`. The method is annotated with `@Override`, indicating that it overrides a method from a superclass or interface. The method implementation simply returns `TableType.TABLE`."
46,getMaxDataModificationId(),get max data modification id ,Method,,,,org.h2.table.PageStoreTable+lastModificationId,95,4,1,,"@Override
    public long getMaxDataModificationId() {
        return lastModificationId;
    }",False,False,This method returns the maximum data modification ID.,True,"The code snippet defines a method named `getMaxDataModificationId()` that returns the value of a variable `lastModificationId`. This method is annotated with `@Override`, indicating that it overrides a method from a superclass or interface."
47,getContainsLargeObject(),get contains large object ,Method,,"org.h2.index.PageBtreeIndex+truncate(Session) org.h2.index.PageDataIndex+remove(Session,Row) org.h2.index.PageDataIndex+truncate(Session) org.h2.index.ScanIndex+truncate(Session)",,org.h2.table.PageStoreTable+containsLargeObject,83,3,1,,"public boolean getContainsLargeObject() {
        return containsLargeObject;
    }",True,True,This method returns a boolean value indicating whether or not the object contains a large object.,False,"The code contains a method named ""getContainsLargeObject"" which returns a boolean value indicating whether a large object is present or not. It is a simple getter method that retrieves the value of the ""containsLargeObject"" variable."
48,getRowCountApproximation(),get row count approximation ,Method,,"org.h2.index.PageBtreeIndex+getRowCountApproximation() org.h2.index.PageDataIndex+getCost(Session,int[],TableFilter[],int,SortOrder,AllColumnsForPlan) org.h2.index.ScanIndex+getCost(Session,int[],TableFilter[],int,SortOrder,AllColumnsForPlan) org.h2.index.TreeIndex+getCost(Session,int[],TableFilter[],int,SortOrder,AllColumnsForPlan)",org.h2.index.Index+getRowCountApproximation() org.h2.index.Index+getRowCountApproximation(),org.h2.table.PageStoreTable+scanIndex,113,4,1,,"@Override
    public long getRowCountApproximation() {
        return scanIndex.getRowCountApproximation();
    }",False,False,This method serves to return an approximate count of the number of rows in a scan index.,True,The code snippet defines an overridden method named `getRowCountApproximation()` that returns the approximate number of rows in a data scan. The method simply delegates the task to another method called `getRowCountApproximation()` of the `scanIndex` object and returns its result.
49,getDiskSpaceUsed(),get disk space used ,Method,,org.h2.index.PageBtreeIndex+getDiskSpaceUsed(),org.h2.index.Index+getDiskSpaceUsed() org.h2.index.Index+getDiskSpaceUsed(),org.h2.table.PageStoreTable+scanIndex,97,4,1,,"@Override
    public long getDiskSpaceUsed() {
        return scanIndex.getDiskSpaceUsed();
    }",False,False,This method serves to retrieve the amount of disk space used by the scan index.,True,"The code snippet defines an overridden method named ""getDiskSpaceUsed"" that returns the amount of disk space used. It retrieves this information by calling the ""getDiskSpaceUsed"" method of the ""scanIndex"" object."
50,setCompareMode(CompareMode),set compare mode compare mode ,Method,,"org.h2.store.PageStore+addMeta(Row,Session,boolean)",,org.h2.table.Table+compareMode org.h2.table.Table+compareMode,99,3,1,,"public void setCompareMode(CompareMode compareMode) {
        this.compareMode = compareMode;
    }",False,False,This method sets the compare mode for an object.,False,"The code defines a method named ""setCompareMode"" that takes a parameter of type ""CompareMode"" and assigns it to the instance variable ""compareMode"" of the current object. This method allows for setting the compare mode for the object."
51,isDeterministic(),is deterministic ,Method,,,,,75,4,1,,"@Override
    public boolean isDeterministic() {
        return true;
    }",True,True,"The function of the method isDeterministic() is to return a boolean value of true, indicating that the object or system it belongs to is deterministic.",True,"The code snippet defines a method named ""isDeterministic"" that returns a boolean value. The method is marked with the ""@Override"" annotation, indicating that it overrides a method from a superclass or interface. The method always returns true, indicating that the behavior it represents is deterministic."
52,getRowIdColumn(),get row id column ,Method,,,"org.h2.table.Column+Column(String,int) org.h2.table.Column+setTable(Table,int) org.h2.table.Column+setTable(Table,int) org.h2.table.Column+setRowId(boolean) org.h2.table.Column+setRowId(boolean)",org.h2.table.PageStoreTable+rowIdColumn org.h2.table.PageStoreTable+rowIdColumn org.h2.table.Column+ROWID org.h2.value.Value+LONG org.h2.table.PageStoreTable+rowIdColumn org.h2.table.PageStoreTable+rowIdColumn org.h2.table.PageStoreTable+rowIdColumn,273,9,1,,"@Override
    public Column getRowIdColumn() {
        if (rowIdColumn == null) {
            rowIdColumn = new Column(Column.ROWID, Value.LONG);
            rowIdColumn.setTable(this, -1);
            rowIdColumn.setRowId(true);
        }
        return rowIdColumn;
    }",True,True,"This method returns the row ID column. If the row ID column is null, it creates a new column with the row ID and sets it as the row ID column for the table. Finally, it returns the row ID column.",True,"This code defines a method called `getRowIdColumn()` that returns a `Column` object. If the `rowIdColumn` is null, it creates a new `Column` object with a row ID and sets it as the `rowIdColumn` for the table. Finally, it returns the `rowIdColumn`."
