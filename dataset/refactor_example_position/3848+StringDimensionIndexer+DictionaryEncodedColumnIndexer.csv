index,name,type,inner invocations,external invocations,calls,visits,length,lines,start location,definition line,modifier,annotation,full text,removed
1,emptyToNullIfNeeded(Object),Method,"processRowValsToUnsortedEncodedKeyComponent(Object,boolean) processRowValsToUnsortedEncodedKeyComponent(Object,boolean) processRowValsToUnsortedEncodedKeyComponent(Object,boolean)",,org.apache.druid.common.config.NullHandling+emptyToNullIfNeeded(String) org.apache.druid.common.config.NullHandling+emptyToNullIfNeeded(String) java.lang.Object+toString() java.lang.Object+toString(),,159,5,3010,68,10,,"@Nullable
  private static String emptyToNullIfNeeded(@Nullable Object o)
  {
    return o != null ? NullHandling.emptyToNullIfNeeded(o.toString()) : null;
  }",False
2,ABSENT_VALUE_ID,Field,,,,,46,1,3173,73,26,,private static final int ABSENT_VALUE_ID = -1;,True
3,DimensionDictionary,MemberClass,,,"org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+DimensionDictionary() java.util.concurrent.locks.ReentrantReadWriteLock+ReentrantReadWriteLock() org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+getId(String) java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock+lock() java.util.concurrent.locks.ReentrantReadWriteLock+readLock() java.util.concurrent.locks.ReentrantReadWriteLock+readLock() java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock+lock() java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock+unlock() java.util.concurrent.locks.ReentrantReadWriteLock+readLock() java.util.concurrent.locks.ReentrantReadWriteLock+readLock() java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock+unlock() org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+getValue(int) java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock+lock() java.util.concurrent.locks.ReentrantReadWriteLock+readLock() java.util.concurrent.locks.ReentrantReadWriteLock+readLock() java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock+lock() java.util.List+get(int) java.util.List+get(int) java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock+unlock() java.util.concurrent.locks.ReentrantReadWriteLock+readLock() java.util.concurrent.locks.ReentrantReadWriteLock+readLock() java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock+unlock() org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+size() java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock+lock() java.util.concurrent.locks.ReentrantReadWriteLock+readLock() java.util.concurrent.locks.ReentrantReadWriteLock+readLock() java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock+lock() java.util.List+size() java.util.List+size() java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock+unlock() java.util.concurrent.locks.ReentrantReadWriteLock+readLock() java.util.concurrent.locks.ReentrantReadWriteLock+readLock() java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock+unlock() org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+add(String) java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock+lock() java.util.concurrent.locks.ReentrantReadWriteLock+writeLock() java.util.concurrent.locks.ReentrantReadWriteLock+writeLock() java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock+lock() java.util.List+size() java.util.List+size() java.util.List+add(E) java.util.List+add(E) java.util.List+size() java.util.List+size() java.util.List+add(E) java.util.List+add(E) java.lang.String+compareTo(String) java.lang.String+compareTo(String) java.lang.String+compareTo(String) java.lang.String+compareTo(String) java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock+unlock() java.util.concurrent.locks.ReentrantReadWriteLock+writeLock() java.util.concurrent.locks.ReentrantReadWriteLock+writeLock() java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock+unlock() org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+getMinValue() java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock+lock() java.util.concurrent.locks.ReentrantReadWriteLock+readLock() java.util.concurrent.locks.ReentrantReadWriteLock+readLock() java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock+lock() java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock+unlock() java.util.concurrent.locks.ReentrantReadWriteLock+readLock() java.util.concurrent.locks.ReentrantReadWriteLock+readLock() java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock+unlock() org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+getMaxValue() java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock+lock() java.util.concurrent.locks.ReentrantReadWriteLock+readLock() java.util.concurrent.locks.ReentrantReadWriteLock+readLock() java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock+lock() java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock+unlock() java.util.concurrent.locks.ReentrantReadWriteLock+readLock() java.util.concurrent.locks.ReentrantReadWriteLock+readLock() java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock+unlock() org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+sort() java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock+lock() java.util.concurrent.locks.ReentrantReadWriteLock+readLock() java.util.concurrent.locks.ReentrantReadWriteLock+readLock() java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock+lock() org.apache.druid.segment.StringDimensionIndexer.SortedDimensionDictionary+SortedDimensionDictionary(List<String>,int) java.util.List+size() java.util.List+size() java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock+unlock() java.util.concurrent.locks.ReentrantReadWriteLock+readLock() java.util.concurrent.locks.ReentrantReadWriteLock+readLock() java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock+unlock()",org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+minValue org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+maxValue org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+idForNull org.apache.druid.segment.StringDimensionIndexer+ABSENT_VALUE_ID org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+valueToId org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+idToValue org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+lock org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+lock org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+valueToId org.apache.druid.segment.StringDimensionIndexer+ABSENT_VALUE_ID org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+lock org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+idForNull org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+valueToId org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+lock org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+lock org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+idForNull org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+idToValue org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+lock org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+lock org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+idToValue org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+lock org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+lock org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+idForNull org.apache.druid.segment.StringDimensionIndexer+ABSENT_VALUE_ID org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+idForNull org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+idToValue org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+idToValue org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+idForNull org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+valueToId org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+idToValue org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+valueToId org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+idToValue org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+minValue org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+minValue org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+minValue org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+minValue org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+maxValue org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+maxValue org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+maxValue org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+maxValue org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+lock org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+lock org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+minValue org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+lock org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+lock org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+maxValue org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+lock org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+lock org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+idToValue org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+idToValue org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+lock,2824,120,-1,-1,10,,"private static class DimensionDictionary
  {
    @Nullable
    private String minValue = null;
    @Nullable
    private String maxValue = null;
    private volatile int idForNull = ABSENT_VALUE_ID;

    private final Object2IntMap<String> valueToId = new Object2IntOpenHashMap<>();

    private final List<String> idToValue = new ArrayList<>();
    private final ReentrantReadWriteLock lock;

    public DimensionDictionary()
    {
      this.lock = new ReentrantReadWriteLock();
      valueToId.defaultReturnValue(ABSENT_VALUE_ID);
    }

    public int getId(@Nullable String value)
    {
      lock.readLock().lock();
      try {
        if (value == null) {
          return idForNull;
        }
        return valueToId.getInt(value);
      }
      finally {
        lock.readLock().unlock();
      }
    }

    @Nullable
    public String getValue(int id)
    {
      lock.readLock().lock();
      try {
        if (id == idForNull) {
          return null;
        }
        return idToValue.get(id);
      }
      finally {
        lock.readLock().unlock();
      }
    }

    public int size()
    {
      lock.readLock().lock();
      try {
        // using idToValue rather than valueToId because the valueToId doesn't account null value, if it is present.
        return idToValue.size();
      }
      finally {
        lock.readLock().unlock();
      }
    }

    public int add(@Nullable String originalValue)
    {
      lock.writeLock().lock();
      try {
        if (originalValue == null) {
          if (idForNull == ABSENT_VALUE_ID) {
            idForNull = idToValue.size();
            idToValue.add(null);
          }
          return idForNull;
        }
        int prev = valueToId.getInt(originalValue);
        if (prev >= 0) {
          return prev;
        }
        final int index = idToValue.size();
        valueToId.put(originalValue, index);
        idToValue.add(originalValue);
        minValue = minValue == null || minValue.compareTo(originalValue) > 0 ? originalValue : minValue;
        maxValue = maxValue == null || maxValue.compareTo(originalValue) < 0 ? originalValue : maxValue;
        return index;
      }
      finally {
        lock.writeLock().unlock();
      }
    }

    public String getMinValue()
    {
      lock.readLock().lock();
      try {
        return minValue;
      }
      finally {
        lock.readLock().unlock();
      }
    }

    public String getMaxValue()
    {
      lock.readLock().lock();
      try {
        return maxValue;
      }
      finally {
        lock.readLock().unlock();
      }
    }

    public SortedDimensionDictionary sort()
    {
      lock.readLock().lock();
      try {
        return new SortedDimensionDictionary(idToValue, idToValue.size());
      }
      finally {
        lock.readLock().unlock();
      }
    }
  }",False
4,SortedDimensionDictionary,MemberClass,,,"org.apache.druid.segment.StringDimensionIndexer.SortedDimensionDictionary+SortedDimensionDictionary(List<String>,int) java.lang.Object+Object() org.apache.druid.java.util.common.guava.Comparators+naturalNullsFirst() org.apache.druid.java.util.common.guava.Comparators+naturalNullsFirst() java.util.List+get(int) java.util.List+get(int) org.apache.druid.segment.StringDimensionIndexer.SortedDimensionDictionary+getUnsortedIdFromSortedId(int) org.apache.druid.segment.StringDimensionIndexer.SortedDimensionDictionary+getSortedIdFromUnsortedId(int) org.apache.druid.segment.StringDimensionIndexer.SortedDimensionDictionary+getValueFromSortedId(int) java.util.List+get(int) java.util.List+get(int)",org.apache.druid.segment.StringDimensionIndexer.SortedDimensionDictionary+sortedVals org.apache.druid.segment.StringDimensionIndexer.SortedDimensionDictionary+idToIndex org.apache.druid.segment.StringDimensionIndexer.SortedDimensionDictionary+indexToId org.apache.druid.segment.StringDimensionIndexer.SortedDimensionDictionary+sortedVals org.apache.druid.segment.StringDimensionIndexer.SortedDimensionDictionary+idToIndex org.apache.druid.segment.StringDimensionIndexer.SortedDimensionDictionary+indexToId org.apache.druid.segment.StringDimensionIndexer.SortedDimensionDictionary+idToIndex org.apache.druid.segment.StringDimensionIndexer.SortedDimensionDictionary+indexToId org.apache.druid.segment.StringDimensionIndexer.SortedDimensionDictionary+indexToId org.apache.druid.segment.StringDimensionIndexer.SortedDimensionDictionary+idToIndex org.apache.druid.segment.StringDimensionIndexer.SortedDimensionDictionary+sortedVals,1150,40,-1,-1,10,,"private static class SortedDimensionDictionary
  {
    private final List<String> sortedVals;
    private final int[] idToIndex;
    private final int[] indexToId;

    public SortedDimensionDictionary(List<String> idToValue, int length)
    {
      Object2IntSortedMap<String> sortedMap = new Object2IntRBTreeMap<>(Comparators.naturalNullsFirst());
      for (int id = 0; id < length; id++) {
        String value = idToValue.get(id);
        sortedMap.put(value, id);
      }
      this.sortedVals = Lists.newArrayList(sortedMap.keySet());
      this.idToIndex = new int[length];
      this.indexToId = new int[length];
      int index = 0;
      for (IntIterator iterator = sortedMap.values().iterator(); iterator.hasNext(); ) {
        int id = iterator.nextInt();
        idToIndex[id] = index;
        indexToId[index] = id;
        index++;
      }
    }

    public int getUnsortedIdFromSortedId(int index)
    {
      return indexToId[index];
    }

    public int getSortedIdFromUnsortedId(int id)
    {
      return idToIndex[id];
    }

    public String getValueFromSortedId(int index)
    {
      return sortedVals.get(index);
    }
  }",False
5,dimLookup,Field,"StringDimensionIndexer(MultiValueHandling,boolean,boolean)",,,,44,1,7205,237,18,,private final DimensionDictionary dimLookup;,True
6,multiValueHandling,Field,"StringDimensionIndexer(MultiValueHandling,boolean,boolean)",,,,52,1,7252,238,18,,private final MultiValueHandling multiValueHandling;,False
7,hasBitmapIndexes,Field,"StringDimensionIndexer(MultiValueHandling,boolean,boolean)",,,,39,1,7307,239,18,,private final boolean hasBitmapIndexes;,False
8,hasSpatialIndexes,Field,"StringDimensionIndexer(MultiValueHandling,boolean,boolean)",,,,40,1,7349,240,18,,private final boolean hasSpatialIndexes;,False
9,hasMultipleValues,Field,,,,,51,1,7392,241,66,,private volatile boolean hasMultipleValues = false;,False
10,isSparse,Field,,,,,42,1,7446,242,66,,private volatile boolean isSparse = false;,True
11,sortedLookup,Field,,,,,59,2,7492,245,2,,"@Nullable
  private SortedDimensionDictionary sortedLookup;",True
12,"StringDimensionIndexer(MultiValueHandling,boolean,boolean)",Method,,,org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+DimensionDictionary(),org.apache.druid.segment.StringDimensionIndexer+dimLookup org.apache.druid.segment.StringDimensionIndexer+dimLookup org.apache.druid.segment.StringDimensionIndexer+multiValueHandling org.apache.druid.segment.StringDimensionIndexer+multiValueHandling org.apache.druid.segment.StringDimensionIndexer+hasBitmapIndexes org.apache.druid.segment.StringDimensionIndexer+hasBitmapIndexes org.apache.druid.segment.StringDimensionIndexer+hasSpatialIndexes org.apache.druid.segment.StringDimensionIndexer+hasSpatialIndexes,383,7,7555,247,1,,"public StringDimensionIndexer(MultiValueHandling multiValueHandling, boolean hasBitmapIndexes, boolean hasSpatialIndexes)
  {
    this.dimLookup = new DimensionDictionary();
    this.multiValueHandling = multiValueHandling == null ? MultiValueHandling.ofDefault() : multiValueHandling;
    this.hasBitmapIndexes = hasBitmapIndexes;
    this.hasSpatialIndexes = hasSpatialIndexes;
  }",False
13,"processRowValsToUnsortedEncodedKeyComponent(Object,boolean)",Method,,org.apache.druid.benchmark.indexing.StringDimensionIndexerBenchmark+setup(),"org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+size() org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+size() org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+getId(String) org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+getId(String) org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+add(String) org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+add(String) java.util.List+isEmpty() java.util.List+isEmpty() org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+add(String) org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+add(String) java.util.List+size() java.util.List+size() org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+add(String) org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+add(String) org.apache.druid.segment.StringDimensionIndexer+emptyToNullIfNeeded(Object) org.apache.druid.segment.StringDimensionIndexer+emptyToNullIfNeeded(Object) java.util.List+get(int) java.util.List+get(int) java.util.List+size() java.util.List+size() java.util.List+size() java.util.List+size() org.apache.druid.segment.StringDimensionIndexer+emptyToNullIfNeeded(Object) org.apache.druid.segment.StringDimensionIndexer+emptyToNullIfNeeded(Object) java.util.List+get(int) java.util.List+get(int) java.util.Arrays+sort(T[],Comparator) java.util.Arrays+sort(T[],Comparator) org.apache.druid.java.util.common.guava.Comparators+naturalNullsFirst() org.apache.druid.java.util.common.guava.Comparators+naturalNullsFirst() org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+add(String) org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+add(String) org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+add(String) org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+add(String) java.util.Arrays+copyOf(int[],int) java.util.Arrays+copyOf(int[],int) org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+add(String) org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+add(String) org.apache.druid.segment.StringDimensionIndexer+emptyToNullIfNeeded(Object) org.apache.druid.segment.StringDimensionIndexer+emptyToNullIfNeeded(Object) org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+size() org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+size()",org.apache.druid.segment.StringDimensionIndexer+dimLookup org.apache.druid.segment.StringDimensionIndexer+dimLookup org.apache.druid.segment.StringDimensionIndexer+ABSENT_VALUE_ID org.apache.druid.segment.StringDimensionIndexer+dimLookup org.apache.druid.segment.StringDimensionIndexer+dimLookup org.apache.druid.segment.StringDimensionIndexer+dimLookup org.apache.druid.segment.StringDimensionIndexer+hasMultipleValues org.apache.druid.segment.StringDimensionIndexer+multiValueHandling org.apache.druid.segment.StringDimensionIndexer+multiValueHandling org.apache.druid.segment.StringDimensionIndexer+dimLookup org.apache.druid.segment.StringDimensionIndexer+dimLookup org.apache.druid.segment.StringDimensionIndexer+dimLookup org.apache.druid.segment.StringDimensionIndexer+dimLookup org.apache.druid.segment.StringDimensionIndexer+sortedLookup,2125,55,7942,256,1,,"@Override
  public int[] processRowValsToUnsortedEncodedKeyComponent(@Nullable Object dimValues, boolean reportParseExceptions)
  {
    final int[] encodedDimensionValues;
    final int oldDictSize = dimLookup.size();

    if (dimValues == null) {
      final int nullId = dimLookup.getId(null);
      encodedDimensionValues = nullId == ABSENT_VALUE_ID ? new int[]{dimLookup.add(null)} : new int[]{nullId};
    } else if (dimValues instanceof List) {
      List<Object> dimValuesList = (List<Object>) dimValues;
      if (dimValuesList.isEmpty()) {
        dimLookup.add(null);
        encodedDimensionValues = IntArrays.EMPTY_ARRAY;
      } else if (dimValuesList.size() == 1) {
        encodedDimensionValues = new int[]{dimLookup.add(emptyToNullIfNeeded(dimValuesList.get(0)))};
      } else {
        hasMultipleValues = true;
        final String[] dimensionValues = new String[dimValuesList.size()];
        for (int i = 0; i < dimValuesList.size(); i++) {
          dimensionValues[i] = emptyToNullIfNeeded(dimValuesList.get(i));
        }
        if (multiValueHandling.needSorting()) {
          // Sort multival row by their unencoded values first.
          Arrays.sort(dimensionValues, Comparators.naturalNullsFirst());
        }

        final int[] retVal = new int[dimensionValues.length];

        int prevId = -1;
        int pos = 0;
        for (String dimensionValue : dimensionValues) {
          if (multiValueHandling != MultiValueHandling.SORTED_SET) {
            retVal[pos++] = dimLookup.add(dimensionValue);
            continue;
          }
          int index = dimLookup.add(dimensionValue);
          if (index != prevId) {
            prevId = retVal[pos++] = index;
          }
        }

        encodedDimensionValues = pos == retVal.length ? retVal : Arrays.copyOf(retVal, pos);
      }
    } else {
      encodedDimensionValues = new int[]{dimLookup.add(emptyToNullIfNeeded(dimValues))};
    }

    // If dictionary size has changed, the sorted lookup is no longer valid.
    if (oldDictSize != dimLookup.size()) {
      sortedLookup = null;
    }

    return encodedDimensionValues;
  }",False
14,setSparseIndexed(),Method,,,,org.apache.druid.segment.StringDimensionIndexer+isSparse,71,5,10071,312,1,,"@Override
  public void setSparseIndexed()
  {
    isSparse = true;
  }",True
15,estimateEncodedKeyComponentSize(int[]),Method,,org.apache.druid.benchmark.indexing.StringDimensionIndexerBenchmark+estimateEncodedKeyComponentSize(Blackhole),org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+getValue(int) org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+getValue(int) java.lang.String+length() java.lang.String+length(),java.lang.Integer+BYTES org.apache.druid.segment.StringDimensionIndexer+dimLookup,1032,21,10146,318,1,,"@Override
  public long estimateEncodedKeyComponentSize(int[] key)
  {
    // string length is being accounted for each time they are referenced, based on dimension handler interface,
    // even though they are stored just once. It may overestimate the size by a bit, but we wanted to leave
    // more buffer to be safe
    long estimatedSize = key.length * Integer.BYTES;
    for (int element : key) {
      String val = dimLookup.getValue(element);
      if (val != null) {
        // According to https://www.ibm.com/developerworks/java/library/j-codetoheap/index.html
        // String has the following memory usuage...
        // 28 bytes of data for String metadata (class pointer, flags, locks, hash, count, offset, reference to char array)
        // 16 bytes of data for the char array metadata (class pointer, flags, locks, size)
        // 2 bytes for every letter of the string
        int sizeOfString = 28 + 16 + (2 * val.length());
        estimatedSize += sizeOfString;
      }
    }
    return estimatedSize;
  }",False
16,getSortedEncodedValueFromUnsorted(Integer),Method,,,org.apache.druid.segment.StringDimensionIndexer.SortedDimensionDictionary+getSortedIdFromUnsortedId(int) org.apache.druid.segment.StringDimensionIndexer+sortedLookup() org.apache.druid.segment.StringDimensionIndexer+sortedLookup() org.apache.druid.segment.StringDimensionIndexer.SortedDimensionDictionary+getSortedIdFromUnsortedId(int),,171,4,11182,339,1,,"public Integer getSortedEncodedValueFromUnsorted(Integer unsortedIntermediateValue)
  {
    return sortedLookup().getSortedIdFromUnsortedId(unsortedIntermediateValue);
  }",True
17,getUnsortedEncodedValueFromSorted(Integer),Method,,,org.apache.druid.segment.StringDimensionIndexer.SortedDimensionDictionary+getUnsortedIdFromSortedId(int) org.apache.druid.segment.StringDimensionIndexer+sortedLookup() org.apache.druid.segment.StringDimensionIndexer+sortedLookup() org.apache.druid.segment.StringDimensionIndexer.SortedDimensionDictionary+getUnsortedIdFromSortedId(int),,179,5,11357,345,1,,"@Override
  public Integer getUnsortedEncodedValueFromSorted(Integer sortedIntermediateValue)
  {
    return sortedLookup().getUnsortedIdFromSortedId(sortedIntermediateValue);
  }",True
18,getSortedIndexedValues(),Method,,,+() +size(),,885,44,11540,351,1,,"@Override
  public CloseableIndexed<String> getSortedIndexedValues()
  {
    return new CloseableIndexed<String>()
    {

      @Override
      public int size()
      {
        return getCardinality();
      }

      @Override
      public String get(int index)
      {
        return getActualValue(index, true);
      }

      @Override
      public int indexOf(String value)
      {
        int id = getEncodedValue(value, false);
        return id < 0 ? ABSENT_VALUE_ID : getSortedEncodedValueFromUnsorted(id);
      }

      @Override
      public Iterator<String> iterator()
      {
        return IndexedIterable.create(this).iterator();
      }

      @Override
      public void inspectRuntimeShape(RuntimeShapeInspector inspector)
      {
        // nothing to inspect
      }

      @Override
      public void close()
      {
        // nothing to close
      }
    };
  }",True
19,getMinValue(),Method,,,org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+getMinValue() org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+getMinValue(),org.apache.druid.segment.StringDimensionIndexer+dimLookup,83,5,12429,396,1,,"@Override
  public String getMinValue()
  {
    return dimLookup.getMinValue();
  }",True
20,getMaxValue(),Method,,,org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+getMaxValue() org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+getMaxValue(),org.apache.druid.segment.StringDimensionIndexer+dimLookup,83,5,12516,402,1,,"@Override
  public String getMaxValue()
  {
    return dimLookup.getMaxValue();
  }",True
21,getCardinality(),Method,"makeDimensionSelector(DimensionSpec,IncrementalIndexRowHolder,IncrementalIndex.DimensionDesc)",,org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+size() org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+size(),org.apache.druid.segment.StringDimensionIndexer+dimLookup,76,5,12603,408,1,,"@Override
  public int getCardinality()
  {
    return dimLookup.size();
  }",True
22,dictionaryEncodesAllValues(),Method,getColumnCapabilities() nameLookupPossibleInAdvance(),,,org.apache.druid.segment.StringDimensionIndexer+isSparse org.apache.druid.segment.StringDimensionIndexer+dimLookup org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+idForNull org.apache.druid.segment.StringDimensionIndexer+ABSENT_VALUE_ID,450,10,12683,416,2,"/** 
 * returns true if all values are encoded in  {@link #dimLookup}
 */
","/**
   * returns true if all values are encoded in {@link #dimLookup}
   */
  private boolean dictionaryEncodesAllValues()
  {
    // name lookup is possible in advance if we explicitly process a value for every row, or if we've encountered an
    // actual null value and it is present in our dictionary. otherwise the dictionary will be missing ids for implicit
    // null values
    return !isSparse || dimLookup.idForNull != ABSENT_VALUE_ID;
  }",False
23,"compareUnsortedEncodedKeyComponents(int[],int[])",Method,,,"java.lang.Math+min(int,int) java.lang.Math+min(int,int) org.apache.druid.segment.StringDimensionIndexer+getActualValue(int,boolean) org.apache.druid.segment.StringDimensionIndexer+getActualValue(int,boolean) org.apache.druid.segment.StringDimensionIndexer+getActualValue(int,boolean) org.apache.druid.segment.StringDimensionIndexer+getActualValue(int,boolean) java.lang.String+compareTo(String) java.lang.String+compareTo(String)",org.apache.druid.segment.StringDimensionIndexer+dimLookup org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+idForNull,1481,43,13137,425,1,,"@Override
  public int compareUnsortedEncodedKeyComponents(int[] lhs, int[] rhs)
  {
    int lhsLen = lhs.length;
    int rhsLen = rhs.length;

    int lenCompareResult = Ints.compare(lhsLen, rhsLen);
    if (lenCompareResult != 0) {
      // if the values don't have the same length, check if we're comparing [] and [null], which are equivalent
      if (lhsLen + rhsLen == 1) {
        int[] longerVal = rhsLen > lhsLen ? rhs : lhs;
        if (longerVal[0] == dimLookup.idForNull) {
          return 0;
        } else {
          //noinspection ArrayEquality -- longerVal is explicitly set to only lhs or rhs
          return longerVal == lhs ? 1 : -1;
        }
      }
    }

    int valsIndex = 0;
    int lenToCompare = Math.min(lhsLen, rhsLen);
    while (valsIndex < lenToCompare) {
      int lhsVal = lhs[valsIndex];
      int rhsVal = rhs[valsIndex];
      if (lhsVal != rhsVal) {
        final String lhsValActual = getActualValue(lhsVal, false);
        final String rhsValActual = getActualValue(rhsVal, false);
        int valueCompareResult = 0;
        if (lhsValActual != null && rhsValActual != null) {
          valueCompareResult = lhsValActual.compareTo(rhsValActual);
        } else if (lhsValActual == null ^ rhsValActual == null) {
          valueCompareResult = lhsValActual == null ? -1 : 1;
        }
        if (valueCompareResult != 0) {
          return valueCompareResult;
        }
      }
      ++valsIndex;
    }

    return lenCompareResult;
  }",False
24,"checkUnsortedEncodedKeyComponentsEqual(int[],int[])",Method,,,"java.util.Arrays+equals(int[],int[]) java.util.Arrays+equals(int[],int[])",,131,5,14622,469,1,,"@Override
  public boolean checkUnsortedEncodedKeyComponentsEqual(int[] lhs, int[] rhs)
  {
    return Arrays.equals(lhs, rhs);
  }",False
25,getUnsortedEncodedKeyComponentHashCode(int[]),Method,,,java.util.Arrays+hashCode(int[]) java.util.Arrays+hashCode(int[]),,113,5,14757,475,1,,"@Override
  public int getUnsortedEncodedKeyComponentHashCode(int[] key)
  {
    return Arrays.hashCode(key);
  }",False
26,getColumnCapabilities(),Method,,,org.apache.druid.segment.column.ColumnCapabilitiesImpl+setDictionaryValuesSorted(boolean) org.apache.druid.segment.column.ColumnCapabilitiesImpl+setDictionaryValuesUnique(boolean) org.apache.druid.segment.column.ColumnCapabilitiesImpl+setHasSpatialIndexes(boolean) org.apache.druid.segment.column.ColumnCapabilitiesImpl+setHasBitmapIndexes(boolean) org.apache.druid.segment.column.ColumnCapabilitiesImpl+setType(ColumnType) org.apache.druid.segment.column.ColumnCapabilitiesImpl+ColumnCapabilitiesImpl() org.apache.druid.segment.column.ColumnCapabilitiesImpl+setType(ColumnType) org.apache.druid.segment.column.ColumnCapabilitiesImpl+setHasBitmapIndexes(boolean) org.apache.druid.segment.column.ColumnCapabilitiesImpl+setHasSpatialIndexes(boolean) org.apache.druid.segment.column.ColumnCapabilitiesImpl+setDictionaryValuesUnique(boolean) org.apache.druid.segment.column.ColumnCapabilitiesImpl+setDictionaryValuesSorted(boolean) org.apache.druid.segment.column.ColumnCapabilitiesImpl+setHasMultipleValues(boolean) org.apache.druid.segment.column.ColumnCapabilitiesImpl+setHasMultipleValues(boolean) org.apache.druid.segment.StringDimensionIndexer+dictionaryEncodesAllValues() org.apache.druid.segment.StringDimensionIndexer+dictionaryEncodesAllValues() org.apache.druid.segment.column.ColumnCapabilitiesImpl+setDictionaryEncoded(boolean) org.apache.druid.segment.column.ColumnCapabilitiesImpl+setDictionaryEncoded(boolean) org.apache.druid.segment.column.ColumnCapabilitiesImpl+setHasNulls(boolean) org.apache.druid.segment.column.ColumnCapabilitiesImpl+setHasNulls(boolean),org.apache.druid.segment.column.ColumnType+STRING org.apache.druid.segment.StringDimensionIndexer+hasBitmapIndexes org.apache.druid.segment.StringDimensionIndexer+hasSpatialIndexes org.apache.druid.segment.StringDimensionIndexer+hasMultipleValues org.apache.druid.segment.StringDimensionIndexer+isSparse org.apache.druid.segment.StringDimensionIndexer+dimLookup org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+idForNull org.apache.druid.segment.StringDimensionIndexer+ABSENT_VALUE_ID,2077,34,14874,481,1,,"@Override
  public ColumnCapabilities getColumnCapabilities()
  {
    ColumnCapabilitiesImpl capabilites = new ColumnCapabilitiesImpl().setType(ColumnType.STRING)
                                                                     .setHasBitmapIndexes(hasBitmapIndexes)
                                                                     .setHasSpatialIndexes(hasSpatialIndexes)
                                                                     .setDictionaryValuesUnique(true)
                                                                     .setDictionaryValuesSorted(false);

    // Strings are opportunistically multi-valued, but the capabilities are initialized as 'unknown', since a
    // multi-valued row might be processed at any point during ingestion.
    // We only explicitly set multiple values if we are certain that there are multiple values, otherwise, a race
    // condition might occur where this indexer might process a multi-valued row in the period between obtaining the
    // capabilities, and actually processing the rows with a selector. Leaving as unknown allows the caller to decide
    // how to handle this.
    if (hasMultipleValues) {
      capabilites.setHasMultipleValues(true);
    }
    // Likewise, only set dictionaryEncoded if explicitly if true for a similar reason as multi-valued handling. The
    // dictionary is populated as rows are processed, but there might be implicit default values not accounted for in
    // the dictionary yet. We can be certain that the dictionary has an entry for every value if either of
    //    a) we have already processed an explitic default (null) valued row for this column
    //    b) the processing was not 'sparse', meaning that this indexer has processed an explict value for every row
    // is true.
    final boolean allValuesEncoded = dictionaryEncodesAllValues();
    if (allValuesEncoded) {
      capabilites.setDictionaryEncoded(true);
    }

    if (isSparse || dimLookup.idForNull != ABSENT_VALUE_ID) {
      capabilites.setHasNulls(true);
    }
    return capabilites;
  }",False
27,"makeDimensionSelector(DimensionSpec,IncrementalIndexRowHolder,IncrementalIndex.DimensionDesc)",Method,,,org.apache.druid.query.dimension.DimensionSpec+getExtractionFn() org.apache.druid.query.dimension.DimensionSpec+getExtractionFn() org.apache.druid.segment.incremental.IncrementalIndex.DimensionDesc+getIndex() org.apache.druid.segment.incremental.IncrementalIndex.DimensionDesc+getIndex() org.apache.druid.segment.StringDimensionIndexer+getCardinality() org.apache.druid.segment.StringDimensionIndexer+getCardinality() org.apache.druid.segment.data.ArrayBasedIndexedInts+ArrayBasedIndexedInts() +getRow(),+indexedInts +nullIdIntArray,7461,249,16955,516,1,,"@Override
  public DimensionSelector makeDimensionSelector(
      final DimensionSpec spec,
      final IncrementalIndexRowHolder currEntry,
      final IncrementalIndex.DimensionDesc desc
  )
  {
    final ExtractionFn extractionFn = spec.getExtractionFn();

    final int dimIndex = desc.getIndex();

    // maxId is used in concert with getLastRowIndex() in IncrementalIndex to ensure that callers do not encounter
    // rows that contain IDs over the initially-reported cardinality. The main idea is that IncrementalIndex establishes
    // a watermark at the time a cursor is created, and doesn't allow the cursor to walk past that watermark.
    //
    // Additionally, this selector explicitly blocks knowledge of IDs past maxId that may occur from other causes
    // (for example: nulls getting generated for empty arrays, or calls to lookupId).
    final int maxId = getCardinality();

    class IndexerDimensionSelector implements DimensionSelector, IdLookup
    {
      private final ArrayBasedIndexedInts indexedInts = new ArrayBasedIndexedInts();

      @Nullable
      @MonotonicNonNull
      private int[] nullIdIntArray;

      @Override
      public IndexedInts getRow()
      {
        final Object[] dims = currEntry.get().getDims();

        int[] indices;
        if (dimIndex < dims.length) {
          indices = (int[]) dims[dimIndex];
        } else {
          indices = null;
        }

        int[] row = null;
        int rowSize = 0;

        // usually due to currEntry's rowIndex is smaller than the row's rowIndex in which this dim first appears
        if (indices == null || indices.length == 0) {
          if (hasMultipleValues) {
            row = IntArrays.EMPTY_ARRAY;
            rowSize = 0;
          } else {
            final int nullId = getEncodedValue(null, false);
            if (nullId >= 0 && nullId < maxId) {
              // null was added to the dictionary before this selector was created; return its ID.
              if (nullIdIntArray == null) {
                nullIdIntArray = new int[]{nullId};
              }
              row = nullIdIntArray;
              rowSize = 1;
            } else {
              // null doesn't exist in the dictionary; return an empty array.
              // Choose to use ArrayBasedIndexedInts later, instead of special ""empty"" IndexedInts, for monomorphism
              row = IntArrays.EMPTY_ARRAY;
              rowSize = 0;
            }
          }
        }

        if (row == null && indices != null && indices.length > 0) {
          row = indices;
          rowSize = indices.length;
        }

        indexedInts.setValues(row, rowSize);
        return indexedInts;
      }

      @Override
      public ValueMatcher makeValueMatcher(final String value)
      {
        if (extractionFn == null) {
          final int valueId = lookupId(value);
          if (valueId >= 0 || value == null) {
            return new ValueMatcher()
            {
              @Override
              public boolean matches()
              {
                Object[] dims = currEntry.get().getDims();
                if (dimIndex >= dims.length) {
                  return value == null;
                }

                int[] dimsInt = (int[]) dims[dimIndex];
                if (dimsInt == null || dimsInt.length == 0) {
                  return value == null;
                }

                for (int id : dimsInt) {
                  if (id == valueId) {
                    return true;
                  }
                }
                return false;
              }

              @Override
              public void inspectRuntimeShape(RuntimeShapeInspector inspector)
              {
                // nothing to inspect
              }
            };
          } else {
            return BooleanValueMatcher.of(false);
          }
        } else {
          // Employ caching BitSet optimization
          return makeValueMatcher(Predicates.equalTo(value));
        }
      }

      @Override
      public ValueMatcher makeValueMatcher(final Predicate<String> predicate)
      {
        final BitSet checkedIds = new BitSet(maxId);
        final BitSet matchingIds = new BitSet(maxId);
        final boolean matchNull = predicate.apply(null);

        // Lazy matcher; only check an id if matches() is called.
        return new ValueMatcher()
        {
          @Override
          public boolean matches()
          {
            Object[] dims = currEntry.get().getDims();
            if (dimIndex >= dims.length) {
              return matchNull;
            }

            int[] dimsInt = (int[]) dims[dimIndex];
            if (dimsInt == null || dimsInt.length == 0) {
              return matchNull;
            }

            for (int id : dimsInt) {
              if (checkedIds.get(id)) {
                if (matchingIds.get(id)) {
                  return true;
                }
              } else {
                final boolean matches = predicate.apply(lookupName(id));
                checkedIds.set(id);
                if (matches) {
                  matchingIds.set(id);
                  return true;
                }
              }
            }
            return false;
          }

          @Override
          public void inspectRuntimeShape(RuntimeShapeInspector inspector)
          {
            // nothing to inspect
          }
        };
      }

      @Override
      public int getValueCardinality()
      {
        return maxId;
      }

      @Override
      public String lookupName(int id)
      {
        if (id >= maxId) {
          // Sanity check; IDs beyond maxId should not be known to callers. (See comment above.)
          throw new ISE(""id[%d] >= maxId[%d]"", id, maxId);
        }
        final String strValue = getActualValue(id, false);
        return extractionFn == null ? strValue : extractionFn.apply(strValue);
      }

      @Override
      public boolean nameLookupPossibleInAdvance()
      {
        return dictionaryEncodesAllValues();
      }

      @Nullable
      @Override
      public IdLookup idLookup()
      {
        return extractionFn == null ? this : null;
      }

      @Override
      public int lookupId(String name)
      {
        if (extractionFn != null) {
          throw new UnsupportedOperationException(
              ""cannot perform lookup when applying an extraction function""
          );
        }

        final int id = getEncodedValue(name, false);

        if (id < maxId) {
          return id;
        } else {
          // Can happen if a value was added to our dimLookup after this selector was created. Act like it
          // doesn't exist.
          return ABSENT_VALUE_ID;
        }
      }

      @SuppressWarnings(""deprecation"")
      @Nullable
      @Override
      public Object getObject()
      {
        IncrementalIndexRow key = currEntry.get();
        if (key == null) {
          return null;
        }

        Object[] dims = key.getDims();
        if (dimIndex >= dims.length) {
          return null;
        }

        return convertUnsortedEncodedKeyComponentToActualList((int[]) dims[dimIndex]);
      }

      @SuppressWarnings(""deprecation"")
      @Override
      public Class classOfObject()
      {
        return Object.class;
      }

      @Override
      public void inspectRuntimeShape(RuntimeShapeInspector inspector)
      {
        // nothing to inspect
      }
    }
    return new IndexerDimensionSelector();
  }",False
28,indexedInts,Field,,,,,78,1,17938,536,18,,private final ArrayBasedIndexedInts indexedInts = new ArrayBasedIndexedInts();,False
29,nullIdIntArray,Field,,,,,69,3,18024,540,2,,"@Nullable
      @MonotonicNonNull
      private int[] nullIdIntArray;",False
30,getRow(),Method,,,"org.apache.druid.segment.incremental.IncrementalIndexRow+getDims() org.apache.druid.segment.incremental.IncrementalIndexRowHolder+get() org.apache.druid.segment.incremental.IncrementalIndexRowHolder+get() org.apache.druid.segment.incremental.IncrementalIndexRow+getDims() org.apache.druid.segment.StringDimensionIndexer+getEncodedValue(String,boolean) org.apache.druid.segment.StringDimensionIndexer+getEncodedValue(String,boolean) org.apache.druid.segment.data.ArrayBasedIndexedInts+setValues(int[],int) org.apache.druid.segment.data.ArrayBasedIndexedInts+setValues(int[],int)",org.apache.druid.segment.StringDimensionIndexer+hasMultipleValues +nullIdIntArray +nullIdIntArray +nullIdIntArray +indexedInts +indexedInts,1536,46,18101,543,1,,"@Override
      public IndexedInts getRow()
      {
        final Object[] dims = currEntry.get().getDims();

        int[] indices;
        if (dimIndex < dims.length) {
          indices = (int[]) dims[dimIndex];
        } else {
          indices = null;
        }

        int[] row = null;
        int rowSize = 0;

        // usually due to currEntry's rowIndex is smaller than the row's rowIndex in which this dim first appears
        if (indices == null || indices.length == 0) {
          if (hasMultipleValues) {
            row = IntArrays.EMPTY_ARRAY;
            rowSize = 0;
          } else {
            final int nullId = getEncodedValue(null, false);
            if (nullId >= 0 && nullId < maxId) {
              // null was added to the dictionary before this selector was created; return its ID.
              if (nullIdIntArray == null) {
                nullIdIntArray = new int[]{nullId};
              }
              row = nullIdIntArray;
              rowSize = 1;
            } else {
              // null doesn't exist in the dictionary; return an empty array.
              // Choose to use ArrayBasedIndexedInts later, instead of special ""empty"" IndexedInts, for monomorphism
              row = IntArrays.EMPTY_ARRAY;
              rowSize = 0;
            }
          }
        }

        if (row == null && indices != null && indices.length > 0) {
          row = indices;
          rowSize = indices.length;
        }

        indexedInts.setValues(row, rowSize);
        return indexedInts;
      }",False
31,makeValueMatcher(String),Method,,,+lookupId(String) +lookupId(String) +() +matches() java.lang.UnsupportedOperationException+UnsupportedOperationException(),,1295,43,19645,590,1,,"@Override
      public ValueMatcher makeValueMatcher(final String value)
      {
        if (extractionFn == null) {
          final int valueId = lookupId(value);
          if (valueId >= 0 || value == null) {
            return new ValueMatcher()
            {
              @Override
              public boolean matches()
              {
                Object[] dims = currEntry.get().getDims();
                if (dimIndex >= dims.length) {
                  return value == null;
                }

                int[] dimsInt = (int[]) dims[dimIndex];
                if (dimsInt == null || dimsInt.length == 0) {
                  return value == null;
                }

                for (int id : dimsInt) {
                  if (id == valueId) {
                    return true;
                  }
                }
                return false;
              }

              @Override
              public void inspectRuntimeShape(RuntimeShapeInspector inspector)
              {
                // nothing to inspect
              }
            };
          } else {
            return BooleanValueMatcher.of(false);
          }
        } else {
          // Employ caching BitSet optimization
          return makeValueMatcher(Predicates.equalTo(value));
        }
      }",False
32,makeValueMatcher(Predicate<String>),Method,,,java.util.BitSet+BitSet(int) java.util.BitSet+BitSet(int) +() +matches() java.lang.UnsupportedOperationException+UnsupportedOperationException(),,1400,47,20948,634,1,,"@Override
      public ValueMatcher makeValueMatcher(final Predicate<String> predicate)
      {
        final BitSet checkedIds = new BitSet(maxId);
        final BitSet matchingIds = new BitSet(maxId);
        final boolean matchNull = predicate.apply(null);

        // Lazy matcher; only check an id if matches() is called.
        return new ValueMatcher()
        {
          @Override
          public boolean matches()
          {
            Object[] dims = currEntry.get().getDims();
            if (dimIndex >= dims.length) {
              return matchNull;
            }

            int[] dimsInt = (int[]) dims[dimIndex];
            if (dimsInt == null || dimsInt.length == 0) {
              return matchNull;
            }

            for (int id : dimsInt) {
              if (checkedIds.get(id)) {
                if (matchingIds.get(id)) {
                  return true;
                }
              } else {
                final boolean matches = predicate.apply(lookupName(id));
                checkedIds.set(id);
                if (matches) {
                  matchingIds.set(id);
                  return true;
                }
              }
            }
            return false;
          }

          @Override
          public void inspectRuntimeShape(RuntimeShapeInspector inspector)
          {
            // nothing to inspect
          }
        };
      }",False
33,getValueCardinality(),Method,,,org.apache.druid.segment.DimensionDictionarySelector+getValueCardinality() org.apache.druid.segment.DimensionDictionarySelector+getValueCardinality(),,86,5,22356,682,1,,"@Override
      public int getValueCardinality()
      {
        return maxId;
      }",False
34,lookupName(int),Method,,,"org.apache.druid.java.util.common.ISE+ISE(String,Object[]) org.apache.druid.segment.StringDimensionIndexer+getActualValue(int,boolean) org.apache.druid.segment.StringDimensionIndexer+getActualValue(int,boolean) org.apache.druid.query.extraction.ExtractionFn+apply(String) org.apache.druid.query.extraction.ExtractionFn+apply(String) java.lang.UnsupportedOperationException+UnsupportedOperationException()",,395,10,22450,688,1,,"@Override
      public String lookupName(int id)
      {
        if (id >= maxId) {
          // Sanity check; IDs beyond maxId should not be known to callers. (See comment above.)
          throw new ISE(""id[%d] >= maxId[%d]"", id, maxId);
        }
        final String strValue = getActualValue(id, false);
        return extractionFn == null ? strValue : extractionFn.apply(strValue);
      }",False
35,nameLookupPossibleInAdvance(),Method,,,org.apache.druid.segment.StringDimensionIndexer+dictionaryEncodesAllValues() org.apache.druid.segment.StringDimensionIndexer+dictionaryEncodesAllValues() java.lang.UnsupportedOperationException+UnsupportedOperationException(),,121,5,22853,699,1,,"@Override
      public boolean nameLookupPossibleInAdvance()
      {
        return dictionaryEncodesAllValues();
      }",False
36,idLookup(),Method,,,java.lang.UnsupportedOperationException+UnsupportedOperationException(),,125,6,22982,706,1,,"@Nullable
      @Override
      public IdLookup idLookup()
      {
        return extractionFn == null ? this : null;
      }",False
37,lookupId(String),Method,,,"java.lang.UnsupportedOperationException+UnsupportedOperationException(String) org.apache.druid.segment.StringDimensionIndexer+getEncodedValue(String,boolean) org.apache.druid.segment.StringDimensionIndexer+getEncodedValue(String,boolean)",org.apache.druid.segment.StringDimensionIndexer+ABSENT_VALUE_ID,547,19,23115,712,1,,"@Override
      public int lookupId(String name)
      {
        if (extractionFn != null) {
          throw new UnsupportedOperationException(
              ""cannot perform lookup when applying an extraction function""
          );
        }

        final int id = getEncodedValue(name, false);

        if (id < maxId) {
          return id;
        } else {
          // Can happen if a value was added to our dimLookup after this selector was created. Act like it
          // doesn't exist.
          return ABSENT_VALUE_ID;
        }
      }",False
38,getObject(),Method,,,org.apache.druid.segment.incremental.IncrementalIndexRowHolder+get() org.apache.druid.segment.incremental.IncrementalIndexRowHolder+get() org.apache.druid.segment.incremental.IncrementalIndexRow+getDims() org.apache.druid.segment.incremental.IncrementalIndexRow+getDims() org.apache.druid.segment.StringDimensionIndexer+convertUnsortedEncodedKeyComponentToActualList(int[]) org.apache.druid.segment.StringDimensionIndexer+convertUnsortedEncodedKeyComponentToActualList(int[]) org.apache.druid.segment.BaseObjectColumnValueSelector+getObject() org.apache.druid.segment.BaseObjectColumnValueSelector+getObject(),,423,17,23670,734,1,,"@SuppressWarnings(""deprecation"")
      @Nullable
      @Override
      public Object getObject()
      {
        IncrementalIndexRow key = currEntry.get();
        if (key == null) {
          return null;
        }

        Object[] dims = key.getDims();
        if (dimIndex >= dims.length) {
          return null;
        }

        return convertUnsortedEncodedKeyComponentToActualList((int[]) dims[dimIndex]);
      }",False
39,classOfObject(),Method,,,org.apache.druid.segment.BaseObjectColumnValueSelector+classOfObject() org.apache.druid.segment.BaseObjectColumnValueSelector+classOfObject(),,128,6,24101,751,1,,"@SuppressWarnings(""deprecation"")
      @Override
      public Class classOfObject()
      {
        return Object.class;
      }",False
40,inspectRuntimeShape(RuntimeShapeInspector),Method,,,"org.apache.druid.query.monomorphicprocessing.RuntimeShapeInspector+visit(String,HotLoopCallee) org.apache.druid.query.monomorphicprocessing.RuntimeShapeInspector+visit(String,HotLoopCallee)",,126,5,24237,757,1,,"@Override
      public void inspectRuntimeShape(RuntimeShapeInspector inspector)
      {
        // nothing to inspect
      }",False
41,"makeColumnValueSelector(IncrementalIndexRowHolder,IncrementalIndex.DimensionDesc)",Method,,,"org.apache.druid.segment.StringDimensionIndexer+makeDimensionSelector(DimensionSpec,IncrementalIndexRowHolder,DimensionDesc) org.apache.druid.segment.StringDimensionIndexer+makeDimensionSelector(DimensionSpec,IncrementalIndexRowHolder,DimensionDesc) org.apache.druid.query.dimension.DefaultDimensionSpec+of(String) org.apache.druid.query.dimension.DefaultDimensionSpec+of(String) org.apache.druid.segment.incremental.IncrementalIndex.DimensionDesc+getName() org.apache.druid.segment.incremental.IncrementalIndex.DimensionDesc+getName()",,255,8,24420,766,1,,"@Override
  public ColumnValueSelector<?> makeColumnValueSelector(
      IncrementalIndexRowHolder currEntry,
      IncrementalIndex.DimensionDesc desc
  )
  {
    return makeDimensionSelector(DefaultDimensionSpec.of(desc.getName()), currEntry, desc);
  }",True
42,convertUnsortedEncodedKeyComponentToActualList(int[]),Method,getObject(),,"org.apache.druid.segment.StringDimensionIndexer+getActualValue(int,boolean) org.apache.druid.segment.StringDimensionIndexer+getActualValue(int,boolean) org.apache.druid.segment.StringDimensionIndexer+getActualValue(int,boolean) org.apache.druid.segment.StringDimensionIndexer+getActualValue(int,boolean) org.apache.druid.common.config.NullHandling+nullToEmptyIfNeeded(String) org.apache.druid.common.config.NullHandling+nullToEmptyIfNeeded(String) java.util.Arrays+asList(T[]) java.util.Arrays+asList(T[])",,514,18,24680,777,1,,"@Nullable
  @Override
  public Object convertUnsortedEncodedKeyComponentToActualList(int[] key)
  {
    if (key == null || key.length == 0) {
      return null;
    }
    if (key.length == 1) {
      return getActualValue(key[0], false);
    } else {
      String[] rowArray = new String[key.length];
      for (int i = 0; i < key.length; i++) {
        String val = getActualValue(key[i], false);
        rowArray[i] = NullHandling.nullToEmptyIfNeeded(val);
      }
      return Arrays.asList(rowArray);
    }
  }",False
43,convertUnsortedValuesToSorted(ColumnValueSelector),Method,,,+size(),,2051,83,25198,795,1,,"@Override
  public ColumnValueSelector convertUnsortedValuesToSorted(ColumnValueSelector selectorWithUnsortedValues)
  {
    DimensionSelector dimSelectorWithUnsortedValues = (DimensionSelector) selectorWithUnsortedValues;
    class SortedDimensionSelector implements DimensionSelector, IndexedInts
    {
      @Override
      public int size()
      {
        return dimSelectorWithUnsortedValues.getRow().size();
      }

      @Override
      public int get(int index)
      {
        return sortedLookup().getSortedIdFromUnsortedId(dimSelectorWithUnsortedValues.getRow().get(index));
      }

      @Override
      public IndexedInts getRow()
      {
        return this;
      }

      @Override
      public ValueMatcher makeValueMatcher(@Nullable String value)
      {
        throw new UnsupportedOperationException();
      }

      @Override
      public ValueMatcher makeValueMatcher(Predicate<String> predicate)
      {
        throw new UnsupportedOperationException();
      }

      @Override
      public int getValueCardinality()
      {
        return dimSelectorWithUnsortedValues.getValueCardinality();
      }

      @Nullable
      @Override
      public String lookupName(int id)
      {
        throw new UnsupportedOperationException();
      }

      @Override
      public boolean nameLookupPossibleInAdvance()
      {
        throw new UnsupportedOperationException();
      }

      @Nullable
      @Override
      public IdLookup idLookup()
      {
        throw new UnsupportedOperationException();
      }

      @Override
      public void inspectRuntimeShape(RuntimeShapeInspector inspector)
      {
        inspector.visit(""dimSelectorWithUnsortedValues"", dimSelectorWithUnsortedValues);
      }

      @Nullable
      @Override
      public Object getObject()
      {
        return dimSelectorWithUnsortedValues.getObject();
      }

      @Override
      public Class classOfObject()
      {
        return dimSelectorWithUnsortedValues.classOfObject();
      }
    }
    return new SortedDimensionSelector();
  }",True
44,size(),Method,,,org.apache.druid.segment.data.IndexedInts+size() org.apache.druid.segment.DimensionSelector+getRow() org.apache.druid.segment.DimensionSelector+getRow() org.apache.druid.segment.data.IndexedInts+size(),,111,5,25509,801,1,,"@Override
      public int size()
      {
        return dimSelectorWithUnsortedValues.getRow().size();
      }",True
45,get(int),Method,,,org.apache.druid.segment.StringDimensionIndexer.SortedDimensionDictionary+getSortedIdFromUnsortedId(int) org.apache.druid.segment.StringDimensionIndexer+sortedLookup() org.apache.druid.segment.StringDimensionIndexer+sortedLookup() org.apache.druid.segment.StringDimensionIndexer.SortedDimensionDictionary+getSortedIdFromUnsortedId(int) org.apache.druid.segment.data.IndexedInts+get(int) org.apache.druid.segment.DimensionSelector+getRow() org.apache.druid.segment.DimensionSelector+getRow() org.apache.druid.segment.data.IndexedInts+get(int),,165,5,25628,807,1,,"@Override
      public int get(int index)
      {
        return sortedLookup().getSortedIdFromUnsortedId(dimSelectorWithUnsortedValues.getRow().get(index));
      }",False
46,getRow(),Method,,,,,80,5,25801,813,1,,"@Override
      public IndexedInts getRow()
      {
        return this;
      }",False
47,makeValueMatcher(String),Method,,,,,143,5,25889,819,1,,"@Override
      public ValueMatcher makeValueMatcher(@Nullable String value)
      {
        throw new UnsupportedOperationException();
      }",False
48,makeValueMatcher(Predicate<String>),Method,,,,,148,5,26040,825,1,,"@Override
      public ValueMatcher makeValueMatcher(Predicate<String> predicate)
      {
        throw new UnsupportedOperationException();
      }",False
49,getValueCardinality(),Method,,,,,132,5,26196,831,1,,"@Override
      public int getValueCardinality()
      {
        return dimSelectorWithUnsortedValues.getValueCardinality();
      }",False
50,lookupName(int),Method,,,,,131,6,26336,838,1,,"@Nullable
      @Override
      public String lookupName(int id)
      {
        throw new UnsupportedOperationException();
      }",False
51,nameLookupPossibleInAdvance(),Method,,,,,127,5,26475,844,1,,"@Override
      public boolean nameLookupPossibleInAdvance()
      {
        throw new UnsupportedOperationException();
      }",False
52,idLookup(),Method,,,,,125,6,26610,851,1,,"@Nullable
      @Override
      public IdLookup idLookup()
      {
        throw new UnsupportedOperationException();
      }",False
53,inspectRuntimeShape(RuntimeShapeInspector),Method,,,,,185,5,26743,857,1,,"@Override
      public void inspectRuntimeShape(RuntimeShapeInspector inspector)
      {
        inspector.visit(""dimSelectorWithUnsortedValues"", dimSelectorWithUnsortedValues);
      }",False
54,getObject(),Method,,,,,131,6,26936,864,1,,"@Nullable
      @Override
      public Object getObject()
      {
        return dimSelectorWithUnsortedValues.getObject();
      }",False
55,classOfObject(),Method,,,,,122,5,27075,870,1,,"@Override
      public Class classOfObject()
      {
        return dimSelectorWithUnsortedValues.classOfObject();
      }",False
56,"fillBitmapsFromUnsortedEncodedKeyComponent(int[],int,MutableBitmap[],BitmapFactory)",Method,,,java.lang.UnsupportedOperationException+UnsupportedOperationException(String) org.apache.druid.collections.bitmap.BitmapFactory+makeEmptyMutableBitmap() org.apache.druid.collections.bitmap.BitmapFactory+makeEmptyMutableBitmap() org.apache.druid.collections.bitmap.MutableBitmap+add(int) org.apache.druid.collections.bitmap.MutableBitmap+add(int),org.apache.druid.segment.StringDimensionIndexer+hasBitmapIndexes,514,19,27253,879,1,,"@Override
  public void fillBitmapsFromUnsortedEncodedKeyComponent(
      int[] key,
      int rowNum,
      MutableBitmap[] bitmapIndexes,
      BitmapFactory factory
  )
  {
    if (!hasBitmapIndexes) {
      throw new UnsupportedOperationException(""This column does not include bitmap indexes"");
    }

    for (int dimValIdx : key) {
      if (bitmapIndexes[dimValIdx] == null) {
        bitmapIndexes[dimValIdx] = factory.makeEmptyMutableBitmap();
      }
      bitmapIndexes[dimValIdx].add(rowNum);
    }
  }",False
57,sortedLookup(),Method,"getSortedEncodedValueFromUnsorted(Integer) getUnsortedEncodedValueFromSorted(Integer) get(int) getActualValue(int,boolean) getEncodedValue(String,boolean)",,org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+sort() org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+sort(),org.apache.druid.segment.StringDimensionIndexer+sortedLookup org.apache.druid.segment.StringDimensionIndexer+sortedLookup org.apache.druid.segment.StringDimensionIndexer+dimLookup org.apache.druid.segment.StringDimensionIndexer+sortedLookup,138,4,27771,898,2,,"private SortedDimensionDictionary sortedLookup()
  {
    return sortedLookup == null ? sortedLookup = dimLookup.sort() : sortedLookup;
  }",True
58,"getActualValue(int,boolean)",Method,"compareUnsortedEncodedKeyComponents(int[],int[]) compareUnsortedEncodedKeyComponents(int[],int[]) lookupName(int) convertUnsortedEncodedKeyComponentToActualList(int[]) convertUnsortedEncodedKeyComponentToActualList(int[])",,org.apache.druid.segment.StringDimensionIndexer.SortedDimensionDictionary+getValueFromSortedId(int) org.apache.druid.segment.StringDimensionIndexer+sortedLookup() org.apache.druid.segment.StringDimensionIndexer+sortedLookup() org.apache.druid.segment.StringDimensionIndexer.SortedDimensionDictionary+getValueFromSortedId(int) org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+getValue(int) org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+getValue(int),org.apache.druid.segment.StringDimensionIndexer+dimLookup,251,10,27913,904,2,,"@Nullable
  private String getActualValue(int intermediateValue, boolean idSorted)
  {
    if (idSorted) {
      return sortedLookup().getValueFromSortedId(intermediateValue);
    } else {
      return dimLookup.getValue(intermediateValue);

    }
  }",True
59,"getEncodedValue(String,boolean)",Method,getRow() lookupId(String),,org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+getId(String) org.apache.druid.segment.StringDimensionIndexer.DimensionDictionary+getId(String) org.apache.druid.segment.StringDimensionIndexer.SortedDimensionDictionary+getSortedIdFromUnsortedId(int) org.apache.druid.segment.StringDimensionIndexer+sortedLookup() org.apache.druid.segment.StringDimensionIndexer+sortedLookup() org.apache.druid.segment.StringDimensionIndexer.SortedDimensionDictionary+getSortedIdFromUnsortedId(int),org.apache.druid.segment.StringDimensionIndexer+dimLookup,252,10,28168,914,2,,"private int getEncodedValue(String fullValue, boolean idSorted)
  {
    int unsortedId = dimLookup.getId(fullValue);

    if (idSorted) {
      return sortedLookup().getSortedIdFromUnsortedId(unsortedId);
    } else {
      return unsortedId;
    }
  }",True
