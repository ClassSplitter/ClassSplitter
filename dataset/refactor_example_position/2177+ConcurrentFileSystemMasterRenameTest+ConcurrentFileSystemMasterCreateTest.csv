index,name,type,inner invocations,external invocations,calls,visits,length,lines,start location,definition line,modifier,commit,full text,moved,removed
1,TEST_USER,Field,"""","""","""","""",47,1,2690,69,26,,"private static final String TEST_USER = ""test"";",False,False
2,CONCURRENCY_FACTOR,Field,"""","""","""","""",49,1,2740,70,26,,private static final int CONCURRENCY_FACTOR = 50;,False,False
3,SLEEP_MS,Field,"""","""","""","""",144,2,2792,72,26,"/** 
 * Duration to sleep during the rename call to show the benefits of concurrency. 
 */
","/** Duration to sleep during the rename call to show the benefits of concurrency. */
  private static final long SLEEP_MS = Constants.SECOND_MS;",False,False
4,LIMIT_MS,Field,"""","""","""","""",158,2,2939,74,26,"/** 
 * Timeout for the concurrent test after which we will mark the test as failed. 
 */
","/** Timeout for the concurrent test after which we will mark the test as failed. */
  private static final long LIMIT_MS = SLEEP_MS * CONCURRENCY_FACTOR / 10;",False,False
5,sCreatePersistedFileOptions,Field,"""","""","""","""",327,6,3100,79,10,"/** 
 * Options to mark a created file as persisted. Note that this does not actually persist the file but flag the file to be treated as persisted, which will invoke ufs operations.
 */
","/**
   * Options to mark a created file as persisted. Note that this does not actually persist the
   * file but flag the file to be treated as persisted, which will invoke ufs operations.
   */
  private static CreateFileOptions sCreatePersistedFileOptions =
      CreateFileOptions.defaults().setWriteType(WriteType.THROUGH);",False,False
6,sCreateDirectoryOptions,Field,"""","""","""","""",123,2,3430,81,10,,"private static CreateDirectoryOptions sCreateDirectoryOptions =
      CreateDirectoryOptions.defaults().setRecursive(true);",False,False
7,sSleepingUfsFactory,Field,"""","""","""","""",66,1,3557,84,10,,private static SleepingUnderFileSystemFactory sSleepingUfsFactory;,False,False
8,mFileSystem,Field,"""","""","""","""",31,1,3627,86,2,,private FileSystem mFileSystem;,False,False
9,mLocalUfsPath,Field,"""","""","""","""",71,1,3662,88,2,,private String mLocalUfsPath = Files.createTempDir().getAbsolutePath();,False,False
10,UnaryOperation,Field,"""","""","""","""",27,1,3737,90,2,,private enum UnaryOperation,False,False
11,mAuthenticatedUser,Field,"""","""","""","""",95,2,3833,98,1,,"@Rule
  public AuthenticatedUserRule mAuthenticatedUser = new AuthenticatedUserRule(TEST_USER);",False,False
12,mLocalAlluxioClusterResource,Field,"""","""","""","""",297,5,3932,101,1,,"@Rule
  public LocalAlluxioClusterResource mLocalAlluxioClusterResource =
      new LocalAlluxioClusterResource.Builder().setProperty(PropertyKey.UNDERFS_ADDRESS,
          ""sleep://"" + mLocalUfsPath).setProperty(PropertyKey
          .USER_FILE_MASTER_CLIENT_THREADS, CONCURRENCY_FACTOR).build();",False,False
13,beforeClass(),Method,"""","""","alluxio.underfs.sleepfs.SleepingUnderFileSystemOptions+SleepingUnderFileSystemOptions() alluxio.underfs.sleepfs.SleepingUnderFileSystemFactory+SleepingUnderFileSystemFactory(SleepingUnderFileSystemOptions) alluxio.underfs.sleepfs.SleepingUnderFileSystemOptions+setIsDirectoryMs(long) alluxio.underfs.sleepfs.SleepingUnderFileSystemOptions+setMkdirsMs(long) alluxio.underfs.sleepfs.SleepingUnderFileSystemOptions+setRenameDirectoryMs(long) alluxio.underfs.sleepfs.SleepingUnderFileSystemOptions+setRenameFileMs(long) alluxio.underfs.sleepfs.SleepingUnderFileSystemOptions+setRenameFileMs(long) alluxio.underfs.sleepfs.SleepingUnderFileSystemOptions+setRenameDirectoryMs(long) alluxio.underfs.sleepfs.SleepingUnderFileSystemOptions+setMkdirsMs(long) alluxio.underfs.sleepfs.SleepingUnderFileSystemOptions+setIsDirectoryMs(long) alluxio.underfs.UnderFileSystemRegistry+register(UnderFileSystemFactory) alluxio.underfs.UnderFileSystemRegistry+register(UnderFileSystemFactory)""","alluxio.master.file.ConcurrentFileSystemMasterRenameTest+sSleepingUfsFactory alluxio.master.file.ConcurrentFileSystemMasterRenameTest+SLEEP_MS alluxio.master.file.ConcurrentFileSystemMasterRenameTest+SLEEP_MS alluxio.master.file.ConcurrentFileSystemMasterRenameTest+SLEEP_MS alluxio.master.file.ConcurrentFileSystemMasterRenameTest+SLEEP_MS alluxio.master.file.ConcurrentFileSystemMasterRenameTest+sSleepingUfsFactory""",457,9,4295,108,9,,"@BeforeClass
  public static void beforeClass() throws Exception {
    // Register sleeping ufs with slow rename
    SleepingUnderFileSystemOptions options = new SleepingUnderFileSystemOptions();
    sSleepingUfsFactory = new SleepingUnderFileSystemFactory(options);
    options.setRenameFileMs(SLEEP_MS).setRenameDirectoryMs(SLEEP_MS)
        .setMkdirsMs(SLEEP_MS).setIsDirectoryMs(SLEEP_MS);
    UnderFileSystemRegistry.register(sSleepingUfsFactory);
  }",False,False
14,afterClass(),Method,"""","""","alluxio.underfs.UnderFileSystemRegistry+unregister(UnderFileSystemFactory) alluxio.underfs.UnderFileSystemRegistry+unregister(UnderFileSystemFactory)""","alluxio.master.file.ConcurrentFileSystemMasterRenameTest+sSleepingUfsFactory""",129,4,4756,118,9,,"@AfterClass
  public static void afterClass() throws Exception {
    UnderFileSystemRegistry.unregister(sSleepingUfsFactory);
  }",False,False
15,before(),Method,"""","""","alluxio.client.file.FileSystem.Factory+get() alluxio.client.file.FileSystem.Factory+get()""","alluxio.master.file.ConcurrentFileSystemMasterRenameTest+mFileSystem""",80,4,4889,123,1,,"@Before
  public void before() {
    mFileSystem = FileSystem.Factory.get();
  }",False,False
16,IntegerSuffixedPathComparator,MemberClass,"""","""","alluxio.master.file.ConcurrentFileSystemMasterRenameTest.IntegerSuffixedPathComparator+compare(URIStatus,URIStatus) alluxio.master.file.ConcurrentFileSystemMasterRenameTest.IntegerSuffixedPathComparator+extractIntegerSuffix(String) alluxio.master.file.ConcurrentFileSystemMasterRenameTest.IntegerSuffixedPathComparator+extractIntegerSuffix(String) alluxio.client.file.URIStatus+getName() alluxio.client.file.URIStatus+getName() alluxio.master.file.ConcurrentFileSystemMasterRenameTest.IntegerSuffixedPathComparator+extractIntegerSuffix(String) alluxio.master.file.ConcurrentFileSystemMasterRenameTest.IntegerSuffixedPathComparator+extractIntegerSuffix(String) alluxio.client.file.URIStatus+getName() alluxio.client.file.URIStatus+getName() alluxio.master.file.ConcurrentFileSystemMasterRenameTest.IntegerSuffixedPathComparator+extractIntegerSuffix(String) java.util.regex.Pattern+compile(String) java.util.regex.Pattern+compile(String) java.util.regex.Pattern+matcher(CharSequence) java.util.regex.Pattern+matcher(CharSequence) java.util.regex.Matcher+matches() java.util.regex.Matcher+matches() java.lang.Integer+parseInt(String) java.lang.Integer+parseInt(String) java.util.regex.Matcher+group(int) java.util.regex.Matcher+group(int)""","java.lang.Integer+MAX_VALUE""",641,20,-1,-1,2,"/** 
 * Uses the integer suffix of a path to determine order. Paths without integer suffixes will be ordered last.
 */
","/**
   * Uses the integer suffix of a path to determine order. Paths without integer suffixes will be
   * ordered last.
   */
  private class IntegerSuffixedPathComparator implements Comparator<URIStatus> {
    @Override
    public int compare(URIStatus o1, URIStatus o2) {
      return extractIntegerSuffix(o1.getName()) - extractIntegerSuffix(o2.getName());
    }

    private int extractIntegerSuffix(String name) {
      Pattern p = Pattern.compile(""\\D*(\\d+$)"");
      Matcher m = p.matcher(name);
      if (m.matches()) {
        return Integer.parseInt(m.group(1));
      } else {
        return Integer.MAX_VALUE;
      }
    }
  }",False,False
17,rootConcurrentRename(),Method,"""","""","alluxio.AlluxioURI+AlluxioURI(String) alluxio.client.file.FileOutStream+close() alluxio.client.file.FileSystem+createFile(AlluxioURI,CreateFileOptions) alluxio.client.file.FileSystem+createFile(AlluxioURI,CreateFileOptions) alluxio.client.file.FileOutStream+close() alluxio.AlluxioURI+AlluxioURI(String) alluxio.master.file.ConcurrentFileSystemMasterRenameTest+concurrentRename(AlluxioURI[],AlluxioURI[]) alluxio.master.file.ConcurrentFileSystemMasterRenameTest+concurrentRename(AlluxioURI[],AlluxioURI[]) alluxio.client.file.FileSystem+listStatus(AlluxioURI) alluxio.client.file.FileSystem+listStatus(AlluxioURI) alluxio.AlluxioURI+AlluxioURI(String) java.util.Collections+sort(List,Comparator) java.util.Collections+sort(List,Comparator) alluxio.master.file.ConcurrentFileSystemMasterRenameTest.IntegerSuffixedPathComparator+IntegerSuffixedPathComparator() alluxio.AlluxioURI+getName() alluxio.AlluxioURI+getName() alluxio.client.file.URIStatus+getName() java.util.List+get(int) java.util.List+get(int) alluxio.client.file.URIStatus+getName() java.util.List+size() java.util.List+size()""","alluxio.master.file.ConcurrentFileSystemMasterRenameTest+CONCURRENCY_FACTOR alluxio.master.file.ConcurrentFileSystemMasterRenameTest+mFileSystem alluxio.master.file.ConcurrentFileSystemMasterRenameTest+sCreatePersistedFileOptions alluxio.master.file.ConcurrentFileSystemMasterRenameTest+mFileSystem""",948,25,5618,152,1,"/** 
 * Tests concurrent renames within the root do not block on each other.
 */
","/**
   * Tests concurrent renames within the root do not block on each other.
   */
  @Test
  public void rootConcurrentRename() throws Exception {
    final int numThreads = CONCURRENCY_FACTOR;
    AlluxioURI[] srcs = new AlluxioURI[numThreads];
    AlluxioURI[] dsts = new AlluxioURI[numThreads];

    for (int i = 0; i < numThreads; i++) {
      srcs[i] = new AlluxioURI(""/file"" + i);
      mFileSystem.createFile(srcs[i], sCreatePersistedFileOptions).close();
      dsts[i] = new AlluxioURI(""/renamed"" + i);
    }

    int errors = concurrentRename(srcs, dsts);

    Assert.assertEquals(""More than 0 errors: "" + errors, 0, errors);
    List<URIStatus> files = mFileSystem.listStatus(new AlluxioURI(""/""));
    Collections.sort(files, new IntegerSuffixedPathComparator());
    for (int i = 0; i < numThreads; i++) {
      Assert.assertEquals(dsts[i].getName(), files.get(i).getName());
    }
    Assert.assertEquals(numThreads, files.size());
  }",False,False
18,concurrentCreate(),Method,"""","""","alluxio.AlluxioURI+AlluxioURI(String) alluxio.master.file.ConcurrentFileSystemMasterRenameTest+concurrentUnaryOperation(UnaryOperation,AlluxioURI[],long) alluxio.master.file.ConcurrentFileSystemMasterRenameTest+concurrentUnaryOperation(UnaryOperation,AlluxioURI[],long)""","alluxio.master.file.ConcurrentFileSystemMasterRenameTest+CONCURRENCY_FACTOR alluxio.master.file.ConcurrentFileSystemMasterRenameTest+SLEEP_MS alluxio.master.file.ConcurrentFileSystemMasterRenameTest+CONCURRENCY_FACTOR alluxio.master.file.ConcurrentFileSystemMasterRenameTest+UnaryOperation""",598,14,6570,175,1,,"@Test
  public void concurrentCreate() throws Exception {
    final int numThreads = CONCURRENCY_FACTOR;
    // 7 nested components to create (2 seconds each).
    final long limitMs = 14 * SLEEP_MS * CONCURRENCY_FACTOR / 10;
    AlluxioURI[] paths = new AlluxioURI[numThreads];

    for (int i = 0; i < numThreads; i++) {
      paths[i] =
          new AlluxioURI(""/existing/path/dir/shared_dir/t_"" + i + ""/sub_dir1/sub_dir2/file"" + i);
    }
    int errors = concurrentUnaryOperation(UnaryOperation.CREATE, paths, limitMs);
    Assert.assertEquals(""More than 0 errors: "" + errors, 0, errors);
  }",True,True
19,concurrentCreateExistingDir(),Method,"""","""","alluxio.client.file.FileSystem+createDirectory(AlluxioURI,CreateDirectoryOptions) alluxio.client.file.FileSystem+createDirectory(AlluxioURI,CreateDirectoryOptions) alluxio.AlluxioURI+AlluxioURI(String) alluxio.client.file.options.CreateDirectoryOptions+setWriteType(WriteType) alluxio.client.file.options.CreateDirectoryOptions+setRecursive(boolean) alluxio.client.file.options.CreateDirectoryOptions+defaults() alluxio.client.file.options.CreateDirectoryOptions+defaults() alluxio.client.file.options.CreateDirectoryOptions+setRecursive(boolean) alluxio.client.file.options.CreateDirectoryOptions+setWriteType(WriteType) alluxio.AlluxioURI+AlluxioURI(String) alluxio.master.file.ConcurrentFileSystemMasterRenameTest+concurrentUnaryOperation(UnaryOperation,AlluxioURI[],long) alluxio.master.file.ConcurrentFileSystemMasterRenameTest+concurrentUnaryOperation(UnaryOperation,AlluxioURI[],long)""","alluxio.master.file.ConcurrentFileSystemMasterRenameTest+CONCURRENCY_FACTOR alluxio.master.file.ConcurrentFileSystemMasterRenameTest+SLEEP_MS alluxio.master.file.ConcurrentFileSystemMasterRenameTest+CONCURRENCY_FACTOR alluxio.master.file.ConcurrentFileSystemMasterRenameTest+mFileSystem alluxio.master.file.ConcurrentFileSystemMasterRenameTest+UnaryOperation""",879,18,7172,190,1,,"@Test
  public void concurrentCreateExistingDir() throws Exception {
    final int numThreads = CONCURRENCY_FACTOR;
    // 7 nested components to create (2 seconds each).
    final long limitMs = 14 * SLEEP_MS * CONCURRENCY_FACTOR / 10;
    AlluxioURI[] paths = new AlluxioURI[numThreads];

    // Create the existing path with MUST_CACHE, so subsequent creates have to persist the dirs.
    mFileSystem.createDirectory(new AlluxioURI(""/existing/path/dir/""),
        CreateDirectoryOptions.defaults().setRecursive(true).setWriteType(WriteType.CACHE_THROUGH));

    for (int i = 0; i < numThreads; i++) {
      paths[i] =
          new AlluxioURI(""/existing/path/dir/shared_dir/t_"" + i + ""/sub_dir1/sub_dir2/file"" + i);
    }
    int errors = concurrentUnaryOperation(UnaryOperation.CREATE, paths, limitMs);
    Assert.assertEquals(""More than 0 errors: "" + errors, 0, errors);
  }",True,True
20,concurrentCreateNonPersistedDir(),Method,"""","""","alluxio.client.file.FileSystem+createDirectory(AlluxioURI,CreateDirectoryOptions) alluxio.client.file.FileSystem+createDirectory(AlluxioURI,CreateDirectoryOptions) alluxio.AlluxioURI+AlluxioURI(String) alluxio.client.file.options.CreateDirectoryOptions+setWriteType(WriteType) alluxio.client.file.options.CreateDirectoryOptions+setRecursive(boolean) alluxio.client.file.options.CreateDirectoryOptions+defaults() alluxio.client.file.options.CreateDirectoryOptions+defaults() alluxio.client.file.options.CreateDirectoryOptions+setRecursive(boolean) alluxio.client.file.options.CreateDirectoryOptions+setWriteType(WriteType) alluxio.AlluxioURI+AlluxioURI(String) alluxio.master.file.ConcurrentFileSystemMasterRenameTest+concurrentUnaryOperation(UnaryOperation,AlluxioURI[],long) alluxio.master.file.ConcurrentFileSystemMasterRenameTest+concurrentUnaryOperation(UnaryOperation,AlluxioURI[],long)""","alluxio.master.file.ConcurrentFileSystemMasterRenameTest+CONCURRENCY_FACTOR alluxio.master.file.ConcurrentFileSystemMasterRenameTest+SLEEP_MS alluxio.master.file.ConcurrentFileSystemMasterRenameTest+CONCURRENCY_FACTOR alluxio.master.file.ConcurrentFileSystemMasterRenameTest+mFileSystem alluxio.master.file.ConcurrentFileSystemMasterRenameTest+UnaryOperation""",880,18,8055,209,1,,"@Test
  public void concurrentCreateNonPersistedDir() throws Exception {
    final int numThreads = CONCURRENCY_FACTOR;
    // 7 nested components to create (2 seconds each).
    final long limitMs = 14 * SLEEP_MS * CONCURRENCY_FACTOR / 10;
    AlluxioURI[] paths = new AlluxioURI[numThreads];

    // Create the existing path with MUST_CACHE, so subsequent creates have to persist the dirs.
    mFileSystem.createDirectory(new AlluxioURI(""/existing/path/dir/""),
        CreateDirectoryOptions.defaults().setRecursive(true).setWriteType(WriteType.MUST_CACHE));

    for (int i = 0; i < numThreads; i++) {
      paths[i] =
          new AlluxioURI(""/existing/path/dir/shared_dir/t_"" + i + ""/sub_dir1/sub_dir2/file"" + i);
    }
    int errors = concurrentUnaryOperation(UnaryOperation.CREATE, paths, limitMs);
    Assert.assertEquals(""More than 0 errors: "" + errors, 0, errors);
  }",True,True
21,concurrentLoadFileMetadata(),Method,"""","""","alluxio.master.file.ConcurrentFileSystemMasterRenameTest+runLoadMetadata(WriteType,boolean,boolean,boolean) alluxio.master.file.ConcurrentFileSystemMasterRenameTest+runLoadMetadata(WriteType,boolean,boolean,boolean)""","""",118,4,8939,228,1,,"@Test
  public void concurrentLoadFileMetadata() throws Exception {
    runLoadMetadata(null, false, true, false);
  }",True,True
22,concurrentLoadFileMetadataExistingDir(),Method,"""","""","alluxio.master.file.ConcurrentFileSystemMasterRenameTest+runLoadMetadata(WriteType,boolean,boolean,boolean) alluxio.master.file.ConcurrentFileSystemMasterRenameTest+runLoadMetadata(WriteType,boolean,boolean,boolean)""","""",148,4,9061,233,1,,"@Test
  public void concurrentLoadFileMetadataExistingDir() throws Exception {
    runLoadMetadata(WriteType.CACHE_THROUGH, false, true, false);
  }",True,True
23,concurrentLoadFileMetadataNonPersistedDir(),Method,"""","""","alluxio.master.file.ConcurrentFileSystemMasterRenameTest+runLoadMetadata(WriteType,boolean,boolean,boolean) alluxio.master.file.ConcurrentFileSystemMasterRenameTest+runLoadMetadata(WriteType,boolean,boolean,boolean)""","""",149,4,9213,238,1,,"@Test
  public void concurrentLoadFileMetadataNonPersistedDir() throws Exception {
    runLoadMetadata(WriteType.MUST_CACHE, false, true, false);
  }",True,True
24,concurrentLoadSameFileMetadata(),Method,"""","""","alluxio.master.file.ConcurrentFileSystemMasterRenameTest+runLoadMetadata(WriteType,boolean,boolean,boolean) alluxio.master.file.ConcurrentFileSystemMasterRenameTest+runLoadMetadata(WriteType,boolean,boolean,boolean)""","""",121,4,9366,243,1,,"@Test
  public void concurrentLoadSameFileMetadata() throws Exception {
    runLoadMetadata(null, true, true, false);
  }",True,True
25,concurrentLoadSameFileMetadataExistingDir(),Method,"""","""","alluxio.master.file.ConcurrentFileSystemMasterRenameTest+runLoadMetadata(WriteType,boolean,boolean,boolean) alluxio.master.file.ConcurrentFileSystemMasterRenameTest+runLoadMetadata(WriteType,boolean,boolean,boolean)""","""",151,4,9491,248,1,,"@Test
  public void concurrentLoadSameFileMetadataExistingDir() throws Exception {
    runLoadMetadata(WriteType.CACHE_THROUGH, true, true, false);
  }",True,True
26,concurrentLoadSameFileMetadataNonPersistedDir(),Method,"""","""","alluxio.master.file.ConcurrentFileSystemMasterRenameTest+runLoadMetadata(WriteType,boolean,boolean,boolean) alluxio.master.file.ConcurrentFileSystemMasterRenameTest+runLoadMetadata(WriteType,boolean,boolean,boolean)""","""",152,4,9646,253,1,,"@Test
  public void concurrentLoadSameFileMetadataNonPersistedDir() throws Exception {
    runLoadMetadata(WriteType.MUST_CACHE, true, true, false);
  }",True,True
27,concurrentLoadDirMetadata(),Method,"""","""","alluxio.master.file.ConcurrentFileSystemMasterRenameTest+runLoadMetadata(WriteType,boolean,boolean,boolean) alluxio.master.file.ConcurrentFileSystemMasterRenameTest+runLoadMetadata(WriteType,boolean,boolean,boolean)""","""",118,4,9802,258,1,,"@Test
  public void concurrentLoadDirMetadata() throws Exception {
    runLoadMetadata(null, false, false, false);
  }",True,True
28,concurrentLoadDirMetadataExistingDir(),Method,"""","""","alluxio.master.file.ConcurrentFileSystemMasterRenameTest+runLoadMetadata(WriteType,boolean,boolean,boolean) alluxio.master.file.ConcurrentFileSystemMasterRenameTest+runLoadMetadata(WriteType,boolean,boolean,boolean)""","""",148,4,9924,263,1,,"@Test
  public void concurrentLoadDirMetadataExistingDir() throws Exception {
    runLoadMetadata(WriteType.CACHE_THROUGH, false, false, false);
  }",True,True
29,concurrentLoadDirMetadataNonPersistedDir(),Method,"""","""","alluxio.master.file.ConcurrentFileSystemMasterRenameTest+runLoadMetadata(WriteType,boolean,boolean,boolean) alluxio.master.file.ConcurrentFileSystemMasterRenameTest+runLoadMetadata(WriteType,boolean,boolean,boolean)""","""",149,4,10076,268,1,,"@Test
  public void concurrentLoadDirMetadataNonPersistedDir() throws Exception {
    runLoadMetadata(WriteType.MUST_CACHE, false, false, false);
  }",True,True
30,concurrentLoadSameDirMetadata(),Method,"""","""","alluxio.master.file.ConcurrentFileSystemMasterRenameTest+runLoadMetadata(WriteType,boolean,boolean,boolean) alluxio.master.file.ConcurrentFileSystemMasterRenameTest+runLoadMetadata(WriteType,boolean,boolean,boolean)""","""",121,4,10229,273,1,,"@Test
  public void concurrentLoadSameDirMetadata() throws Exception {
    runLoadMetadata(null, true, false, false);
  }",True,True
31,concurrentLoadSameDirMetadataExistingDir(),Method,"""","""","alluxio.master.file.ConcurrentFileSystemMasterRenameTest+runLoadMetadata(WriteType,boolean,boolean,boolean) alluxio.master.file.ConcurrentFileSystemMasterRenameTest+runLoadMetadata(WriteType,boolean,boolean,boolean)""","""",151,4,10354,278,1,,"@Test
  public void concurrentLoadSameDirMetadataExistingDir() throws Exception {
    runLoadMetadata(WriteType.CACHE_THROUGH, true, false, false);
  }",True,True
32,concurrentLoadSameDirMetadataNonPersistedDir(),Method,"""","""","alluxio.master.file.ConcurrentFileSystemMasterRenameTest+runLoadMetadata(WriteType,boolean,boolean,boolean) alluxio.master.file.ConcurrentFileSystemMasterRenameTest+runLoadMetadata(WriteType,boolean,boolean,boolean)""","""",152,4,10509,283,1,,"@Test
  public void concurrentLoadSameDirMetadataNonPersistedDir() throws Exception {
    runLoadMetadata(WriteType.MUST_CACHE, true, false, false);
  }",True,True
33,concurrentListDirs(),Method,"""","""","alluxio.master.file.ConcurrentFileSystemMasterRenameTest+runLoadMetadata(WriteType,boolean,boolean,boolean) alluxio.master.file.ConcurrentFileSystemMasterRenameTest+runLoadMetadata(WriteType,boolean,boolean,boolean)""","""",110,4,10665,288,1,,"@Test
  public void concurrentListDirs() throws Exception {
    runLoadMetadata(null, false, false, true);
  }",True,True
34,concurrentListDirsExistingDir(),Method,"""","""","alluxio.master.file.ConcurrentFileSystemMasterRenameTest+runLoadMetadata(WriteType,boolean,boolean,boolean) alluxio.master.file.ConcurrentFileSystemMasterRenameTest+runLoadMetadata(WriteType,boolean,boolean,boolean)""","""",140,4,10779,293,1,,"@Test
  public void concurrentListDirsExistingDir() throws Exception {
    runLoadMetadata(WriteType.CACHE_THROUGH, false, false, true);
  }",True,True
35,concurrentListDirsNonPersistedDir(),Method,"""","""","alluxio.master.file.ConcurrentFileSystemMasterRenameTest+runLoadMetadata(WriteType,boolean,boolean,boolean) alluxio.master.file.ConcurrentFileSystemMasterRenameTest+runLoadMetadata(WriteType,boolean,boolean,boolean)""","""",141,4,10923,298,1,,"@Test
  public void concurrentListDirsNonPersistedDir() throws Exception {
    runLoadMetadata(WriteType.MUST_CACHE, false, false, true);
  }",True,True
36,concurrentListFiles(),Method,"""","""","alluxio.master.file.ConcurrentFileSystemMasterRenameTest+runLoadMetadata(WriteType,boolean,boolean,boolean) alluxio.master.file.ConcurrentFileSystemMasterRenameTest+runLoadMetadata(WriteType,boolean,boolean,boolean)""","""",110,4,11068,303,1,,"@Test
  public void concurrentListFiles() throws Exception {
    runLoadMetadata(null, false, true, true);
  }",True,True
37,concurrentListFilesExistingDir(),Method,"""","""","alluxio.master.file.ConcurrentFileSystemMasterRenameTest+runLoadMetadata(WriteType,boolean,boolean,boolean) alluxio.master.file.ConcurrentFileSystemMasterRenameTest+runLoadMetadata(WriteType,boolean,boolean,boolean)""","""",140,4,11182,308,1,,"@Test
  public void concurrentListFilesExistingDir() throws Exception {
    runLoadMetadata(WriteType.CACHE_THROUGH, false, true, true);
  }",True,True
38,concurrentListFilesNonPersistedDir(),Method,"""","""","alluxio.master.file.ConcurrentFileSystemMasterRenameTest+runLoadMetadata(WriteType,boolean,boolean,boolean) alluxio.master.file.ConcurrentFileSystemMasterRenameTest+runLoadMetadata(WriteType,boolean,boolean,boolean)""","""",141,4,11326,313,1,,"@Test
  public void concurrentListFilesNonPersistedDir() throws Exception {
    runLoadMetadata(WriteType.MUST_CACHE, false, true, true);
  }",True,True
39,folderConcurrentRename(),Method,"""","""","alluxio.AlluxioURI+AlluxioURI(String) alluxio.client.file.FileSystem+createDirectory(AlluxioURI) alluxio.client.file.FileSystem+createDirectory(AlluxioURI) alluxio.AlluxioURI+join(String) alluxio.AlluxioURI+join(String) alluxio.client.file.FileOutStream+close() alluxio.client.file.FileSystem+createFile(AlluxioURI,CreateFileOptions) alluxio.client.file.FileSystem+createFile(AlluxioURI,CreateFileOptions) alluxio.client.file.FileOutStream+close() alluxio.AlluxioURI+join(String) alluxio.AlluxioURI+join(String) alluxio.master.file.ConcurrentFileSystemMasterRenameTest+concurrentRename(AlluxioURI[],AlluxioURI[]) alluxio.master.file.ConcurrentFileSystemMasterRenameTest+concurrentRename(AlluxioURI[],AlluxioURI[]) alluxio.client.file.FileSystem+listStatus(AlluxioURI) alluxio.client.file.FileSystem+listStatus(AlluxioURI) alluxio.AlluxioURI+AlluxioURI(String) java.util.Collections+sort(List,Comparator) java.util.Collections+sort(List,Comparator) alluxio.master.file.ConcurrentFileSystemMasterRenameTest.IntegerSuffixedPathComparator+IntegerSuffixedPathComparator() alluxio.AlluxioURI+getName() alluxio.AlluxioURI+getName() alluxio.client.file.URIStatus+getName() java.util.List+get(int) java.util.List+get(int) alluxio.client.file.URIStatus+getName() java.util.List+size() java.util.List+size()""","alluxio.master.file.ConcurrentFileSystemMasterRenameTest+CONCURRENCY_FACTOR alluxio.master.file.ConcurrentFileSystemMasterRenameTest+mFileSystem alluxio.master.file.ConcurrentFileSystemMasterRenameTest+mFileSystem alluxio.master.file.ConcurrentFileSystemMasterRenameTest+sCreatePersistedFileOptions alluxio.master.file.ConcurrentFileSystemMasterRenameTest+mFileSystem""",1025,28,11471,321,1,"/** 
 * Tests concurrent renames within a folder do not block on each other.
 */
","/**
   * Tests concurrent renames within a folder do not block on each other.
   */
  @Test
  public void folderConcurrentRename() throws Exception {
    final int numThreads = CONCURRENCY_FACTOR;
    AlluxioURI[] srcs = new AlluxioURI[numThreads];
    AlluxioURI[] dsts = new AlluxioURI[numThreads];

    AlluxioURI dir = new AlluxioURI(""/dir"");

    mFileSystem.createDirectory(dir);

    for (int i = 0; i < numThreads; i++) {
      srcs[i] = dir.join(""/file"" + i);
      mFileSystem.createFile(srcs[i], sCreatePersistedFileOptions).close();
      dsts[i] = dir.join(""/renamed"" + i);
    }
    int errors = concurrentRename(srcs, dsts);

    Assert.assertEquals(""More than 0 errors: "" + errors, 0, errors);
    List<URIStatus> files = mFileSystem.listStatus(new AlluxioURI(""/dir""));
    Collections.sort(files, new IntegerSuffixedPathComparator());
    for (int i = 0; i < numThreads; i++) {
      Assert.assertEquals(dsts[i].getName(), files.get(i).getName());
    }
    Assert.assertEquals(numThreads, files.size());
  }",False,False
40,sameFileConcurrentRename(),Method,"""","""","alluxio.AlluxioURI+AlluxioURI(String) alluxio.AlluxioURI+AlluxioURI(String) alluxio.client.file.FileOutStream+close() alluxio.client.file.FileSystem+createFile(AlluxioURI,CreateFileOptions) alluxio.client.file.FileSystem+createFile(AlluxioURI,CreateFileOptions) alluxio.client.file.FileOutStream+close() alluxio.master.file.ConcurrentFileSystemMasterRenameTest+concurrentRename(AlluxioURI[],AlluxioURI[]) alluxio.master.file.ConcurrentFileSystemMasterRenameTest+concurrentRename(AlluxioURI[],AlluxioURI[]) alluxio.client.file.FileSystem+listStatus(AlluxioURI) alluxio.client.file.FileSystem+listStatus(AlluxioURI) alluxio.AlluxioURI+AlluxioURI(String) java.util.List+size() java.util.List+size() java.lang.String+startsWith(String) alluxio.client.file.URIStatus+getName() java.util.List+get(int) java.util.List+get(int) alluxio.client.file.URIStatus+getName() java.lang.String+startsWith(String)""","alluxio.master.file.ConcurrentFileSystemMasterRenameTest+CONCURRENCY_FACTOR alluxio.master.file.ConcurrentFileSystemMasterRenameTest+mFileSystem alluxio.master.file.ConcurrentFileSystemMasterRenameTest+sCreatePersistedFileOptions alluxio.master.file.ConcurrentFileSystemMasterRenameTest+mFileSystem""",951,27,12500,350,1,"/** 
 * Tests that many threads concurrently renaming the same file will only succeed once.
 */
","/**
   * Tests that many threads concurrently renaming the same file will only succeed once.
   */
  @Test
  public void sameFileConcurrentRename() throws Exception {
    int numThreads = CONCURRENCY_FACTOR;
    final AlluxioURI[] srcs = new AlluxioURI[numThreads];
    final AlluxioURI[] dsts = new AlluxioURI[numThreads];
    for (int i = 0; i < numThreads; i++) {
      srcs[i] = new AlluxioURI(""/file"");
      dsts[i] = new AlluxioURI(""/renamed"" + i);
    }

    // Create the one source file
    mFileSystem.createFile(srcs[0], sCreatePersistedFileOptions).close();

    int errors = concurrentRename(srcs, dsts);

    // We should get an error for all but 1 rename
    Assert.assertEquals(numThreads - 1, errors);

    List<URIStatus> files = mFileSystem.listStatus(new AlluxioURI(""/""));

    // Only one renamed file should exist
    Assert.assertEquals(1, files.size());
    Assert.assertTrue(files.get(0).getName().startsWith(""renamed""));
  }",False,False
41,sameDirConcurrentRename(),Method,"""","""","alluxio.AlluxioURI+AlluxioURI(String) alluxio.AlluxioURI+AlluxioURI(String) alluxio.client.file.FileSystem+createDirectory(AlluxioURI) alluxio.client.file.FileSystem+createDirectory(AlluxioURI) alluxio.client.file.FileOutStream+close() alluxio.client.file.FileSystem+createFile(AlluxioURI,CreateFileOptions) alluxio.client.file.FileSystem+createFile(AlluxioURI,CreateFileOptions) alluxio.AlluxioURI+AlluxioURI(String) alluxio.client.file.FileOutStream+close() alluxio.master.file.ConcurrentFileSystemMasterRenameTest+concurrentRename(AlluxioURI[],AlluxioURI[]) alluxio.master.file.ConcurrentFileSystemMasterRenameTest+concurrentRename(AlluxioURI[],AlluxioURI[]) alluxio.client.file.FileSystem+listStatus(AlluxioURI) alluxio.client.file.FileSystem+listStatus(AlluxioURI) alluxio.AlluxioURI+AlluxioURI(String) java.util.List+size() java.util.List+size() java.lang.String+startsWith(String) alluxio.client.file.URIStatus+getName() java.util.List+get(int) java.util.List+get(int) alluxio.client.file.URIStatus+getName() java.lang.String+startsWith(String) alluxio.client.file.FileSystem+listStatus(AlluxioURI) alluxio.client.file.FileSystem+listStatus(AlluxioURI) alluxio.AlluxioURI+AlluxioURI(String) alluxio.client.file.URIStatus+getPath() java.util.List+get(int) java.util.List+get(int) alluxio.client.file.URIStatus+getPath() java.util.List+size() java.util.List+size()""","alluxio.master.file.ConcurrentFileSystemMasterRenameTest+CONCURRENCY_FACTOR alluxio.master.file.ConcurrentFileSystemMasterRenameTest+mFileSystem alluxio.master.file.ConcurrentFileSystemMasterRenameTest+mFileSystem alluxio.master.file.ConcurrentFileSystemMasterRenameTest+sCreatePersistedFileOptions alluxio.master.file.ConcurrentFileSystemMasterRenameTest+mFileSystem alluxio.master.file.ConcurrentFileSystemMasterRenameTest+mFileSystem""",1245,30,13455,378,1,"/** 
 * Tests that many threads concurrently renaming the same directory will only succeed once.
 */
","/**
   * Tests that many threads concurrently renaming the same directory will only succeed once.
   */
  @Test
  public void sameDirConcurrentRename() throws Exception {
    int numThreads = CONCURRENCY_FACTOR;
    final AlluxioURI[] srcs = new AlluxioURI[numThreads];
    final AlluxioURI[] dsts = new AlluxioURI[numThreads];
    for (int i = 0; i < numThreads; i++) {
      srcs[i] = new AlluxioURI(""/dir"");
      dsts[i] = new AlluxioURI(""/renamed"" + i);
    }

    // Create the one source directory
    mFileSystem.createDirectory(srcs[0]);
    mFileSystem.createFile(new AlluxioURI(""/dir/file""), sCreatePersistedFileOptions).close();

    int errors = concurrentRename(srcs, dsts);

    // We should get an error for all but 1 rename
    Assert.assertEquals(numThreads - 1, errors);
    // Only one renamed dir should exist
    List<URIStatus> existingDirs = mFileSystem.listStatus(new AlluxioURI(""/""));
    Assert.assertEquals(1, existingDirs.size());
    Assert.assertTrue(existingDirs.get(0).getName().startsWith(""renamed""));
    // The directory should contain the file
    List<URIStatus> dirChildren =
        mFileSystem.listStatus(new AlluxioURI(existingDirs.get(0).getPath()));
    Assert.assertEquals(1, dirChildren.size());
  }",False,False
42,sameDstConcurrentRename(),Method,"""","""","alluxio.AlluxioURI+AlluxioURI(String) alluxio.client.file.FileOutStream+close() alluxio.client.file.FileSystem+createFile(AlluxioURI,CreateFileOptions) alluxio.client.file.FileSystem+createFile(AlluxioURI,CreateFileOptions) alluxio.client.file.FileOutStream+close() alluxio.AlluxioURI+AlluxioURI(String) alluxio.master.file.ConcurrentFileSystemMasterRenameTest+concurrentRename(AlluxioURI[],AlluxioURI[]) alluxio.master.file.ConcurrentFileSystemMasterRenameTest+concurrentRename(AlluxioURI[],AlluxioURI[]) alluxio.client.file.FileSystem+listStatus(AlluxioURI) alluxio.client.file.FileSystem+listStatus(AlluxioURI) alluxio.AlluxioURI+AlluxioURI(String) java.lang.String+startsWith(String) alluxio.client.file.URIStatus+getName() alluxio.client.file.URIStatus+getName() java.lang.String+startsWith(String) java.util.Set+add(E) java.util.Set+add(E) alluxio.client.file.URIStatus+getName() alluxio.client.file.URIStatus+getName() java.lang.String+startsWith(String) alluxio.client.file.URIStatus+getName() alluxio.client.file.URIStatus+getName() java.lang.String+startsWith(String) java.util.Set+add(E) java.util.Set+add(E) alluxio.client.file.URIStatus+getName() alluxio.client.file.URIStatus+getName() java.util.List+size() java.util.List+size() java.util.Set+size() java.util.Set+size() java.util.Set+size() java.util.Set+size()""","alluxio.master.file.ConcurrentFileSystemMasterRenameTest+CONCURRENCY_FACTOR alluxio.master.file.ConcurrentFileSystemMasterRenameTest+mFileSystem alluxio.master.file.ConcurrentFileSystemMasterRenameTest+sCreatePersistedFileOptions alluxio.master.file.ConcurrentFileSystemMasterRenameTest+mFileSystem""",1409,36,14704,409,1,"/** 
 * Tests renaming files concurrently to the same destination will only succeed once.
 */
","/**
   * Tests renaming files concurrently to the same destination will only succeed once.
   */
  @Test
  public void sameDstConcurrentRename() throws Exception {
    int numThreads = CONCURRENCY_FACTOR;
    final AlluxioURI[] srcs = new AlluxioURI[numThreads];
    final AlluxioURI[] dsts = new AlluxioURI[numThreads];
    for (int i = 0; i < numThreads; i++) {
      srcs[i] = new AlluxioURI(""/file"" + i);
      mFileSystem.createFile(srcs[i], sCreatePersistedFileOptions).close();
      dsts[i] = new AlluxioURI(""/renamed"");
    }

    int errors = concurrentRename(srcs, dsts);

    // We should get an error for all but 1 rename.
    Assert.assertEquals(numThreads - 1, errors);

    List<URIStatus> files = mFileSystem.listStatus(new AlluxioURI(""/""));
    // Store file names in a set to ensure the names are all unique.
    Set<String> renamedFiles = new HashSet<>();
    Set<String> originalFiles = new HashSet<>();
    for (URIStatus file : files) {
      if (file.getName().startsWith(""renamed"")) {
        renamedFiles.add(file.getName());
      }
      if (file.getName().startsWith(""file"")) {
        originalFiles.add(file.getName());
      }
    }
    // One renamed file should exist, and numThreads - 1 original source files
    Assert.assertEquals(numThreads, files.size());
    Assert.assertEquals(1, renamedFiles.size());
    Assert.assertEquals(numThreads - 1, originalFiles.size());
  }",False,False
43,twoDirConcurrentRename(),Method,"""","""","alluxio.AlluxioURI+AlluxioURI(String) alluxio.AlluxioURI+AlluxioURI(String) alluxio.client.file.FileSystem+createDirectory(AlluxioURI) alluxio.client.file.FileSystem+createDirectory(AlluxioURI) alluxio.client.file.FileSystem+createDirectory(AlluxioURI) alluxio.client.file.FileSystem+createDirectory(AlluxioURI) alluxio.AlluxioURI+join(String) alluxio.AlluxioURI+join(String) alluxio.client.file.FileOutStream+close() alluxio.client.file.FileSystem+createFile(AlluxioURI,CreateFileOptions) alluxio.client.file.FileSystem+createFile(AlluxioURI,CreateFileOptions) alluxio.client.file.FileOutStream+close() alluxio.AlluxioURI+join(String) alluxio.AlluxioURI+join(String) alluxio.master.file.ConcurrentFileSystemMasterRenameTest+concurrentRename(AlluxioURI[],AlluxioURI[]) alluxio.master.file.ConcurrentFileSystemMasterRenameTest+concurrentRename(AlluxioURI[],AlluxioURI[]) alluxio.client.file.FileSystem+listStatus(AlluxioURI) alluxio.client.file.FileSystem+listStatus(AlluxioURI) alluxio.client.file.FileSystem+listStatus(AlluxioURI) alluxio.client.file.FileSystem+listStatus(AlluxioURI) java.util.List+size() java.util.List+size() java.util.List+size() java.util.List+size() java.util.Collections+sort(List,Comparator) java.util.Collections+sort(List,Comparator) alluxio.master.file.ConcurrentFileSystemMasterRenameTest.IntegerSuffixedPathComparator+IntegerSuffixedPathComparator() alluxio.AlluxioURI+getName() alluxio.AlluxioURI+getName() alluxio.client.file.URIStatus+getName() java.util.List+get(int) java.util.List+get(int) alluxio.client.file.URIStatus+getName()""","alluxio.master.file.ConcurrentFileSystemMasterRenameTest+CONCURRENCY_FACTOR alluxio.master.file.ConcurrentFileSystemMasterRenameTest+mFileSystem alluxio.master.file.ConcurrentFileSystemMasterRenameTest+mFileSystem alluxio.master.file.ConcurrentFileSystemMasterRenameTest+mFileSystem alluxio.master.file.ConcurrentFileSystemMasterRenameTest+sCreatePersistedFileOptions alluxio.master.file.ConcurrentFileSystemMasterRenameTest+mFileSystem alluxio.master.file.ConcurrentFileSystemMasterRenameTest+mFileSystem""",1230,34,16117,446,1,"/** 
 * Tests renaming files concurrently from one directory to another succeeds.
 */
","/**
   * Tests renaming files concurrently from one directory to another succeeds.
   */
  @Test
  public void twoDirConcurrentRename() throws Exception {
    int numThreads = CONCURRENCY_FACTOR;
    final AlluxioURI[] srcs = new AlluxioURI[numThreads];
    final AlluxioURI[] dsts = new AlluxioURI[numThreads];
    AlluxioURI dir1 = new AlluxioURI(""/dir1"");
    AlluxioURI dir2 = new AlluxioURI(""/dir2"");
    mFileSystem.createDirectory(dir1);
    mFileSystem.createDirectory(dir2);
    for (int i = 0; i < numThreads; i++) {
      srcs[i] = dir1.join(""file"" + i);
      mFileSystem.createFile(srcs[i], sCreatePersistedFileOptions).close();
      dsts[i] = dir2.join(""renamed"" + i);
    }

    int errors = concurrentRename(srcs, dsts);

    // We should get no errors
    Assert.assertEquals(0, errors);

    List<URIStatus> dir1Files = mFileSystem.listStatus(dir1);
    List<URIStatus> dir2Files = mFileSystem.listStatus(dir2);

    Assert.assertEquals(0, dir1Files.size());
    Assert.assertEquals(numThreads, dir2Files.size());

    Collections.sort(dir2Files, new IntegerSuffixedPathComparator());
    for (int i = 0; i < numThreads; i++) {
      Assert.assertEquals(dsts[i].getName(), dir2Files.get(i).getName());
    }
  }",False,False
44,acrossDirConcurrentRename(),Method,"""","""","alluxio.AlluxioURI+AlluxioURI(String) alluxio.AlluxioURI+AlluxioURI(String) alluxio.client.file.FileSystem+createDirectory(AlluxioURI) alluxio.client.file.FileSystem+createDirectory(AlluxioURI) alluxio.client.file.FileSystem+createDirectory(AlluxioURI) alluxio.client.file.FileSystem+createDirectory(AlluxioURI) alluxio.AlluxioURI+join(String) alluxio.AlluxioURI+join(String) alluxio.AlluxioURI+join(String) alluxio.AlluxioURI+join(String) alluxio.AlluxioURI+join(String) alluxio.AlluxioURI+join(String) alluxio.AlluxioURI+join(String) alluxio.AlluxioURI+join(String) alluxio.client.file.FileOutStream+close() alluxio.client.file.FileSystem+createFile(AlluxioURI,CreateFileOptions) alluxio.client.file.FileSystem+createFile(AlluxioURI,CreateFileOptions) alluxio.client.file.FileOutStream+close() alluxio.master.file.ConcurrentFileSystemMasterRenameTest+concurrentRename(AlluxioURI[],AlluxioURI[]) alluxio.master.file.ConcurrentFileSystemMasterRenameTest+concurrentRename(AlluxioURI[],AlluxioURI[]) alluxio.client.file.FileSystem+listStatus(AlluxioURI) alluxio.client.file.FileSystem+listStatus(AlluxioURI) alluxio.client.file.FileSystem+listStatus(AlluxioURI) alluxio.client.file.FileSystem+listStatus(AlluxioURI) java.util.List+size() java.util.List+size() java.util.List+size() java.util.List+size() java.util.Collections+sort(List,Comparator) java.util.Collections+sort(List,Comparator) alluxio.master.file.ConcurrentFileSystemMasterRenameTest.IntegerSuffixedPathComparator+IntegerSuffixedPathComparator() alluxio.AlluxioURI+getName() alluxio.AlluxioURI+getName() alluxio.client.file.URIStatus+getName() java.util.List+get(int) java.util.List+get(int) alluxio.client.file.URIStatus+getName() java.util.Collections+sort(List,Comparator) java.util.Collections+sort(List,Comparator) alluxio.master.file.ConcurrentFileSystemMasterRenameTest.IntegerSuffixedPathComparator+IntegerSuffixedPathComparator() alluxio.AlluxioURI+getName() alluxio.AlluxioURI+getName() alluxio.client.file.URIStatus+getName() java.util.List+get(int) java.util.List+get(int) alluxio.client.file.URIStatus+getName()""","alluxio.master.file.ConcurrentFileSystemMasterRenameTest+CONCURRENCY_FACTOR alluxio.master.file.ConcurrentFileSystemMasterRenameTest+mFileSystem alluxio.master.file.ConcurrentFileSystemMasterRenameTest+mFileSystem alluxio.master.file.ConcurrentFileSystemMasterRenameTest+mFileSystem alluxio.master.file.ConcurrentFileSystemMasterRenameTest+sCreatePersistedFileOptions alluxio.master.file.ConcurrentFileSystemMasterRenameTest+mFileSystem alluxio.master.file.ConcurrentFileSystemMasterRenameTest+mFileSystem""",1643,45,17351,481,1,"/** 
 * Tests renaming files concurrently from and to two directories succeeds.
 */
","/**
   * Tests renaming files concurrently from and to two directories succeeds.
   */
  @Test
  public void acrossDirConcurrentRename() throws Exception {
    int numThreads = CONCURRENCY_FACTOR;
    final AlluxioURI[] srcs = new AlluxioURI[numThreads];
    final AlluxioURI[] dsts = new AlluxioURI[numThreads];
    AlluxioURI dir1 = new AlluxioURI(""/dir1"");
    AlluxioURI dir2 = new AlluxioURI(""/dir2"");
    mFileSystem.createDirectory(dir1);
    mFileSystem.createDirectory(dir2);
    for (int i = 0; i < numThreads; i++) {
      // Dir1 has even files, dir2 has odd files.
      if (i % 2 == 0) {
        srcs[i] = dir1.join(""file"" + i);
        dsts[i] = dir2.join(""renamed"" + i);
      } else {
        srcs[i] = dir2.join(""file"" + i);
        dsts[i] = dir1.join(""renamed"" + i);
      }
      mFileSystem.createFile(srcs[i], sCreatePersistedFileOptions).close();
    }

    int errors = concurrentRename(srcs, dsts);

    // We should get no errors.
    Assert.assertEquals(0, errors);

    List<URIStatus> dir1Files = mFileSystem.listStatus(dir1);
    List<URIStatus> dir2Files = mFileSystem.listStatus(dir2);

    Assert.assertEquals(numThreads / 2, dir1Files.size());
    Assert.assertEquals(numThreads / 2, dir2Files.size());

    Collections.sort(dir1Files, new IntegerSuffixedPathComparator());
    for (int i = 1; i < numThreads; i += 2) {
      Assert.assertEquals(dsts[i].getName(), dir1Files.get(i / 2).getName());
    }

    Collections.sort(dir2Files, new IntegerSuffixedPathComparator());
    for (int i = 0; i < numThreads; i += 2) {
      Assert.assertEquals(dsts[i].getName(), dir2Files.get(i / 2).getName());
    }
  }",False,False
45,sharedPrefixDirConcurrentRename(),Method,"""","""","alluxio.AlluxioURI+AlluxioURI(String) alluxio.AlluxioURI+AlluxioURI(String) alluxio.AlluxioURI+AlluxioURI(String) alluxio.client.file.FileSystem+createDirectory(AlluxioURI,CreateDirectoryOptions) alluxio.client.file.FileSystem+createDirectory(AlluxioURI,CreateDirectoryOptions) alluxio.client.file.FileSystem+createDirectory(AlluxioURI,CreateDirectoryOptions) alluxio.client.file.FileSystem+createDirectory(AlluxioURI,CreateDirectoryOptions) alluxio.client.file.FileSystem+createDirectory(AlluxioURI,CreateDirectoryOptions) alluxio.client.file.FileSystem+createDirectory(AlluxioURI,CreateDirectoryOptions) alluxio.AlluxioURI+join(String) alluxio.AlluxioURI+join(String) alluxio.AlluxioURI+join(String) alluxio.AlluxioURI+join(String) alluxio.AlluxioURI+join(String) alluxio.AlluxioURI+join(String) alluxio.client.file.FileOutStream+close() alluxio.client.file.FileSystem+createFile(AlluxioURI,CreateFileOptions) alluxio.client.file.FileSystem+createFile(AlluxioURI,CreateFileOptions) alluxio.client.file.FileOutStream+close() alluxio.master.file.ConcurrentFileSystemMasterRenameTest+concurrentRename(AlluxioURI[],AlluxioURI[]) alluxio.master.file.ConcurrentFileSystemMasterRenameTest+concurrentRename(AlluxioURI[],AlluxioURI[]) alluxio.client.file.FileSystem+listStatus(AlluxioURI) alluxio.client.file.FileSystem+listStatus(AlluxioURI) alluxio.client.file.FileSystem+listStatus(AlluxioURI) alluxio.client.file.FileSystem+listStatus(AlluxioURI) alluxio.client.file.FileSystem+listStatus(AlluxioURI) alluxio.client.file.FileSystem+listStatus(AlluxioURI) java.util.List+size() java.util.List+size() java.util.List+size() java.util.List+size() java.util.List+size() java.util.List+size() java.util.Collections+sort(List,Comparator) java.util.Collections+sort(List,Comparator) alluxio.master.file.ConcurrentFileSystemMasterRenameTest.IntegerSuffixedPathComparator+IntegerSuffixedPathComparator() alluxio.AlluxioURI+getName() alluxio.AlluxioURI+getName() alluxio.client.file.URIStatus+getName() java.util.List+get(int) java.util.List+get(int) alluxio.client.file.URIStatus+getName()""","alluxio.master.file.ConcurrentFileSystemMasterRenameTest+CONCURRENCY_FACTOR alluxio.master.file.ConcurrentFileSystemMasterRenameTest+mFileSystem alluxio.master.file.ConcurrentFileSystemMasterRenameTest+sCreateDirectoryOptions alluxio.master.file.ConcurrentFileSystemMasterRenameTest+mFileSystem alluxio.master.file.ConcurrentFileSystemMasterRenameTest+sCreateDirectoryOptions alluxio.master.file.ConcurrentFileSystemMasterRenameTest+mFileSystem alluxio.master.file.ConcurrentFileSystemMasterRenameTest+sCreateDirectoryOptions alluxio.master.file.ConcurrentFileSystemMasterRenameTest+mFileSystem alluxio.master.file.ConcurrentFileSystemMasterRenameTest+sCreatePersistedFileOptions alluxio.master.file.ConcurrentFileSystemMasterRenameTest+mFileSystem alluxio.master.file.ConcurrentFileSystemMasterRenameTest+mFileSystem alluxio.master.file.ConcurrentFileSystemMasterRenameTest+mFileSystem""",1609,39,18998,527,1,"/** 
 * Tests renaming files concurrently under directories with a shared path prefix.
 */
","/**
   * Tests renaming files concurrently under directories with a shared path prefix.
   */
  @Test
  public void sharedPrefixDirConcurrentRename() throws Exception {
    int numThreads = CONCURRENCY_FACTOR;
    final AlluxioURI[] srcs = new AlluxioURI[numThreads];
    final AlluxioURI[] dsts = new AlluxioURI[numThreads];
    AlluxioURI dir1 = new AlluxioURI(""/root/dir1"");
    AlluxioURI dir2 = new AlluxioURI(""/root/parent/dir2"");
    AlluxioURI dst = new AlluxioURI(""/dst"");
    mFileSystem.createDirectory(dir1, sCreateDirectoryOptions);
    mFileSystem.createDirectory(dir2, sCreateDirectoryOptions);
    mFileSystem.createDirectory(dst, sCreateDirectoryOptions);
    for (int i = 0; i < numThreads; i++) {
      // Dir1 has even files, dir2 has odd files.
      srcs[i] = i % 2 == 0 ? dir1.join(""file"" + i) : dir2.join(""file"" + i);
      dsts[i] = dst.join(""renamed"" + i);
      mFileSystem.createFile(srcs[i], sCreatePersistedFileOptions).close();
    }

    int errors = concurrentRename(srcs, dsts);

    // We should get no errors.
    Assert.assertEquals(0, errors);

    List<URIStatus> dir1Files = mFileSystem.listStatus(dir1);
    List<URIStatus> dir2Files = mFileSystem.listStatus(dir2);
    List<URIStatus> dstFiles = mFileSystem.listStatus(dst);

    Assert.assertEquals(0, dir1Files.size());
    Assert.assertEquals(0, dir2Files.size());
    Assert.assertEquals(numThreads, dstFiles.size());

    Collections.sort(dstFiles, new IntegerSuffixedPathComparator());
    for (int i = 0; i < numThreads; i++) {
      Assert.assertEquals(dsts[i].getName(), dstFiles.get(i).getName());
    }
  }",False,False
46,"concurrentRename(AlluxioURI[],AlluxioURI[])",Method,"rootConcurrentRename() folderConcurrentRename() sameFileConcurrentRename() sameDirConcurrentRename() sameDstConcurrentRename() twoDirConcurrentRename() acrossDirConcurrentRename() sharedPrefixDirConcurrentRename()""","""","java.util.concurrent.CyclicBarrier+CyclicBarrier(int) +() +uncaughtException(Thread,Throwable)""","""",1999,52,20611,573,2,"/** 
 * Helper for renaming a list of paths concurrently. Assumes the srcs are already created and dsts do not exist. Enforces that the run time of this method is not greater than twice the sleep time (to infer concurrent operations). Injects an artificial sleep time to the sleeping under file system and resets it after the renames are complete.
 * @param src list of source paths
 * @param dst list of destination paths
 * @return how many errors occurred
 */
","/**
   * Helper for renaming a list of paths concurrently. Assumes the srcs are already created and
   * dsts do not exist. Enforces that the run time of this method is not greater than twice the
   * sleep time (to infer concurrent operations). Injects an artificial sleep time to the
   * sleeping under file system and resets it after the renames are complete.
   *
   * @param src list of source paths
   * @param dst list of destination paths
   * @return how many errors occurred
   */
  private int concurrentRename(final AlluxioURI[] src, final AlluxioURI[] dst)
      throws Exception {
    final int numFiles = src.length;
    final CyclicBarrier barrier = new CyclicBarrier(numFiles);
    List<Thread> threads = new ArrayList<>(numFiles);
    // If there are exceptions, we will store them here.
    final ConcurrentHashSet<Throwable> errors = new ConcurrentHashSet<>();
    Thread.UncaughtExceptionHandler exceptionHandler = new Thread.UncaughtExceptionHandler() {
      public void uncaughtException(Thread th, Throwable ex) {
        errors.add(ex);
      }
    };
    for (int i = 0; i < numFiles; i++) {
      final int iteration = i;
      Thread t = new Thread(new Runnable() {
        @Override
        public void run() {
          try {
            AuthenticatedClientUser.set(TEST_USER);
            barrier.await();
            mFileSystem.rename(src[iteration], dst[iteration]);
          } catch (Exception e) {
            Throwables.propagate(e);
          }
        }
      });
      t.setUncaughtExceptionHandler(exceptionHandler);
      threads.add(t);
    }
    Collections.shuffle(threads);
    long startMs = CommonUtils.getCurrentMs();
    for (Thread t : threads) {
      t.start();
    }
    for (Thread t : threads) {
      t.join();
    }
    long durationMs = CommonUtils.getCurrentMs() - startMs;
    Assert.assertTrue(""Execution duration "" + durationMs + "" took longer than expected "" + LIMIT_MS,
        durationMs < LIMIT_MS);
    return errors.size();
  }",False,False
47,"concurrentUnaryOperation(UnaryOperation,AlluxioURI[],long)",Method,"concurrentCreate() concurrentCreateExistingDir() concurrentCreateNonPersistedDir() runLoadMetadata(WriteType,boolean,boolean,boolean) runLoadMetadata(WriteType,boolean,boolean,boolean)""","""","java.util.concurrent.CyclicBarrier+CyclicBarrier(int) +() +uncaughtException(Thread,Throwable)""","""",2103,57,22614,616,2,,"private int concurrentUnaryOperation(final UnaryOperation operation, final AlluxioURI[] paths,
      final long limitMs) throws Exception {
    final int numFiles = paths.length;
    final CyclicBarrier barrier = new CyclicBarrier(numFiles);
    List<Thread> threads = new ArrayList<>(numFiles);
    // If there are exceptions, we will store them here.
    final ConcurrentHashSet<Throwable> errors = new ConcurrentHashSet<>();
    Thread.UncaughtExceptionHandler exceptionHandler = new Thread.UncaughtExceptionHandler() {
      public void uncaughtException(Thread th, Throwable ex) {
        errors.add(ex);
      }
    };
    for (int i = 0; i < numFiles; i++) {
      final int iteration = i;
      Thread t = new Thread(new Runnable() {
        @Override
        public void run() {
          try {
            AuthenticatedClientUser.set(TEST_USER);
            barrier.await();
            switch (operation) {
              case CREATE:
                mFileSystem.createFile(paths[iteration], sCreatePersistedFileOptions).close();
                break;
              case DELETE:
                mFileSystem.delete(paths[iteration]);
                break;
              case GET_FILE_INFO:
                mFileSystem.getStatus(paths[iteration]);
                break;
              case LIST_STATUS:
                mFileSystem.listStatus(paths[iteration]);
                break;
              default: throw new IllegalArgumentException(""'operation' is not a valid operation."");
            }

          } catch (Exception e) {
            Throwables.propagate(e);
          }
        }
      });
      t.setUncaughtExceptionHandler(exceptionHandler);
      threads.add(t);
    }
    Collections.shuffle(threads);
    long startMs = CommonUtils.getCurrentMs();
    for (Thread t : threads) {
      t.start();
    }
    for (Thread t : threads) {
      t.join();
    }
    long durationMs = CommonUtils.getCurrentMs() - startMs;
    Assert.assertTrue(""Execution duration "" + durationMs + "" took longer than expected "" + limitMs,
        durationMs < limitMs);
    return errors.size();
  }",True,True
48,"runLoadMetadata(WriteType,boolean,boolean,boolean)",Method,"concurrentLoadFileMetadata() concurrentLoadFileMetadataExistingDir() concurrentLoadFileMetadataNonPersistedDir() concurrentLoadSameFileMetadata() concurrentLoadSameFileMetadataExistingDir() concurrentLoadSameFileMetadataNonPersistedDir() concurrentLoadDirMetadata() concurrentLoadDirMetadataExistingDir() concurrentLoadDirMetadataNonPersistedDir() concurrentLoadSameDirMetadata() concurrentLoadSameDirMetadataExistingDir() concurrentLoadSameDirMetadataNonPersistedDir() concurrentListDirs() concurrentListDirsExistingDir() concurrentListDirsNonPersistedDir() concurrentListFiles() concurrentListFilesExistingDir() concurrentListFilesNonPersistedDir()""","""","java.io.File+mkdirs() java.io.File+File(String) java.io.File+mkdirs() java.io.FileWriter+FileWriter(String) java.io.Writer+write(String) java.io.Writer+write(String) java.io.OutputStreamWriter+close() java.io.OutputStreamWriter+close() java.io.File+mkdirs() java.io.File+File(String) java.io.File+mkdirs() alluxio.client.file.FileSystem+createDirectory(AlluxioURI,CreateDirectoryOptions) alluxio.client.file.FileSystem+createDirectory(AlluxioURI,CreateDirectoryOptions) alluxio.AlluxioURI+AlluxioURI(String) alluxio.client.file.options.CreateDirectoryOptions+setWriteType(WriteType) alluxio.client.file.options.CreateDirectoryOptions+setRecursive(boolean) alluxio.client.file.options.CreateDirectoryOptions+defaults() alluxio.client.file.options.CreateDirectoryOptions+defaults() alluxio.client.file.options.CreateDirectoryOptions+setRecursive(boolean) alluxio.client.file.options.CreateDirectoryOptions+setWriteType(WriteType) alluxio.AlluxioURI+AlluxioURI(String) alluxio.AlluxioURI+AlluxioURI(String) alluxio.master.file.ConcurrentFileSystemMasterRenameTest+concurrentUnaryOperation(UnaryOperation,AlluxioURI[],long) alluxio.master.file.ConcurrentFileSystemMasterRenameTest+concurrentUnaryOperation(UnaryOperation,AlluxioURI[],long) alluxio.master.file.ConcurrentFileSystemMasterRenameTest+concurrentUnaryOperation(UnaryOperation,AlluxioURI[],long) alluxio.master.file.ConcurrentFileSystemMasterRenameTest+concurrentUnaryOperation(UnaryOperation,AlluxioURI[],long) alluxio.client.file.options.ListStatusOptions+setLoadMetadataType(LoadMetadataType) alluxio.client.file.options.ListStatusOptions+defaults() alluxio.client.file.options.ListStatusOptions+defaults() alluxio.client.file.options.ListStatusOptions+setLoadMetadataType(LoadMetadataType) alluxio.client.file.FileSystem+listStatus(AlluxioURI,ListStatusOptions) alluxio.client.file.FileSystem+listStatus(AlluxioURI,ListStatusOptions) alluxio.AlluxioURI+AlluxioURI(String) java.util.List+size() java.util.List+size() alluxio.client.file.URIStatus+getName() java.util.List+get(int) java.util.List+get(int) alluxio.client.file.URIStatus+getName() alluxio.client.file.URIStatus+getPersistenceState() java.util.List+get(int) java.util.List+get(int) alluxio.client.file.URIStatus+getPersistenceState() alluxio.client.file.FileSystem+listStatus(AlluxioURI,ListStatusOptions) alluxio.client.file.FileSystem+listStatus(AlluxioURI,ListStatusOptions) alluxio.AlluxioURI+AlluxioURI(String) java.util.List+size() java.util.List+size() alluxio.client.file.URIStatus+getName() java.util.List+get(int) java.util.List+get(int) alluxio.client.file.URIStatus+getName() alluxio.client.file.URIStatus+getPersistenceState() java.util.List+get(int) java.util.List+get(int) alluxio.client.file.URIStatus+getPersistenceState() alluxio.client.file.FileSystem+listStatus(AlluxioURI,ListStatusOptions) alluxio.client.file.FileSystem+listStatus(AlluxioURI,ListStatusOptions) alluxio.AlluxioURI+AlluxioURI(String) java.util.List+size() java.util.List+size() java.util.Collections+sort(List,Comparator) java.util.Collections+sort(List,Comparator) alluxio.master.file.ConcurrentFileSystemMasterRenameTest.IntegerSuffixedPathComparator+IntegerSuffixedPathComparator() alluxio.client.file.URIStatus+getName() java.util.List+get(int) java.util.List+get(int) alluxio.client.file.URIStatus+getName() alluxio.client.file.URIStatus+getPersistenceState() java.util.List+get(int) java.util.List+get(int) alluxio.client.file.URIStatus+getPersistenceState()""","alluxio.master.file.ConcurrentFileSystemMasterRenameTest+CONCURRENCY_FACTOR alluxio.master.file.ConcurrentFileSystemMasterRenameTest+SLEEP_MS alluxio.master.file.ConcurrentFileSystemMasterRenameTest+SLEEP_MS alluxio.master.file.ConcurrentFileSystemMasterRenameTest+mLocalUfsPath alluxio.master.file.ConcurrentFileSystemMasterRenameTest+mLocalUfsPath alluxio.master.file.ConcurrentFileSystemMasterRenameTest+mLocalUfsPath alluxio.master.file.ConcurrentFileSystemMasterRenameTest+mFileSystem alluxio.master.file.ConcurrentFileSystemMasterRenameTest+UnaryOperation alluxio.master.file.ConcurrentFileSystemMasterRenameTest+UnaryOperation alluxio.master.file.ConcurrentFileSystemMasterRenameTest+mFileSystem alluxio.master.file.ConcurrentFileSystemMasterRenameTest+mFileSystem alluxio.master.file.ConcurrentFileSystemMasterRenameTest+mFileSystem""",3425,84,24721,683,2,"/** 
 * Runs load metadata tests.
 * @param writeType the {@link WriteType} to create ancestors, if not null
 * @param useSinglePath if true, threads will only use a single path
 * @param createFiles if true, will create files at the bottom of the tree, directories otherwise
 * @param listParentDir if true, will list the parent dir to load the metadata
 * @throws Exception if an error occurs
 */
","/**
   * Runs load metadata tests.
   *
   * @param writeType the {@link WriteType} to create ancestors, if not null
   * @param useSinglePath if true, threads will only use a single path
   * @param createFiles if true, will create files at the bottom of the tree, directories otherwise
   * @param listParentDir if true, will list the parent dir to load the metadata
   * @throws Exception if an error occurs
   */
  private void runLoadMetadata(WriteType writeType, boolean useSinglePath, boolean createFiles,
      boolean listParentDir) throws Exception {
    int numThreads = CONCURRENCY_FACTOR;
    // 2 nested components to create.
    long limitMs = 2 * SLEEP_MS * 3;

    int uniquePaths = useSinglePath ? 1 : numThreads;

    if (listParentDir) {
      // Loading direct children needs to load each child, so reduce the branching factor.
      uniquePaths = 10;
      limitMs = (2 + uniquePaths) * SLEEP_MS * 2;
    }

    // Create UFS files outside of Alluxio.
    new File(mLocalUfsPath + ""/existing/path/"").mkdirs();
    for (int i = 0; i < uniquePaths; i++) {
      if (createFiles) {
        FileWriter fileWriter = new FileWriter(mLocalUfsPath + ""/existing/path/last_"" + i);
        fileWriter.write(""test"");
        fileWriter.close();
      } else {
        new File(mLocalUfsPath + ""/existing/path/last_"" + i).mkdirs();
      }
    }

    if (writeType != null) {
      // create inodes in Alluxio
      mFileSystem.createDirectory(new AlluxioURI(""/existing/path/""),
          CreateDirectoryOptions.defaults().setRecursive(true).setWriteType(writeType));
    }

    // Generate path names for threads.
    AlluxioURI[] paths = new AlluxioURI[numThreads];
    int fileId = 0;
    for (int i = 0; i < numThreads; i++) {
      if (listParentDir) {
        paths[i] = new AlluxioURI(""/existing/path/"");
      } else {
        paths[i] = new AlluxioURI(""/existing/path/last_"" + ((fileId++) % uniquePaths));
      }
    }

    int errors = 0;
    if (listParentDir) {
      errors = concurrentUnaryOperation(UnaryOperation.LIST_STATUS, paths, limitMs);
    } else {
      errors = concurrentUnaryOperation(UnaryOperation.GET_FILE_INFO, paths, limitMs);
    }
    Assert.assertEquals(""More than 0 errors: "" + errors, 0, errors);

    ListStatusOptions listOptions = ListStatusOptions.defaults().setLoadMetadataType(
        LoadMetadataType.Never);

    List<URIStatus> files = mFileSystem.listStatus(new AlluxioURI(""/""), listOptions);
    Assert.assertEquals(1, files.size());
    Assert.assertEquals(""existing"", files.get(0).getName());
    Assert.assertEquals(PersistenceState.PERSISTED,
        PersistenceState.valueOf(files.get(0).getPersistenceState()));

    files = mFileSystem.listStatus(new AlluxioURI(""/existing""), listOptions);
    Assert.assertEquals(1, files.size());
    Assert.assertEquals(""path"", files.get(0).getName());
    Assert.assertEquals(PersistenceState.PERSISTED,
        PersistenceState.valueOf(files.get(0).getPersistenceState()));

    files = mFileSystem.listStatus(new AlluxioURI(""/existing/path/""), listOptions);
    Assert.assertEquals(uniquePaths, files.size());
    Collections.sort(files, new IntegerSuffixedPathComparator());
    for (int i = 0; i < uniquePaths; i++) {
      Assert.assertEquals(""last_"" + i, files.get(i).getName());
      Assert.assertEquals(PersistenceState.PERSISTED,
          PersistenceState.valueOf(files.get(i).getPersistenceState()));
    }
  }",True,True
49,consistentGetFileInfo(),Method,"""","""","alluxio.AlluxioURI+AlluxioURI(String) alluxio.AlluxioURI+AlluxioURI(String) java.util.concurrent.CyclicBarrier+CyclicBarrier(int) +() +uncaughtException(Thread,Throwable)""","alluxio.master.file.ConcurrentFileSystemMasterRenameTest+CONCURRENCY_FACTOR""",2467,60,28150,764,1,"/** 
 * Tests that getFileInfo (read operation) either returns the correct file info or fails if it has been renamed while the operation was waiting for the file lock.
 */
","/**
   * Tests that getFileInfo (read operation) either returns the correct file info or fails if it
   * has been renamed while the operation was waiting for the file lock.
   */
  @Test
  public void consistentGetFileInfo() throws Exception {
    final int iterations = CONCURRENCY_FACTOR;
    final AlluxioURI file = new AlluxioURI(""/file"");
    final AlluxioURI dst = new AlluxioURI(""/dst"");
    final CyclicBarrier barrier = new CyclicBarrier(2);
    // If there are exceptions, we will store them here.
    final ConcurrentHashSet<Throwable> errors = new ConcurrentHashSet<>();
    Thread.UncaughtExceptionHandler exceptionHandler = new Thread.UncaughtExceptionHandler() {
      public void uncaughtException(Thread th, Throwable ex) {
        errors.add(ex);
      }
    };
    for (int i = 0; i < iterations; i++) {
      // Don't want sleeping ufs behavior, so do not write to ufs
      mFileSystem.createFile(file, CreateFileOptions.defaults().setWriteType(WriteType.MUST_CACHE))
          .close();
      Thread renamer = new Thread(new Runnable() {
        @Override
        public void run() {
          try {
            AuthenticatedClientUser.set(TEST_USER);
            barrier.await();
            mFileSystem.rename(file, dst);
            mFileSystem.delete(dst);
          } catch (Exception e) {
            Assert.fail(e.getMessage());
          }
        }
      });
      renamer.setUncaughtExceptionHandler(exceptionHandler);
      Thread reader = new Thread(new Runnable() {
        @Override
        public void run() {
          try {
            AuthenticatedClientUser.set(TEST_USER);
            barrier.await();
            URIStatus status = mFileSystem.getStatus(file);
            // If the uri status is successfully obtained, then the path should match
            Assert.assertEquals(file.getName(), status.getName());
          } catch (InvalidPathException | FileDoesNotExistException e) {
            // InvalidPathException - if the file is renamed while the thread waits for the lock.
            // FileDoesNotExistException - if the file is fully renamed before the getFileInfo call.
          } catch (Exception e) {
            Assert.fail(e.getMessage());
          }
        }
      });
      reader.setUncaughtExceptionHandler(exceptionHandler);
      renamer.start();
      reader.start();
      renamer.join();
      reader.join();
      Assert.assertTrue(""Errors detected: "" + errors, errors.isEmpty());
    }
  }",False,False
