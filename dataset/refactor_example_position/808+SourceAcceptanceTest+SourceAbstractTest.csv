index,name,type,inner invocations,external invocations,calls,visits,length,lines,start location,definition line,modifier,annotation,full text,removed
1,CDC_LSN,Field,,,,,51,1,3518,79,25,,"public static final String CDC_LSN = ""_ab_cdc_lsn"";",False
2,CDC_UPDATED_AT,Field,,,,,65,1,3572,80,25,,"public static final String CDC_UPDATED_AT = ""_ab_cdc_updated_at"";",False
3,CDC_DELETED_AT,Field,,,,,65,1,3640,81,25,,"public static final String CDC_DELETED_AT = ""_ab_cdc_deleted_at"";",False
4,CDC_LOG_FILE,Field,,,,,61,1,3708,82,25,,"public static final String CDC_LOG_FILE = ""_ab_cdc_log_file"";",False
5,CDC_LOG_POS,Field,,,,,59,1,3772,83,25,,"public static final String CDC_LOG_POS = ""_ab_cdc_log_pos"";",False
6,JOB_ID,Field,,,,,38,1,3835,85,26,,private static final long JOB_ID = 0L;,True
7,JOB_ATTEMPT,Field,,,,,41,1,3876,86,26,,private static final int JOB_ATTEMPT = 0;,True
8,LOGGER,Field,,,,,89,1,3921,88,26,,private static final Logger LOGGER = LoggerFactory.getLogger(SourceAcceptanceTest.class);,False
9,testEnv,Field,,,,,35,1,4014,90,2,,private TestDestinationEnv testEnv;,False
10,jobRoot,Field,,,,,21,1,4053,92,2,,private Path jobRoot;,True
11,localRoot,Field,,,,,25,1,4077,93,4,,protected Path localRoot;,True
12,processFactory,Field,,,,,38,1,4105,94,2,,private ProcessFactory processFactory;,True
13,IMAGES_TO_SKIP_SECOND_INCREMENTAL_READ,Field,,,,,1487,29,4147,105,2,"/** 
 * TODO hack: Various Singer integrations use cursor fields inclusively i.e: they output records whose cursor field >= the provided cursor value. This leads to the last record in a sync to always be the first record in the next sync. This is a fine assumption from a product POV since we offer at-least-once delivery. But for simplicity, the incremental test suite currently assumes that the second incremental read should output no records when provided the state from the first sync. This works for many integrations but not some Singer ones, so we hardcode the list of integrations to skip over when performing those tests.
 */
","/**
   * TODO hack: Various Singer integrations use cursor fields inclusively i.e: they output records
   * whose cursor field >= the provided cursor value. This leads to the last record in a sync to
   * always be the first record in the next sync. This is a fine assumption from a product POV since
   * we offer at-least-once delivery. But for simplicity, the incremental test suite currently assumes
   * that the second incremental read should output no records when provided the state from the first
   * sync. This works for many integrations but not some Singer ones, so we hardcode the list of
   * integrations to skip over when performing those tests.
   */
  private Set<String> IMAGES_TO_SKIP_SECOND_INCREMENTAL_READ = Sets.newHashSet(
      ""airbyte/source-intercom-singer"",
      ""airbyte/source-exchangeratesapi-singer"",
      ""airbyte/source-hubspot"",
      ""airbyte/source-iterable"",
      ""airbyte/source-marketo-singer"",
      ""airbyte/source-twilio-singer"",
      ""airbyte/source-mixpanel-singer"",
      ""airbyte/source-twilio-singer"",
      ""airbyte/source-braintree-singer"",
      ""airbyte/source-salesforce-singer"",
      ""airbyte/source-stripe-singer"",
      ""airbyte/source-exchange-rates"",
      ""airbyte/source-stripe"",
      ""airbyte/source-github-singer"",
      ""airbyte/source-gitlab-singer"",
      ""airbyte/source-google-workspace-admin-reports"",
      ""airbyte/source-zendesk-talk"",
      ""airbyte/source-quickbooks-singer"",
      ""airbyte/source-jira"");",False
14,IMAGES_TO_SKIP_IDENTICAL_FULL_REFRESHES,Field,,,,,244,5,5638,129,2,"/** 
 * FIXME: Some sources can't guarantee that there will be no events between two sequential sync
 */
","/**
   * FIXME: Some sources can't guarantee that there will be no events between two sequential sync
   */
  private Set<String> IMAGES_TO_SKIP_IDENTICAL_FULL_REFRESHES = Sets.newHashSet(
      ""airbyte/source-google-workspace-admin-reports"");",False
15,getImageName(),Method,testIdenticalFullRefreshes() testIncrementalSyncWithState() runSpec(),,,,152,6,5886,137,1028,"/** 
 * Name of the docker image that the tests will run against.
 * @return docker image name
 */
","/**
   * Name of the docker image that the tests will run against.
   *
   * @return docker image name
   */
  protected abstract String getImageName();",False
16,getSpec(),Method,testGetSpec(),,,,254,7,6042,145,1028,"/** 
 * Specification for integration. Will be passed to integration where appropriate in each test. Should be valid.
 * @return integration-specific configuration
 */
","/**
   * Specification for integration. Will be passed to integration where appropriate in each test.
   * Should be valid.
   *
   * @return integration-specific configuration
   */
  protected abstract ConnectorSpecification getSpec() throws Exception;",False
17,getConfig(),Method,"runCheck() runDiscover() runRead(ConfiguredAirbyteCatalog,JsonNode)",,,,254,7,6300,153,1028,"/** 
 * Configuration specific to the integration. Will be passed to integration where appropriate in each test. Should be valid.
 * @return integration-specific configuration
 */
","/**
   * Configuration specific to the integration. Will be passed to integration where appropriate in
   * each test. Should be valid.
   *
   * @return integration-specific configuration
   */
  protected abstract JsonNode getConfig() throws Exception;",False
18,getConfiguredCatalog(),Method,testFullRefreshRead() testIdenticalFullRefreshes() testIncrementalSyncWithState() testEmptyStateIncrementalIdenticalToFullRefresh() sourceSupportsIncremental(),,,,643,12,6558,166,1028,"/** 
 * The catalog to use to validate the output of read operations. This will be used as follows: <p> Full Refresh syncs will be tested on all the input streams which support it Incremental syncs: - if the stream declares a source-defined cursor, it will be tested with an incremental sync using the default cursor. - if the stream requires a user-defined cursor, it will be tested with the input cursor in both cases, the input  {@link #getState()} will be used as the input state.
 * @return
 * @throws Exception
 */
","/**
   * The catalog to use to validate the output of read operations. This will be used as follows:
   * <p>
   * Full Refresh syncs will be tested on all the input streams which support it Incremental syncs: -
   * if the stream declares a source-defined cursor, it will be tested with an incremental sync using
   * the default cursor. - if the stream requires a user-defined cursor, it will be tested with the
   * input cursor in both cases, the input {@link #getState()} will be used as the input state.
   *
   * @return
   * @throws Exception
   */
  protected abstract ConfiguredAirbyteCatalog getConfiguredCatalog() throws Exception;",False
19,getState(),Method,testIncrementalSyncWithState(),,,,159,4,7205,171,1028,"/** 
 * @return a JSON file representing the state file to use when testing incremental syncs
 */
","/**
   * @return a JSON file representing the state file to use when testing incremental syncs
   */
  protected abstract JsonNode getState() throws Exception;",False
20,getRegexTests(),Method,testFullRefreshRead(),,,,283,7,7368,179,1028,"/** 
 * List of regular expressions that should match the output of the test sync.
 * @return the regular expressions to test
 * @throws Exception - thrown when attempting ot access the regexes fails
 */
","/**
   * List of regular expressions that should match the output of the test sync.
   *
   * @return the regular expressions to test
   * @throws Exception - thrown when attempting ot access the regexes fails
   */
  protected abstract List<String> getRegexTests() throws Exception;",False
21,setup(TestDestinationEnv),Method,setUpInternal(),,,,405,8,7655,188,1028,"/** 
 * Function that performs any setup of external resources required for the test. e.g. instantiate a postgres database. This function will be called before EACH test.
 * @param testEnv - information about the test environment.
 * @throws Exception - can throw any exception, test framework will handle.
 */
","/**
   * Function that performs any setup of external resources required for the test. e.g. instantiate a
   * postgres database. This function will be called before EACH test.
   *
   * @param testEnv - information about the test environment.
   * @throws Exception - can throw any exception, test framework will handle.
   */
  protected abstract void setup(TestDestinationEnv testEnv) throws Exception;",False
22,tearDown(TestDestinationEnv),Method,tearDownInternal(),,,,501,9,8064,198,1028,"/** 
 * Function that performs any clean up of external resources required for the test. e.g. delete a postgres database. This function will be called after EACH test. It MUST remove all data in the destination so that there is no contamination across tests.
 * @param testEnv - information about the test environment.
 * @throws Exception - can throw any exception, test framework will handle.
 */
","/**
   * Function that performs any clean up of external resources required for the test. e.g. delete a
   * postgres database. This function will be called after EACH test. It MUST remove all data in the
   * destination so that there is no contamination across tests.
   *
   * @param testEnv - information about the test environment.
   * @throws Exception - can throw any exception, test framework will handle.
   */
  protected abstract void tearDown(TestDestinationEnv testEnv) throws Exception;",False
23,setUpInternal(),Method,,,"java.nio.file.Path+of(URI) java.nio.file.Path+of(URI) java.nio.file.Files+createDirectories(Path,FileAttribute[]) java.nio.file.Files+createDirectories(Path,FileAttribute[]) java.nio.file.Files+createTempDirectory(String,FileAttribute[]) java.nio.file.Files+createTempDirectory(String,FileAttribute[]) java.nio.file.Files+createDirectories(Path,FileAttribute[]) java.nio.file.Files+createDirectories(Path,FileAttribute[]) java.nio.file.Path+of(String,String[]) java.nio.file.Path+of(String,String[]) java.nio.file.Path+toString() java.nio.file.Path+toString() java.nio.file.Files+createTempDirectory(String,FileAttribute[]) java.nio.file.Files+createTempDirectory(String,FileAttribute[]) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest.TestDestinationEnv+TestDestinationEnv(Path) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+setup(TestDestinationEnv) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+setup(TestDestinationEnv) io.airbyte.workers.process.DockerProcessFactory+DockerProcessFactory(Path,String,String,String) java.nio.file.Path+toString() java.nio.file.Path+toString() java.nio.file.Path+toString() java.nio.file.Path+toString()",io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+jobRoot io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+localRoot io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+testEnv io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+localRoot io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+testEnv io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+processFactory io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+localRoot,599,17,8569,201,1,,"@BeforeEach
  public void setUpInternal() throws Exception {
    final Path testDir = Path.of(""/tmp/airbyte_tests/"");
    Files.createDirectories(testDir);
    final Path workspaceRoot = Files.createTempDirectory(testDir, ""test"");
    jobRoot = Files.createDirectories(Path.of(workspaceRoot.toString(), ""job""));
    localRoot = Files.createTempDirectory(testDir, ""output"");
    testEnv = new TestDestinationEnv(localRoot);

    setup(testEnv);

    processFactory = new DockerProcessFactory(
        workspaceRoot,
        workspaceRoot.toString(),
        localRoot.toString(),
        ""host"");
  }",True
24,tearDownInternal(),Method,,,io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+tearDown(TestDestinationEnv) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+tearDown(TestDestinationEnv),io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+testEnv,89,4,9172,219,1,,"@AfterEach
  public void tearDownInternal() throws Exception {
    tearDown(testEnv);
  }",True
25,testGetSpec(),Method,,,io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+getSpec() io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+getSpec() io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+runSpec() io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+runSpec(),,271,7,9265,227,1,"/** 
 * Verify that a spec operation issued to the connector returns a valid spec.
 */
","/**
   * Verify that a spec operation issued to the connector returns a valid spec.
   */
  @Test
  public void testGetSpec() throws Exception {
    assertEquals(getSpec(), runSpec(), ""Expected spec output by integration to be equal to spec provided by test runner"");
  }",False
26,testCheckConnection(),Method,,,io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+runCheck() io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+runCheck(),,305,8,9540,236,1,"/** 
 * Verify that a check operation issued to the connector with the input config file returns a success response.
 */
","/**
   * Verify that a check operation issued to the connector with the input config file returns a
   * success response.
   */
  @Test
  public void testCheckConnection() throws Exception {
    assertEquals(Status.SUCCEEDED, runCheck().getStatus(), ""Expected check connection operation to succeed"");
  }",False
27,testDiscover(),Method,,,io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+runDiscover() io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+runDiscover(),,458,10,10336,256,1,"/** 
 * Verifies when a discover operation is run on the connector using the given config file, a valid catalog is output by the connector.
 */
","/**
   * Verifies when a discover operation is run on the connector using the given config file, a valid
   * catalog is output by the connector.
   */
  @Test
  public void testDiscover() throws Exception {
    // the worker validates that it is a valid catalog, so we do not need to validate again (as long as
    // we use the worker, which we will not want to do long term).
    assertNotNull(runDiscover(), ""Expected discover to produce a catalog"");
  }",False
28,testFullRefreshRead(),Method,,,io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+withFullRefreshSyncModes(ConfiguredAirbyteCatalog) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+withFullRefreshSyncModes(ConfiguredAirbyteCatalog) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+getConfiguredCatalog() io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+getConfiguredCatalog() io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+runRead(ConfiguredAirbyteCatalog) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+runRead(ConfiguredAirbyteCatalog) java.util.stream.Collectors+toList() java.util.stream.Collectors+toList() io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+getRegexTests() io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+getRegexTests() java.util.stream.Collectors+toList() java.util.stream.Collectors+toList() java.util.List+size() java.util.List+size() java.lang.Iterable+forEach(Consumer) java.lang.Iterable+forEach(Consumer) java.util.stream.Stream+anyMatch(Predicate) java.util.Collection+stream() java.util.Collection+stream() java.util.stream.Stream+anyMatch(Predicate),io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+LOGGER io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+LOGGER,1257,22,10798,267,1,"/** 
 * Configuring all streams in the input catalog to full refresh mode, verifies that a read operation produces some RECORD messages.
 */
","/**
   * Configuring all streams in the input catalog to full refresh mode, verifies that a read operation
   * produces some RECORD messages.
   */
  @Test
  public void testFullRefreshRead() throws Exception {
    ConfiguredAirbyteCatalog catalog = withFullRefreshSyncModes(getConfiguredCatalog());
    final List<AirbyteMessage> allMessages = runRead(catalog);
    final List<AirbyteMessage> recordMessages = allMessages.stream().filter(m -> m.getType() == Type.RECORD).collect(Collectors.toList());
    // the worker validates the message formats, so we just validate the message content
    // We don't need to validate message format as long as we use the worker, which we will not want to
    // do long term.
    assertFalse(recordMessages.isEmpty(), ""Expected a full refresh sync to produce records"");

    final List<String> regexTests = getRegexTests();
    final List<String> stringMessages = allMessages.stream().map(Jsons::serialize).collect(Collectors.toList());
    LOGGER.info(""Running "" + regexTests.size() + "" regex tests..."");
    regexTests.forEach(regex -> {
      LOGGER.info(""Looking for ["" + regex + ""]"");
      assertTrue(stringMessages.stream().anyMatch(line -> line.matches(regex)), ""Failed to find regex: "" + regex);
    });
  }",False
29,testIdenticalFullRefreshes(),Method,,,"java.util.Set+contains(Object) java.util.Set+contains(Object) java.lang.String+split(String) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+getImageName() io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+getImageName() java.lang.String+split(String) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+withFullRefreshSyncModes(ConfiguredAirbyteCatalog) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+withFullRefreshSyncModes(ConfiguredAirbyteCatalog) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+getConfiguredCatalog() io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+getConfiguredCatalog() io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+filterRecords(Collection<AirbyteMessage>) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+filterRecords(Collection<AirbyteMessage>) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+runRead(ConfiguredAirbyteCatalog) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+runRead(ConfiguredAirbyteCatalog) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+filterRecords(Collection<AirbyteMessage>) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+filterRecords(Collection<AirbyteMessage>) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+runRead(ConfiguredAirbyteCatalog) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+runRead(ConfiguredAirbyteCatalog) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+assertSameRecords(List<AirbyteRecordMessage>,List<AirbyteRecordMessage>,String) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+assertSameRecords(List<AirbyteRecordMessage>,List<AirbyteRecordMessage>,String)",io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+IMAGES_TO_SKIP_IDENTICAL_FULL_REFRESHES,1275,21,12059,291,1,"/** 
 * Configuring all streams in the input catalog to full refresh mode, performs two read operations on all streams which support full refresh syncs. It then verifies that the RECORD messages output from both were identical.
 */
","/**
   * Configuring all streams in the input catalog to full refresh mode, performs two read operations
   * on all streams which support full refresh syncs. It then verifies that the RECORD messages output
   * from both were identical.
   */
  @Test
  public void testIdenticalFullRefreshes() throws Exception {
    if (IMAGES_TO_SKIP_IDENTICAL_FULL_REFRESHES.contains(getImageName().split("":"")[0])) {
      return;
    }

    final ConfiguredAirbyteCatalog configuredCatalog = withFullRefreshSyncModes(getConfiguredCatalog());
    final List<AirbyteRecordMessage> recordMessagesFirstRun = filterRecords(runRead(configuredCatalog));
    final List<AirbyteRecordMessage> recordMessagesSecondRun = filterRecords(runRead(configuredCatalog));
    // the worker validates the messages, so we just validate the message, so we do not need to validate
    // again (as long as we use the worker, which we will not want to do long term).
    assertFalse(recordMessagesFirstRun.isEmpty(), ""Expected first full refresh to produce records"");
    assertFalse(recordMessagesSecondRun.isEmpty(), ""Expected second full refresh to produce records"");

    assertSameRecords(recordMessagesFirstRun, recordMessagesSecondRun, ""Expected two full refresh syncs to produce the same records"");
  }",False
30,testIncrementalSyncWithState(),Method,,,"io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+sourceSupportsIncremental() io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+sourceSupportsIncremental() io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+withSourceDefinedCursors(ConfiguredAirbyteCatalog) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+withSourceDefinedCursors(ConfiguredAirbyteCatalog) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+getConfiguredCatalog() io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+getConfiguredCatalog() java.util.stream.Collectors+toList() java.util.stream.Collectors+toList() io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+runRead(ConfiguredAirbyteCatalog,JsonNode) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+runRead(ConfiguredAirbyteCatalog,JsonNode) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+getState() io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+getState() io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+filterRecords(Collection<AirbyteMessage>) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+filterRecords(Collection<AirbyteMessage>) java.util.stream.Collectors+toList() java.util.stream.Collectors+toList() java.util.Set+contains(Object) java.util.Set+contains(Object) java.lang.String+split(String) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+getImageName() io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+getImageName() java.lang.String+split(String) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+filterRecords(Collection<AirbyteMessage>) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+filterRecords(Collection<AirbyteMessage>) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+runRead(ConfiguredAirbyteCatalog,JsonNode) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+runRead(ConfiguredAirbyteCatalog,JsonNode)",io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+IMAGES_TO_SKIP_SECOND_INCREMENTAL_READ,2585,48,13338,322,1,"/** 
 * This test verifies that all streams in the input catalog which support incremental sync can do so correctly. It does this by running two read operations on the connector's Docker image: the first takes the configured catalog and config provided to this test as input. It then verifies that the sync produced a non-zero number of RECORD and STATE messages. <p> The second read takes the same catalog and config used in the first test, plus the last STATE message output by the first read operation as the input state file. It verifies that no records are produced (since we read all records in the first sync). <p> This test is performed only for streams which support incremental. Streams which do not support incremental sync are ignored. If no streams in the input catalog support incremental sync, this test is skipped.
 */
","/**
   * This test verifies that all streams in the input catalog which support incremental sync can do so
   * correctly. It does this by running two read operations on the connector's Docker image: the first
   * takes the configured catalog and config provided to this test as input. It then verifies that the
   * sync produced a non-zero number of RECORD and STATE messages.
   * <p>
   * The second read takes the same catalog and config used in the first test, plus the last STATE
   * message output by the first read operation as the input state file. It verifies that no records
   * are produced (since we read all records in the first sync).
   * <p>
   * This test is performed only for streams which support incremental. Streams which do not support
   * incremental sync are ignored. If no streams in the input catalog support incremental sync, this
   * test is skipped.
   */
  @Test
  public void testIncrementalSyncWithState() throws Exception {
    if (!sourceSupportsIncremental()) {
      return;
    }

    final ConfiguredAirbyteCatalog configuredCatalog = withSourceDefinedCursors(getConfiguredCatalog());
    // only sync incremental streams
    configuredCatalog.setStreams(
        configuredCatalog.getStreams().stream().filter(s -> s.getSyncMode() == INCREMENTAL).collect(Collectors.toList()));

    final List<AirbyteMessage> airbyteMessages = runRead(configuredCatalog, getState());
    final List<AirbyteRecordMessage> recordMessages = filterRecords(airbyteMessages);
    final List<AirbyteStateMessage> stateMessages = airbyteMessages
        .stream()
        .filter(m -> m.getType() == Type.STATE)
        .map(AirbyteMessage::getState)
        .collect(Collectors.toList());
    assertFalse(recordMessages.isEmpty(), ""Expected the first incremental sync to produce records"");
    assertFalse(stateMessages.isEmpty(), ""Expected incremental sync to produce STATE messages"");
    // TODO validate exact records

    if (IMAGES_TO_SKIP_SECOND_INCREMENTAL_READ.contains(getImageName().split("":"")[0])) {
      return;
    }

    // when we run incremental sync again there should be no new records. Run a sync with the latest
    // state message and assert no records were emitted.
    final JsonNode latestState = stateMessages.get(stateMessages.size() - 1).getData();
    final List<AirbyteRecordMessage> secondSyncRecords = filterRecords(runRead(configuredCatalog, latestState));
    assertTrue(
        secondSyncRecords.isEmpty(),
        ""Expected the second incremental sync to produce no records when given the first sync's output state."");
  }",False
31,testEmptyStateIncrementalIdenticalToFullRefresh(),Method,,,"io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+sourceSupportsIncremental() io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+sourceSupportsIncremental() io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+getConfiguredCatalog() io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+getConfiguredCatalog() io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+withFullRefreshSyncModes(ConfiguredAirbyteCatalog) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+withFullRefreshSyncModes(ConfiguredAirbyteCatalog) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+filterRecords(Collection<AirbyteMessage>) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+filterRecords(Collection<AirbyteMessage>) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+runRead(ConfiguredAirbyteCatalog) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+runRead(ConfiguredAirbyteCatalog) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+filterRecords(Collection<AirbyteMessage>) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+filterRecords(Collection<AirbyteMessage>) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+runRead(ConfiguredAirbyteCatalog,JsonNode) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+runRead(ConfiguredAirbyteCatalog,JsonNode) io.airbyte.commons.json.Jsons+jsonNode(T) io.airbyte.commons.json.Jsons+jsonNode(T) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+assertSameRecords(List<AirbyteRecordMessage>,List<AirbyteRecordMessage>,String) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+assertSameRecords(List<AirbyteRecordMessage>,List<AirbyteRecordMessage>,String)",,1455,25,15927,366,1,"/** 
 * If the source does not support incremental sync, this test is skipped. <p> Otherwise, this test runs two syncs: one where all streams provided in the input catalog sync in full refresh mode, and another where all the streams which in the input catalog which support incremental, sync in incremental mode (streams which don't support incremental sync in full refresh mode). Then, the test asserts that the two syncs produced the same RECORD messages. Any other type of message is disregarded.
 */
","/**
   * If the source does not support incremental sync, this test is skipped.
   * <p>
   * Otherwise, this test runs two syncs: one where all streams provided in the input catalog sync in
   * full refresh mode, and another where all the streams which in the input catalog which support
   * incremental, sync in incremental mode (streams which don't support incremental sync in full
   * refresh mode). Then, the test asserts that the two syncs produced the same RECORD messages. Any
   * other type of message is disregarded.
   */
  @Test
  public void testEmptyStateIncrementalIdenticalToFullRefresh() throws Exception {
    if (!sourceSupportsIncremental()) {
      return;
    }

    final ConfiguredAirbyteCatalog configuredCatalog = getConfiguredCatalog();
    final ConfiguredAirbyteCatalog fullRefreshCatalog = withFullRefreshSyncModes(configuredCatalog);

    final List<AirbyteRecordMessage> fullRefreshRecords = filterRecords(runRead(fullRefreshCatalog));
    final List<AirbyteRecordMessage> emptyStateRecords = filterRecords(runRead(configuredCatalog, Jsons.jsonNode(new HashMap<>())));
    final String assertionMessage = ""Expected a full refresh sync and incremental sync with no input state to produce identical records"";
    assertFalse(fullRefreshRecords.isEmpty(), assertionMessage);
    assertFalse(emptyStateRecords.isEmpty(), assertionMessage);
    assertSameRecords(fullRefreshRecords, emptyStateRecords, assertionMessage);
  }",False
32,filterRecords(Collection<AirbyteMessage>),Method,testIdenticalFullRefreshes() testIdenticalFullRefreshes() testIncrementalSyncWithState() testIncrementalSyncWithState() testEmptyStateIncrementalIdenticalToFullRefresh() testEmptyStateIncrementalIdenticalToFullRefresh(),,java.util.stream.Collectors+toList() java.util.stream.Collectors+toList(),,248,6,17386,382,2,,"private List<AirbyteRecordMessage> filterRecords(Collection<AirbyteMessage> messages) {
    return messages.stream()
        .filter(m -> m.getType() == Type.RECORD)
        .map(AirbyteMessage::getRecord)
        .collect(Collectors.toList());
  }",False
33,withSourceDefinedCursors(ConfiguredAirbyteCatalog),Method,testIncrementalSyncWithState(),,io.airbyte.commons.json.Jsons+clone(T) io.airbyte.commons.json.Jsons+clone(T),,564,11,17638,389,2,,"private ConfiguredAirbyteCatalog withSourceDefinedCursors(ConfiguredAirbyteCatalog catalog) {
    final ConfiguredAirbyteCatalog clone = Jsons.clone(catalog);
    for (ConfiguredAirbyteStream configuredStream : clone.getStreams()) {
      if (configuredStream.getSyncMode() == INCREMENTAL
          && configuredStream.getStream().getSourceDefinedCursor() != null
          && configuredStream.getStream().getSourceDefinedCursor()) {
        configuredStream.setCursorField(configuredStream.getStream().getDefaultCursorField());
      }
    }
    return clone;
  }",False
34,withFullRefreshSyncModes(ConfiguredAirbyteCatalog),Method,testFullRefreshRead() testIdenticalFullRefreshes() testEmptyStateIncrementalIdenticalToFullRefresh(),,io.airbyte.commons.json.Jsons+clone(T) io.airbyte.commons.json.Jsons+clone(T),,489,10,18206,401,2,,"private ConfiguredAirbyteCatalog withFullRefreshSyncModes(ConfiguredAirbyteCatalog catalog) {
    final ConfiguredAirbyteCatalog clone = Jsons.clone(catalog);
    for (ConfiguredAirbyteStream configuredStream : clone.getStreams()) {
      if (configuredStream.getStream().getSupportedSyncModes().contains(FULL_REFRESH)) {
        configuredStream.setSyncMode(FULL_REFRESH);
        configuredStream.setDestinationSyncMode(DestinationSyncMode.OVERWRITE);
      }
    }
    return clone;
  }",False
35,sourceSupportsIncremental(),Method,testIncrementalSyncWithState() testEmptyStateIncrementalIdenticalToFullRefresh(),,io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+getConfiguredCatalog() io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+getConfiguredCatalog(),,332,9,18699,412,2,,"private boolean sourceSupportsIncremental() throws Exception {
    final ConfiguredAirbyteCatalog catalog = getConfiguredCatalog();
    for (ConfiguredAirbyteStream stream : catalog.getStreams()) {
      if (stream.getStream().getSupportedSyncModes().contains(INCREMENTAL)) {
        return true;
      }
    }
    return false;
  }",False
36,runSpec(),Method,testGetSpec(),,"io.airbyte.workers.DefaultGetSpecWorker+run(JobGetSpecConfig,Path) io.airbyte.workers.DefaultGetSpecWorker+DefaultGetSpecWorker(IntegrationLauncher) io.airbyte.workers.process.AirbyteIntegrationLauncher+AirbyteIntegrationLauncher(long,int,String,ProcessFactory) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+getImageName() io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+getImageName() io.airbyte.workers.DefaultGetSpecWorker+run(JobGetSpecConfig,Path) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+getImageName() io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+getImageName()",io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+JOB_ID io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+JOB_ATTEMPT io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+processFactory io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+jobRoot,269,4,19035,422,2,,"private ConnectorSpecification runSpec() throws WorkerException {
    return new DefaultGetSpecWorker(new AirbyteIntegrationLauncher(JOB_ID, JOB_ATTEMPT, getImageName(), processFactory))
        .run(new JobGetSpecConfig().withDockerImage(getImageName()), jobRoot);
  }",True
37,runCheck(),Method,testCheckConnection(),,"io.airbyte.workers.DefaultCheckConnectionWorker+run(StandardCheckConnectionInput,Path) io.airbyte.workers.DefaultCheckConnectionWorker+DefaultCheckConnectionWorker(IntegrationLauncher) io.airbyte.workers.process.AirbyteIntegrationLauncher+AirbyteIntegrationLauncher(long,int,String,ProcessFactory) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+getImageName() io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+getImageName() io.airbyte.workers.DefaultCheckConnectionWorker+run(StandardCheckConnectionInput,Path) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+getConfig() io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+getConfig()",io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+JOB_ID io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+JOB_ATTEMPT io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+processFactory io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+jobRoot,300,4,19308,427,2,,"private StandardCheckConnectionOutput runCheck() throws Exception {
    return new DefaultCheckConnectionWorker(new AirbyteIntegrationLauncher(JOB_ID, JOB_ATTEMPT, getImageName(), processFactory))
        .run(new StandardCheckConnectionInput().withConnectionConfiguration(getConfig()), jobRoot);
  }",True
38,runDiscover(),Method,testDiscover(),,"io.airbyte.workers.DefaultDiscoverCatalogWorker+run(StandardDiscoverCatalogInput,Path) io.airbyte.workers.DefaultDiscoverCatalogWorker+DefaultDiscoverCatalogWorker(IntegrationLauncher) io.airbyte.workers.process.AirbyteIntegrationLauncher+AirbyteIntegrationLauncher(long,int,String,ProcessFactory) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+getImageName() io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+getImageName() io.airbyte.workers.DefaultDiscoverCatalogWorker+run(StandardDiscoverCatalogInput,Path) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+getConfig() io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+getConfig()",io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+JOB_ID io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+JOB_ATTEMPT io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+processFactory io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+jobRoot,288,4,19612,432,2,,"private AirbyteCatalog runDiscover() throws Exception {
    return new DefaultDiscoverCatalogWorker(new AirbyteIntegrationLauncher(JOB_ID, JOB_ATTEMPT, getImageName(), processFactory))
        .run(new StandardDiscoverCatalogInput().withConnectionConfiguration(getConfig()), jobRoot);
  }",True
39,runRead(ConfiguredAirbyteCatalog),Method,testFullRefreshRead() testIdenticalFullRefreshes() testIdenticalFullRefreshes() testEmptyStateIncrementalIdenticalToFullRefresh(),,"io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+runRead(ConfiguredAirbyteCatalog,JsonNode) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+runRead(ConfiguredAirbyteCatalog,JsonNode)",,148,3,19904,437,2,,"private List<AirbyteMessage> runRead(ConfiguredAirbyteCatalog configuredCatalog) throws Exception {
    return runRead(configuredCatalog, null);
  }",True
40,"runRead(ConfiguredAirbyteCatalog,JsonNode)",Method,testIncrementalSyncWithState() testIncrementalSyncWithState() testEmptyStateIncrementalIdenticalToFullRefresh() runRead(ConfiguredAirbyteCatalog),,"io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+getConfig() io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+getConfig() io.airbyte.workers.protocols.airbyte.DefaultAirbyteSource+DefaultAirbyteSource(IntegrationLauncher) io.airbyte.workers.process.AirbyteIntegrationLauncher+AirbyteIntegrationLauncher(long,int,String,ProcessFactory) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+getImageName() io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+getImageName() io.airbyte.workers.protocols.Source+start(StandardTapConfig,Path) io.airbyte.workers.protocols.Source+start(StandardTapConfig,Path) io.airbyte.workers.protocols.Source+isFinished() io.airbyte.workers.protocols.Source+isFinished() io.airbyte.workers.protocols.Source+attemptRead() io.airbyte.workers.protocols.Source+attemptRead() io.airbyte.workers.protocols.Source+close() io.airbyte.workers.protocols.Source+close()",io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+JOB_ID io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+JOB_ATTEMPT io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+processFactory io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+jobRoot,718,16,20136,442,2,,"private List<AirbyteMessage> runRead(ConfiguredAirbyteCatalog catalog, JsonNode state) throws Exception {
    final StandardTapConfig sourceConfig = new StandardTapConfig()
        .withSourceConnectionConfiguration(getConfig())
        .withState(state == null ? null : new State().withState(state))
        .withCatalog(catalog);

    final AirbyteSource source = new DefaultAirbyteSource(new AirbyteIntegrationLauncher(JOB_ID, JOB_ATTEMPT, getImageName(), processFactory));
    final List<AirbyteMessage> messages = new ArrayList<>();
    source.start(sourceConfig, jobRoot);
    while (!source.isFinished()) {
      source.attemptRead().ifPresent(messages::add);
    }
    source.close();

    return messages;
  }",True
41,"assertSameRecords(List<AirbyteRecordMessage>,List<AirbyteRecordMessage>,String)",Method,testIdenticalFullRefreshes() testEmptyStateIncrementalIdenticalToFullRefresh(),,io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+pruneEmittedAt(AirbyteRecordMessage) java.util.stream.Collectors+toList() java.util.stream.Collectors+toList() io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+pruneEmittedAt(AirbyteRecordMessage) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+pruneCdcMetadata(AirbyteRecordMessage) java.util.stream.Collectors+toList() java.util.stream.Collectors+toList(),,645,11,20858,459,2,,"private void assertSameRecords(List<AirbyteRecordMessage> expected, List<AirbyteRecordMessage> actual, String message) {
    final List<AirbyteRecordMessage> prunedExpected = expected.stream().map(this::pruneEmittedAt).collect(Collectors.toList());
    final List<AirbyteRecordMessage> prunedActual = actual
        .stream()
        .map(this::pruneEmittedAt)
        .map(this::pruneCdcMetadata)
        .collect(Collectors.toList());
    assertEquals(prunedExpected.size(), prunedActual.size(), message);
    assertTrue(prunedExpected.containsAll(prunedActual), message);
    assertTrue(prunedActual.containsAll(prunedExpected), message);
  }",False
42,pruneEmittedAt(AirbyteRecordMessage),Method,,,io.airbyte.commons.json.Jsons+clone(T) io.airbyte.commons.json.Jsons+clone(T),,120,3,21507,471,2,,"private AirbyteRecordMessage pruneEmittedAt(AirbyteRecordMessage m) {
    return Jsons.clone(m).withEmittedAt(null);
  }",False
43,pruneCdcMetadata(AirbyteRecordMessage),Method,,,io.airbyte.commons.json.Jsons+clone(T) io.airbyte.commons.json.Jsons+clone(T),io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+CDC_LSN io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+CDC_LOG_FILE io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+CDC_LOG_POS io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+CDC_UPDATED_AT io.airbyte.integrations.standardtest.source.SourceAcceptanceTest+CDC_DELETED_AT,431,9,21631,475,2,,"private AirbyteRecordMessage pruneCdcMetadata(AirbyteRecordMessage m) {
    final AirbyteRecordMessage clone = Jsons.clone(m);
    ((ObjectNode) clone.getData()).remove(CDC_LSN);
    ((ObjectNode) clone.getData()).remove(CDC_LOG_FILE);
    ((ObjectNode) clone.getData()).remove(CDC_LOG_POS);
    ((ObjectNode) clone.getData()).remove(CDC_UPDATED_AT);
    ((ObjectNode) clone.getData()).remove(CDC_DELETED_AT);
    return clone;
  }",False
44,TestDestinationEnv,MemberClass,,,io.airbyte.integrations.standardtest.source.SourceAcceptanceTest.TestDestinationEnv+TestDestinationEnv(Path) io.airbyte.integrations.standardtest.source.SourceAcceptanceTest.TestDestinationEnv+getLocalRoot(),io.airbyte.integrations.standardtest.source.SourceAcceptanceTest.TestDestinationEnv+localRoot io.airbyte.integrations.standardtest.source.SourceAcceptanceTest.TestDestinationEnv+localRoot io.airbyte.integrations.standardtest.source.SourceAcceptanceTest.TestDestinationEnv+localRoot,233,13,-1,-1,9,,"public static class TestDestinationEnv {

    private final Path localRoot;

    public TestDestinationEnv(Path localRoot) {
      this.localRoot = localRoot;
    }

    public Path getLocalRoot() {
      return localRoot;
    }

  }",False
